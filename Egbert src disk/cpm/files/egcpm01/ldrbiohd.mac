;******************************************************************************
;*  L D R B I O S  *  C P M S Y S 3  *  T h o m a s   H o l t e * 8 5 0 9 0 8 *
;******************************************************************************
;*									      *
;*  		 M I N I M U M   B I O S   F O R   C P M L D R		      *
;*               =============================================                *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *	
;*									      *
;*									      *
;******************************************************************************
;
; Jetzt angepasst an Tandon TM 262 HD mit 20 MB . 3.Aug 1993
;
; Nun an Seagate ST 225 mit 2 Partitionen. Die Charakteristik von 
; Partition 1 wird in LDRBIOHD zum Bootvorgang von der Festplatte ben|tigt
;
  
	.Z80

;ASCII control codes:
BEL	EQU  07H		;bell
LF	EQU  0AH		;line feed
CR	EQU  0DH		;carriage return
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape
RS	EQU  1EH		;record separator

$SYS1 	EQU  0FAH		;system byte 1

PUSHHL	EQU  0E5H		;machine code of PUSH HL

;BIOS jump vector.

;All BIOS routines are invoked by calling these entry points.

?BOOT:	JP   BOOT		;initial entry on cold start
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
?CONO:	JP   CONOUT		;send console output character
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
?HOME:	JP   HOME		;set disks to logical home
?SLDSK:	JP   SELDSK		;select disk drive, return disk parameter info
?STTRK:	JP   SETTRK		;set disk track
?STSEC:	JP   SETSEC		;set disk sector
?STDMA:	JP   SETDMA		;set disk I/O memory address
?READ:	JP   READ		;read physical block(s)
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
?SCTRN:	JP   SECTRN		;translate logical to physical sector
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
?MOVE:	JP   MOVE		;block move memory to memory
	JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
 	

*EJECT
BOOT:
;====

;Initial entry point for system startup.

	JP   ?INIT		;perform any additional system initialization
				;and print signon message 


CONOUT:
;======

;Console output. Send character in reg. C to all selected devices.
	LD   A,C		;character  --> accu
        LD   C,4  		;function # --> reg. C
      	JP   ?USERF		;display char


HOME:
;====

;Home selected drive. Treated as SETTRK (0).

	LD   BC,0		;same as set track zero
	JR   SETTRK


SELDSK:
;======

;Select disk drive. Drive code in reg. C. Invoke login procedure for drive if
;this is first select. Return address of disk parameter header in reg. HL.
;
; DS0= Harddisk partition 1
; DPB0= disk parameter block parttion 1
;
	LD   HL,DS0             ;^extended disk parameter header --> reg. HL
	RET

;Extended Disk Parameter Headers (XDPHs)

	DEFS 8
	DEFB 0,2	        ;relative drive zero
DS0:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB0   		;disk parameter block
	DEFW 0            	;no CSV
	DEFW ALV0  		;allocation vector
	DEFW DIRBCB		;DIRBCB alloc'd by GENCPM
	DEFW DTABCB	
	DEFW 0FFFFH		;no HASH
	DEFB 0			;hash bank

;Disk Parameter Block (DPB)

;:---------------------------------:
;:HARDISK 20MByte, Partition 1 C:  :
;:---------------------------------:
; this data are from hddtbl.asm
;
 
DPB0:	DEFB	10h,01h	    ;SPT= 272      128 Byte records/track
	DEFB	005h	    ;BSH=   5      block shift factor  
        DEFB	01fh	    ;BLM=  31      block mask   
	DEFB	001H        ;EXM=   1      extend mask  
        DEFB    01fH,0aH    ;DSM=	   maximum block number 
	DEFW	1024        ;DRM=1024      maximum directory number
	DEFB	0FFH,0FFH   ;AL0= 255      allocation vector 0
        		    ;AL1= 000      allocation vector 1
	DEFB	000H,080H   ;CKS=   0      checksum size is zero
                            ;              ,permanently mounted
	DEFW	2	    ;OFF=   2      reserved tracks of partition 1
 	DEFB	2,3         ;PSH=   2      physical sector shift
			    ;PHM=   3      physical record mask 

;directory buffer control block:

DIRBCB:	DEFB 0FFH		;drive
	DEFS 4			;record #, written ?
	DEFB 0
	DEFS 4			;track, sector
	DEFW DIR		;buffer address

;data buffer:
DTABCB:	DEFB 0FFH		;drive
	DEFS 4			;record #, written ?
	DEFB 0
	DEFS 4			;track, sector
	DEFW DATA		;buffer address


SETTRK:
;======

;Set track. Saves track address from reg. BC in @TRK for further operations.

	LD   (@TRK),BC
	RET


SETSEC:
;======

;Set sector. Saves sector number from reg. BC in @SECT for further operations.

	LD   (@SECT),BC
	RET


SETDMA:
;======

;Set disk memory address. Saves DMA address from reg. BC in @DMA.

	LD   (@DMA),BC
	RET


READ:
;====
;Read physical record from currently selected drive. Finds address of proper
;read routine from extended disk parameter header (XDPH).

hdport	equ	40h
hdstat	equ	hdport+1
hdres	equ	hdport+1
hdsel	equ	hdport+2
hdconf	equ	hdport+2
hdmask	equ	hdport+3

hdread:	xor	a
	ld	(head),a
	ld	bc,(@trk)
	ld	a,c
	ld	(cylind),a
	rr	b
	rr	c
	rr	b
	rr	c
	ld	a,c
	and	0c0h
	ld	c,a

	ld	b,0		; head count
	ld	a,(@sect)	; sector # (only low byte significant)
fdhead:	cp	17		; find head #
	jr	c,hds0		; if head 0
	sub	17		; else convert to sector # and head #
	inc	b		; next head, if more than 26 secs
	jr	fdhead
hds0:	or	c
	ld	(sect),a	; set sector and track msb
	ld	a,b		; head #
	ld	(head),a

	

;	read sector into dma buffer
rdsect:	di			; disable interrupts
	ld	bc,0508h	; get length and command
	call	hdscmd		; send command
rd1$:	in	a,(hdstat)	; hdc get status
	cp	0cfh		; test if status is to send
	jr	z,termcmd	; skip if yes
	cp	0cbh		; test transfer direction
	jr	nz,rd1$		; loop until o. k.

	ld	hl,(@dma)	; get sector buffer address
	ld	c,hdport	; get hd port address
	jr	rd_dat		; branch to get first data byte

hdrdlp:	in	a,(hdstat)	; get hdc status
	cp	0cfh		; test if transfer is terminated
	jr	z,termcmd	; if yes quit loop
	cp	0cbh		; data available  ?
	jr	nz,hdrdlp	; loop if not
rd_dat:	ini			; read data
	jr	hdrdlp		; and loop

;	test if hard disk command is correctly terminated
termcmd:			; test termination of command
	ld	c,8		; set loop cont to 8
tr$:	ld	b,0		; set retry count to 256
tr$1:	in	a,(hdstat)	; get hdc status
	cp	0cfh		; ready to read status  ?
	jr	z,tr$2		; skip if o. k.
	djnz	tr$1		; else retry b times
	ld	hl,hdmsg2	; print error mesage if command
	jr	tr$3		; is not correctly terminated
	dec	c		; decrement loop count
	jr	nz,tr$

tr$2:	in	a,(hdport)	; get command status
	and	2		; to test completion
	jr	z,exit
	ld	hl,hdmsg1	; else print terminate error

tr$3:	call	pr_msg		; print message
	ld	a,1		; set error condition

exit:	ret			; return with status in accu


															

SECTRN:
;======

;Sector translate. Indexes skew table in reg. DE with sector in reg. BC.
;Returns physical sector in reg. HL. If no skew table (reg. DE = 0) then
;returns physical = logical.

	LD   L,C
	LD   H,B
	RET


MOVE:
;====
      	EX   DE,HL		;we are passed source in DE and dest in HL
	LDIR			;use Z80 block move instruction
        EX   DE,HL              ;need next addresses in same regs
DUMMY:  RET


*EJECT
?INIT:	DI			;disable interrupts
	IM   1			;interrupt mode 1 (RST 7)
      	LD   C,23		;function # --> reg. C
	CALL ?USERF		;general system initialization

	.XLIST
	.XCREF


;hard disk init routine:
DS$INIT:

hdinit:	out	(hdres),a	; reset hard-disk controller
get_st:	in	a,(hdstat)	; get status
	cp	0c0h		; test if hdc is idle
	jr	nz,get_st	; else loop until hdc is idle

setmsk:	xor	a		; clear accu and send mask to disable
	out	(hdmask),a	; interrupt and dma from hard-disk

w0:	in	a,(hdstat)	; get status
	cp	0c0h		; and wait until hdc is idle
	jr	nz,w0

;	init hd controller with hd-drive-characteristics

trpara:	ld	hl,ifield	; point to init-parameter field
	ld	bc,050ch	; get command to set hd characteristics
	call	hdscmd		; send command
	ld	hl,hd_charact	; point to table of hd characteristics
	ld	c,hdport	; get hd port
	ld	b,8		; get length of table
tr_p1:	in	a,(hdstat)	; get hdc status
	cp	0c9h		; request for data --> hdc  ?
	jr	nz,tr_p1	; loop until hdc requests for data
	jr	nx1		; else send data from data table

nxtbyt:	call	wcr		; wait for controller ready
nx1:	ld	a,(hl)		; get byte from table
	out	(c),a		; send byte to hd controller
	inc	hl		; increment pointer
	djnz	nxtbyt		; loop until done

;	test if command successfully completed

rdy1:	in	a,(hdstat)	; get hdc status
	cp	0cfh		; test if status is to be send
	jr	nz,rdy1		; loop until o. k.
	in	a,(hdport)	; get command status state
	bit	2,a		; test if correctly terminated
	jr	z,pri_ok	; skip if o. k.
	out	(hdres),a	; reset controller
	ld	hl,hdmsg1	; else print hd-init-error
	jp	pr_msg		; and return

pri_ok:	ld	hl,iniok	; print init o. k.
	jp	pr_msg


iniok:	db	'Reading CPM3.SYS',cr,lf,0
hdmsg1:	db	bel,cr,lf
	db	'HD Term. Error !'
	db	cr,lf,lf,0
hdmsg2:	db	bel,cr,lf
	db	'Hard Disk Read Error  !'
	db	cr,lf,lf,0

; Subroutine Area				

pr_msg:	ld	a,(hl)
	cp	0
	ret	z
	ld	c,a
	call	conout
	inc	hl
	jr	pr_msg
	
	

; hard disk subroutines

; wait controller ready
wcr:	in	a,(hdstat)	; get hd controller status
	bit	0,a		; test for data request
	jr	z,wcr		; quit if request
	ret

;hd send command	hl -->	parameterlist
;			b  -->	count
;			c  -->	command
hdscmd:	in	a,(hdstat)	; get hdc status
	cp	0c0h		; to test if hdc is idle
	jr	z,hdc_id	; skip if o. k.
	out	(hdres),a	; else reset hdc
	jr	hdscmd		; and try again
hdc_id:	out	(hdsel),a	; select hd controller
	ld	hl,cfield	; set pointer to command field
	call	wcr		; wait for controller ready
	ld	a,c		; get command
	out	(hdport),a	; to send it
nxtpar:	call	wcr		; wait for controller ready
	ld	a,(hl)		; fetch next parameter
	out	(hdport),a	; to send it
	inc	hl		; increment parameter pointer
	djnz	nxtpar		; and loop until done
hd1ini:	ret

;  hard disk data area
cfield:				; hdc command field
head:	db	0		; selected head, lun and c10
sect:	db	0		; sector #, c8 and c9
cylind:	db	0		; cylinder #  < modulo 256 >
bcount:	db	1		; block count
termin:	db	2		; step rate --> 25 us

hd_charact:			; drive characteristics
				; 614 cylinders, 4 heads 
	db	2		; last cylinder  (msb)
	db	67h		; last cylinder  (lsb)
	db	4		; 4 heads
	db	02h,58h  	; start cyl reduced wr current
	db	01h,2ch		; start cyl wr precomp
	db	0		; always zero

ifield:	db	0,0,0,0,0	; hard disk init-parameter field
								
			

*EJECT
;table of driver entry vectors:
$VDINIT	EQU  0    		;initialize the video controller chip M6845
$RSINIT	EQU  1    		;initialize the RS-232-C interface
$KBCHAR	EQU  2    		;get a keyboard character if available
$KBWAIT	EQU  3     		;wait for a keyboard character
$VDCHAR	EQU  4    		;display a character
$PRSTAT	EQU  5    		;test printer status
$PRCHAR	EQU  6    		;output a character to the printer
$RSRCST	EQU  7    		;get a character from the RS-232-C interface if
				;available
$RSRCV	EQU  8    		;receive a character from the RS-232-C
				;interface
$RSTXST	EQU  9    		;test the RS-232-C output status
$RSTX	EQU  10    		;transmit a character to the RS-232-C interface
$READ	EQU  11   		;read a disk sector
$WRITE	EQU  12   		;write a disk sector
$GETTIM	EQU  13   		;get time and date in binary format
$SETTIM	EQU  14   		;set time and date in binary format
$XMOVE	EQU  15			;interbank data transfer
$GTIME3	EQU  18			;get time and date in CP/M 3 format
$STIME3	EQU  19			;set time and date in CP/M 3 format
$LDCHAR	EQU  20			;load bit pattern into character RAM
$RSTCHR	EQU  21			;restore original character set
$SCRNIO EQU  22			;direct screen I/O
$INIT	EQU  23			;general system initialization
$CLOCK	EQU  24			;turn clock display on/off
$DISP	EQU  25			;turn on/off graphic display
$CLS	EQU  26			;clear graphic screen
$PLOT	EQU  27			;plot dot    on graphic screen
$POINT	EQU  28			;read dot  from graphic screen
$LINE	EQU  29			;draw line   on graphic screen
$CIRCLE	EQU  30			;draw circle on graphic screen
$ARC	EQU  31			;draw arc    on graphic screen
$COPY	EQU  33			;copy area

;call ROM driver routines:
?USERF:	LD   (SAVESP),SP	;save stack pointer
	LD   SP,0E100H  	;temporary stack --> stack pointer
        PUSH BC			;save register set
	PUSH DE
	PUSH HL
	PUSH IX
	PUSH IY
	DI			;disable interrupts
       	RST  0     		;call driver routine
	PUSH AF    		;save accu
	LD   A,11010101B	;disable memory mapped I/O
				;disable graphic display
				;disable boot EPROM
				;disable graphic page
				;7.2 MHz clock frequency
				;enable video display
	OUT  ($SYS1),A		;write system byte 1
	POP  AF    		;restore accu
	POP  IY			;restore register set
	POP  IX
	POP  HL
	POP  DE
	POP  BC
	LD   SP,(SAVESP)	;restore stack pointer
	RET			;return to caller

SAVESP: DEFS 2			;temporary memory for stack pointer


*EJECT
@TRK:	DEFS 2			;current track number
@SECT:	DEFS 2			;current sector number
@DMA:	DEFS 2			;current DMA address


ALV0    EQU  $
DIR     EQU  ALV0+203
DATA   	EQU  DIR+512 
SPARE$DIRECTORY EQU DATA+512 

	END
