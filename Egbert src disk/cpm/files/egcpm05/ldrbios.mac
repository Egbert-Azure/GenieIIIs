;******************************************************************************
;*  L D R B I O S  *  C P M S Y S 3  *  T h o m a s   H o l t e * 8 5 0 9 0 8 *
;******************************************************************************
;*									      *
;*  		 M I N I M U M   B I O S   F O R   C P M L D R		      *
;*               =============================================                *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************
; Dieser Programmteil des Betriebssystems sollte bei illegaler Kopie des
; Betriebssystems die Boot-Diskette zerst|ren. Durch Einf}gen eines RET
; wird dies unterbunden.
 
	.Z80

;ASCII control codes:
BEL	EQU  07H		;bell
LF	EQU  0AH		;line feed
CR	EQU  0DH		;carriage return
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape
RS	EQU  1EH		;record separator

$SYS1 	EQU  0FAH		;system byte 1

PUSHHL	EQU  0E5H		;machine code of PUSH HL

;BIOS jump vector.

;All BIOS routines are invoked by calling these entry points.

?BOOT:	JP   BOOT		;initial entry on cold start
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
?CONO:	JP   CONOUT		;send console output character
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
?HOME:	JP   HOME		;set disks to logical home
?SLDSK:	JP   SELDSK		;select disk drive, return disk parameter info
?STTRK:	JP   SETTRK		;set disk track
?STSEC:	JP   SETSEC		;set disk sector
?STDMA:	JP   SETDMA		;set disk I/O memory address
?READ:	JP   READ		;read physical block(s)
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
?SCTRN:	JP   SECTRN		;translate logical to physical sector
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
?MOVE:	JP   MOVE		;block move memory to memory
	JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
 	

*EJECT
BOOT:
;====

;Initial entry point for system startup.

	JP   ?INIT		;perform any additional system initialization
				;and print signon message 


CONOUT:
;======

;Console output. Send character in reg. C to all selected devices.
	LD   A,C		;character  --> accu
        LD   C,4  		;function # --> reg. C
      	JP   ?USERF		;display char


HOME:
;====

;Home selected drive. Treated as SETTRK (0).

	LD   BC,0		;same as set track zero
	JR   SETTRK


SELDSK:
;======

;Select disk drive. Drive code in reg. C. Invoke login procedure for drive if
;this is first select. Return address of disk parameter header in reg. HL.

	LD   HL,DS0             ;^extended disk parameter header --> reg. HL
	RET

;Extended Disk Parameter Headers (XDPHs)

	DEFS 8
	DEFB 0,2	        ;relative drive zero
DS0:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB0   		;disk parameter block
	DEFW 0            	;no CSV
	DEFW ALV0  		;allocation vector
	DEFW DIRBCB		;DIRBCB alloc'd by GENCPM
	DEFW DTABCB	
	DEFW 0FFFFH		;no HASH
	DEFB 0			;hash bank

;Disk Parameter Block (DPB)
DPB0: 	DEFW 68			;128 byte records per track
	DEFB 6,63		;block shift and mask
	DEFB 3			;extent mask
	DEFW 1298		;maximum block number
	DEFW 1023		;maximum directory entry number
	DEFB 0F0H,0		;alloc vector for directory
	DEFW 0			;checksumm size
	DEFW 1			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask


;directory buffer control block:
DIRBCB:	DEFB 0FFH		;drive
	DEFS 4			;record #, written ?
	DEFB 0
	DEFS 4			;track, sector
	DEFW DIR		;buffer address

;data buffer:
DTABCB:	DEFB 0FFH		;drive
	DEFS 4			;record #, written ?
	DEFB 0
	DEFS 4			;track, sector
	DEFW DATA		;buffer address


SETTRK:
;======

;Set track. Saves track address from reg. BC in @TRK for further operations.

	LD   (@TRK),BC
	RET


SETSEC:
;======

;Set sector. Saves sector number from reg. BC in @SECT for further operations.

	LD   (@SECT),BC
	RET


SETDMA:
;======

;Set disk memory address. Saves DMA address from reg. BC in @DMA.

	LD   (@DMA),BC
	RET


READ:
;====

;Read physical record from currently selected drive. Finds address of proper
;read routine from extended disk parameter header (XDPH).

;*****************************************************
;* Bad block administration (sector skipping method) *
;* originally written by Andy Johnson-Laird	     *
;* modified by Thomas Holte (c) 1985		     *
;* (you've fooled me with many errors, Andy !!!)     *	
;*****************************************************
SECTORS$PER$TRACK EQU 17
SPARE$LENGTH	  EQU 512 	;170 entries, 3 bytes each

	LD   HL,SPARE$DIRECTORY-3
				 ;HL -> spare directory

	LD   DE,(@TRK)		;get requested track
	LD   A,(@SECT)		;get sector number

CHECK$ENTRY:
	LD   C,A		;save sector number for later
	LD   B,0   		;set counter

CHECK$ENTRY1:
	INC  HL			;update to next (or first entry)
	INC  HL
	INC  HL

	INC  B			;update count

	CALL CMPM		;compare req. track to table entry

	JR   Z,TRACKS$MATCH	;possible match of track and sector
	JR   NC,COMPUTE$INCREMENT
				;requested track < table entry
	JR   CHECK$ENTRY1	;requested track > table entry

TRACKS$MATCH:
	INC  HL			;HL -> MS byte of track
	INC  HL			;HL -> sector
	LD   A,(HL)		;get sector from table
	DEC  HL
	DEC  HL

	CP   C			;compare with requested sector
	JR   Z,SECTORS$MATCH	;track/sector matches
	JR   NC,COMPUTE$INCREMENT
				;req. trk/sec < spare trk/sec
	JR   CHECK$ENTRY1	;move to next table entry

SECTORS$MATCH:
	INC  B			;if track and sectors match with
				;a table entry, then an additional 
				;sector must be skipped

COMPUTE$INCREMENT:		;B contains number of cumulative
				;number of sectors to skip
	DEC  B			;0 sectors to skip ?
	JP   Z,DS$IO		;if yes, go to physical sector read/write 
	LD   A,C		;get requested sector
	ADD  A,B		;skip required number
	LD   B,SECTORS$PER$TRACK;determine final sector number
				;and track increment
	CALL DIV$A$BY$B		;returns C = quotient, A = remainder
	LD   (@SECT),A          ;A = new sector number

	LD   B,0		;make track increment a word
	EX   DE,HL    		;get requested track
	ADD  HL,BC		;add on increment
	LD   (@TRK),HL		;save updated track
	EX   DE,HL		;get table pointer
	JP   CHECK$ENTRY	;go to physical disk read/write

; DIV$A$BY$B
; Divide A by B
;
; This routine divides A by B, returning the quotient in C
; and the remainder in A.
;
; Entry parameters
;
;	A = dividend
;	B = divisor
;
; Exit parameters
;
;	A = remainder
;	C = quotient
;
DIV$A$BY$B:
	LD   C,0		;initialize quotient
DIV$A$BY$B$LOOP:
	INC  C			;increment quotient
	SUB  B			;subtract divisor
	JP   P,DIV$A$BY$B$LOOP	;repeat if result still +ve
	DEC  C			;correct quotient
	ADD  A,B		;correct remainder
	RET

; CMPM
; Compare memory
;
; This subroutine compares the contents of DE to (HL) and (HL+1)
; returning with the flags as though the subtraction (HL) - DE
; were performed.
;
; Entry parameters
;
;	HL -> word in memory
;	DE =  value to be compared
;
; Exit parameters
;
;	Flags set for (HL) - DE
;
CMPM:	INC  HL
	LD   A,(HL)		;get MS byte
	CP   D
	DEC  HL			;return with HL unchanged
	RET  NZ			;return now if MS bytes unequal
	LD   A,(HL)		;get LS byte
	CP   E
	RET

;*****************************************************

DS$IO:	LD   A,(@SECT)		;sector number 	       --> reg. B
	LD   B,A
	XOR  A			;drive number	       --> accu
	LD   DE,(@TRK)		;track number	       --> reg. DE
	LD   HL,(@DMA)		;DMA address	       --> reg. HL
	LD   C,16		;function #	       --> reg. C
	CALL ?USERF		;transfer hard disk sector
	OR   A			;any errors ?
	RET  Z			;return if not
	LD   A,1		;return common error code
	RET


SECTRN:
;======

;Sector translate. Indexes skew table in reg. DE with sector in reg. BC.
;Returns physical sector in reg. HL. If no skew table (reg. DE = 0) then
;returns physical = logical.

	LD   L,C
	LD   H,B
	RET


MOVE:
;====
      	EX   DE,HL		;we are passed source in DE and dest in HL
	LDIR			;use Z80 block move instruction
        EX   DE,HL              ;need next addresses in same regs
DUMMY:  RET


*EJECT
?INIT:	DI			;disable interrupts
	IM   1			;interrupt mode 1 (RST 7)
      	LD   C,23		;function # --> reg. C
	CALL ?USERF		;general system initialization

	.XLIST
	.XCREF

;check copyright message of boot sector:
COPYRGT	EQU  0FD0FH		;location of copyright message
CGTLEN	EQU  47			;length of copyright message
CHKSUM	EQU  0F0E2H		;checksumm of copyright message

	LD   IX,COPYRGT		;^copyright message 	         --> reg. IX
	DEFB 0FDH,2EH,CGTLEN	;LD LY,CGTLEN (length of message --> reg. LY)
	LD   HL,0		;clear reg. HL (accumulator)
	LD   D,H		;clear MSB of summand
ADDC:	LD   E,(IX)		;load first char of message
	ADD  HL,DE
	INC  IX			;bump message pointer
	DEFB 0FDH,2DH		;DEC LY (decrement loop counter)
	JR   NZ,ADDC		;add all chars of message
	LD   A,L		;make 2'complement of checksumm
	NEG
	LD   L,A
	LD   A,H
	CPL
	CCF
	ADC  A,D
	LD   H,A 
	LD   DE,CHKSUM		;compare value of checksumm --> reg. DE
	OR   A          	;16 bit compare
	SBC  HL,DE
	JR   Z,SERCHK		;jump if match
	LD   HL,VIOMSG		;^violate message      --> reg. HL
	LD   B,VIOLEN/2         ;length of message / 2 --> reg. B		
	CALL DECODE		;decode violate message
	LD   DE,VIOMSG		;^violate message  --> reg. DE
	LD   B,VIOLEN-1     	;length of message --> reg. B
	JR   DISPMSG

;check serial number:
SERNO  	EQU  0FD3EH		;location of serial number
SERLEN	EQU  7			;length of serial number

SERCHK:	LD   IX,SERNO  		;^serial number     	        --> reg. IX
	DEFB 0FDH,2EH,SERLEN	;LD LY,SERLEN (length of number --> reg. LY)
	LD   HL,0		;clear reg. HL (accumulator)
	LD   D,H		;clear MSB of summand
ADDS:	LD   E,(IX)		;load first char of serial number
	ADD  HL,DE
	INC  IX			;bump serial number pointer
	DEFB 0FDH,2DH		;DEC LY (decrement loop counter)
	JR   NZ,ADDS		;add all digits of number 
	LD   A,L		;make 2'complement of checksumm
	NEG
	LD   L,A
	LD   A,H
	CPL
	CCF
	ADC  A,D
	LD   H,A 
	LD   B,H		;checksumm		    --> reg. BC
	LD   C,L
	LD   DE,(0036H)		;compare value of checksumm --> reg. DE
	OR   A          	;16 bit compare
	SBC  HL,DE
	JP   Z,DS$INIT		;jump if match
	JP   DS$INIT		;Statt des Copyright Schutzes, immer springen 	
	OR   A
	SBC  HL,BC		;compare value not initialized ?
	JR   Z,INISER		;jump to serialization
	LD   HL,ILLMSG		;^illegal message      --> reg. HL
	LD   B,ILLEN/2          ;length of message / 2 --> reg. B		
	CALL DECODE		;decode illegal message
	LD   DE,ILLMSG		;^violate message  --> reg. DE
	LD   B,ILLEN-1     	;length of message --> reg. B
	JR   DISPMSG

;initialize serial number:
INISER:	LD   (0036H),BC		
	XOR  A			;bank   0, drive 0
	LD   B,1		;sector 1
	LD   E,A		;track  0
	LD   H,A 		;^buffer    --> reg. HL
	LD   L,A
	LD   C,$WRITE		;function # --> reg. C
	CALL ?USERF		;write serial #
	OR   A			;any errors ?
	JP   Z,DS$INIT		;jump if not
DISPERR:LD   DE,ERRMSG		;^violate message  --> reg. DE
	LD   B,ERRLEN-1		;length of message --> reg. B
	LD   C,$VDCHAR		;function #     --> reg. C
DISPER1:LD   A,(DE)		;next character --> accu
	CALL ?USERF		;clear screen
	INC  DE			;bump char pointer
	DJNZ DISPER1		;display message
	JR   $			;hang up

;display message:
	LD   HL,VIOMSG		;^violate message      --> reg. HL
	LD   B,VIOLEN/2         ;length of message / 2 --> reg. B		
	CALL DECODE		;decode violate message
	LD   DE,VIOMSG		;^violate message  --> reg. DE
	LD   B,VIOLEN-1     	;length of message --> reg. B



DISPMSG:LD   C,$VDCHAR		;vector # 	   --> reg. C
DISPMS1:LD   A,(DE)		;next character    --> accu
	CALL ?USERF		;clear screen
	INC  DE			;bump char pointer
	DJNZ DISPMS1   		;display message
	LD   C,$WRITE		;vector # --> reg. C
	LD   HL,3800H     	;^screen  --> reg. HL
	LD   E,0    		; track # --> reg. E 
      	LD   B,E      		;begin with sector 0
CLEAR:	LD   A,11010100B	;enable  memory mapped I/O
				;disable graphic display
				;disable boot EPROM
				;disable graphic page
				;7.2 MHz clock frequency
				;enable video display
	OUT  ($SYS1),A		;write system byte 1
      	XOR  A			; drive # --> accu 
	PUSH HL			;save buffer pointer
       	CALL ?USERF		;destroy selected sector
	POP  HL			;restore buffer pointer
	INC  B			;increment sector #
	JR   NZ,CLEAR           ;destroy all sectors
	INC  E   		;destory all tracks
	JR   CLEAR    		;endless loop

;disk error message:
ERRMSG:	DEFB SUB
	DEFM 'DISK ERROR'
	DEFB BEL,BEL,BEL,BEL,BEL,BEL,BEL
ERRLEN	EQU  $-ERRMSG

;violate message is encrypted for harder disassembly:
VIOMSG:	DEFB NOT 'C',NOT SUB
	DEFW NOT 'OP',NOT 'YR',NOT 'IG',NOT 'HT',NOT ' V'
 	DEFW NOT 'IO',NOT 'LA',NOT 'TE',NOT 'D ' 
VIOLEN	EQU  $-VIOMSG

;illegal copy message is encrypted for harder disassembly:
ILLMSG:	DEFB NOT 'I',NOT SUB
	DEFW NOT 'LL',NOT 'EG',NOT 'AL',NOT ' C',NOT 'OP', NOT 'Y '
ILLEN	EQU  $-ILLMSG


DECODE:	LD   A,(HL)		;first byte of message --> accu
	CPL  			;decode it
	LD   C,A		;save it
	INC  HL			;bump message pointer
	LD   A,(HL)		;second byte of message --> accu
	CPL			;decode it
	DEC  HL			;swap both bytes
	LD   (HL),A
	INC  HL
	LD   (HL),C
	INC  HL			;bump message pointer
	DJNZ DECODE 		;decode and swap next two bytes
	RET

	.CREF
	.LIST

;hard disk init routine:
DS$INIT:XOR  A			;bank 0, drive 0
	LD   D,A		;track 0
	LD   E,A
	LD   B,A		;sector 0
	LD   HL,SPARE$DIRECTORY	;^buffer
	LD   C,16		;function #
	CALL ?USERF		;read in spare directory
	OR   A			;any errors ?
	RET  Z			;return if not
	JP   DISPERR     	;display error message and hang up


*EJECT
;table of driver entry vectors:
$VDINIT	EQU  0    		;initialize the video controller chip M6845
$RSINIT	EQU  1    		;initialize the RS-232-C interface
$KBCHAR	EQU  2    		;get a keyboard character if available
$KBWAIT	EQU  3     		;wait for a keyboard character
$VDCHAR	EQU  4    		;display a character
$PRSTAT	EQU  5    		;test printer status
$PRCHAR	EQU  6    		;output a character to the printer
$RSRCST	EQU  7    		;get a character from the RS-232-C interface if
				;available
$RSRCV	EQU  8    		;receive a character from the RS-232-C
				;interface
$RSTXST	EQU  9    		;test the RS-232-C output status
$RSTX	EQU  10    		;transmit a character to the RS-232-C interface
$READ	EQU  11   		;read a disk sector
$WRITE	EQU  12   		;write a disk sector
$GETTIM	EQU  13   		;get time and date in binary format
$SETTIM	EQU  14   		;set time and date in binary format
$XMOVE	EQU  15			;interbank data transfer
$GTIME3	EQU  18			;get time and date in CP/M 3 format
$STIME3	EQU  19			;set time and date in CP/M 3 format
$LDCHAR	EQU  20			;load bit pattern into character RAM
$RSTCHR	EQU  21			;restore original character set
$SCRNIO EQU  22			;direct screen I/O
$INIT	EQU  23			;general system initialization
$CLOCK	EQU  24			;turn clock display on/off
$DISP	EQU  25			;turn on/off graphic display
$CLS	EQU  26			;clear graphic screen
$PLOT	EQU  27			;plot dot    on graphic screen
$POINT	EQU  28			;read dot  from graphic screen
$LINE	EQU  29			;draw line   on graphic screen
$CIRCLE	EQU  30			;draw circle on graphic screen
$ARC	EQU  31			;draw arc    on graphic screen
$COPY	EQU  33			;copy area

;call ROM driver routines:
?USERF:	LD   (SAVESP),SP	;save stack pointer
	LD   SP,0E100H  	;temporary stack --> stack pointer
        PUSH BC			;save register set
	PUSH DE
	PUSH HL
	PUSH IX
	PUSH IY
	DI			;disable interrupts
       	RST  0     		;call driver routine
	PUSH AF    		;save accu
	LD   A,11010101B	;disable memory mapped I/O
				;disable graphic display
				;disable boot EPROM
				;disable graphic page
				;7.2 MHz clock frequency
				;enable video display
	OUT  ($SYS1),A		;write system byte 1
	POP  AF    		;restore accu
	POP  IY			;restore register set
	POP  IX
	POP  HL
	POP  DE
	POP  BC
	LD   SP,(SAVESP)	;restore stack pointer
	RET			;return to caller

SAVESP: DEFS 2			;temporary memory for stack pointer


*EJECT
@TRK:	DEFS 2			;current track number
@SECT:	DEFS 2			;current sector number
@DMA:	DEFS 2			;current DMA address


ALV0    EQU  $
DIR     EQU  ALV0+203
DATA   	EQU  DIR+512 
SPARE$DIRECTORY EQU DATA+512 

	END
