
                    Z P M 3   by Simeon Cran
                    ========================

          A Z80 coded CP/M 3.0 compatible BDOS replacement.

               The first public release: 27/3/92
                    This document dated: 2/4/92

          Distributed at: Z-Node 62 (Perth, Western Australia)
                     V21,V22,V22bis 09 450 0200


WELCOME TO ZPM3
~~~~~~~~~~~~~~~
Welcome to the best CP/M compatible operating system for Z80 
based computers with banked memory. The best? Yes, we believe so. 
CP/M 3.0 has had bad press, but the fact is that it is faster 
than CP/M 2.2 ever was, and it offered more integrated 
facilities. Perhaps it was all the Z80 replacement BDOSes for 
CP/M 2.2 which stole the limelight from CP/M 3.0, or was it just 
that few computers had the required banked memory?

Whatever the reason for CP/M 3.0's lack of success in the 
marketplace, there are still plenty of users who will stand by 
its wonderful facilities and speed. For those users ZPM3 provides 
the long awaited Z80 coded update.

ZPM3 offers all the good things that CP/M 3.0 does, and then it 
offers more. Because ZPM3 is written in Z80 code rather than the 
8080 code of CP/M 3.0, it can do everything that CP/M 3.0 does, 
but in much less space. With the extra space recovered, ZPM3 
packs in a number of new facilities. Yet the whole package fits 
in exactly the same space as CP/M 3.0 so you can directly replace 
your old CP/M 3.0 BDOS with ZPM3 without a worry.

ZPM3 is also fast. Faster, in fact, than CP/M 3.0. This is 
possible because the rich Z80 instruction set allows many 
algorithms to be implemented more efficiently. In addition, the 
extra space available in ZPM3 has been put to use to further 
optimise the code. Lots of small optimisations smooth the 
execution flow, so ZPM3 becomes the fastest operating system on 
most banked CP/M computers.


THE FEATURES
~~~~~~~~~~~~
ZPM3, in addition to complete CP/M 3.0 compatibility, offers the 
following features:

Random Read Bug fixed.
++++++++++++++++++++++
Maybe you didn't know, but CP/M 3.0 has a bug. It affects random 
reads under very specific circumstances, and can result in a 
program thinking that you don't have some pieces of data in a 
file when in fact you do. The bug would occur very, very rarely, 
but it is real. ZPM3 finally squashes it.


Protected SCB User code
+++++++++++++++++++++++
The System Control Block of CP/M 3.0 was a revolution at the 
time. ZCPR has a system environment and most other operating 
systems have other similar structures, but the SCB of CP/M 3.0 
was one of the very first.

Unfortunately, Digital Research never properly documented it, and 
some programmers found things out about it that weren't quite 
true and started programming accordingly. As well, because it is 
available in the TPA bank, runaway programs can overwrite it 
causing problems.

Mostly though, the SCB will survive, or at least any problems 
will be so obvious that the user will realise that a crash has 
occurred and will reboot. A real problem exists with the CP/M 3.0 
code however when the user value is written over with a value 
above 15. Many programs now directly write to this byte, and if 
they put a value in that is above 15, all sorts of havoc can 
happen with the disk system. Actually, CP/M 3.0 will handle user 
areas above 15 with this method, and all seems ok until the 
operating system mistakes one of these directory entries as an 
XFCB. Simply put, user areas above 15 must not be used with CP/M 
3.0.

ZPM3 has code which prevents these problems, making the system 
even more stable.


Obsoleted Trap system.
++++++++++++++++++++++
One of the problems of the banked operating system was that it 
was possible to redirect the BIOS to code below common memory, in 
which case the banked BDOS could not access it. One solution is 
to call all BIOS code from common memory, but this involves a 
bank switch for every BIOS call, and this slows things down 
considerably.

CP/M 3.0 got around the problem by providing special code just 
below the SCB. If you redirected the BIOS, you also had to change 
this code which caused a bank switch when your new BIOS routine 
was called. When you removed the redirection, you also had to 
restore the special code.

This system has major drawbacks. For a start, if you redirect the 
BIOS, then another program redirects your redirection, then you 
remove your first redirection (along with the special code), the 
bank switch won't happen for the second redirection and the 
system will crash.

If a CP/M 2.2 program tried to do the redirection, it would know 
nothing about CP/M 3.0 and would not adjust the special code, so 
a crash would result in that case too.

The special code was called the "Trap System" as it was meant to 
trap redirection (as long as you set the trap). ZPM3 has 
eliminated the need for the traps. They are still there, and 
programs can still fiddle with them, but it doesn't matter how 
they are set, they are ignored. There is simply no need for them 
anymore. And this has been achieved without a performance 
penalty. In fact, in the case of a program which sets the traps 
but forgets to restore them, performance is now much better.


Semi-Permanent Read Only status for drives.
+++++++++++++++++++++++++++++++++++++++++++
In recent years, a trend in CP/M 2.2 is to make drives which have 
been set read only to remain that way until explicitly changed by 
function 37. ZPM3 now adopts this logic. Previously a control-C 
would return a read only drive to read write. The advantage is 
that a program can now make a drive read only for a session and 
know that it will stay that way.


ZCPR compatible function 152
++++++++++++++++++++++++++++
Function 152 is the CP/M 3.0 parser. It was a great innovation at 
the time as parsing is one of the more tedious aspects of 
programming for CP/M. Unfortunately, almost as soon as it 
appeared, it was made obsolete by the fact that it didn't handle 
references to user number (DU references). A line such as 
A:FILE.TYP would be correctly parsed, but A3:FILE.TYP would not. 
CP/M 3.0 programs would often parse the drive and user 
separately, then give function 152 the line without the DU: 
reference. All this extra work should not have been necessary if 
CP/M 3.0 had included user number parsing.

ZPM3 parses the user number, and goes even further by handling 
named directories for ZCPR. This is possible as long as you set a 
special word in the SCB which tells ZPM3 where to find the ZCPR 
system environment descriptor. ZCCP, a companion CCP for ZPM3, 
handles this automatically, but for Z3PLUS users, a special 
utility is available which automatically sets this word.

The result is that CP/M 3.0 programs will not balk at DU: 
references and ZPM3 aware programs can use the full DU: and DIR: 
facilities of function 152. It has also made the brilliant ZCCP 
code possible.


New Functions 54 and 55
+++++++++++++++++++++++
Datestamps in CP/M 3.0 are wonderful, but difficult to 
manipulate. Two new functions make them easier to handle and at 
the same time give compatibility to Z80DOS aware programs.

Function 54 (Get Stamp) returns a Z80DOS compatible datestamp. 
Any program (such as many directory programs) which recognise the 
Z80DOS standard can make use of function 54. There is only one 
slight difference between Z80DOS datestamps and ZPM3's which you 
should be aware of. Z80DOS will return a correct datestamp after 
any successful open or search of any extent. ZPM3 can only return 
a correct datestamp after a successful open or search of the 
first extent of the file. This is because CP/M 3.0 datestamps are 
only saved for the first extents of each file, in order to 
provide the highest performance.

Even more interesting is Function 55 (Use Stamp) which provides a 
mechanism for changing datestamps on files. Trying to do this 
with CP/M 3.0 was virtually impossible because it involved direct 
sector writes. With Function 55 you can simply set the stamp and 
then write.

Wheel protected files
+++++++++++++++++++++
If you are using a ZCPR system (ZCCP or Z3PLUS), ZPM3 has access 
to the wheel byte and supports wheel protected files. Such files 
act normally if the wheel is set (signifying a priveleged user), 
but if the wheel is not set, the files can not be changed. This 
is of most benefit to BBS systems. The implementation is 
virtually the same as most current Z80 CP/M 2.2 compatible 
BDOSes.

Better error messages
+++++++++++++++++++++
CP/M 3.0 introduced the best error messages that CP/M had ever 
had. ZPM3 goes further. The main difference you will notice is 
that the user number as well as the drive is shown in the error 
message. This is invaluable in helping you identify which file 
might have caused a problem.

Function 10 history buffer and improved editing.
++++++++++++++++++++++++++++++++++++++++++++++++
Function 10 is used by the CCP to input command lines. Many other 
programs use function 10 for input.

CP/M 3.0 introduced a history buffer for function 10. You press 
control-W and you were returned the last command. It is a great 
facility, but because it only remembers one command it is rather 
limited. There have been RSXes written which give a much larger 
history buffer, but RSXes take up extra program memory so are 
undesirable.

ZPM3 gives a large (approximately 250 bytes) history buffer which 
can store multiple commands. It also makes very intelligent use 
of the buffer so that identical commands are not stored twice, 
and commands of less than three characters are not stored. The 
history buffer takes up no additional memory, and is always 
available.

For security, it is possible to clear the history buffer so that 
other users can not see what commands you have used.

The ZPM3 history buffer feature is so good, that for many users, 
the ZPM3 upgrade is completely justified by it.

As part of the history buffer system, ZPM3 also offers a facility 
called Automatic Command Prompting. This can be disabled, or can 
be made switchable from the keyboard. When it is on, ZPM3 tries 
to fill in the rest of your command based on what commands you 
used most recently. It is like magic, and can save you typing out 
complicated commands many times. In effect, it looks through the 
history buffer for you and finds the command it thinks you want. 
As you keep typing, if it turns out that the command doesn't 
match anymore, it will try to match another command, and if it 
can't, it lets you make the command by yourself. This facility is 
quite amazing to watch.

And to integrate the history buffer and the automatic command 
prompting, function 10 has the best command line editing you'll 
find anywhere. Most of the control keys do something when you are 
editing a function 10 line, and for the most part they mimic the 
standard WordStar/NewWord/ZDE functions. You can jump to 
different words in the command, delete individual words, delete 
individual letters, insert letters, and a whole lot more.


Here is a list of what the various control keys do for function 
10:

A    Move left one word
B    Go to the beginning or end of the line
C    Warm boot if at start of line, otherwise nothing
D    Go right one character
E    Go backwards one command in the history buffer
F    Go right one word
G    Delete current character
H    Destructive backspace
I
J    Enter line
K    Delete all to the right
L
M    Enter line
N
O
P    Toggle printing
Q    Toggle automatic command prompting (if enabled)
R
S    Go left one character
T    Delete current word
U    Add current line to history buffer
V    Clear line and delete from history buffer
W    Go forwards one command in the history buffer
X    Delete all to the left
Y    Clear the whole line
Z





If in using ZPM3 you find that it doesn't act as described, 
please forward the details to me so that either the ZPM3 code or 
the documentation can be changed. If you would like further 
details, please forward your specific questions to me. SJC.