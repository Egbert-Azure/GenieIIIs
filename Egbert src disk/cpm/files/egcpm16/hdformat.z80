; This is a stand alone program written in Z80 assembly language
; which sends commands to the XEBEC S1410 controller and 5.25 hard
; disk in following order:
;   1) reset the controler
;   2) recalibrate the drive
;   3) format the drive
;   4) write one sector from WRITEBUF
;   5) read the same sector into READBUF
;
; if the program completes properly, the read buffer (READBUF)
; should be the same. Normal completion is at label TEST6
;
; lets wait and see / E.S. 12.12.92
; Program from owner manual XEBEC CONTROLER
;
WPORT0   EQU       000H      ;SASI WRITE PORT 0-WRITE DATA
WPORT1   EQU       001H      ;                1-SOFTWARE RESET
WPORT2   EQU       002H      ;                2-CNTRL SELECT
WPORT3   EQU       003H      ;NOT USED
RPORT0   EQU       000H      ;SASI READ PORT 0-READ DATA
RPORT1   EQU       001H      ;               1-READ STATUS
RPORT2   EQU       002H      ;NOT USED
RPORT3   EQU       003H      ;NOT USED

REQBIT   EQU       000H      ;REQUEST LINE BIT POSITION
REQMASK  EQU       001H      ;REQUEST MASK FOR BIT TEST
BUSYBIT  EQU       001H      ;BUSY LINE BIT POSITION
BUSYMASK EQU       002H      ;BUSY MASK FOR BIT TEST
MSGBIT   EQU       002H      ;MESSAGE LINE BIT POSITION
MSGMASK  EQU       004H      ;MESSAGE MASK FOR BIT TEST
CDBIT    EQU       003H      ;COMMAND/DATA BIT POSITION
CDMASK   EQU       008H      ;COMMAND/DATA BIT POSITION TEST
IOBIT    EQU       004H      ;INPUT/OUTPUT BIT POSITION
IOMASK   EQU       010H      ;INPUT/OUTPUT BIT MASK

DRVREADY EQU       000H      ;TEST DRIVE READY COMMAND
FORMAT   EQU       004H      ;FORMAT COMMAND CODE 
READ     EQU       008H      ;READ COMMAND CODE
WRITE    EQU       00AH      ;WRITE COMMAND CODE
SENSE    EQU       003H      ;STATUS SENSE COMMAND CODE
INITL    EQU       00CH      ;INITIALIZE DISK SIZE COMMAND
SEEK     EQU       00BH      ;SEEK COMMAND CODE
RECAL    EQU       001H      ;RECALIBRATE COMMAND CODE
RAMDIAG  EQU       0E0H      ;RAM DIAGNOSTIC COMMAND CODE
ERROR    EQU       002H      ;TEST FOR AN ERROR

WRITEBUF DEFS      512       ;WRITE BUFFER
READBUF  DEFS      512       ;READ BUFFER
STACK    DEFS      020H      ;CALL STACK
STACKTOP EQU       $         ;TOP OF STACK
TASK     DB        0,0,0,0,1,80
         DB        0FH
         DB        0,0,0,0
         org       100h
start
;
;First reset the controler
         out       (wport1),a     ;send out a reset pulse
;test to see that the drive is up and ready after controller
;has been selected
test1    equ       $
         ld        sp,stacktop    ;set the stack pointer
         call      selcntlr       ;select the controller
         ld        a,drvready     ;drive ready command
         call      taskout        ;send out the command
         call      getstat        ;get the completion status
         jp        z,test2        ;test for proper completion
         ret                      ;error completion
;send out a recalibrate to the controller
test2    EQU       $
         CALL      selcntlr       ;SELECT THE CONTROLLER
         LD        A,RECAL        ;RECALIBRATE COMMAND CODE
         CALL      TASKOUT        ;SEND COMMAND TO CNTRL
         CALL      GETSTAT        ;GET COMPLETION STATUS
         JP        Z,TEST3        ;TEST FOR ERROR COMPLETION
         RET
;send a format command to the controller
test3    equ       $
         call      selcntlr       ;select the controller
         ld        a,format       ;format command code
         call      taskout        ;send command to controller
         call      getstat        ;get completion status
         jp        z,test4        ;test completion status
         ret
;write out a sector to the disk
test4    equ       $
         call      selcntlr       ;select the controller
         ld        a,write        ;write command code
         call      taskout        ;send task to controller
         ld        hl,writebuf    ;point to the write buffer
         call      reqwait        ;wait for cntrl request
write1   equ       $
         in        a,(rport1)     ;get cntrl status lines
         and       cdmask         ;test for command mode
         jp        nz,write2      ;if cmnd transfer is done
         ld        a,(hl)         ;get a data byte
         out       (wport0),a      ;send data to controller
         inc       hl             ;bump the buffer pointer
         jp        write1         ;more to go, loop
write2   equ       $
         call      getstat        ;get transfer status
         jp        z,test5        ;test completion status
         ret
;read a sector from the disk
test5    equ       $
         call      selcntlr       ;select the controller
         ld        a,read         ;read command code
         call      taskout        ;send command to controller
         ld        hl,readbuf     ;point to read buffer
         call      reqwait        ;wait for request from cntrlr
read1    equ       $
         in        a,(rport1)     ;get cntrlr status lines
         and       cdmask         ;test for cmnd mode from cntlr
         jp        nz,read2       ;if on end of transfer
         in        a,(rport0)     ;read in the disk data
         ld        (hl),a         ;save it in the buffer
         inc       hl             ;bump the buffer pointer
         jp        read1          ;loop until 256 transferred
read2    equ       $
         call      getstat        ;get completion status
         jp        z,test6        ;continue if no error
         ret                      ;error stop
test6    equ       $
         jp        prende
;this subroutine selects the default controller
selcntlr equ       $
         in        a,(rport1)     ;read status port
         and       busymask       ;mask busy bit
         jp        nz,selcntlr    ;jump if busy
         ld        a,1            ;cntrl default select code
         out       (wport0),a     ;send it to transparent latch
         out       (wport2),a     ;generate a select strobe
sel1     equ       $
         in        a,(rport1)     ;get cntrl response
         and       busymask       ;isolate the busy mask
         jp        z,sel1         ;wait for cntrl busy
         ret
;this subroutine sends out the command contained in a register
;to the disk controler
taskout  equ       $
         ld        hl,task        ;point to task control block
         ld        (hl),a         ;save the command
         ld        b,6            ;set up a byte counter
         call      reqwait        ;wait for controller request
task1    equ       $
         ld        a,(hl)         ;get a command byte
         out       (wport0),a     ;send it to the controller
         inc       hl             ;bump the task pointer
         dec       b              ;decrement the byte count
         jp        nz,task1       ;wait until all are output
         ret
;this subroutines retrieves the status byte and the null byte
;from the disk controller at the end of a command. The a register
;is returned with a non-zero value if error has been detected.
getstat  equ       $
         call      reqwait        ;wait for request
         in        a,(rport0)     ;read in the status byte
         ld        d,a            ;save status temporarily
         call      reqwait        ;wait for second byte
         in        a,(rport0)     ;get the null byte
         ld        a,d            ;restore status to a
         and       error          ;isolate the error bit
         ret
;this subroutine waits for the request line to become active
;from the disk controller
reqwait  equ       $
         in        a,(rport1)     ;get cntrl status bits
         and       reqmask        ;request and wait for it
         ret
prende   end       start
