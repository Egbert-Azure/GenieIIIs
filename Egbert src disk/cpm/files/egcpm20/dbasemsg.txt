*DBASE
                   HELP TEXT FILE DBASEMSG.TXT
                 VERSION 1.16 FOR dBASE II v2.4
             Copyright 1983 Ashton-Tate and RSP, Inc.
     Written by Wayne Ratliff, Jim Taylor, and Howard Dickler

                         EINF]HRUNG

Diese   Einf}hrung gibt Ihnen On-Line Informationen zum dBASE  II
Datenbank-System. Sie erl{utert die verschiedenen Dateien, welche
Sie mit dBASE II erhalten haben und vermitteln einen Eindruck vom
Leistunsgverm|gen des Systems.

Durch die gleichzeitig* Nutzung der HELP-Funktion und des  Benut-eldung                                  J*die Lage versetzt, Daten-n und des  Benut-eldung                                  J*iduellen versetzt, Daten-n und des  Benut-eldung                                  J*hren <<<<<<<setzt, Daten-n und des  Benut-eldung                                  J*n Hilfestellung zum dBASE II-System,  indem  Sie HELP                             J*Kommandos oder HELP  und  eines  der  indem  Sie HELP                             J*ENDERPROGRAMME    BEGRIFFE      HELP          NEUHELP                             J*E     FUNKTIONEN    DBASEE      HELP          NEUHELP                             J*S: Das Schl}sselwort mu~  vollst{ndig eingegeben werden !                         J*rkl{rung f}r das Schl}sselwort suchen  undegeben werden !                         J*gefunden wird (z.B. wegenlwort suchen  undegeben werden !                         J*LP-TEXTE wird (z.B. wegenlwort suchen  undegeben werden !                         J* jeder Seite "SYSTEM WARTET", z.B. wie hier:eben werden !                         J* um fortzufahren <<<<<<<TET", z.B. wie hier:eben werden !                         J*nd: fortzufahren <<<<<<<TET", z.B. wie hier:eben werden !                         J*achrichtenfahren <<<<<<<TET", z.B. wie hier:eben werden !                         J*.COM  -- Programm  zur  Anpassung an das  Terminal  (bei!                         J*gepa~ter  Version bzw. nach erfolgterdas  Terminal  (bei!                         J*gepa~ter  Version bzw. nach erfolgterdas  Terminal  (bei!                         J*f vorhanden sein m}ssen, sind:folgterdas  Terminal  (bei!                         J*IHREM dBASE II-SYSTEM ARBEITEN:olgterdas  Terminal  (bei!                         J*hres  Terminals.YSTEM ARBEITEN:olgterdas  Terminal  (bei!                         J
                gestartet haben.
SETS.PRG     -- Stellt  die Standardwerte bei de*               gestartet haben.olgterdas  Terminal  (bei!                         J*i  nach        gestartet haben.olgterdas  Terminal  (bei!                         J*-- Druckt Adressenaufkleber (Labels).das  Terminal  (bei!                         J*utzt wird.Adressenaufkleber (Labels).das  Terminal  (bei!                         J*ER.PRG    -- Wandelt  das Kalenderdatum in das Julianische Datum                  J* und umgekehrt.ndelt  das Kalenderdatum in das Julianische Datum                  J*programme vorberei-t  das Kalenderdatum in das Julianische Datum                  J*htogramme vorberei-t  das Kalenderdatum in das Julianische Datum                  J*end  von selbst.  Sie eignen sich gut zum  ]ben  undnische Datum                  J*rderungen {ndern. Die einzelnen Pro-t zum  ]ben  undnische Datum                  J*weckm{~ig mit einemie einzelnen Pro-t zum  ]ben  undnische Datum                  J*seckm{~ig mit einemie einzelnen Pro-t zum  ]ben  undnische Datum                  J*CARDFILE) mit einemie einzelnen Pro-t zum  ]ben  undnische Datum                  J*    TEXT.DBF       CPRINT.PRG     KEYWORD.NDXen  undnische Datum                  J*ICKLE.FRM     EDITCARD.FMTPRG     KEYWORD.NDXen  undnische Datum                  J*             (F}hren eines Girokontos)ORD.NDXen  undnische Datum                  J*OS.FMT   CHXBOOK.MEM eines Girokontos)ORD.NDXen  undnische Datum                  J*NTORY MANAGEMENT FILESines Girokontos)ORD.NDXen  undnische Datum                  J*N.PRG        INVENT.DBF    ISETUP.PRG      I'BYNMBR.NDXche Datum                  J*SC.NDX  INVQUAN.PRG     INV'CONS.FRMG      I'BYNMBR.NDXche Datum                  J*SC.NDX  INVQUAN.PRG     INV'CONS.FRMG      I'BYNMBR.NDXche Datum                  J*n Personaldaten)PRG     INV'CONS.FRMG      I'BYNMBR.NDXche Datum                  J*   EMP-ENTR.PRG   EMP-UPD.FMT      EMP-UPD.PRG    EMP-PRT.FRMtum                  J*MP-CONS.FRM     EMP-RPRT.PRG   E'BYNMBR.NDXPRG    EMP-PRT.FRMtum                  J
*HP150
dBASE II auf dem HEWLETT PACKARD  150
dBASE II wurde speziell f}r den HP 150 angepa~t. F}r dieses System
wurden nachfolgend aufgef}hrte HELP-Texte integrier*BASE II auf dem HEWLETT PACKARD  150MBR.NDXPRG    EMP-PRT.FRMtum                  J

*EXIT
*KEYBOARD

dBASE wurde speziell f}r die Tastatur des HP 150 angepa~t. Folgende
Tasten sind im Seitenmodus (Full-screen-mode) m|glich:

Clear line             -- l|scht den Inhalt eines Feldes oder einer Zeile
Insert line            -- f}gt eine neue Zeile in MODIFY COMMAND und
                          MODIFY STRUCTUR ein
Delete line            -- l|scht eine Zeile im MODIFY COMMAND und
          *BASE wurde speziell f}r die Tastatur des HP 150 angepa~t. Folgende                J*f}g-und-]berschreib-Modusie Tastatur des HP 150 angepa~t. Folgende                J*     -- l|scht das Zeichen auf der Cursor-Positiongepa~t. Folgende                J*t eine Zeile oder einen Datensatz zur}ckr-Positiongepa~t. Folgende                J*te oder einen Datensatz weiter vorzur}ckr-Positiongepa~t. Folgende                J*OWSE weiteren Datensatz weiter vorzur}ckr-Positiongepa~t. Folgende                J*{~SE weiteren Datensatz weiter vorzur}ckr-Positiongepa~t. Folgende                J* den Bildschirm an, bis diese Taste erneutPositiongepa~t. Folgende                J
Softkeys F1 bis F8     -- Softkeys F1 bis F8 m|glich
                          (V*oftkeys F1 bis F8     -- Softkeys F1 bis F8 m|glichepa~t. Folgende                J*ktiv:ys F1 bis F8     -- Softkeys F1 bis F8 m|glichepa~t. Folgende                J*t                  Home             EnterF8 m|glichepa~t. Folgende                J*zeptiert die deutsche Tastatur und verarbeitetglichepa~t. Folgende                J*Die auf der lokalen Tastatur gene- verarbeitetglichepa~t. Folgende                J*nbanken einbringen undstatur gene- verarbeitetglichepa~t. Folgende                J*cksichtigt.bringen undstatur gene- verarbeitetglichepa~t. Folgende                J*eldnamen noch als Speichervariablen-Namen.itetglichepa~t. Folgende                J*iver Bildschirmeingabe mit dBASE II:Namen.itetglichepa~t. Folgende                J*befehlsausf}hrung von ESCape-ASE II:Namen.itetglichepa~t. Folgende                J* nicht auf dem Bild-n ESCape-ASE II:Namen.itetglichepa~t. Folgende                J*ziellenauf dem Bild-n ESCape-ASE II:Namen.itetglichepa~t. Folgende                J*ngabefelder auf dem Bildschirm zu l|schen, m}ssen die nachfolgend auf-            J*ichen abgesendet werden. Sie erscheinen nicht auf dem Bild-olgend auf-            J*sichtbar, da das erste Zeichen ein ESCape ist.auf dem Bild-olgend auf-            J*in TOUCH-Feld, das die Zeilen 5-7 und die Stellen 11-22 abdeckend auf-            J* Sequenz gegeben werden.eilen 5-7 und die Stellen 11-22 abdeckend auf-            J*+chr(13) gegeben werden.eilen 5-7 und die Stellen 11-22 abdeckend auf-            J*rmhr(13) gegeben werden.eilen 5-7 und die Stellen 11-22 abdeckend auf-            J*enz spezifiziert ein sensitives Eingabefeldtellen 11-22 abdeckend auf-            J*er Zeileifiziert ein sensitives Eingabefeldtellen 11-22 abdeckend auf-            J*wird nicht auf dieses Feld gesetztngabefeldtellen 11-22 abdeckend auf-            J*rung ert|nenuf dieses Feld gesetztngabefeldtellen 11-22 abdeckend auf-            J*    -- das Feld ver{ndert sich zur inversen Darstellung nach Ber}hrung            J*ASCII-Zeichenfelder{ndert sich zur inversen Darstellung nach Ber}hrung            J*Zeichen im sensitiven Feldsich zur inversen Darstellung nach Ber}hrung            J*-- ist ein RETurn-Befehlldsich zur inversen Darstellung nach Ber}hrung            J*em Bildschirm.urn-Befehlldsich zur inversen Darstellung nach Ber}hrung            J*FILE,ldschirm.urn-Befehlldsich zur inversen Darstellung nach Ber}hrung            J*etzte ESCape-Sequenzen werden durch nachfolgend beschriebene Sequenzen            J

      ? chr(27)+"-z2N"

dBASE erlaubt Ihnen somit eine freie Konfiguration von *     ? chr(27)+"-z2N"n werden durch nachfolgend beschriebene Sequenzen            J*uerung chr(27)+"-z2N"n werden durch nachfolgend beschriebene Sequenzen            J* Programm "TSETUP.Prg" auf Ihrer Diskette, wel -beschriebene Sequenzen            J*einhaltet. Weitere M|glichkeiten,sensi-te, wel -beschriebene Sequenzen            J*dem HP 150 durchzuf}hren,fin-ten,sensi-te, wel -beschriebene Sequenzen            Jntation.

*EXIT
*SOFTKEYS
Die Funktionstasten des HP 150 k|nnen mit EScape-Sequenzen programmiert
werden. Um die Werte dieser Funktions-Tasten zu ver{ndern, benutzen Sie
bitte die Funktionstasten gem{~ der HEWLETT-PACKARD-Dokumentation.
Die SET-Funktion von dBASE, die eine [nderung der Funktionstasten erm|g-
licht, sind im dBASE-Programm abgeschaltet.

*EXIT
*BILDSCHIRM-MODUS
               CURSOR BEWEGUNGEN -- ALLE KOMMANDOS

ctrl-X bewegt Cursor abw{rts zum n{chsten Feld (wie ctrl-F)
ctrl-E bewegt Cursor aufw{rts zum vorherigen Feld (wie ctrl-A)
ctrl-D bewegt Cursor ein Zeichen nach rechts (vorw{rts)
ctrl-S bewegt Cursor ein Zeichen nach links (r}ckw{rts)
ctrl-G l|scht das Zeichen unter dem Cursor
<Rubout> oder <DEL> l|scht das Zeichen links vom Cursor
ctrl-Y l|scht das laufende Feld rechts vom Cursor
ctrl-V schaltet um zwischen ]berschreib- und INSERT-Modus
ctrl-W speichert [nderungen und geht zur}ck zum "." -Prompt

                         IM EDITIER-MODUS

ctrl-U schaltet die Markierung DELETE des Satzes EIN bzw. AUS
ctrl-C schreibt laufenden Satz auf Diskette, geht zum n{chsten
ctrl-R schreibt laufenden Satz auf Diskette, geht zum vorherigen
ctrl-Q ignoriert [nderungen im Satz und geht zur}ck zum "."-Prompt
ctrl-W speichert alle [nderungen und geht zur}ck zum "."-Prompt

                         IM BROWSE-MODUS

ctrl-B verschiebt das Bildschirm-Fenster ein Feld nach RECHTS
ctrl-Z verschiebt das Bildschirm-Fenster ein Feld nach LINKS

                         IM MODIFY-MODUS

ctrl-T l|scht die laufende Zeile, zieht alle unteren Zeilen hoch
ctrl-N einf}gen einer neuen Zeile an der Cursorposition
ctrl-C schiebt Bildschirm eine halbe Seite abw{rts
ctrl-W speichert alle [nderungen und geht zur}ck zum "."-Prompt
ctrl-Q ignoriert alle [nderungen und geht zur}ck

                         IM APPEND-MODUS

<enter> beendet APPEND, wenn der Cursor in der ersten Position
        des ersten Feldes ist
ctrl-W speichert den Datensatz und geht zum n{chsten Satz
ctrl-Q ignoriert den laufenden Satz, geht zur}ck zum "."-Prompt

    CONTROL-TASTEN OPERATIONEN, WENN NICHT IM BILDSCHIRM-MODUS

ctrl-P schaltet Ihren Drucker AN und AUS
ctrl-R wiederholt das zuletzt ausgef}hrte Kommando
ctrl-X l|scht die Kommandozeile, ohne ein Kommando auszuf}hren
ctrl-H R}cklauf
ctrl-M erzeugt einen Wagenr}cklauf
ctrl-S startet/stoppt CPU-Operationen
*INSTALL
Zur  vollen Nutzung der dBASE II Bildschirm-Editierm|glichkeiten,
mu~  eine  vollst{ndige  Anpassung von dBASE II an  das  Terminal
erfolgen.  Wird  dies vers{umt,  erscheint ein Durcheinander  auf
Ihrem  Bildschirm bei Operationen  wie APPEND oder  EDIT, die den
gesamten Bildschirm zur Anzeige verwenden.


Die  Anpassung nimmt das Programm INSTALL.COM (wird  mit  INSTALL
aufgerufen) im Dialog mit Ihnen vor.  Mit STARTUP.PRG sollten Sie
zun{chst die Anpassung }berpr}fen, ehe SIe mit INSTALL [nderungen
vornehmen.  Anschlie~end  kann  das Ergebnis wiederum mit STARTUP
gepr}ft werden.
*EXIT
*NEU
> Neue Kommandos und [nderungen im dBASE II
Neue Kommandos:

HELP      --    Kommando zur Benutzerhilfe.
REINDEX   --    ordnet und aktualisiert vorhandene Index-Dateien.
SET F<n>  --    zur Belegung der Funktionstasten bei den Rechnern
                PC, IBM PC, Victor, TI Professional sowie zum IBM
                PC kompatible Typen.
SET COLOR --    {ndert Bildschirmfarbe der o.a. Terminals.
TEXT      --    zeigt mehrere Textzeilen an, wird beendet mit ENDTEXT.
RANK(  )  --    liefert ASCII-Kode des ersten Zeichens.
TEST(  )  --    bestimmt die G}ltigkeit von <Ausdr>.

Erweiterte Kommandos:

APPEND,INSERT,EDIT,CREATE -- k|nnen nun eine Format-Datei zur
                             Bildschirmsteuerung verwenden.
BROWSE    --    kann nun eine Liste von Feldern bearbeiten.
DISPLAY  STATUS  -- zeigt benutzte Datenbank-Dateien , Indizes
                    und SET-Parameter an.
READ & REPLACE  --  Diskettenzugriff kann unterbunden werden,
                    z.B. wenn keine [nderung an Schl}sselwerten
RELEASE   --    kann nun "subsets" der tempor{ren Variablen freisetzen.
RESTORE   --    bereits vorhandene tempor{re Variablen bleiben auf
                Wunsch erhalten.
SAVE      --    kann nun "subsets"der tempor{ren Variablen speichern.
SET RAW ON  --  eliminiert freien Platz im DISPLAY- und ?-Kommando.
UPDATE    --    ersetzte Klausel kann nun WITH-Ausdruck beinhalten.
*EXIT
*BEGRIFFE
                        dBASE II BEGRIFFE

<Kommando>   oder   <Aussage>  - alle  g}ltigen   dBASE-Kommandos
     (Befehle) oder -Funktionen.

<Zeichenkette>  -- Sie m}ssen in den meisten F{llen begrenzt
     sein mit einfachen (' '), doppelten Anf}hrungszeichen
     (" ") oder Klammern ( : : ).

<Zeichenketten Ausdr> -- Ausdruck, dessen Inhalt vom Zeichentyp
     her festgelegt ist. Kann eine "Zeichenkette", eine "tempor{re
     Variable"  oder  ein  Feld vom Typ C  bzw. Kombinationen dieser
     Arten mittels dBASE-Operatoren (z.B. "+")

<Begrenzer>  -- jedes nicht alphanumerische Zeichen, das benutzt
     wird,  um  Daten zu kennzeichnen,  z.B.  Apostroph (' '),
     Anf}hrungszeichen (" ") oder Klammern.

<Ausdr> oder <Ausdruck> -- ein Zeichen oder eine Zeichengruppe,
     deren Wert von dBASE bestimmt werden kann. <Ausdr> ist ab-
     h{ngig vom Datentyp mit C, N, oder L bezeichnet.

<Ausdrliste> -- eine Liste durch Komma getrennter Ausdr}cke.

<Feld>       -- Name eines Datenfeldes innerhalb eines Datensatzes.

<Feldliste>  -- eine Liste mit Feldnamen, getrennt durch Kommas.

<Datei>      -- Name der Datei, die Sie erzeugen oder bearbeiten wollen.

<Indexdatei> -- Name der Index-Datei.

<Schl}ssel>  -- Felder (auch kombiniert) zum Indizieren von Daten-
                bankdateien

<tempVar>    -- Der Name einer tempor{ren Variablen.

<tempVarliste> -- Liste mit tempor{ren Variablen,  getrennt durch
                  Kommas.

<n>          -- eine Zahl, die dBASE als Buchstaben betrachtet.

<num Ausdr>  -- Ausdruck mit numerischem Inhalt.

<Bereich>    -- das Kommando legt einen Bereich in einer Datenbank-
     datei fest, der bei  Ausf}hrung eines Kommandos ber}cksichtigt
     wird. <Bereich>  kann  sein:  ALL(e) S{tze der Datei; NEXT <n>
     S{tze  der Datei und  RECORD <n>. Der Standardwert ist vom je-
     weiligen Befehl abh{ngig.

<Muster>     -- erlaubt eine  Batchverarbeitung von Dateien dessel-
                ben Typs und/oder  mit passenden Zeichen im  Datei-
                namen bei Benutzung von "wild cards", ? and*. Dient
                auch zur Auswahl einer Gruppe von  termpor{ren  Va-
                riablen.

<Variable>   -- Name eines Datenfeldes oder einer <tempVar>.

: :          -- schlie~t optional zu verwendende Angabe ein  (statt
                eckiger Klammern)
*EXIT
*?
*??
> ?          -- Erarbeitet  und  zeigt den Wert eines Ausdruckes an.
                Kann in Programmdateien (und woanders) ohne Ausdruck
                benutzt  werden, um  das Ergebnis  eine Zeile tiefer
                anzuzeigen.

                   . ? 6/3
                     2
                   . ? 'Stadt'
                     Stadt
                   . ? STADT (Feld innerhalb der benutzten Datei)
                     Managua

> ??     --  wie ?; zeigt aber das Ergebnis auf derselben Zeile an.
*EXIT
*@
> @      --  Ausgabe (formatierter) Daten auf Bildschirm oder Drucker
             beginnend bei x,y-Koordinate (x=Zeile, y=Spalte).

Syntax:

  @ <Koordinaten> :SAY <Ausdr> :USING '<picture>'::
       :GET <Variable> :PICTURE '<picture>'::

Beispiele:

  @ 3,23 SAY WERT * 1.06 USING '$$$,$$$.99'

  @ 14,23 SAY "TEL-NR EINGEBEN" GET TEL PICTURE '(###)###-####'

  @ LINE+2,45 SAY TOTAL USING '99999.99'
*EXIT
*ACCEPT
>  ACCEPT  -- Eingabe  einer Zeichenkette in eine bestimmte tempo-
              r{re Variable, die dann vom Typ "C"  ist. Als Prompt
              erscheint ein Doppelpunkt; leere Engabe (d.h. RETURN)
              belegt Varibale mit einem Leerzeichen)

   Syntax: ACCEPT :"<Zeichenkette>": TO <tempVar>

   Beispiele: . ACCEPT "Wie ist Ihr Name?" TO NAME
             Wie ist Ihr Name?: (Antwort wird in NAME gespeichert)
           . ? NAME
             (Antwort wird auf dem Bildschirm angezeigt)
*EXIT
*APPEND
> APPEND FROM <Datei> :FOR <Ausdr>: oder APPEND FROM <Datei> :SDF:
     :DELIMITED: :FOR <Ausdr>: -- f}gt Datens{tze von einer Daten-
      bank-Datei oder  einer Format-Datei an die  gerade  benutzte
     Datenbank-Datei an. Datens{tze, die in der Ursprungsdatei zum
     L|schen markiert sind, werden nicht }bernommen.

     z.B.  APPEND FROM ADRESSLISTE FOR NAME='N'
           APPEND FROM TEST.TXT DELIMITED

> APPEND BLANK -- f}gt einen leeren Datensatz an die Datei an.

> APPEND -- f}gt neue Datens{tze an die benutzte Datenbank-Datei an.
     (Falls ein Index benutzt wird,  wird die Index-Datei ebenfalls
     aktualisiert).
*EXIT
*BROWSE
> BROWSE :FIELDS <Feldliste>: -- Ausgabe der Felder auf Bildschirm
        (Voreinstellung: alle) und Bearbeitungsm|glichkeit dort mit
        freier Cursor-Positionierung.
*EXIT
*CANCEL
> CANCEL -- Beendet in einer Programmdatei die Dateibearbeitung und
            geht zur}ck zum "."-Prompt.

        Ausschnitt aus Programmdatei:

     ACCEPT "Was soll diese Maschine machen?" TO NEXT
        IF NEXT = 'Q'
           CANCEL
        ENDIF
*EXIT
*CHANGE
> CHANGE -- Erlaubt eine feldweise Bearbeitung von Datenbanken.
            Dr}cken der ESCape-Taste beendet CHANGE-Modus.

         Syntax:  CHANGE :<Bereich>: FIELD <Liste> :FOR <Ausdr>:

  Beispiel: CHANGE ALL FIELD PLZ FOR PLZ = '8000'
            RECORD: 00001
            PLZ: 8000
            CHANGE?
   (Zu {nderndes Zeichen eingeben und Return dr}cken. Neue  Daten
   mit dem TO-Prompt einf}gen oder  Return dr}cken, um den n{chs-
   ten gew}nschten Datensatz zu erhalten.)
*EXIT
*CLEAR
> CLEAR -- schlie~t alle er|ffneten Datenbanken und l|scht alle
           erzeugten tempor{ren Variablen und Arbeitsbereiche.

> CLEAR GETS -- weist dBASE an, alle noch aktiven GET-Angaben zu
                eliminieren, ohne den Bildschirm zu l|schen.
*EXIT
*COPY
> COPY  -- kopiert  Daten aus der benutzten Datenbank oder deren
      Struktur in eine andere Datei. COPY erzeugt die neue Datei,
      falls sie noch nicht existiert, kann aber eine bereits vor-
      handene Datei mit gleichem Namen zerst|ren. Zum L|schen mar-
      kierte Datens{tze werden nicht kopiert.

  Das Kommando hat drei Formen:

  COPY TO <Datei> :<Bereich>: :FIELD <Liste>: :FOR <Ausdr>:
  COPY  TO  <Datei>  :SDF:  :DELIMITED  :WITH  <Begrenzer>::
            :FOR <Ausdr>:
  COPY TO <Datei> STRUCTURE :FIELD <Liste>:

>  COPY  TO  <Datei> STRUCTURE EXTENDED -- spezielle Form von COPY.
      Erzeugt Datenbank, deren Datens{tze die Struktur der be-
      nutzten Datei beschreiben.
*EXIT
*COUNT
> COUNT -- Z{hlt die Anzahl der Datens{tze in der benutzten Datei,
           die eine angegebe Bedingung erf}llen. Standardwert ist:
           COUNT alle Datens{tze.

  Syntax:  COUNT  <Bereich> :FOR <Ausdr>: :TO <tempVar>:

  Beispiel: COUNT NEXT 25 FOR TEMPERATUR > 'B-' TO LISTE
*EXIT
*CREATE>  CREATE :<Dateiname>: -- Erzeugt eine neue Datenbank. Be-
          nutzer wird nach der Dateistruktur gefragt.

>  CREATE <Neudatei> FROM <Altdatei> EXTENDED -- erzeugt eine Da-
          tenbank,  deren Struktur bestimmt wird durch die Daten,
          die in den Datens{tzen der alten Datei enthalten sind.
          (siehe auch COPY STRUCTURE EXTENDED.)
*EXIT
*DELETE
> DELETE FILE <Datei> -- l|scht eine bestimmte Datei.

> DELETE :<Bereich>: :FOR <Ausdr>: -- markiert S{tze als gel|scht.
         Datens{tze, die mit "*" als gel|scht markiert sind, wer-
         den erst entfernt, wenn das PACK-Kommando gegeben wird.
         Datens{tze k|nnen auch durch die Satznummer angegeben
         werden.

 Beispiele: DELETE ALL FOR FIRMA = 'ZMB'
             DELETE RECORD 15
*EXIT
*DISPLAY
> DISPLAY  FILES :ON <Laufwerk>:  :LIKE  <Muster>:  -- zeigt
          Inhaltsverzeichnis des Disketten-Laufwerkes.

          Zum Beispiel: DISPLAY FILES ON B LIKE *.MEM.

> DISPLAY :<Bereich>: :<Feldliste>: :FOR<Ausdrliste>: :OFF:
          -- zeigt die Datens{tze der benutzten Datei an.

> DISPLAY STRUCTURE -- zeigt die Feldnamen, -typen, -l{ngen und
          Dezimalstellen (Datenstruktur) der benutzten Datei an.

> DISPLAY MEMORY -- zeigt Namen, Typen und Werte alle tempor{ren
                    Variablen an.

> DISPLAY STATUS -- listet benutzte Datenbanken, Indizes, System-
          angaben und laufende Systemparameter auf.
*EXIT
*DO
*ENDCASE
*ENDDO
*LOOP
> DO <Datei> -- |ffnet und f}hrt eine Programmdatei aus.

> DO WHILE <Ausdr> -- f}hrt in einer Programmdatei eine Gruppe von
     Anweisungen mehrfach aus (Schleife); wird so lange durchlaufen,
     wie DO WHILE <Ausdr> wahr ist.

  Syntax: DO WHILE <Ausdr>      Beispiel: USE ADRESSLISTE
             <Befehle>                    DO WHILE .NOT. EOF
          :LOOP:                          ? NAME
             <Befehle>                    ? TELEFON
          ENDDO                           SKIP
                                          ENDDO

> ENDDO -- beendet den Anweisungsblock in einer DO WHILE-
           Anweisung.





>  LOOP -- veranla~t die Programmdatei, zur weiteren Bearbeitung
           zur}ck zum DO WHILE-Kommando zu springen.

           Beispiel:  USE ADRESSLISTE
                      DO WHILE .NOT. EOF
                        IF PLZ = '8000'
                           SKIP
                           LOOP
                         ENDIF
                           ? NAME
                           ? TELEFON
                           SKIP
                      ENDDO

*CASE
> DO CASE -- wird in Programmdateien benutzt, um die Ausf}hrung
     fallweise zu steuern. Wahlweise  kann die OTHERWISE-Klausel
     benutzt werden, die dann gilt, wenn kein CASE zutrifft.
     Befehl mu~  mit ENDCASE beendet werden.

     Beispiel: USE ADRESSLISTE
               ACCEPT "WELCHE ALTERNATIVE W]NSCHEN SIE?" TO Wahl
               DO CASE
                  CASE Wahl = '1'
                       DO Aufkleber
                  CASE Wahl = '2'
                       DO Anf}gen
                  CASE Wahl = '3'
                       DO Editieren
                 OTHERWISE
                      Return
               ENDCASE
*EXIT
*EDIT
> EDIT :<Satznummer>: -- erlaubt die gezielt Bearbeitung von
       Daten durch die Angabe der Satznummer. Fragt nach der
       Satznummer, falls diese nicht mit dem Befehl angegeben
       wurde. Wenn die Bearbeitung eines Satzes abgeschlossen
       ist, wird mit ctrl-W wieder das Prompt zur Eingabe der
       Satznummer erreicht. Um den EDIT-Modus zu beenden,
       f}r Satznummer RETURN eingeben.
*EXIT
*EJECT
> EJECT -- veranla~t beim Drucker einen Seitenvorschub, falls
       PRINT auf "ON" oder FORMAT auf "PRINT" gesetzt ist. Bei
       Verwendung von "@ SAY"-Kommandos f}r formatierte Ausgaben
       setzt EJECT den Zeilen- und Spaltenz{hler auf Null.
*EXIT
*ERASE
>  ERASE -- l|scht die Bildschirmanzeige. Im Dialog erscheint
       der "."-Prompt in der linken oberen Bildschirmecke.
*EXIT
*FIND
> FIND <Zeichenkette> -- sucht einen Datensatz in einer indi-
       zierten Datenbank nach dem Wert des Schl}sels <Zeichenkette>.
*EXIT
*GO
*GOTO
>  GO oder GOTO -- geht zu einer bestimmten Position (Datensatz-
       nummer) in einer Datenbank. Die Datensatznummer kann auch
       Inhalt einer tempor{ren Variablen sein.

   Syntax: GO oder GOTO :RECORD <n>:, <n>, :TOP:, :BOTTOM: od
           <temp.Var>
*EXIT
*HELP
                dBASE II ON-LINE HELP EINRICHTUNG

Im folgenden finden Sie eine Liste aller  dBASE-Kommandos. Zu je-
dem hier aufgef}hrten Kommando sind  mit HELP <Kommando>  weitere
Erl{uterungen verf}gbar.

Daran schlie~t sich eine  kurze Beschreibung  jedes Kommandos mit
einer Darstellung der Schreibweise an. Diese Information gibt nur
eine ]bersicht - sozusagen als Ged{chtnisst}tze, um  allzu h{ufi-
ges Nachschlagen im Handbuch zu vermeiden.

Um  Angaben }ber die dBASE-Kommandos  (oder andere  Angaben  }ber
die HELP-Datei) zu erhalten,  geben Sie nach dem  "."-Prompt ein-
fach HELP <Kommandoname>  und Return (<cr>) ein (z.B. HELP CREATE
<cr>).  Nach Ausgabe der  Erl{uterung kehrt dBASE zum  "."-Prompt
zur}ck; so da~  Sie ohne Unterbrechung weiterarbeiten k|nnen.  In
einigen F{llen beansprucht die Information mehrere Seiten auf dem
Bildschirm,  z.B. wie hier. Um weiterzubl{ttern, dr}cken Sie eine
beliebige Taste.

Falls Sie die HELP-Datei verlassen wollen, bevor Sie alle Angaben
gesehen haben, dr}cken Sie einfach ESCape.

       >>>> Geben Sie 'HELP dBASE' ein f}r weitere <<<<<<
               >>>>> wichtige Informationen <<<<<

> ?      -- zeigt einen Ausdruck, eine Variable oder ein Feld an.
> ??     -- zeigt eine Liste von Ausdr}cken an, ohne vorher einen
            Zeilenvorschub auszuf}hren.
> @      -- gibt formatierte Daten auf Bildschirm oder Drucker aus.
> ACCEPT -- Eingabe einer Zeichenkette in eine bestimmte tempo-
            r{re Variable.
> APPEND -- f}gt Informationen von einer anderen dBASE-Datenbank
            oder Datei an die benutzte Datei an.
> BROWSE -- Bildschirm-Darstellung und -Bearbeitung der Datenbank.
> CANCEL -- beendet die Ausf}hrung einer Programmdatei.
> CHANGE -- feldweise Bearbeitung von Datenbanken.
> CLEAR  -- schlie~t alle er|ffneten Datenbanken und l|scht alle
            erzeugten tempor{ren Variablen.
> CONTINUE -- setzt die Suchaktion nach einem LOCATE-Befehl fort.
> COPY   -- kopiert Daten aus einer Datei in eine andere Datei.
> COUNT  -- z{hlt die Datens{tze in einer Datei, die eine an-
            gegebene Bedingung erf}llen.
> CREATE -- erzeugt eine neue Datenbank-Datei.
> DELETE -- l|scht eine Datei oder markiert einen Satz zum L|schen.
> DISPLAY-- zeigt Dateien, Datens{tze oder Strukturen, tempor{re
            Variable oder den Status an.
> DO     -- f}hrt Programmdateien oder strukturierte Schleifen aus.
> EDIT   -- ruft die Bearbeitung von Daten in einer Datenbank auf.
> EJECT  -- erzeugt Seitenvorschub auf dem Drucker.
> ELSE   -- alternativer Weg bei der Befehlsausf}hrung innerhalb IF.
> ENDCASE-- beendet einen CASE-Befehl.
> ENDDO  -- beendet einen DO WHILE-Befehl.
> ENDIF  -- beendet einen IF-Befehl.
> ENDTEXT-- beendet einen TEXT-Befehl.
> ERASE  -- l|scht den Bildschirm.
> FIND   -- sucht einen Datensatz in einer indizierten Datei.
> GO oder GOTO -- geht zu einer bestimmten Position in einer Datei
> HELP   -- gibt dem Benutzer Hilfestellung auf dem Bildschirm.
> IF     -- erlaubt eine bedingte Befehlsausf}hrung.
> INDEX  -- erzeugt eine Index-Datei.
> INPUT  -- erlaubt Eingabe von Ausdr}cken in tempor{re Variable.
> INSERT -- einf}gen neuer Datens{tze.
> JOIN   -- erzeugt gemeinsame Ausgabe aus zwei Datenbank-Dateien.
> LIST   -- listet Dateien, Datens{tze, Strukturen, tempor{re
            Variable und den Status auf.
> LOCATE -- findet einen Datensatz, der eine Bedingung erf}llt.
> LOOP   -- springt zum Anfang eines DO WHILE-Befehls.
> MODIFY -- erzeugt und/oder bearbeitet eine Programmdatei oder
            {ndert die Struktur in einer Datenbank-Datei.
> NOTE oder * -- Kommentar-Einleitung in einem Programm.
> PACK   -- eliminiert Datens{tze, die zum L|schen markiert sind.
> QUIT   -- verl{~t dBASE und geht zum Betriebssystem zur}ck.
> READ   -- erlaubt Datei-Bearbeitung mit formatiertem Bildschirm,
            nimmt die Daten aus @ GET-Anweisungen entgegen.
> RECALL -- l|scht die Markierungen zum L|schen von Datens{tzen.
> REINDEX-- aktualisiert die vorhandene Index-Datei.
> RELEASE-- eliminiert unerw}nschte tempor{re Variablen und
            macht Speicherbereiche frei.
> REMARK -- erlaubt die Anzeige beliebiger Zeichen.
> RENAME -- gibt einer Datei einen neuen Namen.
> REPLACE-- {ndert Informationen in einem Datensatz oder in einer
            ganzen Datenbank-Datei Feld f}r Feld.
> REPORT -- erzeugt einen Bericht.
> RESET  -- startet Betriebssystem nach Einlegen einer neuen Diskette.
> RESTORE-- reaktiviert tempor{re Varibale aus einer Datei, ggf. in
            Erg{nzung zu bereits vorhandenen Variablen.
> RETURN -- beendet den Lauf einer Programmdatei.
> SAVE   -- speichert die tempor{ren Variablen auf der Diskette.
> SELECT -- schaltet zwischen prim{rer und sekund{rer Datenbank um.
> SET    -- setzt dBASE-Kontrollparameter.
> SKIP   -- springt vorw{rts und r}ckw{rts in der Datenbank.
> SORT   -- erzeugt  eine  Datei,  die  nach  einem  Schl}sselfeld
            sortiert ist.
> STORE  -- erzeugt tempor{re Variablen.
> SUM    -- berechnet die Gesamtsummen der Felder in einer Datenbank.
> TEXT   -- gibt Textbl|cke von einer Programmdatei aus.
> TOTAL  -- erzeugt zusammengefa~te Kopien einer Datenbank, be-
            stehend aus Daten bestimmter Felder oder Datens{tze.
> UPDATE -- aktualisiert eine Datenbank im Batchbetrieb.
> USE    -- er|ffnet eine Datenbank f}r nachfolgende  Bearbeitung,
            bis der n{chste USE-Befehl erscheint.
> WAIT   -- unterbricht die Programmausf}hrung, bis eine Eingabe
            vom Benutzer erfolgt ist.

               >>>>> Andere Schl}sselw|rter <<<<<

                (z.B. 'HELP BEISPIELE' eingeben)

    ANWENDERPROGRAMME    BEGRIFFE      HELP          NEU
    KENNDATEN            BEISPIELE     FUNKTIONEN    DBASE 
    BILDSCHIRM-MODUS     INSTALL
*EXIT
*IF
*ELSE
*ENDIF
> IF -- erlaubt in der Programmdatei die bedingte Ausf}hrung von     
        Befehlen. Die ELSE-Klausel ist optional.

  Syntax: IF <Ausdr>         Beispiel: IF STAAT = 'D'
             <Aussage>                     DO INLAND (CMD Datei)
          :ELSE                         ELSE
             <Aussage>:                    DO AUSLAND (CMD Datei)
          ENDIF                         ENDIF 
*EXIT
*INDEX
> INDEX  ON <Ausdr> TO <Indexdatei> -- erzeugt eine Index-Datei
     f}r die Datenbank, wobei der Index festgelegt wird durch
     <Ausdr> oder <Indexschl}ssel>.
*EXIT
*INPUT
> INPUT :"<Zeichenkette>": TO <tempVar> -- nimmt Eingaben des Be-
        nutzers (numerische und logische Informationen) entgegen
        und legt sie in tempor{ren Variablen ab.

        Beispiel: INPUT 'Benutzernr. eingeben' TO X
                  Benutzernummer eingeben: 12 <cr>
                  (Benutzernr., 12, wird in X gespeichert)
                  . ? X
                  12
*EXIT
*INSERT
>  INSERT ::BEFORE: :BLANK:: -- f}gt einen Datensatz in die  Datei
       ein, unmittelbar nach oder - mit BEFORE - vor dem laufenden
       Datensatz.  Zeigt  dem Benutzer das Dateneingabeformat  f}r
       die  benutzte Datei an, au~er, ein leerer (BLANK) Datensatz
       wird eingegeben.

*EXIT
*JOIN
> JOIN  -- erzeugt eine neue Datei durch Verbindung der Datens{tze
       aus  zwei  bestehenden  Dateien  (prim{re  und   sekund{re
       Datei).  Datens{tze  werden   angef}gt,  solange  wie  FOR
       <Ausdr>  wahr ist. Befehl mu~ im  prim{ren Datenbankbereich
       ausgef}hrt werden. Standardwert f}r <Feldliste> ist ALL.

       Syntax: JOIN TO <Datei> FOR <Ausdr> :FIELDS <Feldliste>:

       Example: . USE NAMES
                . SELECT SECONDARY
                . USE ADRESSLISTE
                . SELECT PRIMARY
                . JOIN TO NAMEJ FOR LAST <> S.LAST
*EXIT
*LIST
> LIST FILES :ON <Laufwerk>: :LIKE  <Muster>:  --  listet alle
       Dateien  auf dem gew{hlten Laufwerk auf.  Standardwert  ist 
       das gew{hlte Laufwerk.
       Beispiel: LIST FILES ON C LIKE *.FRM

> LIST :<Bereich>: :<Feldliste>: :FOR <Ausdrliste>: :OFF: 
       -- zeigt  Datens{tze der benutzten Datei  an.  Standardwert 
          ist ALL (alle) Datens{tze.
   
    Beispiel: LIST NEXT 25 NAME, TELEFON FOR KOSTEN > 100
       (z.B., NAME und TELEFON f}r die n{chsten 25, die mehr als
       DM 100 Telefonkosten haben.
    
> LIST STRUCTURE -- zeigt Datenstruktur der benutzten Datei.

> LIST MEMORY -- listet alle Namen und Werte der festgelegten
                 tempor{ren Variablen auf.

> LIST STATUS -- listet ge|ffnete  Dateien, benutzte Indizes, Sy-
                 stemdaten und gesetzte Parameter auf.
*EXIT
*LOCATE
*CONTINUE
>  LOCATE  :<Bereich>: FOR <Ausdr> -- findet ersten Datensatz f}r
         den  FOR <Ausdr> als Wahr gilt.  Verwenden Sie CONTINUE, 
         um den n{chsten Datensatz zu finden. 


       . LOCATE ALL FOR PLZ >= '5000' .AND. PLZ < '4000'
       RECORD: 00123
       . DISPLAY
       . CONTINUE
       RECORD: 00232
*EXIT
*MODIFY
> MODIFY  STRUCTURE  -- erlaubt, die Struktur der benutzten Daten-
       bank zu ver{ndern. Dieser Befehl zerst|rt alle Daten in der
       benutzten  Datenbank.  Um die Struktur zu  ver{ndern,  ohne
       Daten zu verlieren, benutzen Sie COPY STRUCTURE, USE und
       APPEND wie unten beschrieben:

        . USE NAMES
        . COPY STRUCTURE TO TEMP
        . USE TEMP
        . MODIFY STRUCTURE  -- kein Datenverlust, da Datei leer
        . APPEND FROM NAMES -- bringt Daten in modifizierte Datei
        . DELETE FILE NAMES
        . USE -- TEMP
        . RENAME TEMP TO NAMES

>  MODIFY COMMAND <Datei> -- ruft dBASE's Texteditor und zeigt
       oder erzeugt die gew}nschte Datei. Prim{r zu nutzen zum
       Erzeugen und Bearbeiten von Programmdateien (.PRG), Text-
       dateien (.TXT) und Formatdateien (.FMT); aber auch als
       Bildschirm-Wortprozessor einzusetzen.
*EXIT
*NOTE
>  NOTE  or  * -- erlaubt das Einf}gen von  Kommentaren  in  eine
       Programmdatei.  Kommentare,  die  nach NOTE oder * folgen, 
       werden bei der Programmausf}hrung }bergangen. 
*EXIT
*PACK
> PACK -- eliminiert Datens{tze, die zum L|schen markiert sind.
       Falls eine Index-Datei vorhanden ist, wird sie automa-
       tisch aktualisiert.
*EXIT
*QUIT
> QUIT  :TO  <Programmdateiliste>: --  beendet  dBASE  und  geht
       zum Betriebssystem zur}ck. Ruft optional Programmdateien
       auf.
*EXIT
*READ
> READ   -- erm|glicht Bildschirm-Modus f}r die Eingabe  und  das
         Editieren  von  Variablen.  Die Bildschirm-Prompts  und
         -Fenster werden durch SAY- und GET-Kommandos erzeugt.

       Ausschnitt aus Programmdatei:

         STORE '          ' TO name
         STORE '          ' TO telefon
         @ 4,4 SAY 'Name' GET name
         @ 6,4 SAY 'Telefon' GET telefon PICTURE '(###)###-####'
         READ
*EXIT
*RECALL
> RECALL :<Bereich>: :FOR <Ausdr>:  -- reaktiviert  zum L|schen
        markierte Datens{tze. Standardwert f}r <Bereich> ist der
        laufende Datensatz.
*EXIT
*REINDEX
> REINDEX  -- aktualisiert diejenigen Index-Dateien, die nicht mit
        USE angeschlossen und daher nicht automatisch ge{ndert wurden.

       Beispiel:. USE ADRESSLISTE INDEX INDEXA
                . APPEND
                (auszuf}hrende Kommandos)
                . SET INDEX TO INDEXB,INDEXC
                . REINDEX
*EXIT
*RELEASE
>   RELEASE  -- eliminiert nicht mehr ben|tigte tempor{re Variable
       und macht davon belegten Speicherpl{tze frei. Mit "?" werden
       einzelne  (beliebige) Zeichen zugelassen,  mit "*" beliebige
       Zeichenreihen.

       Syntax: RELEASE :<tempVarliste>: oder :ALL:
               RELEASE ALL LIKE <Muster>
               RELEASE ALL EXCEPT <Muster>

       Beispiele (mit N, N1, N2, N10, V7 als Variablen):

               RELEASE ALL LIKE N?  (N10 und V7 bleiben erhalten)
               RELEASE ALL LIKE N?? (V7 bleibt erhalten)
               RELEASE ALL EXCEPT ?1* (N1 und N10 bleiben erhalten)
*EXIT
*REMARK
> REMARK  -- zur Kommentierung; beliebige Zeichenreihen verwendbar.
             Wird bei der Ausf}hrung von Programmen }berlesen.

       Beispiel: . REMARK abracadabara!!!
                   abracadabara!!!
*EXIT
*RENAME
> RENAME  <Datei> TO  <neuer Dateiname> -- {ndert  den Namen einer
       Datei im Verzeichnis des Betriebssystems. Wenn nicht anders
       vorgegeben, definiert dBASE den Dateityp als DBF.

       Beispiel: . RENAME REVIEW.FRM TO REVIEW2.FRM
*EXIT
*REPLACE
> REPLACE -- {ndert Daten in bestimmten Datenfeldern oder Dateien.
       Falls  das ge{nderte Feld gleichzeitig Schl}sselfeld in  der
       Index-Datei ist, erfolgt deren [nderung.
       Standardwert f}r <Bereich> ist der laufende Datensatz.

  Syntax: REPLACE :<Bereich>: <Feld> WITH <Ausdr> :,<Feld2> WITH
                         <Ausdr2>: :FOR <Ausdr>:

  Beispiel: . USE MXPROJ
            . REPLACE ALL COST WITH COST * 6.1 FOR ITEM = 'ELEC'
*EXIT
*REPORT
> REPORT -- erzeugt eine Format-Datei f}r einen Bericht (FRM), um
       bestimmte  Informationen aus einer Datei in einem  vom  Be-
       nutzer  festgelegten  Format auszugeben. Das  Ergebnis  er-
       scheint auf dem Bildschirm oder wird ausgedruckt.

       Syntax: REPORT :FORM <Formdatei>: :<Bereich>: :TO PRINT:
                       :FOR <Ausdr>: :PLAIN:
*EXIT
*RESET
> RESET :<Laufwerk>: -- nach einem Diskettenwechsel  ist  dieser
       Befehl auszuf}hren. Dadurch k|nnen w{hrend der Arbeit die
       dBASE Disketten ausgetauscht werden. Bevor jedoch der Be-
       fehl RESET ergeht, sind unbedingt alle Dateien auf der zu
       wechselnden Diskette abzumelden.
*EXIT
*RESTORE
> RESTORE FROM <Datei> :ADDITIVE: -- sucht und aktiviert die Pa-
       rameter  f}r tempor{re Variablen, die vorher mit SAVE ge-
       speichert worden sind.  Mit  ADDITIVE  wird erreicht, da~
       bereits vorhandene Variablen erhalten bleiben. Fehlt  die
       Angabe, werden alle aktuellen Variablen gel|scht   (siehe
       auch RELEASE).
*EXIT
*RETURN
> RETURN -- wird in einer Programmdatei benutzt,  um zum aufrufen-
       den Programm  oder  zum  dBASE  "."-Prompt  zur}ckzukehren.
*EXIT
*SAVE
> SAVE TO <Datei> :ALL LIKE <Muster>: oder :ALL EXCEPT <Muster>:
       -- speichert  alle  tempor{ren  Variablen  oder  nur  die-
       jenigen, die durch <Muster> definiert sind, in der angege-
       benen Datei. "?"  wird benutzt,  um einzelne   (beliebige)
       Zeichen  zuzulassen; mit "*" sind beliebige  Zeichenreihen
       erlaubt.

    Beispiele: (mit N1, N2, N10, V1, V2, V10 als Variablen):

         . SAVE TO NUMBER ALL LIKE N* (Speichert N1, N2, N10)
         . SAVE TO NUMBER ALL LIKE N? (Speichert N1, N2)
         . SAVE TO NUMBER ALL EXCEPT ?1* (Speichert N2, V2)
*EXIT
*SELECT
*PRIMARY
*SECONDARY
> SELECT :PRIMARY / secondary: -- schaltet zwischen prim{rer und
       sekund{rer Datenbank um. Dadurch kann der Benutzer gleich-
       zeitig  mit  zwei Dateien arbeiten,  wobei der  Satzz{hler
       jeweils erhalten bleibt.  Nach dem Start von dBASE ist zu-
       n{chst die prim{re Datenbank aktiviert.
*EXIT
*SET
> SET -- setzt dBASE Kontrollparameter.

         Syntax: SET <Parameter> :ON oder OFF:
                 SET <Parameter> TO <Option>

Alle SET-Kommandos sind unten in alphabetischer Reihenfolge  auf-
gelistet:  Beachten  Sie,  da~  einige SETs vom ON/OFF-Typ  sind,
andere  aber  bestimmte  Eingaben  erfordern.  Standardwerte  f}r
ON/OFF-Kommandos  werden  jeweils durch Gro~buchstaben  (ON  oder
OFF) angezeigt.

      Beispiel: SET BELL :ON/off: - Standardwert ist ON.

>  SET ALTERNATE :OFF/on: -- ON  sendet  alle  Bildschirmausgaben,
       au~er im Bildschirm-Modus) zu einer Disketten-Datei.  (Dem
       mu~ vorangehen: SET ALTERNATE TO <Datei>). OFF unterbricht
       die Ausgabe in die Datei.

>  SET BELL :ON/off: -- Mit ON ert|nt ein akustisches Signal, wenn
       ein  ung}ltiges  Zeichen  eingegeben  wird  oder  die Feld-
       grenze }berschritten wird. OFF schaltet das Signal aus.

>  SET CARRY :OFF/on: -- Mit  ON werden Daten aus  dem  vorherigen
       Datensatz in den laufenden Satz  geschrieben, wenn im Bild-
       schirm-Modus APPEND benutzt wird. OFF l{~t das Feld leer.

>  SET COLON :ON/off: -- ON zeigt im Bildschirm-Modus Doppelpunkte
       an, um Variablen einzugrenzen. OFF hebt diese Anzeige auf.

>  SET CONFIRM :OFF/on: -- ON verhindert im  Bildschirm-Modus  das
       automatische Springen zum n{chsten Feld, wenn das  laufende
       Feld   gef}llt  ist.   OFF  wartet  auf  die   Eingabe  von
       <Return>, bevor der Cursor zum n{chsten Feld springt.

>  SET  CONSOLE :ON/off: -- Mit  ON  erscheinen alle Eingaben  auf
       dem Bildschirm. OFF schaltet die Bildschirm-Anzeige aus;
       das System ist anscheinend "tot".

>  SET DEBUG :OFF/on: -- Mit  ON erscheint die mit ECHO und   STEP
       erzeugte Ausgabe auf dem  Drucker. OFF l{~t die Ausgabe auf
       dem Bildschirm erscheinen.


>  SET DELETED  :OFF/on: -- ON verhindert, da~  dBASE  zum L|schen
       markierte   Datens{tze  mit irgendeinem  Kommando  aufrufen
       oder  bearbeiten  kann   (z.B.  <Bereich>,  LIST,  DISPLAY,
       COUNT). OFF erlaubt dBASE, alle Datens{tze zu sehen.

>  SET ECHO :OFF/on:  --  ON  erm|glicht die Verfolgung einer Pro-
       grammausf}hrung  durch  Anzeige  aller  Kommandos  auf  dem
       Bildschirm. OFF zeigt keinen Ausf}hrungsbericht.

>  SET EJECT :ON/off:  -- ON  veranla~t den  REPORT-Befehl,  einen
       Seitenvorschub   auszuf}hren,  bevor ein auszugebender  Be-
       richt  zum  Drucker  geschickt  wird.  OFF  verhindert  den
       Seitenvorschub.

>  SET ESCAPE :ON/off: -- Mit ON kann der Benutzer die  Ausf}hrung
       der  Programmdatei  abbrechen,  indem  er die  ESCape-Taste
       dr}ckt. OFF erlaubt keinen Abbruch mit der ESCape-Taste.


>  SET EXACT :OFF/on: -- ON erfordert genaue Eingaben der Zeichen-
       ketten in jeder Einzelheit  (bei FOR<Ausdr>, FIND-Kommandos
       etc).  OFF  erlaubt die  Eingabe  voneinander  abweichender
       Zeichenketten,  z.B.  unterschiedliche  L{nge:
       'ABCDEF' = 'ABC'.

>  SET INTENSITY  :ON/off: -- ON erm|glicht eine inverse Darstel-
       lung oder  eine andere Helligkeit in der Bildschirmanzeige
       (falls die Hardware dies zul{~t).  OFF schaltet diese Ein-
       richtung ab.

>  SET LINKAGE :OFF/on:  -- ON erlaubt Bewegungen des  Satzzeigers
       in  der  prim{ren  und sekund{ren Datenbank mit  Hilfe  von
       Kommandos, die  einen bestimmten <Bereich> definieren, z.B.
       Bewegungen nur abw{rts. OFF schaltet diese Einrichtung ab.

>  SET PRINT :OFF/on: -- ON sendet die Ausgabe zum  Drucker.  OFF
       stoppt die Druckerausgabe.

>  SET RAW :OFF/on: --  Mit ON  werden bei  DISPLAY-  und   LIST-
       Befehlen keine Leerstellen zwischen den Feldern eingef}gt;
       OFF f}gt Leerstellen zwischen den Feldern ein.

>  SET SCREEN :ON/off: -- ON  erlaubt Bildschirm-Bearbeitung mit
       APPEND, EDIT, INSERT, READ, und CREATE Kommandos.

>  SET STEP :OFF/on: -- ON unterst}tzt das Testen von Programmda-
       teien, indem diese  in  Einzelschritten ausgef}hrt werden,
       d.h. nach jedem Befehl angehalten wird. OFF schaltet diese
       Testeinrichtung ab.

>  SET TALK :ON/off: -- ON zeigt Ergebnisse der Kommandoausf}hrung
       auf  dem  Bildschirm an. OFF unterdr}ckt diese Anzeige.

>  SET ALTERNATE TO :<Datei>: --  erzeugt eine Disketten-Datei mit
       der  Erweitung .TXT  zur Protokollierung der Bildschirmaus-
       gaben. SET  ALTERNATE  TO schlie~t die .TXT-Datei.

>  SET COLOR TO <n1,n2> -- bestimmt  Farbe oder  Bildschirmeigen-
       schaft der Terminalausgabe f}r IBM PC,  Victor, TI Profes-
       sional oder IBM PC kompatible Terminals.
       <n1>  w{hlt  die Farbe oder Helligkeit f}r die herausgeho-
       bene Darstellung, <n2> f}r die normale Darstellung. Weitere
       m|gliche <n>-Werte sind dem "Change Summary" zu entnehmen.

>  SET DATE  TO <xx/xx/xx> -- speichert  eine  Zeichenkette  als
       Systemdatum, pr}ft aber nicht die G}ltigkeit des Datums.

>  SET DEFAULT TO <Laufwerk> -- bestimmt das Laufwerk,  auf  dem
       dBASE  die  nicht  um die  Laufwerksbezeichnung erg{nzten
       Dateien sucht (Systemlaufwerk)

>  SET F<n> TO <'neuer Wert'> --  speichert 'neuen Wert' unter der
       Funktionstaste <n> beim IBM PC, TI Professional, Victor und
       zum IBM PC kompatiblen Rechnern. Siehe  dazu den Anhang f}r
       Standardwerte in "Change Summary" sowie  die Auflistung bei
       DISPLAY STATUS.

>  SET FORMAT TO <SCREEN/PRINT) -- Mit SCREEN erfolgt  die Ausgabe
       der  SAY-Kommandos auf  dem  Bildschirm, mit  PRINT auf dem
       Drucker.

>  SET FORMAT TO :<Formatdatei>: -- |ffnet eine  .FMT-Datei,  die
       dBASE benutzt,  um den Bildschirm bei READ,  APPEND,  EDIT,
       INSERT, CREATE, und SAY-Kommandos zu formatieren (Maske).
       SET FORMAT TO schlie~t die Format-Datei.

>  SET HEADING  TO  <Zeichenkette>  -- speichert  <Zeichenkette>
       intern und druckt sie als Kopfzeile im Bericht.

>  SET INDEX TO <Indexdateiliste> -- bestimmt Index-Datei f}r die
       korrespondierende Datenbank.   Die erste .NDX-Datei in der
       Liste wird als relevanter Index ( siehe  auch FIND ) akti-
       viert. Alle anderen Index-Dateien werden bei [nderungen in
       der Datenbank automatisch aktualisiert.

>  SET MARGIN TO <n> -- festlegen des linken Randes auf dem Drucker
       in Spalte <n>.
*EXIT
*SKIP
>  SKIP  :-: :<n>: -- bewegt den Satzz{hler auf- oder abw{rts  um
       <n> Datens{tze innerhalb der Datei. Standardwert ist +1.
*EXIT
*SORT
> SORT ON <Feld> TO <Datei> :ASCENDING / DESCENDING:  -- schreibt
       eine  neue Kopie der Datei mit allen Datens{tzen in  einer
       bestimmten  Reihenfolge.  Benutzt den ASCII-Kode  f}r  die
       Sortierung (Leerstellen,  Zahlen,  Gro~ buchstaben,  Klein-
       buchstaben  und dann Symbole). Zum L|schen markierte S{tze
       werden }bergangen.  Standardwert f}r die  Sortierfolge ist
       ASCENDING (aufsteigend).

       Beispiel: . USE ADRESSLISTE
                 . SORT ON PLZ TO POSTLEITZAHL DESCENDING
*EXIT
*STORE
> STORE <Ausdr>  TO  <tempVar> -- speichert den Wert  eines  Aus-
        drucks in eine tempor{re Variable.

        Beispiel: . STORE 3 TO NUMMER
                   3
                  . STORE NUMMER + 9 TO NUMMER2
                   12
                  . STORE 'KLAUS' TO NAME
                    KLAUS
                  . ? NUMMER+NUMMER2, ' ', NAME
                   15   KLAUS
*EXIT
*SUM
> SUM  -- berechnet und zeigt die Summen von numerischen  Feldern
       der Datei an.  Die Option <Bereich> bestimmt die Menge der
       Datens{tze  f}r die Summierung;  FOR <Ausdr> gibt f}r  die
       Summierung   bestimmte   Bedingungen  an;   TO   <tempVar>
       speichert das Ergebnis in der angegebenen tempor{ren Vari-
       ablen.  Standardwert f}r <Bereich> ist ALL (alle). Zum L|-
       schen markierte Datens{tze werden }bergangen.

       Syntax: SUM <Feld> :,<Feld2>: :<Bereich>:
                   :TO <tempVarliste>: :FOR <Ausdr>:

       Beispiele:

 . USE EINKAUFSLISTE :Felder sind TEIL, ANZAHL, PREIS:
 . SUM PREIS * ANZAHL FOR TEIL = 'Nahrung'
 . SUM ANZAHL FOR TEIL = 'Bier' TO GETR[NK
 . SUM ANZAHL, ANZAHL*PREIS FOR TEIL = 'BIER' .AND. PREIS >1.00
*EXIT
*TEXT

>  TEXT -- erzeugt in programmierte Textausgaben. Der  Text  ist
           zwischen TEXT und ENDTEXT einzuschlie~en. Erspart die
           (umst{ndlichere) Verwendung von "?" bzw. SAY.
*EXIT
*TOTAL
>  TOTAL  --  erzeugt eine summarisch ausgewertete Form einer in-
       dizierten oder vorsortierten Datei. Der Schl}ssel  mu~ als
       Index vorhanden oder die Datenbankdatei danach sortiert sein.
       Es  werden  dann die angegebenen Felder der S{tze mit glei-
       chem Schl}ssel summiert und das Ergebnis in einer  weiteren
       Datei abgelegt.
       Mit TOTAL kann man auch duplizierte S{tze entfernen.

       Syntax:   TOTAL  TO  <Datei> ON <Schl}ssel>
                 :FIELDS <Feldliste>:
*EXIT
*UPDATE
>  UPDATE -- aktualisiert vorsortierte oder indizierte Dateien im
       Batch  durch ]bernahme von Informationen von (FROM)  einer
       angegebenen  Datei (mit demselben Schl}ssel  vorsortiert).
       Die  Schl}ssel der benutzten Datei werden mit den  Schl}s-
       seln  der  angegebenen Datei auf ]bereinstimmung  gepr}ft.
       dBASE kann dann zusammengeh|rige Felder aus beiden Dateien
       miteinander  verbinden (z.B.  Addieren).  Es  k|nnen  auch
       ganze Felder in der benutzten Datei durch Inhalte der ent-
       sprechenden Felder der anderen Datei ersetzt werden.

   Syntax: UPDATE FROM <Datei> ON <Schl}ssel> :ADD <Feldliste>:
           :REPLACE <Feldliste> oder <Feld> WITH <Feldliste>:
           :RANDOM:
*EXIT
*USE
>  USE <Datei> :INDEX <Indexdateiliste>:  -- bestimmt  die  Datei
       f}r die nachfolgende Bearbeitung. USE schlie~t automatisch
       die  mit  einem vorherigem USE-Kommando  ge|ffnete  Datei.
       Optional  kann ein Index vergeben werden,  um die Datei zu
       ordnen. Weitere mit USE angeschlossene Indexdateien werden
       bei [nderungen automatisch aktualisiert.
*EXIT
*WAIT
> WAIT :TO <tempVar>:  -- wird in Programmdateien benutzt, um die
       dBASE-Ausf}hrung solange zu unterbrechen, bis auf der Tasta-
       tur ein einzelnes Zeichen eingegeben wird.
       WAIT  TO  <tempVar> speichert  automatisch  die  Tastatur-
       eingabe  in  eine tempor{re Variable und kann dadurch  den
       Ablauf des Programmes steuern.
*EXIT
*FUNKTIONEN
> @ --  @(<Zeichenkette1>,<Zeichenkette2>) -- "AT"-Funktion: ergibt
       eine ganze Zahl f}r die Position in Zeichenkette2,   wo Zei-
       chenkette1 beginnt.

> * -- L|schmarkierung; f}hrt zum ]berlesen des Satzes bei COPY oder
       {hnlichen Operationen.

> # -- Satznummer Funktion:  zeigt ganzzahligen Wert an,  der der
       laufenden Satznummer entspricht.

> ! -- !(<Zeichenkette>)  -- Gro~buchstaben Funktion:  wandelt die
       Zeichen in Gro~buchstaben um.

> $ -- $(<Zeichenkette>,<Start>,<L{nge>) -- Unterketten Funktion:
       erzeugt eine Zeichenkette aus dem angegebenen Teil einer
       anderen Zeichenkette.

> CHR -- CHR(<numerischer Ausdruck>) -- ergibt das  ASCII-Zeichen
       entsprechend dem numerischen Ausdruck.
       z.B.  .? CHR(7) erzeugt akustisches Signal (Bell)

> DATE() -- gibt das Systemdatum in der Form xx/xx/xx aus.

> EOF -- Datei-Ende Funktion:  ist wahr, wenn versucht worden ist,
       }ber den letzten Datensatz der Datei hinauszugehen.

> FILE  -- FILE(<Datei>)  -- Existenz  Funktion:  ist wahr, falls
       <Datei> auf dem angegebenen Laufwerk vorhanden ist.

> INT -- INT (<Numerischer Ausdruck>) -- Ganzzahl Funktion:
       schneidet  alle  Stellen rechts vom Dezimalpunkt  weg,  um
       eine ganze Zahl zu bilden.

> LEN -- LEN(<Zeichenkette>) -- L{ngen Funktion: zeigt die Anzahl
       der Zeichen in der Zeichenkette an.
       z.B.  .?? LEN('HELLO')  5

> RANK -- RANK(<Zeichenkette>) -- gibt den numerischen ASCII-Kode
       des ersten Zeichens in der Zeichenkette wieder.

> STR -- STR (<Numerischer Ausdruck>, <Weite> :,<Dezimalstelle>:)
       String  Funktion:  wandelt einen numerischen  Ausdruck  in
       eine Zeichenkette um.

> TEST  -- TEST(<Ausdruck>) -- mit  ?  und  IF,  Test Funktion:
       pr}ft,  ob  ein Ausdruck g}ltig und passend ist.  Ein g}l-
       tiger  Ausdruck liefert einen Wert ungleich 0; ein  ung}l-
       tiger den Wert 0.

> TRIM -- TRIM(<Zeichenkette>) - Trim Funktion: entfernt nachlau-
       fende Leerstellen der Zeichenkette.
         ? TRIM(FIRST) + ' ' + LAST.

> TYPE -- TYPE(<Ausdruck>) -- erzeugt eine einstellige  Zeichen-
       kette, die  'C','N','L' oder 'U' enth{lt, wenn der Ausdruck
       vom  Typ Character (Zeichen), Numeric (Numerisch), Logical
       (Logisch) oder Undefined (Unbestimmt) ist.

> VAL  -- VAL(<Zeichenkette>) -- Wert Funktion: wandelt  eine  aus
       Zahlen bestehende Zeichenkette in einen numerischen Wert um.
*EXIT
*KENNDATEN
                KENNDATEN UND GRENZEN
     Anzahl Felder/Datensatz                    32 max
     Anzahl Zeichen/Datensatz                 1000 max
     Anzahl Datens{tze/Datei                 65535 max
     Anzahl Zeichen/Zeichenkette               254 max
     Rechengenauigkeit                      10 Stellen
     gr|~ter Wert                     1.8 x 10** 63 ca
     kleinster Wert                  1.0 x 10** -63 ca
     Anzahl tempor{re Variable                  64 max
     Anzahl Zeichen/Kommandozeile              254 max
     Anzahl  <Ausdr> in SUM-Kommando             5 max
     Anzahl Zeichen im REPORT-Kopf             254 max
     Anzahl Felder im REPORT                    24 max
     Anzahl Zeichen im Indexschl}ssel           99 max
     Anzahl "pending" GETS                      64 max
     Anzahl der gleichzeitig offenen Dateien    16 max
     L{nge einer Programmdatei              unbegrenzt
*EXIT
*FEHLER
UNZUL[SSIGE DEZIMALSTELLEN IM FELD  -- Anzahl der Dezimalstellen bei
                               Feld-Definition ist neu einzugeben.

UNZUL[SSIGER DATEI-NAME     -- Syntaxfehler im Datei-Namen.


UNZUL[SSIGER FELD-NAME      -- Unzul{ssige Zeichen/L{nge im Feld-
                               Namen; neu eingeben.

UNZUL[SSIGER FELD-TYP       -- Nur C (Character), N (Numerisch) oder
                               L (Logisch) zugelassen.

UNZUL[SSIGE FELD-L[NGE      -- Feldl{nge minimal 1, maximal 255 Stellen
                               Bei String-Befehlen darf Stellenagabe
                               den Wert 255 nicht }bersteigen.

EINF]GEN (INSERT) NICHT M\GLICH - DATENBANKDATEI IST LEER --
                               INSERT durch APPEND ersetzen.

DATEI KANN NICHT GE\FFNET WERDEN -- Pr}fen, ob Datei vorhanden ist.

BEFEHLSDATEI NICHT VORHANDEN -- Dateiname/Laufwerksangabe pr}fen.

DATENELEMENT NICHT GEFUNDEN -- Pr}fen ob Feldbezeichnung korrekt bzw.
                               Feld in Struktur vorhanden. REPLACE-
                               Befehl neu eingeben.

DATENBANKDATEI WURDE OHNE INDEXDATEI AKTIVIERT -- FIND ist nur auf
                                indizierten Datenbankdateien m|glich.
                                Index-Datei mit USE anschlie~en.

DISKETTENVERZEICHNIS IST VOLL -- Nicht ben|tigte Dateien l|schen.

DISKETTE IST VOLL            -- Nicht ben|tigte Dateien l|schen.

DATEIENDE UNERWARTET ERREICHT -- Datenbankdatei weist Fehler auf
                                gegebenenfalls kopieren bzw. re-indizieren.

DIE "FIELD"-ANGABE FEHLT     -- CHANGE-Kommando neu eingeben.

DATEI BEREITS VORHANDEN      -- Nicht ben|tigte Datei gleichen Namens
                                l|schen oder anderen Namen verwenden.

DATEI NICHT VORHANDEN        -- Pr}fen, ob Datei vorhanden ist, z.B. mit
                                DISPLAY FILES LIKE *.* .

DATEI IST BEREITS ER\FFNET   -- Mit USE oder CLEAR aktive Datei)en abmelden.

FORMAT-DATEI KANN NICHT GE\FFNET WERDEN  -- ".FMT"-Datei pr}fen, z.B.
                                durch Auflisten.

ES WURDE NOCH KEINE FORMAT-DATEI AUSGEW[HLT  -- Format-Datei akti-
                                vieren.

UNG]LTIGER DATEN-TYP         -- SORT kann nicht auf logischen Feldern
                                sortieren.


UNG]LTIGER WERT BEI "GOTO"   -- Satz-Nr. mu~  im belegten Bereich der
                                Datenbank und im Bereich zwischen
                                1 und 65.535 liegen.

UNG]LTIGER VARIABLENNAME     -- Nur alphanumerische Zeichen und
                                Doppelpunkte sind als Namen f}r
                                Felder und Variable zugelassen.

INDEXDATEI PASST NICHT ZUR DATENBANK -- Nur zur Datenbankdatei
                                geh|renden Index-Dateien verwenden.

INDEXDATEI KANN NICHT GE\FFNET WERDEN  -- Dateiname pr}fen oder Datenbank
                               neu indizieren.

MIT JOIN WURDE VERSUCHT, MEHR ALS 65.534 S[TZE ZU ERZEUGEN  -- Die
                               "FOR"-Bedingung einengen.

SCHL]SSEL HABEN ABWEICHENDE L[NGE  -- UPDATE verlangt }bereinstim-
                                mende Schl}ssel.

MACRO IST KEINE ZEICHENFOLGE -- Makroexpansion verlangt Variablen mit
                                Zeichenreihe als Wert.

MAXIMAL 5 FELDER F]R SUMMENBILDUNG M\GLICH -- SUM nur mit maximal 5 Feldern.

MAXIMALE SCHACHTELUNGSGRENZE ]BERSCHRITTEN  -- Programmdateien }berarbeiten
                                und zusammenfassen.

ES FEHLT DER NUMERISCHE AUSDRUCK ZUM SUMMIEREN -- SUM erfordert Angabe
                                des/der zu summierenden Feldes(r).

DIE "FOR"-ANGABE FEHLT       -- JOIN erneut mit "FOR"-Angabe eingeben.

DIE "FROM"-ANGABE FEHLT      -- UPDATE erneut mit "FROM"-Angabe eingeben.

WERT NICHT GEFUNDEN          -- Nicht unbedingt ein Fehler: der
                                Schl}sselwert ist nicht vorhanden (# = 0).

AUSDRUCK IST NICHT NUMERISCH -- SUM erfordert einen numerischen
                                Ausdruck f}r die Summierung.

DATEI NICHT VORHANDEN        -- Name pr}fen, ggf. vorhandene Dateien
                                auflisten lassen.

DIE "ON"-ANGABE FEHLT        -- UPDATE oder INDEX mit "ON"-Angabe neu
                                formulieren.

SPEICHER F]R TEMPOR[RE VARIABLEN IST VOLL -- Nicht ben|tigte tempor{re
                                Variablen l|schen.

SATZL[NGE ]BERSCHREITET MAXIMALWERT VON 1000 BYTES -- Feldl{ngen
                                k}rzen, so da~  Satzl{nge <= 1000 Bytes.

SATZ NICHT IN INDEXDATEI ENTHALTEN -- Index-Datei nicht aktuell;
                                Datenbankdatei re-indizieren.

SATZ AUSSERHALB DES IN DATENBANKDATEI BELEGTEN BEREICHES --
                               Datei }berpr}fen (ggf. COPY) bzw. re-indizieren.

INTERNER FEHLER BEIM SORTIEREN, BITTE H[NDLER UNTERRICHTEN

UNTERSCHIEDLICHE DATEN-TYPEN BEI QUELLE UND ZIEL -- Datentypen
                                m}ssen }bereinstimmen.

*** SYNTAX FEHLER ***        -- unbekanntes Kommando, neu formulieren.

SYNTAXFEHLER BEI DER FORMAT-DEFINITION -- ein @ SAY GET PICTURE
                                wurde fehlerhaft formuliert.

DIE "TO"-ANGABE FEHLT        -- Kommando mit "TO"- Angabe neu eingeben.

ZU VIELE ZEICHEN (BEFEHLSZEILE ZU LANG) -- Feldl{nge bzw. maximale L{nge
                                der Befehlszeile wurden }berschritten.

ZU VIELE DATEIEN ER\FFNET    -- Nur bis zu 16 Dateien (aller Typen)
                                k|nnen gleichzeitig aktiviert werden.

ZU VIELE TEMPOR[RE VARIABLE -- H|chstens 64 tempor{re Variable sind m|g-
                               lich; nicht ben|tigte Variablen l|schen.

ZUVIELE "RETURNS" BENUTZT   -- Struktur der Programmdateien }berpr}fen
                               (insbes. Schachtelung, Schleifen).

DIE "WITH"-ANGABE FEHLT     -- REPLACE mit "WITH"-Angabe neu eingeben.

DATEI-NUMMER NICHT ZUGEORDNET -- Pr}fen, ob DBASEMSG.TXT vorhanden ist;
                               Fehlermeldung an H{ndler

*** UNBEKANNTER BEFEHL ***  -- Formulierung pr}fen.

VARIABLE NICHT VORHANDEN    -- Tempor{re Variable erzeugen bzw.
                               Name korrigieren.
*EXIT

 

RIABLE NICHT VORHANDEN    -- Tempor{re Variable erzeugen bzw.
         