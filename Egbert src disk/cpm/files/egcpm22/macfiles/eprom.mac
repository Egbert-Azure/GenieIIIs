;******************************************************************************
;*  E P R O M  *  C P M S Y S 1   *   T h o m a s   H o l t e *  8 4 1 2 1 5  *
;******************************************************************************
;*									      *
;*    R O M R E S I D E N T   B O O T E R   A N D   I / O - D R I V E R S     *
;*    ===================================================================     *
;*									      *
;* F O R   T H E   G E N I E  I I I   M I C R O C O M P U T E R   S Y S T E M *
;* ========================================================================== *
;*									      *
;*									      *
;*  Thomas Holte			                         Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	ASEG
	ORG  0000H


;ASCII control codes:
NUL	EQU  00H		;null
SOH	EQU  01H		;start of heading
STX	EQU  02H		;start of text
ETX	EQU  03H		;end of text
EOT	EQU  04H		;end of transmission
ENQ	EQU  05H		;enquiry
ACK	EQU  06H		;acknowledge
BEL	EQU  07H		;bell
BS	EQU  08H		;backspace
HT	EQU  09H		;horizontal tabulation
LF	EQU  0AH		;line feed
VT	EQU  0BH		;vertical tabulation
FF	EQU  0CH		;form feed
CR	EQU  0DH		;carriage return
SO	EQU  0EH		;shift out
SI	EQU  0FH		;shift in
DLE	EQU  10H		;data link escape
DC1	EQU  11H		;device control 1
DC2	EQU  12H		;device control 2
DC3	EQU  13H		;device control 3
DC4	EQU  14H		;device control 4
NAK	EQU  15H		;negative acknowledge
SYN	EQU  16H		;synchronous idle
ETB	EQU  17H		;end of transmission block
CAN	EQU  18H		;cancel
EM	EQU  19H		;end of medium
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape
FS	EQU  1CH		;file separator
GS	EQU  1DH		;group separator
RS	EQU  1EH		;record separator
DEL	EQU  7FH		;delete

	
;power-up entry point:
       	DI			;disable interrupts
	JR   $RESET   		;initialize stack pointer

;serial number:
	DEFW 0

;common entry point for all driver routines
	PUSH BC			;save contents of reg. B & HL
	PUSH HL
	LD   B,0		;vector # * 2 --> reg. BC
	SLA  C
	LD   HL,DRITBL		;base of vector table --> reg. IX
	ADD  HL,BC		;calc table entry
	LD   C,(HL)		;get entry point of driver routine
	INC  HL
	LD   B,(HL)
	PUSH BC
	POP  IX
	POP  HL			;restore contents of reg. B & HL
	POP  BC
	JP   (IX)		;execute driver	routine

;table of driver addresses:
DRITBL:	DEFW $VDINIT		;initialize video  controller chip M6845
	DEFW $RSINIT		;initialize RS232C controller chip INS8250
	DEFW $KBCHAR		;get a keyboard character if available
	DEFW $KBWAIT		;wait for keyboard character
	DEFW $VDCHAR		;display a character
	DEFW $PRSTAT		;test printer status
	DEFW $PRCHAR		;output a character to the printer
	DEFW $RSRCST		;get a character from the RS232C interface
				;if available
	DEFW $RSRCV		;receive a character from the RS232C interface
	DEFW $RSTXST		;test RS232C output status
	DEFW $RSTX  		;transmit a character to the RS232C interface
	DEFW $READ		;read a sector
	DEFW $WRITE		;write a sector
	DEFW $GETTIM		;get time and date in ASCII format
	DEFW $SETTIM		;set time and date in binary format
	DEFW $RESET		;system reset
	DEFW $READW		;read  a Winchester sector (not implemented)
	DEFW $WRITW		;wriTe a Winchester sector (not implemented)
	DEFW $GTIME3		;get time and date in CP/M 3 format
	DEFW $STIME3		;set time and date in CP/M 3 format

$READW:
$WRITW:	RET
	

*EJECT
	ORG  0066H		;NMI entry point

;*****************
;*  $ R E S E T  *
;*****************

$IOSEL	EQU  0FAH		;select port for memory mapped I/O

;system reset:
$RESET:	DI			;disable interrupts
	IM   1			;set interrupt mode 1 (RST 38)
	LD   SP,417DH		;initialize stack pointer

       	LD   HL,VID0 		;^video parameters 	   --> reg. HL
	CALL $VDINIT+12		;initialize video controller

	LD   A,070H
	OUT  ($IOSEL),A		;turn on video RAM
	LD   HL,3C00H      	;lowest video RAM address     --> reg. HL
	LD   (HL),' '		;blank it
	LD   DE,3C01H		;lowest video RAM address + 1 --> reg. DE
	LD   BC,2048		;clear 2K video RAM
	LDIR
	 	
	LD   HL,MSG  		;^message    --> reg. HL
	LD   DE,3C00H+64*15	;^last line  --> reg. DE
	LD   BC,DRV0-MSG  	;line length --> reg. BC
	LDIR			;output init message

RESET1:	DI
	LD   A,0F6H
	OUT  ($IOSEL),A		;enable boot ROM
	LD   HL,DRV0		;^parameters for drive 0   --> reg. HL
	LD   DE,DCT		;^DCT  			   --> reg. DE
	LD   BC,6		;length of parameter table --> reg. BC
	LDIR			;transfer disk parameters to high RAM

	XOR  A
	LD   (TRYS),A

	LD   B,20		;count of disk read tries
RESET2: PUSH BC    		;save counter
	XOR  A			;drive #
	LD   E,A		;track #
	LD   B,A		;sector #
	LD   HL,4200H		;buffer address
	CALL $READ		;try to read first sector on disk
	POP  BC			;restore counter
	OR   A			;read successful ?
      	JR   Z,NEWDOS		;if yes, jump
RESET3:	BIT  5,(IX)		;test density
	JR   NZ,RESET4		;jump if double density
	SET  5,(IX)		;set to double density
	DJNZ RESET2		;try again
RESET4:	RES  5,(IX)		;switch to single density
	DJNZ RESET2		;try again
	JR   $     		;no load --> HANG UP !
RESET5: LD   A,0F7H		
	OUT  ($IOSEL),A		;disable ROM
	XOR  A			;switch boot marker off
	PUSH AF
	JP   06ADH		;jump into "TRS-80 pseudo ROM

NEWDOS: LD   HL,RESET1		;^NEWDOS/80-booter code --> reg. HL
	LD   DE,3D13H		;destination address    --> reg. DE
	LD   BC,VID1-RESET1     ;length of booter code  --> reg. BC
	LDIR			;transfer booter code --> RAM
	LD   A,RESET5-RESET3	;address of "TRS-80 pseudo ROM"
	LD   (RESET3-RESET1-1+3D13H),A 		;store new JP-address
	LD   A,0F4H
	OUT  ($IOSEL),A		;enable video RAM
	LD   A,1		;switch boot marker on
	PUSH AF
	LD   HL,$FDCMD		;address of FDC command register --> reg. HL
	JP   4200H		;enter location of boot sector

;special code for NEWDOS/80 Ver. 2.0A:

;table of video parameters (64 x 16):
VID0:   DEFB 102		;horizontal total
	DEFB 64			;horizontal displayed
	DEFB 83			;h sync position
	DEFB 52			;h sync width
	DEFB 25			;vertical total
	DEFB 0			;v total adjust
	DEFB 16  		;vertical displayed
	DEFB 25			;v sync position
	DEFB 0			;interlace mode (non-interlace)
	DEFB 11			;max scan line address
	DEFB 2BH		;cursor start
	DEFB 11			;cursor end
	DEFB 0  		;start address (H)
	DEFB 0			;start address (L)
	DEFB 0			;cursor (H)
   	DEFB 0			;cursor (L)

;table of video parameters (80 x 24):
VID1:   DEFB 102		;horizontal total
	DEFB 80			;horizontal displayed
	DEFB 88			;h sync position
	DEFB 52			;h sync width
	DEFB 25			;vertical total
	DEFB 0			;v total adjust
	DEFB 24  		;vertical displayed
	DEFB 25			;v sync position
	DEFB 0			;interlace mode (non-interlace)
	DEFB 11			;max scan line address
	DEFB 2  		;cursor start
	DEFB 0 			;cursor end
	DEFB 0  		;start address (H)
	DEFB 0			;start address (L)
	DEFB 0			;cursor (H)
   	DEFB 0			;cursor (L)

MSG:	DEFM 'Insert system disk into drive 0 and press <RESET>'
 
DRV0:	DEFB 00010011B,0,1,1,1,0


*EJECT
;*******************
;*  $ V D I N I T  *
;*******************

;entry: HL = address of video parameter table

;  struct {
;	    char R0, R1, R2 , R3 , R4 , R5 , R6 , R7 ,
;		 R8, R9, R10, R11, R12, R13, R14, R15;
;	  } *HL;

;  R0  = This 8 bit write-only register determines the horizontal frequency of
;	 HS. It is the total of displayed plus non-displayed character time
;	 units minus one.
;  R1  = This 8 bit write-only register determines the number of displayed 
;	 characters per horizontal line.
;  R2  = This 8 bit write-only register determines the horizontal sync position
;	 on the horizontal line.
;  R3  = This 4 bit write-only register determines the width of the HS pulse.
;	 It may not be apparent why this width needs to be programmed. However,
;	 consider that all timing widths must be programmed as multiples of the
;	 character clock period which varies. If HS width were fixed as an
;	 integral number of character times, it would vary with character rate
;	 and be out of tolerance for certain monitors. The rate programmable
;	 feature allows compensating HS width.
;  R4
;  R5  = The vertical frequency of VS is determined by both R4 and R5. The
;	 calculated number of character line times is usually an integer plus a
;	 fraction to get exactly a 50 or 60 Hz vertical refresh rate. The
;	 integer number of character line times minus one is programmed in the
;	 7 bit write-only Vertical Total Register (R4); the fraction is
;	 programmed in the 5 bit write-only Vertical Scan Adjust Register (R5)
;	 as a number of scan line times.
;  R6  = This 7 bit write-only register determines the number of displayed
;	 character rows on the CRT screen, and is programmed in character row
;	 times.
;  R7  = This 7 bit write-only register determines the vertical sync position
;	 with respect to the reference. It is programmed in character row
;	 times.
;  R8  = This 2 bit write-only register controls the raster scan mode. When bit
;	 0 and bit 1 are reset, or bit 0 is reset and bit 1 set, the non-
;	 interlace raster scan mode is selected. Two interlace modes are
;	 available. Both are interlaced 2 fields per frame. When bit 0 is set
;	 and bit 1 is reset, the interlace sync raster scan mode is selected.
;	 Also when bit 0 and bit 1 are set, the interlace sync and video raster
;	 scan mode is selected.
;  R9  = This 5 bit write-only register determines the number of scan lines per
;	 character row including spacing. The programmed value is a max address
;	 and is one less than the number of scan lines.
;  R10 = This 7 bit write-only register controls the cursor format. Bit 5 is
;	 the blink timing control. When bit 5 is low, the blink frequency is
;	 1/16 of the vertical field rate, and when bit 5 is high, the blink
;	 frequency is 1/32 of the vertical field rate. Bit 6 is used to enable
;	 a blink. The cursor start scan line is set by the lower 5 bits.
;  R11 = This 5 bit write-only register sets the cursor end scan line.
;  R12
;  R13 = Start Address Register is a 14 bit write-only register which
;	 determines the first address put out as a refresh address after
;	 vertical blanking. It consists of an 8 bit lower register (R13), and a
;	 6 bit higher register (R12).
;  R14
;  R15 = This 14 read/write register stores the cursor location. This register
; 	 consists of an 8 bit lower (R15) and 6 bit higher (R14) register.
 
$CRTREG EQU  0F6H		;CRT controller address register
$CRTCMD EQU  0F7H		;CRTC command register

;initialize the video controller chip M6845:
$VDINIT:LD   DE,VIDPAR		;^temp buffer	     	   --> reg. DE
	LD   BC,16		;length of parameter table --> reg. BC
	CALL MOVE		;get video parameter table

	LD   HL,VIDPAR		;^video parameter table    --> reg. HL
        LD   BC,1000H		;CRTC register count       --> reg.  B
				;CRTC start register       --> reg.  C
OUTCMD:	LD   A,C		;CRTC register no.   	   --> accu
       	OUT  ($CRTREG),A	;select CRTC register
	LD   A,(HL)		;video parameter 	   --> accu
	OUT  ($CRTCMD),A	;output CRTC command
	INC  HL			;bump ^video parameter
	INC  C			;increment CRTC register no.
	DJNZ OUTCMD		;output 16 parameters
	OR   A			;clear carry flag
	LD   C,6		;calc table entry for cursor start
	SBC  HL,BC
	LD   A,(HL)		;get control byte for cursor start
	LD   (CURBEG),A		;store it for subsequent use
	RET  			;return to caller


	ORG  016BH
;special video init entry for NEWDOS/80 Ver 2.0A:
	LD   HL,VID1		;^video parameter table --> reg. HL
	CALL $VDINIT+12		;initialize video controller
	JP   (IY)		;return to NEWDOS/80


*EJECT
;*******************
;*  $ R S I N I T  *
;*******************

;entry: A  = line control register (LCR)
;	HL = divisor latch (DL)

;  LCR
;  Bit 0
;  Bit 1 = This two bits specify the number of bits in each transmitted or
;	   received serial character. The encoding of bits 0 and 1 is as
;	   follows:
;
;	   Bit 1 | Bit 0 | Word Length
;	   ======|=======|============
;	     0   |   0   |   5 Bits
;	     0   |   1   |   6 Bits
;	     1   |   0   |   7 Bits
;	     1   |   1   |   8 Bits
;
;  Bit 2 = This bit specifies the number of Stop bits in each transmitted
;	   character. If bit 2 is a logic 0, one Stop bit is generated in the
;	   transmitted data. If bit 2 is a logic 1 when a 5-bit word length is
;	   selected via bits 0 and 1, one and a half Stop bits are generated.
;	   If bit 2 is a logic 1 when either a 6-, 7-, or 8-bit word length is
;	   selected, two stop bits are generated. The Receiver checks the first
;	   Stop-Bit only, regardless of the number of Stop bits selected.   
;  Bit 3 = This is the Parity Enable bit. When bit 3 is a logic 1, a Parity bit
;	   is generated (transmit data) or checked (receive data) between the
;	   last data word bit and Stop bit of the serial data. (The Parity bit
;	   is used to produce an even or odd number of 1s when the data word
;	   bits and the Parity bit are summed.)
;  Bit 4 = This is the Even Parity Select bit. When bit 3 is a logic 1 and bit
;	   4 is a logic 0, an odd number of logic 1s is transmitted or checked
;	   in the data word bits an Parity bit. When bit 3 is a logic 1 and bit
;	   4 is a logic 1, an even number of logic 1s is transmitted or
;	   checked.
;  Bit 5 = This bit is the Stick Parity bit. When bit 3 is a logic 1 and bit 5
;	   is a logic 1, the Parity bit is transmitted and checked by the
;	   receiver as a logic 0 if bit 4 is a logic 1 or as a logic 1 if bit 4
;	   is a logic 0.

;  DL
;	   divisor table:
;
;  	    Desired Baud Rate  |     Divisor
;	  =====================|=================
;          	 50	       |      3840
;          	 75	       |      2560
;	      	110	       |      1745
;	  	134.5	       |      1428
;	  	150	       |      1280
;	  	300	       |       640
;	  	600	       |       320
;	       1200	       |       160
;	       1800	       |       107
;	       2000	       |	96
;	       2400	       |        80
;	       3600	       |        53
;	       4800	       |	40
;	       7200	       |	27
;	       9600	       |	20
;	      19200	       |	10
;	      38400	       |	 5

;registers of the asynchronous communications chip INS8250:
RBR	EQU  0E8H		;receiver buffer register
THR	EQU  0E8H		;transmitter holding register
DLL	EQU  0E8H		;divisor latch (LSB)
DLM	EQU  0E9H		;divisor latch (MSB)
IER	EQU  0E9H		;interrupt enable register
LCR	EQU  0EBH		;line control register
MCR	EQU  0ECH		;MODEM control register	
LSR	EQU  0EDH		;line status register
MSR	EQU  0EEH		;MODEM status register

$RSINIT:PUSH AF			;save LCR
        XOR  A
	OUT  (MCR),A		;deselect MODEM
	OUT  (IER),A		;disable all interrupts
        POP  AF    		;word length, stop bits, parity --> accu
	RES  6,A 		;reset break bit
        SET  7,A		;switch on divisor latch access bit
	OUT  (LCR),A		;select divisor latch
	PUSH AF			;save RS-232-C data 
	LD   A,L          	;divisor (LSB) --> accu
	OUT  (DLL),A            
	LD   A,H   		;divisor (MSB) --> accu
	OUT  (DLM),A		;desired baud rate selected
	POP  AF			;restore RS-232-C data
	RES  7,A		;switch off divisor latch acces bit
	OUT  (LCR),A		;deselect divisor latch
	LD   A,1
	OUT  (MCR),A		;set MODEM control
	RET			;return to caller

								
*EJECT
;*******************
;*  $ K B C H A R  *  
;*******************

;exit: A = char (0 = no char available)

;get a keyboard character if available:
$KBCHAR:LD   A,(RDYKEY)		;is there a key ready ?
	OR   A			
	CALL Z,SCAN   		;scan keyboard if not
	LD   (RDYKEY),A		;store new key
	RET			;return to caller

;this area makes the preliminary check of keyboard rows:
SCAN:	LD   HL,KEYHLD		;HL = keyboard work area ptr
	LD   IX,KEYBRD		;IX = row address table ptr
	LD   BC,38E0H		;BC = row A10 ptr
	LD   D,10 		; E = column index
	LD   A,(BC)		;load row 10
	AND  0F7H		;mask out LOCK key
	LD   E,A		;8 column bits
	XOR  (HL)               ;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E        		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row 10
	DEC  D			;decrement row index
       	INC  HL			;eleven byte buffer indexed by row
        LD   C,(IX)		;row address (LSB) --> reg. C
	LD   A,(BC)		;load row 9
	AND  0FCH		;mask out SHIFT + CTRL keys
	LD   E,A		;8 column bits
	XOR  (HL)               ;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E        		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row 9
     	INC  IX			;increment ^row address table
	DEC  D			;decrement row index
CHKKEY:	INC  HL			;ten byte buffer indexed by row
        LD   C,(IX)		;row address (LSB) --> reg. C
	LD   A,(BC)		;load row N
	LD   E,A		;8 column bits
	XOR  (HL)		;XOR with previous
	LD   (HL),E   		;store column bits in buffer
	AND  E     		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row N
     	INC  IX			;increment ^row address table
	DEC  D			;decrement row index
	JP   P,CHKKEY		;try next row

;check for previous key:
	PUSH AF			;save column bits
       	LD   HL,(OLDROW)	;^previous row   --> reg. HL
        LD   A,(OLCLMN)		;old column bits --> accu
        AND  (HL)               ;previous key active ?
	JR   NZ,PREV    	;jump to wait/repeat procedure if yes
	XOR  A			;clear repeat mode
	LD   (REPEAT),A
	LD   H,A
	LD   L,A
        LD   (COUNT1),HL        ;reset first counter
	LD   HL,(DELAY3)        ;preset second counter
	LD   (COUNT2),HL
	POP  AF      		;restore column bits
	RET   			;no key depression - return

;delay routine until key autorepeats:
PREV:	PUSH AF                 ;save previous column bits
	PUSH HL                 ;save previous row
	LD   HL,(COUNT1)        ;increment first counter
	INC  HL
   	LD   (COUNT1),HL
	LD   DE,(COUNT2)        ;and compare it with second counter
	LD   A,H
        CP   D
	JR   NZ,REST  
	LD   A,L
	CP   E
REST:  	POP  HL			;restore previous row
	JR   NZ,RTN		;return if first counter <> second counter
	POP  AF			;restore previous column bits
	CPL			;clear previous row
	AND  (HL)
	LD   (HL),A
	LD   A,1		;set repeat mode
	LD   (REPEAT),A		
	LD   HL,0		;clear first counter
	LD   (COUNT1),HL
	LD   HL,(DELAY4)	;initialize second counter
	LD   (COUNT2),HL	
	POP  AF			;adjust stack pointer
	JR   SCAN		;scan keyboard again
RTN:	POP  AF			;restore column bits
	POP  AF
	RET			;no key active - return
	
;fist debounce routine:
ACTIVE:	LD   E,A		;save column bits
	PUSH BC			;save active row address
	LD   BC,(DELAY1)	;delay count value
	CALL DELAY		;delay for 7.33 milliseconds (may be varied)
	POP  BC			;restore row address
	LD   A,(BC)		;and reload original flags from active row
	AND  E			;then combine current flag bits with original
				;flag bits
	RET  Z			;rtn to caller if zero because row was not
				;active on 2nd test
	LD   (OLDROW),HL	;save row

;calculate ordinal number of pressed key:
	LD   A,D		;otherwise we have a legimately active row
	RLCA			;row index * 2
	RLCA			;row index * 4
	RLCA			;row index * 8
	LD   D,A		;save in D
	LD   C,1		;start with bit 0
AGAIN:	LD   A,C		;mask
	AND  E			;test for non-zero column
	JR   NZ,FOUND		;go if found
	INC  D			;bump column number
	RLC  C			;align mask
	JR   AGAIN		;try again
FOUND:	LD   A,C      		;column bits --> accu
	LD   (OLCLMN),A		;store them
	LD   E,D		; row * 8 + column (0 - 7)  --> reg. DE
	LD   D,0
	LD   H,D		; row * 8 + column (0 - 7)  --> reg. HL
	LD   L,E
	ADD  HL,HL		;(row * 8 + column (0 - 7)) * 2
 	ADD  HL,DE		;(row * 8 + column (0 - 7)) * 3
		
;get ASCII code of pressed key:
	LD   BC,(KEYTAB)	;^table of ASCII codes --> reg. BC
	ADD  HL,BC              ;calculate ^ASCII code of pressed key
	LD   A,(3880H)          ;load SHIFT bit
	BIT  0,A		;SHIFT ?
	JR   Z,CTRL             ;jump if not
	INC  HL 		;adjust table pointer
	JR   LOCK
CTRL:	BIT  1,A		;CTRL ?
	JR   Z,LOCK		;jump if not
	INC  HL			;adjust table pointer
	INC  HL
	LD   A,(HL)		;get ASCII code
	JR   DBOUNCE

;check if caps lock:
LOCK:   LD   A,(38E0H)          ;load LOCK bit
	BIT  3,A		;LOCK ?
	JR   Z,UMLAUT           ;jump if not
	LD   A,(HL)    		;restore char
	CP   'a'		;is it a letter ?
	JR   C,DBOUNCE          ;jump if not
	LD   A,(GERMAN)		;German character set ?
	OR   A
	LD   A,(HL)		;restore char
	JR   Z,UCAPS		;jump if US-ASCII
	CP   DEL
	JR   NC,DBOUNCE		;adjust to lower case
	JR   UCASE
UCAPS:  CP   '{'  		;adjust to lower case
	JR   NC,DBOUNCE
UCASE:	AND  5FH                ;force upper case
	JR   DBOUNCE

;check if German character set:
UMLAUT:	LD   A,(GERMAN)		;German character set ?
	OR   A
	LD   A,(HL)		;restore char
	JR   Z,DBOUNCE		;jump if US-ASCII
        LD   A,(3880H) 		;load SHIFT bit
	BIT  0,A      		;SHIFT ?
        LD   A,(HL)   		;restore char
	JR   NZ,SHIFT     	;jump if SHIFT
	CP   '['    		;"Umlaut" ?
      	JR   C,DBOUNCE		;jump if not
	CP   '_'
	JR   NC,DBOUNCE
        JR   FILTER
SHIFT:  CP   '{'   		;"Umlaut" ?
	JR   C,DBOUNCE          ;jump if not
	CP   DEL
	JR   NC,DBOUNCE
FILTER: XOR  20H		;change to upper/lower case

;second debounce routine:
DBOUNCE:LD   D,A      		;save character
	LD   A,(REPEAT)		;auto repeat ?
	OR   A
	JR   NZ,NBOUNCE		;no debounce if repeat mode
	LD   BC,(DELAY2)        ;load delay count
	CALL DELAY 		;delay
NBOUNCE:LD   A,D       		;A = ASCII - like character
	RET			;return

;delay for ((BC-1)*26+17)*2.255 T-states:
DELAY:	DEC  BC			;decrement cycle count
	LD   A,B		;test if count zero
	OR   C			;combine LSB/MSB of count
	JR   NZ,DELAY		;loop until delay count exhausted
	RET			;rtn to caller

KEYBRD:	DEFB 80H,0C0H,0A0H,40H,20H,10H,08H,04H,02H,01H


*EJECT
;*******************
;*  $ K B W A I T  *
;*******************

;exit: A = char

;wait for a keyboard character:

;scan for special function key:
$KBWAIT:LD   A,(COUNT3)		;letter counter --> accu
	OR   A			;test it
	JR   Z,DZERO		;jump if counter empty
	DEC  A			;decrement counter
	LD   (COUNT3),A		;store it
	LD   HL,(FPTR)		;load letter pointer
	LD   A,(HL)  		;load next letter
	INC  HL			;bump letter pointer
	LD   (FPTR),HL		;store it
	LD   C,A		;save active key
	LD   A,(HL)		;get next key
	LD   (RDYKEY),A		;store that sucker
	LD   A,C		;restore active key
	JP   TSTKEY+2

;scan for special key "00":
DZERO:  LD   HL,RDYKEY		;^scanned key --> reg. HL
	LD   A,(HL)		; scanned key --> accu
	CP   0FBH		;is it PRINT ?
	JR   Z,PRINT		;jump if yes
	CP   0FCH		;is it SHIFT - CLEAR ?
	JR   Z,ERASE		;jump if yes
	CP   0FDH		;is it SHIFT - BREAK ?
	JR   Z,GERSET		;jump if yes
	CP   0FEH		;is it "00" ?
	JR   C,FKEY  		;jump if not
	INC  A			;bump "00"-counter
	LD   (HL),A		;store "00"-counter
	LD   A,'0'		;return one zero
	RET			;return to caller
PRINT:	PUSH HL			;save reg. HL
      	LD   HL,$SCREEN		;address of first screen location --> reg. HL
	LD   A,(VDTAB)		;line count of screen		  --> reg. D
	LD   D,A
PRINT1:	LD   A,(VDTAB+1)	;column count of screen		  --> reg. B
	LD   B,A
PRINT2:	LD   A,(HL)		;screen character 		  --> accu
	AND  7FH		;mask it
	INC  HL			;bump screen pointer
 	CALL $PRCHAR		;output character to printer 0
	DJNZ PRINT2		;repeat "column count" times
	LD   A,CR		;output a carriage return
	CALL $PRCHAR
	LD   A,LF		;output a line feed
	CALL $PRCHAR
	DEC  D			;decrement line counter
	JR   NZ,PRINT1		;print next line	
	POP  HL			;restore reg. HL
	JR   GERSE1		;go on
ERASE:	LD   A,SUB
	PUSH HL
	CALL $VDCHAR		;clear screen
	POP  HL
	JR   GERSE1		;go on
GERSET:	LD   A,(GERMAN)		;load switch bit for changing char set
	CPL			;invert it
	LD   (GERMAN),A		;store it
GERSE1:	XOR  A			;clear key code	
	JR   TSTKEY

;test if function key:
FKEY:	BIT  7,A		;check if code >= 80H
	JR   Z,TSTKEY		;jump if not 	 
	PUSH HL			;save ^key memory
	LD   C,A		;save key code
	LD   E,A
	LD   HL,VECTOR		;^function key vector --> reg. HL
	LD   A,(HL)		;function key vector = 0 ?
	LD   D,A		;save LSB of key vector
	INC  HL
	OR   (HL)
	JR   Z,FKEYEND		;jump if no special function
	LD   H,(HL)		;function key vector --> reg. HL
	LD   L,D
	LD   D,0
	SLA  E			;most significant 7 bits of code * 2
	ADD  HL,DE		;calculate vector address
	LD   A,(HL)		;no special function ?
	LD   E,A
	INC  HL
	LD   D,(HL)
	OR   D
	JR   Z,FKEYEND
	LD   A,(DE)		;vector --> accu
	LD   (COUNT3),A		;load counter
	INC  DE
	LD   (FPTR),DE		;load address of first function key character
	POP  HL			;adjust stack pointer
	JP   $KBWAIT
FKEYEND:LD   A,C		;restore original key code	
	POP  HL			;restore ^key memory

;test key memory if legal code:
TSTKEY: LD   (HL),0		;clear key memory
	OR   A			;legal key code ?
	RET  NZ       		;return to caller

;scan keyboard:
        CALL $KBCHAR		;scan keyboard
	JP   $KBWAIT		;test if active key


*EJECT
;*******************
;*  $ V D C H A R  *
;*******************

;entry: A = char

$VMODE	EQU  0F5H		;port for selecting normal/inverse display mode
$BUZZ	EQU  3860H		;buzzer address
$SCREEN EQU  3C00H		;address of first screen location:

;character output routine:
$VDCHAR:LD   IX,VDTAB		;^screen constants --> reg. IX
	LD   HL,ESCAPE 		;test if escape sequence
	BIT  2,(HL)		
	JR   NZ,ESCSQ2		;cursor addressing routine
	BIT  1,(HL)
	JR   NZ,ESCSQ1		;handle second byte of escape sequence
	BIT  0,(HL)
	JR   NZ,ESCSEQ		;handle first byte of escape sequence
	CP   ESC		;char = ESC ?
	JR   NZ,NORMAL 		;jump if normal ASCII char
	SET  0,(HL)		;remark escape sequence
	RET

;handling of single byte ASCII's:
NORMAL: CP   20H		;control char ?
	JR   C,CNTRL 
	LD   L,A		;save char
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	LD   A,(GERMAN)		;test if German character set
	OR   A
	LD   A,L		;restore char	
	JR   Z,ASCII		;jump if not
	LD   HL,$PRSTAT-1	;^end of American table --> reg. HL
	LD   BC,$PRSTAT-TABUS	;table length           --> reg. BC
	CPDR			;search char
	JR   NZ,ASCII		;unchange char if not found
	LD   A,C   		;load converted char
ASCII:	LD   HL,INVERSE		;^invert mask --> reg. HL
	OR   (HL)		;mask character
	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   (HL),A		;output char
	JP   CURRGT		;output cursor

;handling of control codes: 
CNTRL:	OR   A			;control code = 0 ?
	RET  Z
      	LD   HL,TAB1E+1		;^end of control code table --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length               --> reg. BC
CAGAIN:	CPDR			;search char
	RET  NZ			;return to caller if not found
	INC  (HL)		;escape sequence ?
	DEC  (HL)
	JR   NZ,CAGAIN		;search next char
	JR   ESCEND

;first entry into escape sequence:
ESCSEQ:	RES  0,(HL)		;reset escape bit
	LD   HL,TAB1E+1		;^end of ESC-sequence-table-1 --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length                 --> reg. BC
EAGAIN:	CPDR          		;search char
	RET  NZ			;return to caller if not found
	INC  (HL)		;escape sequence ?
	DEC  (HL)
	JR   Z,EAGAIN		;search next char
ESCEND:	LD   HL,CTRLJP		;jump vector --> reg. HL
        DEC  BC			;calc jump address
	ADD  HL,BC
	LD   C,(HL)		;jump address --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute function

;second entry into escape sequence:
ESCSQ1: RES  1,(HL)		;reset second escape bit
	SUB  20H		;adjust line/column no.
	LD   D,A		;save it
	LD   A,(ESCCHR)		;load first byte of escape sequence
	LD   HL,TAB2E+1		;^end of ESC-sequence-table-2 --> reg. HL
	LD   BC,TAB2E-TAB2S+2	;table length                 --> reg. BC
	CPDR			;search char
	LD   HL,ESCJP 		;^jump vector
	LD   A,D		;restore line/column no.
	JR   ESCEND+3

;third entry into escape sequence:
ESCSQ2: RES  2,(HL)		;reset third escape bit
	SUB  20H		;adjust column no.
	CP   (IX+7)		;legal column no. ?
	RET  NC			;return if not
	ADD  A,(IX+3)		;add left column
	LD   (IX+9),A		;store new column no.
	LD   A,(LINE)  		;fetch new line no.
	ADD  A,(IX+2)		;add top line
	LD   (IX+8),A		;store it
	CALL OUTCUR		;output cursor
	JP   CURON+4		;turn on cursor

;handle first byte of two or three byte escape sequence:
ESC1ST: LD   (ESCCHR),A		;store first byte of escape sequence
	LD   HL,ESCAPE
	SET  1,(HL)		;remark it
	RET

;handle second byte of three byte escape sequence:
ESC2ND: CP   (IX+6)		;legal line no. ?
	RET  NC			;return if not
	LD   (LINE),A  		;save new line
	LD   HL,ESCAPE
	SET  2,(HL)		;remark cursor addressing sequence
	RET

;beep:
BEEP:	LD   BC,0B080H		;repeat counter --> reg. B
				;  wait counter --> reg. C
	LD   A,($BUZZ)		;turn on buzzer
	PUSH BC			;save base value of wait counter
BUZZON: DEC  C			;decrement wait counter
	JR   NZ,BUZZON		;wait `til end of buzz
	POP  BC			;restore wait counter
	DJNZ BEEP+3		;turn on buzzer eleven times
	RET

;cursor left:
CURLFT: LD   A,(IX+3)		;left column --> accu
	CP   (IX+9)		; >= right column ?
	RET  P			;return if yes
	DEC  (IX+9) 		;decrement column no.
	JP   INSLI3

;cursor down:
CURDWN: LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; >= bottom line ?
	JP   P,CURDW1		;scroll up if yes
	INC  (IX+8) 		;increment line no.
	JP   OUTCUR
CURDW1: LD   A,(IX+2)		;top line --> current line
	LD   (IX+8),A
	JP   SCRLU		;scroll window up one line

;cursor up:
CURUP:  LD   A,(IX+2)		;top line --> accu
	CP   (IX+8)		; >= current line ?
	RET  P			;return if yes
	DEC  (IX+8) 		;decrement line
	JP   OUTCUR

;cursor right:
CURRGT:	LD   A,(IX+5)		;right column --> accu
	CP   (IX+9)		;right column >= current column ?
	RET  M			;return if cursor beyond right column
	PUSH AF			;save status reg.
	INC  (IX+9) 		;increment column no.
	POP  AF			;restore status reg.
	JR   Z,CUROFF+5		;turn cursor off, if cursor beyond right column
	JP   OUTCUR

;carriage return:
NEWLIN:	LD   A,(IX+3)		;left column  --> current column
	LD   (IX+9),A
	JP   INSLI3		;output cursor
	
;home cursor:
HOME:	LD  A,(IX+2)		;top line    --> current line
	LD  (IX+8),A
	LD  A,(IX+3)		;left column --> current column
	LD  (IX+9),A
	JP  OUTCUR		;output cursor

;set top line:
SETTOP:	CP   (IX)		;legal  line/column no. ?
	RET  NC			;return if not
	LD   B,A		;save line/column
	SUB  (IX+4)		;top    line   - bottom line
				;left   column - right  column
	NEG			;bottom line   - top    line
				;right  column - left   column
	JP   M,SETTO1		;jump if illegal top line/left column
	INC  A			;adjust line/column count
	LD   (IX+6),A		;store new line/column count
SETTO1:	LD   A,B		;restore line column
	RET  M
	LD   (IX+2),A		;store new top line/left column
	CP   (IX+8)		;current line   > top  line ?
				;current column > left column ?
	RET  C			;return to caller if yes
SETTO2: LD   (IX+8),A		;store new current line/column
       	LD   IX,VDTAB		;adjust ^screen constants
	JP   OUTCUR		;output cursor

;set bottom line:
SETBOT:	CP   (IX)		;legal  line/column no. ?
	RET  NC			;return if not
	LD   B,A		;save line/column
	SUB  (IX+2)		;bottom line   - top  line
				;right  column - left column
	JP   M,SETTO1		;jump if illegal bottom line/left column
	INC  A			;adjust line/column count
	LD   (IX+6),A		;store new line/column count
       	LD   A,B		;restore line column
	LD   (IX+4),A		;store new bottom line/left column
	CP   (IX+8)		;current line   > bottom line ?
				;current column > right  column ?
	RET  P			;return to caller if not
	JR   SETTO2

;set left column:
SETLFT: INC  IX			;adjust ^screen constants
	JR   SETTOP		;set left column

;set right column:
SETRGT: INC  IX			;adjust ^screen constants
	JR   SETBOT		;set right column

;set erase character:
SETERA:	ADD  A,20H		;restore ASCII code of erase character
	LD   (IX+10),A		;store new erase character
	RET			;return to caller

;turn off cursor:
CUROFF:	LD   A,0FFH
	LD   (CURSOR),A		;store remark byte
        LD   A,10		;CRTC register no. --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,20H
	OUT  ($CRTCMD),A	;turn off cursor
	RET

;turn on cursor:
CURON:	XOR  A
	LD   (CURSOR),A		;clear remark byte
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc nm. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	LD   A,(CURSOR)		;load remark byte
	OR   A			;test remark byte
	RET  NZ			;no action if cursor is invisible
       	LD   A,10		;CRTC register no. --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,(CURBEG)		;cursor image      --> accu
	OUT  ($CRTCMD),A	;turn on cursor
	RET

;set ASCII character set:
SETASC:	XOR  A			;clear accu
SETAS1:	LD   (GERMAN),A		;set ASCII char set
	RET			;return to caller

;disable status line:
STATOFF:LD   A,(STONOFF)	;status line enabled ?
	OR   A
	RET  Z			;return if not
	XOR  A 			;clear marker
        LD   HL,VDTEMP		;restore screen parameter table
	JR   STATO1

;enable status line:
STATON:	LD   A,(STONOFF)	;status line already enabled ?
	OR   A
	RET  NZ			;return if yes
	CPL			;set marker
       	LD   HL,VDTAB		;save screen parameter table
	LD   DE,VDTEMP
	LD   BC,11
	LDIR
	LD   HL,VDSTAT		;setup status line parameters
STATO1:	LD   DE,VDTAB
	LD   BC,11
	LDIR
	LD   (STONOFF),A	;store marker
	JP   OUTCUR		;output cursor

;set German character set:
SETGER:	LD   A,0FFH		;set accu to ones
	JR   SETAS1		;set German char set

;switch on normal keyboard:
SETNKB:	LD   HL,NBOARD		;^normal key table  --> reg. HL
SETNK1:	LD   (KEYTAB),HL	;store it
	RET			;return to caller

;switch on WordStar keyboard:
SETWKB:	LD   HL,WBOARD		;^WordStar key table --> reg. HL
	JR   SETNK1		 

;turn on inverse display mode:
INVON:	LD   A,1		
	OUT  ($VMODE),A		;turn on inverse display mode
	RRCA			;now accu contains invert mask (80H)
	LD   (INVERSE),A	;store it
	RET

;turn off inverse display mode:
INVOFF: XOR  A			;clear invert mask
	LD   (INVERSE),A	;store it
	RET

;insert character:
INSCHR:	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   A,(IX+5)		;right column            --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	JR   Z,INSCH1		;no columns to shift
	LD   B,0		;no of columns to shift --> reg. BC
	LD   C,A
	ADD  HL,BC		;now HL contains address of last column
	LD   D,H
	LD   E,L		;now DE contains address of last column
	DEC  HL			;now HL contains address of last column - 1
	LDDR			;shift rest of line right one char
	INC  HL			;now HL contains current cursor address
INSCH1:	LD   A,(IX+10)		;get erase char
        LD   (HL),A  		;insert one space at current cursor location
	RET

;insert line:
INSLIN:	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	LÄ   A,(IX+4©		;bottoí linå --¾ accu
	SUB  (IX+8)		;calc. no. of lines to scroll
	LD   B,(IX+4)		;bottom line --> current line
	LD   (IX+8),B
INSLI1: JR   Z,INSLI2		;return if line count = 0
       	CALL CALC		;calculate start position
	PUSH HL			;save it
	LD   D,0 		;maximum column count --> reg. DE
	LD   E,(IX+1)
	SBC  HL,DE		;now HL contains ^(last line - 1)
	POP  DE			;restore ^last line
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll down one line
	DEC  (IX+8)		;decrement current line
	DEC  A			;decrement counter
	JR   INSLI1		;scroll down all lines
INSLI2:	CALL ERAEOLN		;erase current line
INSLI3:	CALL OUTCUR		;output cursor
	JP   CURON+4		;turn on cursor

;delete character:
DELCHR:	LD   HL,(CURADR)	;absolute screen address  --> reg. HL
       	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	JR   Z,INSCH1		;no columns to shift
	LD   B,0		;no. of columns to shift --> reg. BC
	LD   C,A
	LD   D,H
	LD   E,L		;now DE contains absolute screen address
	INC  HL			;now HL contains absolute screen address + 1
	LDIR			;shift rest of line left one char
	DEC  HL			;now HL contains address of last column
	JR   INSCH1		;insert one space at last column

;erase to end of line:
ERAEOLN:CALL CALC		;calculate absolute screen address
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;now accu contains number of columns to erase
	RET  M			;return if cursor beyond right column
       	LD   C,(IX+10)		;get erase char
ERAEO1:	LD   (HL),C  		;clear column
	INC  HL			;bump column ptr
	DEC  A			;decrement column counter
	JP   P,ERAEO1		;erase all columns right to the cursor
	RET

;delete line:
DELLIN: LD   A,(IX+3)		;left  column --> current column
	LD   (IX+9),A
       	LD   A,(IX+8)		;current line no. --> accu
	PUSH AF			;save it
	CALL SCRLU		;scroll rest of window up one line
	POP  AF
	LD   (IX+8),A		;restore current line
	JR   INSLI3		;output cursor
 
;erase to end of screen:
ERAEOS: CALL ERAEOLN		;erase to end of first line
	LD   B,(IX+8)		;save current line
	LD   C,(IX+9)		;save current column
	PUSH BC
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	LD   A,(IX+4)		;bottom line --> accu
	SUB  B			;now accu contains number of lines to erase
	LD   B,A		;counter --> reg. B
        JR   Z,ERAES2		;no further lines to erase
ERAES1: INC  (IX+8)		;increment current line
	PUSH BC			;save counter
	CALL ERAEOLN		;erase current line
	POP  BC			;restore counter
	DJNZ ERAES1		;erase to end of whole window
ERAES2: POP  BC
        LD   (IX+8),B		;restore original line   no.
	LD   (IX+9),C		;restore original column no.
	RET

;clear screen:
ERAALL: CALL HOME		;home cursor
	JR   ERAEOS		;clear to end of screen

;output cursor:
OUTCUR:	CALL CALC               ;calculate absolute screen address
	LD   (CURADR),HL	;store it
	LD   DE,$SCREEN		;base address of video RAM --> reg. DE
	OR   A			;clear carry flag
	SBC  HL,DE		;subtract base address from current cursor
				;address
	LD   C,$CRTREG		;CRTC address register --> reg. C
	LD   A,14		;CRTC register number  --> accu
	OUT  (C),A		;select CRTC register
	INC  C			;CRTC command register --> reg. C
	OUT  (C),H		;output cursor address (MSB)
	INC  A			;increment CRTC register no.
	DEC  C			;decrement port number
	OUT  (C),A		;select CRTC register
	INC  C			;CRTC command register --> reg. C
	OUT  (C),L		;output cursor address (LSB)
	RET

;scroll up routine:
SCRLU:	LD   A,(IX+9)		;current column --> accu
	PUSH AF			;save it
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
      	LD   A,(IX+4)		;bottom line  --> accu
	SUB  (IX+8)		;calc. no. of lines to scroll
SCRLU1: JR   Z,SCRLU2		;clear last line if count = 0
        CALL CALC		;calculate start position
	PUSH HL			;save it
	LD   D,0 		;maximum column count --> reg. DE
	LD   E,(IX+1)
	ADD  HL,DE		;now HL contains address of line to scroll
	POP  DE			;restore ^line before
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll up one line
	INC  (IX+8)		;increment current line
	DEC  A			;decrement counter
	JR   SCRLU1             ;scroll up all lines
SCRLU2:	CALL ERAEOLN		;clear last line
	POP  AF			;restore column no.
	LD   (IX+9),A		;store it
	RET

;calculate absolute cursor address:
CALC:	LD   HL,$SCREEN		;address of first screen loc --> reg. HL
	LD   D,0		;maximum column count        --> reg. DE
	LD   E,(IX+1)
	LD   B,(IX+8)		;current line                --> reg. B
	DEC  B
	INC  B
CALC1:  JR   Z,CALC2		;jump if line no. = 0
	ADD  HL,DE
	DJNZ CALC1		;handle all lines
CALC2:	LD   E,(IX+9)		;current column --> reg. DE
	ADD  HL,DE		;now HL contains absolute screen address
	RET

;jump vectors:
CTRLJP:	DEFW BEEP,CURLFT,CURDWN,CURUP,CURRGT,NEWLIN,HOME,ESC1ST,ESC1ST,ESC1ST
	DEFW ESC1ST,ESC1ST,ESC1ST,CUROFF,CURON,SETASC,STATOFF,STATON,SETGER
	DEFW SETNKB,SETWKB,INVON,INVOFF,INSCHR,INSLIN,DELCHR,ERAEOLN,DELLIN
	DEFW ERAEOS,ERAALL
ESCJP:	DEFW ESC2ND,SETTOP,SETBOT,SETLFT,SETRGT,SETERA

;convert table for German character set:
TABUS:	DEFM '@[{\|]}~'		;original US-ASCII characters 


*EJECT
;*******************
;*  $ P R S T A T  *
;*******************

;exit : A = printer status
;       0 = printer ready 
;    <> 0 = printer not ready

;test status of printer:
$PTR	EQU  0FDH		;printer port

$PRSTAT:IN   A,($PTR)		;read printer status
	XOR  3FH		;mask it
	RET			;return to caller


;*******************
;*  $ P R C H A R  *
;*******************

;entry: A = char

;output a character to printer:
$PRCHAR:LD   C,A		;save char
	CALL $PRSTAT		;test status of printer 0
	JR   NZ,$PRCHAR+1	;wait for printer ready
	LD   A,C		;restore char
	OUT  ($PTR),A		;print it
	RET			;return to caller
			  

*EJECT
;*******************
;*  $ R S R C S T  *
;*******************

;exit : A = input status
;	0 = no char available
;    <> 0 = char available	

;test input status of RS-232-C interface:
$RSRCST:LD   A,(RSCHR)		;get input status
	OR   A			;character ready ?
	RET  NZ			;return if yes
	LD   B,0		;load counter
        LD   A,3
	OUT  (MCR),A		;request to send
RSRCS0: CALL RSRCS2		;scan interface
	JR   NZ,RSRCS1		;jump if character ready
	DJNZ RSRCS0		;scan 256 times
        LD   A,1
	OUT  (MCR),A		;data terminal ready
	XOR  A			;return negative input status
	RET
RSRCS1:	OUT  (MCR),A		;data terminal ready
       	LD   (RSCHR),A		;store input statatus
	RET			;return to caller
RSRCS2:	IN   A,(LSR)		;read line status
	AND  1  		;data ready ?
	RET          		;return


;*****************
;*  $ R S R C V  *
;*****************

;exit: A = char	

;receive a character from RS-232-C interface:
$RSRCV:	LD   A,(RSCHR)		;character ready ?
	JR   NZ,RSRCV2
        LD   A,3
	OUT  (MCR),A		;request to send
RSRCV1:	CALL RSRCS2		;scan interface
	JR   Z,RSRCV1		;loop `til char ready
	OUT  (MCR),A		;data terminal ready
RSRCV2:	XOR  A			;clear input status
	LD   (RSCHR),A
        IN   A,(RBR)		;read character
	RET			;return to caller


*EJECT
;*******************
;*  $ R S T X S T  *
;******************* 
	
;exit: A = terminal status
;      0 = data terminal ready
;   <> 0 = data terminal not ready

;test output status of RS232C interface:
$RSTXST:IN   A,(LSR)		;read line status
	CPL			;invert status bits
	AND  60H		;transmitter holding register & transmitter
	        		;shift register empty ?
	RET  NZ       		;return to caller if no
       	IN   A,(MSR)		;read MODEM status	 
	AND  30H		;mask DSR & CTS bits
	SUB  30H		;clear to send ?
	RET			;return to caller
	

;***************
;*  $ R S T X  *
;***************

;entry: A = char

;transmit a character to RS-232-C interface:
$RSTX:	LD   C,A		;save char
	CALL $RSTXST		;test interface status
	JR   NZ,$RSTX+1		;wait for interface ready
	LD   A,C		;restore char
	OUT  (THR),A		;output char
	RET			;return to caller


*EJECT
;disk driver:

;FDC registers:
$FDSEL  EQU  37E0H              ;FDC select  register
$FDCMD  EQU  37ECH              ;FDC command register
$FDSTAT EQU  37ECH              ;FDC status  register
$FDTRK  EQU  37EDH              ;FDC track   register
$FDSIZ  EQU  37EEH              ;FDC size    register
$FDSEC  EQU  37EEH              ;FDC sector  register
$FDDATA EQU  37EFH              ;FDC data    register

;FDC commands:
$SEEK   EQU  10H                ;seek
$RDSEC  EQU  88H                ;read sector
$WRSEC  EQU  0A8H               ;write sector
$SET8   EQU  0C0H               ;set disk size to 5 inch
$FCINT  EQU  0D0H               ;force interrupt
$DDDEN  EQU  0FFH               ;set double density


;***************
;*  $ R E A D  *
;***************

;entry: A  = drive  number
;       B  = sector number
;       E  = track  number
;       HL = buffer pointer

;exit : A = error code
;       0 = NO ERROR
;       1 = ILLEGAL DRIVE #
;       2 = TRACK # TOO HIGH
;       3 = SECTOR # TOO HIGH
;       4 = DEVICE NOT AVAILABLE
;       6 = TRIED TO READ LOCKED/DELETED RECORD
;       7 = DATA RECORD NOT FOUND DURING READ
;       8 = PARITY ERROR DURING READ
;       9 = LOST DATA DURING READ

;read a sector:
$READ:  LD   C,A                ;save drive #
        LD   A,0FFH             ;set READ-flag
        JR   TASK


*EJECT
;*****************
;*  $ W R I T E  *
;*****************

;entry: A  = drive  number
;       B  = sector number
;       E  = track  number
;       HL = buffer pointer

;exit : A = error code
;       0 = NO ERROR
;       1 = ILLEGAL DRIVE #
;       2 = TRACK # TOO HIGH
;       3 = SECTOR # TOO HIGH
;       4 = DEVICE NOT AVAILABLE
;       5 = WRITE PROTECTED DISKETTE
;       6 = WRITE FAULT ON DISK DRIVE
;       7 = DATA RECORD NOT FOUND DURING WRITE
;       8 = PARITY ERROR DURING WRITE
;       9 = LOST DATA DURING WRITE

;write a sector:
$WRITE: LD   C,A                ;save drive #
        XOR  A                  ;clear READ-flag

;dominant controller:
TASK:   LD   (RDFLAG),A         ;set/reset READ-flag
        LD   A,C                ;restore drive #
        CP   4                  ;legal drive # ?
        JR   C,TRKNO            ;jump if yes
        LD   A,1                ;error code 1 --> accu
        RET
TRKNO:  LD   (DRIVE),A          ;store drive #
        LD   (BUFFER),HL        ;store buffer pointer
        CALL GETDCT             ;get control table ptr
        LD   A,E                ;track # --> accu
        CP   (IX+4)             ;legal track # ?
        JR   C,SECNO            ;jump if yes
        LD   A,2                ;error code 2 --> accu
        RET
SECNO:  LD   (TRACK),A          ;store track #
        LD   A,B                ;sector # --> accu
        CP   (IX+3)             ;legal sector # ?
        JR   C,TRYNO            ;jump if yes
        LD   A,3                ;error code 3 --> accu
        RET
TRYNO:	LD   (SECTOR),A		;store sector #
        LD   A,(TRYS)           ;get # of err tries
        INC  A                  ;adjust it
        LD   (TRIES),A          ;store in counter

;set double density & disk size to 8 inch:
INIT:   LD   A,$DDDEN           ;set double density command
        LD   ($FDCMD),A         ;set density
        LD   A,$SET8            ;set 8 inch command
        LD   ($FDSIZ),A         ;set disk size

;actual I/O handler:
        LD   HL,0               ;clear wait counter
        LD   (WAIT),HL
        LD   HL,$FDCMD          ;FDC command/status reg
        LD   (HL),$FCINT        ;reset FDC
        LD   A,(HL)             ;get FDC status
        LD   (OLDSTAT),A        ;save drive status
        CALL SELECT             ;select drive
        BIT  0,(IX+1)           ;is drive initialized ?
        JR   NZ,TRKSEC          ;yes skip init process

;restore drive head:
        SET  0,(IX+1)           ;set init bit in DCT
        LD   A,255              ;max possible track # --> accu
        LD   (IX+5),A           ;make current track # to 255
        XOR  A                  ;desired track # = 0
        JR   TRKS10

;set track and sector:
TRKSEC: LD   A,(TRACK)          ;track # --> accu
        BIT  5,(IX)             ;disk density ?
        JR   Z,TRKSE1           ;jump if single density
        BIT  4,(IX)             ;density of first track ?
        JR   NZ,TRKSE1          ;jump if double density
        INC  A                  ;increment track #
TRKSE1: BIT  2,(IX)             ;step count from track to track
        JR   Z,TRKSE2           ;jump if step count = 1
        ADD  A,A                ;track # * 2
TRKSE2: CP   (IX+5)             ;same as current track
        JR   NZ,TRKSE8          ;jump to SEEK cmd if not
	LD   C,A		;save track #
        LD   A,$DDDEN           ;set double density command
        BIT  5,(IX)             ;density ?
        JR   NZ,TRKSE3          ;jump if double density
        DEC  A                  ;set single density
TRKSE3: LD   (HL),A             ;set density
        LD   A,$SET8            ;set 8 inch command
        BIT  7,(IX)             ;disk size ?
        JR   NZ,TRKSE4          ;jump if 8 inch
        RES  6,A                ;set 5 inch command
TRKSE4: LD   ($FDSIZ),A         ;set disk size
	LD   A,$FCINT		;force interrupt
	LD   (HL),A
	LD   A,C		;restore track #
        BIT  2,(IX)             ;step count from track to track
        JR   Z,TRKSE5           ;jump if step count = 1
        SRL  A                  ;track # / 2
TRKSE5: LD   ($FDTRK),A         ;adjust current track #
        LD   A,(SECTOR)         ;sector # --> accu
        BIT  6,(IX)             ;single or double sided ?
        JR   Z,TRKSE6           ;jump if single sided
        BIT  5,(IX+1)           ;sector numbering continued on backside ?
        JR   NZ,TRKSE6          ;jump if yes
        LD   B,(IX+3)           ; sectors/track --> reg. B
        SRL  B                  ;(sectors/track) / 2
        CP   B                  ;front or back side ?
        JR   C,TRKSE6           ;jump if front side
        SUB  B                  ;adjust sector #
TRKSE6: BIT  3,(IX)             ;test number of first sector
        JR   Z,TRKSE7           ;jump if zero
        INC  A                  ;else adjust sector #
TRKSE7: LD   ($FDSEC),A         ;store sector # in FDC reg
        JR   WAITEN             ;no SEEK
TRKSE8: LD   C,A                ;save track #
        SUB  (IX+5)             ;subtract current track #
        JR   NC,TRKSE9
        NEG                     ;make result positive
TRKSE9: LD   (WAIT),A           ;store calculated step count
        LD   A,C                ;restore track #
TRKS10: LD   ($FDDATA),A        ;store track # in FDC reg
        LD   (HL),$FCINT        ;reset FDC
        LD   A,(IX+5)           ;current track from DCT
        LD   ($FDTRK),A         ;FDC track register
        LD   A,(IX)
        AND  3                  ;step rate --> accu
        PUSH HL                 ;save ^FDC command reg
        LD   HL,(WAIT)          ;get step count
        JR   Z,TRKS12           ;jump if step rate = 3 msec
        LD   D,H                ;step count --> reg. DE
        LD   E,L
        LD   B,A                ;step rate --> reg. B
TRKS11: ADD  HL,DE              ;counter = step count * step rate
        DJNZ TRKS11
TRKS12: LD   B,H                ;counter --> reg. BC
        LD   C,L
        ADD  HL,HL              ;counter * 2
        ADD  HL,BC              ;counter * 3
        LD   BC,15              ;adjust value for delay loop --> reg. BC
        ADD  HL,BC              ;adjust wait counter
        LD   (WAIT),HL          ;store wait counter (msecs of passed time)
        POP  HL                 ;restore ^FDC command reg
        OR   $SEEK              ;or step rate with "seek" command
        LD   (HL),A             ;issue seek command
TRKS13: CALL SELECT             ;select drive
        BIT  7,(HL)             ;drive not ready ?
        JR   NZ,READ2           ;jump to error exit
        BIT  0,(HL)             ;seek done ?
        JR   NZ,TRKS13          ;no, loop
        LD   BC,2000            ;load delay counter
        CALL DELAY              ;15 msec head settle delay
        LD   A,($FDTRK)         ;get current track
        LD   (IX+5),A           ;store in drive's DCT
        JP   TRKSEC             ;check track # again

;motor on / head load time:
WAITEN: LD   A,(DRIVE)          ;get drive #
        PUSH HL                 ;save ^FDC status register
        LD   HL,OLDDRV          ;^previous drive # --> reg. HL
        CP   (HL)               ;new drive # same as old drive # ?
        LD   (HL),A             ;store new drive #
        LD   A,(OLDSTAT)        ;get old FDC status
        RLCA                    ;drive rotating already
        JR   C,WAITE2           ;jump to motor on delay loop, if not
        JR   Z,WAITE6           ;jump if same drive #
WAITE1: LD   HL,50              ;50 msec head load time
        JR   WAITE3
WAITE2: BIT  7,(IX)             ;8 inch drive
        JR   NZ,WAITE1          ;jump if 8 inch drive
        LD   HL,1000            ;1 sec delay after motor on
WAITE3: LD   BC,(WAIT)          ;msecs of passed time --> reg. BC
        OR   A                  ;clear carry bit
        SBC  HL,BC              ;calculate remaining wait time
        JR   C,WAITE6           ;no further time to wait
        JR   Z,WAITE6
WAITE5: LD   BC,137             ;1 msec delay
        CALL DELAY
        DEC  HL
        LD   A,H
        OR   L
        JR   NZ,WAITE5          ;loop HL times
WAITE6: POP  HL                 ;restore ^FDC status register
        LD   A,(HL)             ;get FDC status
        RLCA                    ;drive rotating already ?
        JR   C,READ2            ;jump if not

;init READ/WRITE:
TASK1:  CALL SELECT             ;select drive
        LD   DE,$FDDATA         ;data register
        LD   A,(RDFLAG)
        OR   A                  ;READ or WRITE ?
        JR   Z,WRITE1           ;jump if WRITE

;read sector:
        LD   (HL),$RDSEC        ;issue "read" command
        LD   BC,6               ;56 usec delay
        CALL DELAY
        LD   BC,(BUFFER)        ;get buffer pointer
READ1:  BIT  1,(HL)             ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  1,(HL)             ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  0,(HL)             ;full sector transferred ?
        JR   Z,STATUS           ;yes, go end process
        BIT  1,(HL)             ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  7,(HL)             ;drive not ready ?
        JR   Z,READ1            ;no loop
READ2:  LD   A,4                ;error code 4 --> accu
        RET
READ3:  LD   A,(DE)             ;read char
        LD   (BC),A             ;put buffer char
        INC  BC                 ;bump buffer pointer
        JR   READ1

;write sector:
WRITE1: LD   (HL),$WRSEC        ;issue "write" command
        LD   BC,6               ;56 usec delay
        CALL DELAY
        LD   BC,(BUFFER)        ;get buffer pointer
WRITE2: LD   A,(BC)             ;get buffer char
WRITE3: BIT  1,(HL)             ;data request ?
        JR   NZ,WRITE4          ;yes, get byte
        BIT  1,(HL)             ;data request ?
        JR   NZ,WRITE4          ;yes, get byte
        BIT  0,(HL)             ;full sector transferred ?
        JR   Z,STATUS           ;yes, go end process
        BIT  1,(HL)             ;data request ?
        JR   NZ,WRITE4          ;yes, get byte
        BIT  7,(HL)             ;drive not ready ?
        JR   Z,WRITE3           ;no loop
        JR   READ2              ;jump to error exit
WRITE4: LD   (DE),A             ;write char
        INC  BC                 ;bump buffer pointer
        JR   WRITE2             ;put next byte

;test controller status:
STATUS: LD   A,(HL)             ;get FDC status
        BIT  6,A                ;write protect ?
        JR   Z,STATU1           ;jump if not
        LD   A,5                ;error code 5 --> accu
        RET
STATU1: BIT  5,A                ;hardware fault (WRITE) ?
                                ;sector   prot  (READ ) ?
        JR   Z,STATU2           ;jump if no
        LD   A,6                ;error code 6 --> accu
        RET
STATU2: AND  1CH                ;any errors ?
        RET  Z
        RES  0,(IX+1)           ;clear init bit in DCT
        LD   HL,TRIES           ;get tries counter
        DEC  (HL)               ;dec value
        JP   NZ,INIT            ;try again, reseek
        BIT  4,A                ;data record not found ?
        JR   Z,STATU3
        LD   A,7                ;error code 7 --> accu
        RET
STATU3: BIT  3,A                ;parity error ?
        JR   Z,STATU4
        LD   A,8                ;error code 8 --> accu
        RET
STATU4: LD   A,9                ;error code 9 --> accu
        RET

;put drive control table pointer in "IX":
GETDCT: PUSH DE                 ;save reg. DE
        LD   H,0                ;drive # --> reg. HL
        LD   L,A
        ADD  A,A                ; drive # * 2
        ADD  A,L                ; drive # * 3
        ADD  A,A                ; drive # * 6
        LD   L,A                ;(drive # * 6) --> reg. HL
        LD   DE,DCT             ;get drive table start
        ADD  HL,DE              ;add offset and get ^DCT
        PUSH HL                 ;^DCT --> reg. IX
        POP  IX
        POP  DE                 ;restore reg. DE
        RET                     ;return to caller

;select drive:
SELECT: LD   A,(DRIVE)          ;get drive #
        OR   A                  ;drive # zero ?
        LD   B,A                ;drive # --> reg. B
        LD   A,1                ;select code for drive zero
        JR   Z,SELEC1           ;jump if drive # zero
        RLCA                    ;rotate left accu
        DJNZ $-1                ;decrement drive #
SELEC1: BIT  6,(IX)             ;single or double sided ?
        JR   Z,SELEC2           ;jump if single sided
        LD   C,A                ;save select code
        LD   A,(SECTOR)         ;sector #       --> accu
        LD   B,(IX+3)           ; sectors/track --> reg. B
        SRL  B                  ;(sectors/track) / 2
        CP   B                  ;front or back side ?
        LD   A,C                ;restore select code
        JR   C,SELEC2           ;jump if front side
        SET  4,A                ;set side select bit
SELEC2: LD   ($FDSEL),A         ;select drive and side
        RET                     ;return to caller


*EJECT
;*******************
;*  $ G E T T I M  *
;*******************

;exit : HL = address of a 22 bytes long buffer, containing
;	     time & date in the form WWW MM/DD/YY HH:MM:SS

;		  WWW = weekday
;		   MM = month
;		   DD = day
;		   YY = year
;		   HH = hours
;		   MM = minutes
;		   SS = seconds		 

;get time & date in ASCII format:
$GETTIM:PUSH HL			;save ^user buffer
        CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer --> reg. IX

	LD   A,(IX+6)		;weekday      --> accu
	AND  7			;make binary
	LD   H,0		;weekday      --> reg. HL			
	LD   L,A
	LD   DE,DAYTAB		;base of weekday table --> reg. DE
	ADD  A,A		;calc table entry
	ADD  A,L
	LD   L,A
	ADD  HL,DE
	LD   DE,ATIMBUF		;^ASCII buffer 	       --> reg. DE	
	LD   BC,3		;length of table entry --> reg. BC
	LDIR			;move weekday into ASCII buffer
	INC  DE			;bump buffer ptr over space

	LD   A,(IX+2)		;month (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+3)		;month (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX+4)		;day (tenths) --> accu
	AND  '3'		;mask leapyear bit
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+5)		;day (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX)		;year (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+1)		;year (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over space		

	LD   A,(IX+7)		;hours (tenths) --> accu
	AND  '3'		;mask format bit 
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+8)		;hours (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon	

	LD   A,(IX+9)		;minutes (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+10)		;minutes (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon	

	LD   A,(IX+11)		;seconds (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+12)		;seconds (ones)   --> accu
	LD   (DE),A		;store them

	POP  DE			;restore ^user buffer
	LD   HL,ATIMBUF		;^(time & date buffer) 	      --> reg. HL
	LD   BC,21		;length of time & date string --> reg. BC
	JP   MOVE		;transfer time & date string and return	
	RET

;read time & date from clock chip:
GETTIM: LD   HL,TIMBUF		;^temp buffer --> reg. HL
        CALL RTCFREE		;wait for read RTC
	LD   A,40H
	OUT  (0E1H),A		;turn on read mode
	LD   DE,10CFH		;register address displacement --> reg. D
				;register address	       --> reg. E
	LD   B,13		;byte counter 		       --> reg. B
GETTI1:	LD   A,E		;read date & time
	OUT  (0E0H),A
	SUB  D
	LD   E,A
	IN   A,(0E0H)	 	
	AND  0FH		;mask undesired bits
	OR   '0'		;make ASCII digit
	LD   (HL),A
	INC  HL			;bump ^(time & date)
	DJNZ GETTI1
	RET			;return to caller

DAYTAB:	DEFM 'SatSunMonTueWedThuFri'


*EJECT
;*******************
;*  $ S E T T I M  *
;*******************

;entry:  A = weekday (0 - 6, 0 = Sat)
;	 B = month   (MM)
;        D = hours   (HH)
;	 E = minutes (MM)
;	 H = day     (DD)
;	 L = year    (YY)


;set time and date in binary format:
$SETTIM:LD   IX,TIMBUF		;^temp buffer --> reg. IX
	LD   (IX+6),A		;weekday      --> buffer
	LD   A,L		;year (ones)  --> accu
	AND  0FH		;mask it
	LD   (IX+1),A		;year (ones)  --> buffer
	SRL  L			;shift reg. E four bits right
	SRL  L
	SRL  L
	SRL  L
	LD   (IX),L		;year  (tenths) --> buffer
	LD   A,B		;month (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+3),A		;month (ones)   --> buffer
	SRL  B			;shift reg. B four bits right
	SRL  B
	SRL  B
	SRL  B
	LD   (IX+2),B		;month (tenths) --> buffer
	LD   A,H		;day   (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+5),A		;day   (ones)   --> buffer
	SRL  H			;shift reg. D four bits right
	SRL  H
	SRL  H
	SRL  H
	LD   (IX+4),H		;day   (tenths) --> buffer
	LD   A,D		;hours (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+8),A		;hours (ones)	--> buffer
	SRL  D			;shift reg. H four bits right
	SRL  D
	SRL  D
	SRL  D
	LD   (IX+7),D		;hours   (tenths) --> buffer
	LD   A,E		;minutes (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+10),A		;minutes (ones)   --> buffer
	SRL  E			;shift reg. L four bits right
	SRL  E
	SRL  E
	SRL  E
	LD   (IX+9),E		;minutes (tenths) --> buffer
	LD   (IX+11),0		;seconds (tenths) --> buffer
	LD   (IX+12),0		;seconds (ones)   --> buffer
	LD   HL,TIMBUF		;^buffer	  --> reg. HL
        CALL RTCFREE		;wait for read RTC
	LD   DE,10D0H		;register address displacement --> reg. D
				;register address	       --> reg. E
	LD   B,13		;byte counter 		       --> reg. B
SETTI1: XOR  A			;set date & time
	OUT  (0E1H),A
       	LD   A,E
	SUB  D
	LD   E,A
	OR   (HL)
	OUT  (0E0H),A
	INC  HL			;bump ^(time & date)
	LD   A,80H
	OUT  (0E1H),A
	DJNZ SETTI1
	JP   GETTIM		;adjust clock chip and return to caller

RTCFREE:LD   A,(37E0H)		;interrogate interrupts
	OR   A
	JP   M,RTCFREE
RTCFR1:	LD   A,(37E0H)
	OR   A
	JP   P,RTCFR1
	RET	


*EJECT
;*******************
;*  $ G T I M E 3  *
;*******************

;entry: HL = pointer to a 5 byte buffer containing on exit
;	     date and time in the form DDDDHHMMSS

;	      DDDD = number of days since January 1st, 1978 (binary    )
;		HH = hours   				    (BCD format)
;		MM = minutes 				    (BCD format)
;		SS = seconds 				    (BCD format)

;get time & date in CP/M 3 format:
$GTIME3:PUSH HL			;save ^user buffer
        CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer   --> reg. IX
	LD   IY,TBUF3    	;^result buffer --> reg. IY	

	LD   A,(IX+7)		;hours (tenths) --> reg. C
	AND  3			;make binary
	RLCA    		;hours (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	--> reg. C
	LD   A,(IX+8)		;hours (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+2),A           ;store BCD hours	

	LD   A,(IX+9)		;minutes (tenths) --> reg. C
	AND  7			;make binary
	RLCA    		;minutes (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+10)		;minutes (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+3),A           ;store BCD minutes

	LD   A,(IX+11)		;seconds (tenths) --> reg. C
	AND  7			;make binary
	RLCA    		;seconds (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+12)		;seconds (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+4),A           ;store BCD seconds

	LD   A,(IX+1)		;year (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;year (ones)   --> reg. C
	LD   A,(IX)		;year (tenths) --> accu
	AND  0FH		;make binary
	CALL BCDBIN		;convert BCD year to binary
	LD   (YEAR),A		;store it

	LD   A,(IX+3)		;month (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;month (ones)   --> reg. C
	LD   A,(IX+2)		;month (tenths) --> accu
	AND  1  		;make binary
	CALL BCDBIN		;convert BCD month to binary
	LD   (MONTH),A		;store it

	LD   A,(IX+5)		;day (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;day (ones)   --> reg. C
	LD   A,(IX+4)		;day (tenths) --> accu
	AND  3  		;make binary
	CALL BCDBIN		;convert BCD day to binary
	LD   (DAY),A		;store it

	LD   A,(YEAR)		;binary year --> accu
	SUB  78                 ;subtract base year
	JR   NC,GTIME1          ;result negative ?
	ADD  A,100              ;correct year	
GTIME1: SRL  A			;year / 4 --> accu
	RR   C        		;year % 4 --> reg. C
	SRL  A
	RR   C
	LD   B,6
GTIME2: SRL  C
	DJNZ GTIME2
	LD   HL,0               ;clear daycount
	OR   A			;year / 4 == 0 ?
	JR   Z,GTIME4		;no multiplication
	LD   B,A                ;year / 4 --> reg. B
	LD   DE,1461		;number of days in 4 years --> reg. DE
GTIME3: ADD  HL,DE              ;daycount = year / 4 * 1461
	DJNZ GTIME3
GTIME4:	EX   DE,HL		;daycount --> reg. DE

;calc table index:
	LD   A,C		;year %  4    --> accu
	ADD  A,A		;accu *  2
 	ADD  A,A		;accu *  4
	LD   C,A     		;accu *  4    --> reg. C
  	ADD  A,A		;accu *  8
	ADD  A,C   		;accu * 12
	LD   C,A		;accu * 12    --> reg. C
	LD   A,(MONTH)          ;binary month --> accu
	DEC  A     		;normalize
	ADD  A,C		;index = year % 4 * 12 + month - 1
	ADD  A,A		;make byte index
	LD   C,A		;table index       --> reg. BC
	LD   HL,MONTAB          ;base of day table --> reg. HL
	ADD  HL,BC		;add index
	LD   A,(HL)		;table[index]      --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,A

	ADD  HL,DE 		;daycount += table[index]
	LD   A,(DAY)		;binary day --> accu
	LD   C,A   		;day        --> reg. BC
	ADD  HL,BC		;now reg. HL contains number of days
	        		;since January 1st, 1978

	LD   (IY),L 		;store daycount
	LD   (IY+1),H           

	POP  DE			;restore ^user buffer
	LD   HL,TBUF3		;^temporary buffer --> reg. HL
	LD   BC,5		;buffer length	   --> reg. BC
	JP   MOVE		;move time & date into user buffer and return

;convert BCD to binary:
BCDBIN:	ADD  A,A		;lower nibble *  2
	LD   B,A		;lower nibble *  2 --> reg. B
	ADD  A,A		;lower nibble *  4
	ADD  A,A		;lower nibble *  8
	ADD  A,B		;lower nibble * 10
	ADD  A,C		;add lower nibble
	RET


*EJECT
;*******************
;*  $ S T I M E 3  *
;*******************

;entry:  D = hours   (HH)
;	 E = minutes (MM)
;	HL = number of days since January 1st, 1978 (binary)

;set time & date in CP/M 3 format:
$STIME3:PUSH DE			;save hours & minutes
	PUSH HL			;save daycount
	DEC  HL			;normalize

        XOR  A     		;clear quotient
	LD   DE,1461  		;number of days in 4 years --> reg. DE
STIME1: SBC  HL,DE              ;daycount / 1461 	   --> accu
	JR   C,STIME2
	INC  A
	JR   STIME1
STIME2: ADD  HL,DE              ;adjust remainder
	EX   DE,HL		;remainder --> reg. DE
	ADD  A,A		;accu * 2
	ADD  A,A		;accu * 4
	LD   (YEAR),A           ;year = daycount / 1461 * 4

;search table entry:
	LD   A,47               ;last index 	   --> accu
STIME3: LD   H,0                ;index #           --> reg. HL
	LD   L,A
	ADD  HL,HL  		;make byte index
	LD   BC,MONTAB          ;dase of day table --> reg. BC
	ADD  HL,BC		;calc table entry
	LD   B,(HL)             ;table[index]      --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,B
	SBC  HL,DE              ;daycount >= table index ?
	JR   C,STIME4 		;if yes search finished
	JR   Z,STIME4
	DEC  A  		;index = index - 1
	JP   P,STIME3

STIME4: LD   B,0                ;clear quotient
STIME5:	SUB  12                 ;index / 12 --> accu
	JR   C,STIME6
	INC  B			;increment quotient
	JR   STIME5
STIME6:	ADD  A,13		;adjust remainder and calc month
	LD   (MONTH),A          ;store it
	LD   A,(YEAR) 		;year --> accu
	ADD  A,B   		;year += index / 12
	SUB  22			;normalize
	JR   NC,STIME7          ;year negative ?
	ADD  A,100		;correct it
STIME7: LD   (YEAR),A           ;store it
	LD   A,L		;table[index] - daycount --> accu
	NEG     		;daycount - table[index] --> accu
	INC  A     		;day = daycount - table[index] + 1
	LD   (DAY),A            ;store it

	POP  HL			;restore day count
	LD   A,H		;daycount (MSB)	      --> accu
	LD   C,L		;daycount (LSB)	      --> reg. C
	LD   DE,7		;no. of days per week --> reg. DE
	LD   HL,0		;clear accumulator
	LD   B,16		;init counter
STIME8:	RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
	SBC  HL,DE		;subtract divisor
	JR   NC,$+3		;subtraction ok
	ADD  HL,DE		;restore accumulator
	CCF			;complement carry flag
	DJNZ STIME8		;counter = 0 ?
	LD   A,L		;weekday no. --> accu
        PUSH AF 		;save weekday

	LD   A,(MONTH)		;binary month --> accu
	CALL BINBCD		;convert to BCD format
	LD   D,A     		;save month

	LD   A,(DAY)		;binary day --> accu
	CALL BINBCD		;convert to BCD format
	LD   H,A		;BCD day     --> reg. H
	LD   A,(YEAR)		;binary year --> accu
	RRA			;year / 4
	JR   C,STIME9
	RRA
	JR   C,STIME9
       	SET  6,H		;set leapyear flag

STIME9:	LD   A,(YEAR)		;binary year --> accu
	CALL BINBCD		;convert to BCD format
	LD   L,A   		;BCD year    --> reg. L

	LD   B,D		;BCD month   --> reg. B
	POP  AF			;weekday     --> accu
	POP  DE			;BCD hours   --> reg. D
				;BCD minutes --> reg. E
	SET  7,D		;set "24 hour" format
	JP   $SETTIM		;set time & date and return to caller

;convert binary to BCD:
BINBCD:	LD   C,0		;clear result
BINBC1: SUB  10			;accu / 10
	JR   C,BINBC2
	INC  C  		;increment quotient
	JR   BINBC1
BINBC2: ADD  A,10		;adjust remainder
	LD   B,4
BINBC3:	SLA  C			;quotient --> upper nibble
	DJNZ BINBC3
	ADD  A,C		;add remainder
	RET

;day table:
;	     Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec	
MONTAB:	DEFW 0000,0031,0059,0090,0120,0151,0181,0212,0243,0273,0304,0334  ;1978
        DEFW 0365,0396,0424,0455,0485,0516,0546,0577,0608,0638,0669,0699  ;1979
        DEFW 0730,0761,0790,0821,0851,0882,0912,0943,0974,1004,1035,1065  ;1980
        DEFW 1096,1127,1155,1186,1216,1247,1277,1308,1339,1369,1400,1430  ;1981


*EJECT
	ORG  0D00H

        INCLUDE SYSTAB

	END
           ;set cylinder # (MSB)
	OUT  ($CYLHI),A
	LD   A,L		;restore drive select bits
	OUT  ($SDH),A		;select drive

;init READ/WRITE:
	LD   HL,(BUFFER)	;get buffer pointer
	LD   E,(IX+1)		;get sector length bits
	LD   B,6
	SRL  E
	DJNZ $-2
	LD   C,$DATA		;init byte counter and data port number
	LD   A,(RDFLAG)		;READ or WRITE
	OR   A
	JR   Z,WRITW1		;jump if WRITE

;read sector:
      	LD   A,$$READ     	;issue "read" command
	OUT  ($COMND),A
READW1: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;read done ?
	JR   NZ,READW1  	;no, loop
	LD   A,E		;sector length bits --> accu
	OR   A   		;test sector length bits
	JR   Z,R256		;read 256 bytes
	DEC  A
	JR   Z,R512             ;read 512 bytes
        DEC  A
      	JR   Z,R1024		;read 1024 bytes
	LD   B,128 		;load new byte counter
      	JR   R256    		;read 128 bytes
R1024:  INIR		        ;transfer sector
	INIR
R512:   INIR
R256: 	INIR
        JR   WDCSTAT   		;read WDC status

;write sector:
WRITW1: LD   A,$$WRITE    	;issue "write" command
	OUT  ($COMND),A
	LD   A,E		;sector length bits --> accu
	OR   A   		;test sector length bits
	JR   Z,W256		;write 256 bytes
	DEC  A
	JR   Z,W512             ;write 512 bytes
        DEC  A
      	JR   Z,W1024		;write 1024 bytes
	LD   B,128 		;load new byte counter
      	JR   W256    		;write 128 bytes
W1024:  OTIR		        ;transfer sector
	OTIR
W512:   OTIR
W256: 	OTIR
WRITW2: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;write done ?
	JR   NZ,WRITW2   	;no, loop

;test controller status:
WDCSTAT:IN   A,($STATUS)	;get WDC status
	AND  1  		;any errors ?
	LD   C,A		;"no error" code --> reg. C
	JR   Z,DSEL             ;return if not
	IN   A,($ERROR)	        ;read WDC error register
	LD   L,A		;save error code
	AND  13H		;data record not found ?
       	JR   Z,WDCST1          
	LD   C,7 		;error code 7 --> reg. C
	JR   DSEL
WDCST1: LD   A,L		;restore error code
	AND  60H		;parity error ?
	JR   Z,WDCST2
	LD   C,8		;error code 8 --> reg. C
	JR   DSEL
WDCST2:	BIT  2,L                ;aborted command ?
        JR   Z,WDCST3
	LD   C,6 		;error code 6 --> reg. C
	JR   DSEL
WDCST3: IN   A,($STATUS)	;read status again
	BIT  6,A    		;drive not ready ?
        LD   C,4		;error code 4 --> reg. C
	JR   NZ,DSEL
       	LD   C,6		;error code 6 --> reg. C

DSEL:	LD   A,$DSEL 		;deselect drive
	OUT  ($SDH),A
	LD   A,C		;error code --> accu
	RET			;return to caller

;put drive control table pointer in "IX":
GETWCT: PUSH DE			;save reg. DE
	LD   H,0		;drive # --> reg. HL	
	LD   L,A		
	ADD  A,A		;drive # * 2
	ADD  A,L		;drive # * 3
	ADD  A,A		;drive # * 6
	ADD  A,L  		;drive # * 7	
	LD   L,A		;drive # * 7 --> reg. H
	LD   DE,DCTW		;get drive table start
  	ADD  HL,DE		;add offset and get ^DCT
	PUSH HL			;^DCT --> reg. IX
	POP  IX
	POP  DE			;restore reg. DE
	RET			;return


*EJECT
	ORG  0D00H
;******************************************************************************
;*			     	  S Y S T A B				      *
;******************************************************************************

DELAY1: DEFW 150   		;determines debounce time (start of key press)
DELAY2: DEFW 1500  		;determines debounce time (end   of key press)
DELAY3: DEFW 1750  		;determines wait time until key autorepeats
DELAY4:	DEFW 125		;determines frequency of auto repeat
KEYTAB:	DEFW NBOARD		;contains ^(keyboard table)

;table contains codes for all caps (may be altered by user):
NBOARD:

;address 3801H (letter keys):
	DEFB '@','`',NUL	;@, SHIFT-@, CTRL-@
	DEFB 'a','A',SOH	;A, SHIFT-A, CTRL-A
	DEFB 'b','B',STX	;B, SHIFT-B, CTRL-B
	DEFB 'c','C',ETX	;C, SHIFT-C, CTRL-C
	DEFB 'd','D',EOT	;D, SHIFT-D, CTRL-D
	DEFB 'e','E',ENQ	;E, SHIFT-E, CTRL-E
	DEFB 'f','F',ACK	;F, SHIFT-F, CTRL-F
	DEFB 'g','G',BEL	;G, SHIFT-G, CTRL-G

;address 3802H (letter keys):
	DEFB 'h','H',BS 	;H, SHIFT-H, CTRL-H
	DEFB 'i','I',HT 	;I, SHIFT-I, CTRL-I
	DEFB 'j','J',LF 	;J, SHIFT-J, CTRL-J
	DEFB 'k','K',VT 	;K, SHIFT-K, CTRL-K
	DEFB 'l','L',FF 	;L, SHIFT-L, CTRL-L
	DEFB 'm','M',CR 	;M, SHIFT-M, CTRL-M
	DEFB 'n','N',SO 	;N, SHIFT-N, CTRL-N
	DEFB 'o','O',SI 	;O, SHIFT-O, CTRL-O

;address 3804H (letter keys):
	DEFB 'p','P',DLE	;P, SHIFT-P, CTRL-P
	DEFB 'q','Q',DC1	;Q, SHIFT-Q, CTRL-Q
	DEFB 'r','R',DC2	;R, SHIFT-R, CTRL-R
	DEFB 's','S',DC3	;S, SHIFT-S, CTRL-S
	DEFB 't','T',DC4	;T, SHIFT-T, CTRL-T
	DEFB 'u','U',NAK	;U, SHIFT-U, CTRL-U
	DEFB 'v','V',SYN	;V, SHIFT-V, CTRL-V
	DEFB 'w','W',ETB	;W, SHIFT-W, CTRL-W

;address 3808H (letter keys):
	DEFB 'x','X',CAN	;X, SHIFT-X, CTRL-X
	DEFB 'y','Y',EM 	;Y, SHIFT-Y, CTRL-Y
	DEFB 'z','Z',SUB	;Z, SHIFT-Z, CTRL-Z
	DEFB '[','{',ESC	;[, SHIFT-[, CTRL-[
	DEFB '\','|',FS 	;\, SHIFT-\, CTRL-\
	DEFB ']','}',GS 	;], SHIFT-], CTRL-]
	DEFB '^','~',RS 	;^, SHIFT-^, CTRL-^
	DEFB '_','^',RS 	;_, SHIFT-_, CTRL-_

;address 3810H (number keys):
	DEFB '0','0',0  	;0, SHIFT-0, CTRL-0
	DEFB '1','!',0  	;1, SHIFT-1, CTRL-1
	DEFB '2','"',0  	;2, SHIFT-2, CTRL-2
	DEFB '3','#',0  	;3, SHIFT-3, CTRL-3
	DEFB '4','$',0  	;4, SHIFT-4, CTRL-4
	DEFB '5','%',0  	;5, SHIFT-5, CTRL-5
	DEFB '6','&',0  	;6, SHIFT-6, CTRL-6
	DEFB '7','''',0 	;7, SHIFT-7, CTRL-7

;address 3820H (number & special keys):
	DEFB '8','(',0  	;8, SHIFT-8, CTRL-8
	DEFB '9',')',0  	;9, SHIFT-9, CTRL-9
	DEFB ':','*',0  	;:, SHIFT-:, CTRL-:
	DEFB ';','+',0  	;;, SHIFT-;, CTRL-;
	DEFB ',','<',0  	;,, SHIFT-,, CTRL-,
	DEFB '-','=',0  	;-, SHIFT--, CTRL--
	DEFB '.','>',0  	;., SHIFT-., CTRL-.
	DEFB '/','?',0 		;/, SHIFT-/, CTRL-/

;address 3840H (special keys):	
	DEFB CR,CR,0    	;NEWLINE   , SHIFT-NEWLINE   , CTRL-NEWLINE
	DEFB DEL,0FCH,0 	;CLEAR     , SHIFT-CLEAR     , CTRL-CLEAR
	DEFB ESC,0FDH,0 	;BREAK     , SHIFT-BREAK     , CTRL-BREAK
	DEFB VT,DC2,ETB 	;UP-ARROW  , SHIFT-UP-ARROW  , CTRL-UP-ARROW
	DEFB LF,ETX,SUB 	;DOWN-ARROW, SHIFT-DOWN-ARROW, CTRL-DOWN-ARROW
	DEFB BS,CAN,BEL 	;LEFT-ARROW, SHIFT-LEFT-ARROW, CTRL-LEFT-ARROW
	DEFB FF,HT,ACK  	;RGHT-ARROW, SHIFT-RGHT-ARROW, CTRL-RGHT-ARROW
	DEFB ' ',' ',0 		;SPACE     , SHIFT-SPACE     , CTRL-SPACE

;address 38A0H (function keys)8	
	DEFB 80H,80H,0  	;F1, SHIFT-F1, CTRL-F1
	DEFB 81H,81H,0  	;F2, SHIFT-F2, CTRL-F2
	DEFB 82H,82H,0  	;F3, SHIFT-F3, CTRL-F3
	DEFB 83H,83H,0  	;F4, SHIFT-F4, CTRL-F4
	DEFB 84H,84H,0  	;F5, SHIFT-F5, CTRL-F5
	DEFB 85H,85H,0  	;F6, SHIFT-F6, CTRL-F6
	DEFB 86H,86H,0  	;F7, SHIFT-F7, CTRL-F7
	DEFB 87H,87H,0 		;F8, SHIFT-F8, CTRL-F8

;address 38C0H (number keys [numeric keypad]):	
	DEFB '0','0',0  	;1, SHIFT-1, CTRL-1
	DEFB '1','1',0  	;2, SHIFT-2, CTRL-2
	DEFB '2','3',0  	;3, SHIFT-3, CTRL-3
	DEFB '3','3',0  	;4, SHIFT-4, CTPL-4
	DEFB '4','4',0  	;5, SHIFT-5, CTRL-5
	DEFB '5','5',0  	;6, SHIFT-6, CTRL-6
	DEFB '6','6',0  	;7, SHIFT-7, CTRL-7
	DEFB '7','7',0 		;8, SHIFT-8, CTRL-8

;address 3880H (function keys & escape key):
	DEFB 0,0,0      	;SHIFT
	DEFB 0,0,0      	;CTRL
	DEFB ESC,ESC,0  	;ESC
	DEFB 8CH,8CH,0  	;P5, SHIFT-P5, CTRL-P5
	DEFB 8BH,8BH,0  	;P4, SHIFT-P4, CTRL-P4
	DEFB 8AH,8AH,0  	;P3, SHIFT-P3, CTRL-P3
	DEFB 89H,89H,0  	;P2, SHIFT-P2, CTRL-P2
	DEFB 88H,88H,0 		;P1, SHIFT-P1, CTRL-P1

;address 38E0H (number & special keys [numeric keypad]):	
	DEFB '8','8',0  	;8 , SHIFT-8 , CTRL-8
	DEFB '9','9',0  	;9 , SHIFT-9 , CTRL-9
	DEFB 0FEH,0FEH,0	;00, SHIFT-00, CTRL-00
	DEFB 0,0,0      	;LOCK
	DEFB ',',',',0  	;, , SHIFT-, , CTRL-,
	DEFB '-','-',0  	;- , SHIFT-- , CTRL--
	DEFB '.','.',0  	;. , SHIFT-. , CTRL-.
	DEFB 0FBH,0FBH,0	;PRINT


*EJECT
;table contains codes for all caps (special WordStar version):
WBOARD:

;address 3801H (letter keys):
	DEFB '@','`',NUL	;@, SHIFT-@, CTRL-@
	DEFB 'a','A',SOH	;A, SHIFT-A, CTRL-A
	DEFB 'b','B',STX	;B, SHIFT-B, CTRL-B
	DEFB 'c','C',ETX	;C, SHIFT-C, CTRL-C
	DEFB 'd','D',EOT	;D, SHIFT-D, CTRL-D
	DEFB 'e','E',ENQ	;E, SHIFT-E, CTRL-E
	DEFB 'f','F',ACK	;F, SHIFT-F, CTRL-F
	DEFB 'g','G',BEL	;G, SHIFT-G, CTRL-G

;address 3802H (letter keys):
	DEFB 'h','H',BS 	;H, SHIFT-H, CTRL-H
	DEFB 'i','I',HT 	;I, SHIFT-I, CTRL-I
	DEFB 'j','J',LF 	;J, SHIFT-J, CTRL-J
	DEFB 'k','K',VT 	;K, SHIFT-K, CTRL-K
	DEFB 'l','L',FF 	;L, SHIFT-L, CTRL-L
	DEFB 'm','M',CR 	;M, SHIFT-M, CTRL-M
	DEFB 'n','N',SO 	;N, SHIFT-N, CTRL-N
	DEFB 'o','O',SI 	;O, SHIFT-O, CTRL-O

;address 3804H (letter keys):
	DEFB 'p','P',DLE	;P, SHIFT-P, CTRL-P
	DEFB 'q','Q',DC1	;Q, SHIFT-Q, CTRL-Q
	DEFB 'r','R',DC2	;R, SHIFT-R, CTRL-R
	DEFB 's','S',DC3	;S, SHIFT-S, CTRL-S
	DEFB 't','T',DC4	;T, SHIFT-T, CTRL-T
	DEFB 'u','U',NAK	;U, SHIFT-U, CTRL-U
	DEFB 'v','V',SYN	;V, SHIFT-V, CTRL-V
	DEFB 'w','W',ETB	;W, SHIFT-W, CTRL-W

;address 3808H (letter keys):
	DEFB 'x','X',CAN	;X, SHIFT-X, CTRL-X
	DEFB 'y','Y',EM 	;Y, SHIFT-Y, CTRL-Y
	DEFB 'z','Z',SUB	;Z, SHIFT-Z, CTRL-Z
	DEFB '[','{',ESC	;[, SHIFT-[, CTRL-[
	DEFB '\','|',FS 	;\, SHIFT-\, CTRL-\
	DEFB ']','}',GS 	;], SHIFT-], CTRL-]
	DEFB '^','~',RS 	;^, SHIFT-^, CTRL-^
	DEFB '_','^',RS 	;_, SHIFT-_, CTRL-_

;address 3810H (number keys):
	DEFB '0','0',0  	;0, SHIFT-0, CTRL-0
	DEFB '1','!',0  	;1, SHIFT-1, CTRL-1
	DEFB '2','"',0  	;2, SHIFT-2, CTRL-2
	DEFB '3','#',0  	;3, SHIFT-3, CTRL-3
	DEFB '4','$',0  	;4, SHIFT-4, CTRL-4
	DEFB '5','%',0  	;5, SHIFT-5, CTRL-5
	DEFB '6','&',0  	;6, SHIFT-6, CTRL-6
	DEFB '7','''',0 	;7, SHIFT-7, CTRL-7

;address 3820H (number & special keys):
	DEFB '8','(',0  	;8, SHIFT-8, CTRL-8
	DEFB '9',')',0  	;9, SHIFT-9, CTRL-9
	DEFB ':','*',0  	;:, SHIFT-:, CTRL-:
	DEFB ';','+',0  	;;, SHIFT-;, CTRL-;
	DEFB ',','<',0  	;,, SHIFT-,, CTRL-,
	DEFB '-','=',0  	;-, SHIFT--, CTRL--
	DEFB '.','>',0  	;., SHIFT-., CTRL-.
	DEFB '/','?',0 		;/, SHIFT-/, CTRL-/

;address 3840H (special keys):	
	DEFB CR,CR,0    	;NEWLINE   , SHIFT-NEWLINE   , CTRL-NEWLINE
	DEFB 8DH,8EH,DEL	;CLEAR     , SHIFT-CLEAR     , CTRL-CLEAR
				;CLEAR 	     = erase to end of line
				;SHIFT-CLEAR = erase to start of line
				;CTRL -CLEAR = erase previous character
	DEFB NAK,0FDH,0  	;BREAK     , SHIFT-BREAK     , CTRL-BREAK
				;BREAK = abort current operation
	DEFB ENQ,8FH,90H 	;UP-ARROW  , SHIFT-UP-ARROW  , CTRL-UP-ARROW
				;      UP-ARROW = cursor up
				;SHIFT-UP-ARROW = start of text
				;CTRL -UP-ARROW = start of screen
	DEFB CAN,91H,92H 	;DOWN-ARROW, SHIFT-DOWN-ARROW, CTRL-DOWN-ARROW
				;      DOWN-ARROW = cursor down
				;SHIFT-DOWN-ARROW = end of text
				;CTRL -DOWN-ARROW = end of screen
	DEFB BS,93H,SOH 	;LEFT-ARROW, SHIFT-LEFT-ARROW, CTRL-LEFT-ARROW
				;      LEFT-ARROW = cursor left
				;SHIFT-LEFT-ARROW = start of line
				;CTRL -LEFT-ARROW = word left
	DEFB EOT,94H,ACK  	;RGHT-ARROW, SHIFT-RGHT-ARROW, CTRL-RGHT-ARROW
				;      RIGHT-ARROW = cursor right
				;SHIFT-RIGHT-ARROW = end of line
				;CTRL -RIGHT-ARROW = word right
	DEFB ' ',' ',95H	;SPACE     , SHIFT-SPACE     , CTRL-SPACE
				;CTRL-SPACE = hard space

;address 38A0H (function keys):	
	DEFB SYN,SYN,0  	;F1, SHIFT-F1, CTRL-F1
				;F1 = toggle insert mode
	DEFB SO,SO,0    	;F2, SHIFT-F2, CTRL-F2
				;F2 = insert line
	DEFB BEL,BEL,0  	;F3, SHIFT-F3, CTRL-F3
				;F3 = delete character
	DEFB DC4,DC4,0  	;F4, SHIFT-F4, CTRL-F4
				;F4 = delete word
	DEFB EM,EM,0   		;F5, SHIFT-F5, CTRL-F5
				;F5 = delete line
	DEFB STX,STX,0  	;F6, SHIFT-F6, CTRL-F6
				;F6 = reformat paragraph
	DEFB 96H,96H,0  	;F7, SHIFT-F7, CTRL-F7
				;F7 = toggle hyphen help
	DEFB 97H,97H,0  	;F8, SHIFT-F8, CTRL-F8
				;F8 = toggle right justifying

;address 38C0H (number keys [numeric keypad]):	
	DEFB '0','0',0  	;1, SHIFT-1, CTRL-1
	DEFB '1','1',0  	;2, SHIFT-2, CTRL-2
	DEFB '2','3',0  	;3, SHIFT-3, CTRL-3
	DEFB '3','3',0  	;4, SHIFT-4, CTRL-4
	DEFB '4','4',0  	;5, SHIFT-5, CTRL-5
	DEFB '5','5',0  	;6, SHIFT-6, CTRL-6
	DEFB '6','6',0  	;7, SHIFT-7, CTRL-7
	DEFB '7','7',0 		;8, SHIFT-8, CTRL-8

;address 3880H (function keys & escape key):
	DEFB 0,0,0      	;SHIFT
	DEFB 0,0,0      	;CTRL
	DEFB ESC,ESC,0  	;ESC
	DEFB ETX,ETX,0 		;P5, SHIFT-P5, CTRL-P5
				;P5 = page down
	DEFB DC2,DC2,0  	;P4, SHIFT-P4, CTRL-P4
				;P4 = page up	
	DEFB SUB,SUB,0  	;P3, SHIFT-P3, CTRL-P3
				;P3 = line down
	DEFB ETB,ETB,0  	;P2, SHIFT-P2, CTRL-P2
				;P2 = line up
	DEFB HT,HT,0    	;P1, SHIFT-P1, CTRL-P1
				;P1 = TAB

;address 38E0H (number & special keys [numeric keypad]):	
	DEFB '8','8',0  	;8 , SHIFT-8 , CTRL-8
	DEFB '9','9',0  	;9 , SHIFT-9 , CTRL-9
	DEFB 0FEH,0FEH,0	;00, SHIFT-00, CTRL-00
	DEFB 0,0,0      	;LOCK
	DEFB ',',',',0  	;, , SHIFT-, , CTRL-,
	DEFB '-','-',0  	;- , SHIFT-- , CTRL--
	DEFB '.','.',0  	;. , SHIFT-. , CTRL-.
	DEFB 0FBH,0FBH,0	;PRINT


*EJECT
VECTOR:	DEFW FKEYS 		;function key vector

OFFSET  DEFL 0			;initialize offset

FKEYS:	REPT 13			;function key pointer
	DEFW F0+Oinput status routine:
$RSRCST:LD   HL,RSSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
 	LD   L,C
	JP   (HL)		;execute RS232C input status routine

;RS232C input status routine entry table:
RSSTAB:	DEFW RSRCS0,RSRCS1,RSRCS2

;test input status of RS-232-C interface 0:
RSRCS0:	LD   A,(RSCHR0)		;get input status
	OR   A			;character ready ?
	RET  NZ			;return if yes
	LD   B,0		;load counter
        LD   A,3
	OUT  (MCR0),A		;request to send
RSRC00: CALL RSRC02		;scan interface
	JR   NZ,RSRC01		;jump if character ready
	DJNZ RSRC00		;scan 256 times
        LD   A,1
	OUT  (MCR0),A		;data terminal ready
	XOR  A			;return negative input status
	RET
RSRC01:	OUT  (MCR0),A		;data terminal ready
       	LD   (RSCHR0),A		;store input statatus
	RET			;return to caller
RSRC02:	IN   A,(LSR0)		;read line status
	AND  1  		;data ready ?
	RET          		;return
RSCHR0:	DEFB 0			;input status 

;test input status of RS-232-C interface 1:
RSRCS1:	LD   A,(RSCHR1)		;get input status
	OR   A			;character ready ?
	RET  NZ			;return if yes
	LD   B,0		;load counter
        LD   A,3
	OUT  (MCR1),A		;request to send
RSRC10: CALL RSRC12		;scan interface
	JR   NZ,RSRC11		;jump if character ready
	DJNZ RSRC10		;scan 256 times
        LD   A,1
	OUT  (MCR1),A		;data terminal ready
	XOR  A			;return negative input status
	RET
RSRC11:	OUT  (MCR1),A		;data terminal ready
       	LD   (RSCHR1),A		;store input statatus
	RET			;return to caller
RSRC12:	IN   A,(LSR1)		;read line status
	AND  1  		;data ready ?
	RET          		;return
RSCHR1:	DEFB 0			;input status 

;test input status of RS-232-C interface 2:
RSRCS2:	LD   A,(RSCHR2)		;get input status
	OR   A			;character ready ?
	RET  NZ			;return if yes
	LD   B,0		;load counter
        LD   A,3
	OUT  (MCR2),A		;request to send
RSRC20: CALL RSRC22		;scan interface
	JR   NZ,RSRC21		;jump if character ready
	DJNZ RSRC20		;scan 256 times
        LD   A,1
	OUT  (MCR2),A		;data terminal ready
	XOR  A			;return negative input status
	RET
RSRC21:	OUT  (MCR2),A		;data terminal ready
       	LD   (RSCHR2),A		;store input statatus
	RET			;return to caller
RSRC22:	IN   A,(LSR2)		;read line status
	AND  1  		;data ready ?
	RET          		;return
RSCHR2:	DEFB 0			;input status 


*EJECT
;*****************
;*  $ R S R C V  *
;*****************

;entry: B = number of RS232C interface (0-2)

;exit: A = char	

;calc entry of RS232C input routine:
$RSRCV:	LD   HL,RSRTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
 	LD   L,C
	JP   (HL)		;execute RS232C input routine

;RS232C input routine entry table:
RSRTAB:	DEFW RSRCV0,RSRCV1,RSRCV2

;receive a character from RS-232-C interface 0:
RSRCV0:	LD   A,(RSCHR0)		;character ready ?
	JR   NZ,RSRV02
        LD   A,3
	OUT  (MCR0),A		;request to send
RSRV01:	CALL RSRC02		;scan interface
	JR   Z,RSRV01		;loop `til char ready
	OUT  (MCR0),A		;data terminal ready
RSRV02:	XOR  A			;clear input status
	LD   (RSCHR0),A
        IN   A,(RBR0)		;read character
	RET			;return to caller

;receive a character from RS-232-C interface 1:
RSRCV1:	LD   A,(RSCHR1)		;character ready ?
	JR   NZ,RSRV12
        LD   A,3
	OUT  (MCR1),A		;request to send
RSRV11:	CALL RSRC12		;scan interface
	JR   Z,RSRV11		;loop `til char ready
	OUT  (MCR1),A		;data terminal ready
RSRV12:	XOR  A			;clear input status
	LD   (RSCHR1),A
        IN   A,(RBR1)		;read character
	RET			;return to caller

;receive a character from RS-232-C interface 2:
RSRCV2:	LD   A,(RSCHR2)		;character ready ?
	JR   NZ,RSRV22
        LD   A,3
	OUT  (MCR2),A		;request to send
RSRV21:	CALL RSRC22		;scan interface
	JR   Z,RSRV21		;loop `til char ready
	OUT  (MCR2),A		;data terminal ready
RSRV22:	XOR  A			;clear input status
	LD   (RSCHR2),A
        IN   A,(RBR2)		;read character
	RET			;return to caller


*EJECT
;*******************
;*  $ R S T X S T  *
;******************* 
	
;exit: A = terminal status
;      0 = data terminal ready
;   <> 0 = data terminal not ready

;calc entry of RS232C output status routine:
$RSTXST:LD   HL,RSTTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
 	LD   L,C
	JP   (HL)		;execute RS232C output status routine

;RS232C input status routine entry table:
RSTTAB:	DEFW RSTXS0,RSTXS1,RSTXS2

;test output status of RS232C interface 0:
RSTXS0:	IN   A,(LSR0)		;read line status
	CPL			;invert status bits
	AND  60H		;transmitter holding register & transmitter
	        		;shift register empty ?
	RET  NZ       		;return to caller if no
       	IN   A,(MSR0)		;read MODEM status	 
	AND  30H		;mask DSR & CTS bits
	SUB  30H		;clear to send ?
	RET			;return to caller
	
;test output status of RS232C interface 1:
RSTXS1:	IN   A,(LSR1)		;read line status
	CPL			;invert status bits
	AND  60H		;transmitter holding register & transmitter
	        		;shift register empty ?
	RET  NZ       		;return to caller if no
       	IN   A,(MSR1)		;read MODEM status	 
	AND  30H		;mask DSR & CTS bits
	SUB  30H		;clear to send ?
	RET			;return to caller
	
;test output status of RS232C interface 2:
RSTXS2:	IN   A,(LSR2)		;read line status
	CPL			;invert status bits
	AND  60H		;transmitter holding register & transmitter
	        		;shift register empty ?
	RET  NZ       		;return to caller if no
       	IN   A,(MSR2)		;read MODEM status	 
	AND  30H		;mask DSR & CTS bits
	SUB  30H		;clear to send ?
	RET			;return to caller
	

*EJECT
;***************
;*  $ R S T X  *
;***************

;entry: A = char
;       B = number of RS232C interface (0-2)

;calc entry of RS232C output routine:
$RSTX:  LD   HL,RSXTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
 	LD   L,C
	JP   (HL)		;execute RS232C output routine

;RS232C output routine entry table:
RSXTAB:	DEFW RSTX0,RSTX1,RSTX2

;transmit a character to RS-232-C interface 0:
RSTX0:	LD   C,A		;save char
	CALL RSTXS0		;test interface status
	JR   NZ,RSTX0+1		;wait for interface ready
	LD   A,C		;restore char
	OUT  (THR0),A		;output char
	RET			;return to caller

;transmit a character to RS-232-C interface 1:
RSTX1:	LD   C,A		;save char
	CALL RSTXS1		;test interface status
	JR   NZ,RSTX1+1		;wait for interface ready
	LD   A,C		;restore char
	OUT  (THR1),A		;output char
	RET			;return to caller

;transmit a character to RS-232-C interface 2:
RSTX2:	LD   C,A		;save char
	CALL RSTXS2		;test interface status
	JR   NZ,RSTX2+1		;wait for interface ready
	LD   A,C		;restore char
	OUT  (THR2),A		;output char
	RET			;return to caller


*EJECT
;disk driver:

;FDC registers:
$FDSEL  EQU  37E0H              ;FDC select  register
$FDCMD  EQU  37ECH              ;FDC command register
$FDSTAT EQU  37ECH              ;FDC status  register
$FDTRK  EQU  37EDH              ;FDC track   register
$FDSIZ  EQU  37EEH              ;FDC size    register
$FDSEC  EQU  37EEH              ;FDC sector  register
$FDDATA EQU  37EFH              ;FDC data    register

;FDC commands:
$SEEK   EQU  10H                ;seek
$RDSEC  EQU  88H                ;read sector
$WRSEC  EQU  0A8H               ;write sector
$SET8   EQU  0C0H               ;set disk size to 5 inch
$FCINT  EQU  0D0H               ;force interrupt
$DDDEN  EQU  0FFH               ;set double density


;***************
;*  $ R E A D  *
;***************

;entry: A  = drive  number
;       B  = sector number
;       E  = track  number
;       HL = buffer pointer

;exit : A = error code
;       0 = NO ERROR
;       1 = ILLEGAL DRIVE #
;       2 = TRACK # TOO HIGH
;       3 = SECTOR # TOO HIGH
;       4 = DEVICE NOT AVAILABLE
;       6 = TRIED TO READ LOCKED/DELETED RECORD
;       7 = DATA RECORD NOT FOUND DURING READ
;       8 = PARITY ERROR DURING READ
;       9 = LOST DATA DURING READ

;read a sector:
$READ:  LD   C,A                ;save drive #
        LD   A,0FFH             ;set READ-flag
        JR   TASK


*EJECT
;*****************
;*  $ W R I T E  *
;*****************

;entry: A  = drive  number
;       B  = sector number
;       E  = track  number
;       HL = buffer pointer

;exit : A = error code
;       0 = NO ERROR
;       1 = ILLEGAL DRIVE #
;       2 = TRACK # TOO HIGH
;       3 = SECTOR # TOO HIGH
;       4 = DEVICE NOT AVAILABLE
;       5 = WRITE PROTECTED DISKETTE
;       6 = WRITE FAULT ON DISK DRIVE
;       7 = DATA RECORD NOT FOUND DURING WRITE
;       8 = PARITY ERROR DURING WRITE
;       9 = LOST DATA DURING WRITE

;write a sector:
$WRITE: LD   C,A                ;save drive #
        XOR  A                  ;clear READ-flag

;dominant controller:
TASK:   LD   (RDFLAG),A         ;set/reset READ-flag
        LD   A,C                ;restore drive #
        CP   4                  ;legal drive # ?
        JR   C,TRKNO            ;jump if yes
        LD   A,1                ;error code 1 --> accu
        RET
TRKNO:  LD   (DRIVE),A          ;store drive #
        LD   (BUFFER),HL        ;store buffer pointer
        CALL GETDCT             ;get control table ptr
        LD   A,E                ;track # --> accu
        CP   (IX+4)             ;legal track # ?
        JR   C,SECNO            ;jump if yes
        LD   A,2                ;error code 2 --> accu
        RET
SECNO:  LD   (TRACK),A          ;store track #
        LD   A,B                ;sector # --> accu
        CP   (IX+3)             ;legal sector # ?
        JR   C,TRYNO            ;jump if yes
        LD   A,3                ;error code 3 --> accu
        RET
TRYNO:	LD   (SECTOR),A		;store sector #
        LD   A,(TRYS)           ;get # of err tries
        INC  A                  ;adjust it
        LD   (TRIES),A          ;store in counter

;set double density & disk size to 8 inch:
INIT:   LD   A,$DDDEN           ;set double density command
        LD   ($FDCMD),A         ;set density
        LD   A,$SET8            ;set 8 inch command
        LD   ($FDSIZ),A         ;set disk size

;actual I/O handler:
        LD   HL,0               ;clear wait counter
        LD   (WAIT),HL
        LD   HL,$FDCMD          ;FDC command/status reg
        LD   (HL),$FCINT        ;reset FDC
        LD   A,(HL)             ;get FDC status
        LD   (OLDSTAT),A        ;save drive status
        CALL SELECT             ;select drive
        BIT  0,(IX+1)           ;is drive initialized ?
        JR   NZ,TRKSEC          ;yes skip init process

;restore drive head:
        SET  0,(IX+1)           ;set init bit in DCT
        LD   A,255              ;max possible track # --> accu
        LD   (IX+5),A           ;make current track # to 255
        XOR  A                  ;desired track # = 0
        JR   TRKS10

;set track and sector:
TRKSEC: LD   A,(TRACK)          ;track # --> accu
        BIT  5,(IX)             ;disk density ?
        JR   Z,TRKSE1           ;jump if single density
        BIT  4,(IX)             ;density of first track ?
        JR   NZ,TRKSE1          ;jump if double density
        INC  A                  ;increment track #
TRKSE1: BIT  2,(IX)             ;step count from track to track
        JR   Z,TRKSE2           ;jump if step count = 1
        ADD  A,A                ;track # * 2
TRKSE2: CP   (IX+5)             ;same as current track
        JR   NZ,TRKSE8          ;jump to SEEK cmd if not
	LD   C,A		;save track #
        LD   A,$DDDEN           ;set double density command
        BIT  5,(IX)             ;density ?
        JR   NZ,TRKSE3          ;jump if double density
        DEC  A                  ;set single density
TRKSE3: LD   (HL),A             ;set density
        LD   A,$SET8            ;set 8 inch command
        BIT  7,(IX)             ;disk size ?
        JR   NZ,TRKSE4          ;jump if 8 inch
        RES  6,A                ;set 5 inch command
TRKSE4: LD   ($FDSIZ),A         ;set disk size
	LD   A,$FCINT		;force interrupt
	LD   (HL),A
	LD   A,C		;restore track #
        BIT  2,(IX)             ;step count from track to track
        JR   Z,TRKSE5           ;jump if step count = 1
        SRL  A                  ;track # / 2
TRKSE5: LD   ($FDTRK),A         ;adjust current track #
        LD   A,(SECTOR)         ;sector # --> accu
        BIT  6,(IX)             ;single or double sided ?
        JR   Z,TRKSE6           ;jump if single sided
        BIT  5,(IX+1)           ;sector numbering continued on backside ?
        JR   NZ,TRKSE6          ;jump if yes
        LD   B,(IX+3)           ; sectors/track --> reg. B
        SRL  B                  ;(sectors/track) / 2
        CP   B                  ;front or back side ?
        JR   C,TRKSE6           ;jump if front side
        SUB  B                  ;adjust sector #
TRKSE6: BIT  3,(IX)             ;test number of first sector
        JR   Z,TRKSE7           ;jump if zero
        INC  A                  ;else adjust sector #
TRKSE7: LD   ($FDSEC),A         ;store sector # in FDC reg
        JR   WAITEN             ;no SEEK
TRKSE8: LD   C,A                ;save track #
        SUB  (IX+5)             ;subtract current track #
        JR   NC,TRKSE9
        NEG                     ;make result positive
TRKSE9: LD   (WAIT),A           ;store calculated step count
        LD   A,C                ;restore track #
TRKS10: LD   ($FDDATA),A        ;store track # in FDC reg
        LD   (HL),$FCINT        ;reset FDC
        LD   A,(IX+5)           ;current track from DCT
        LD   ($FDTRK),A         ;FDC track register
        LD   A,(IX)
        AND  3                  ;step rate --> accu
        PUSH HL                 ;save ^FDC command reg
        LD   HL,(WAIT)          ;get step count
        JR   Z,TRKS12           ;jump if step rate = 3 msec
        LD   D,H                ;step count --> reg. DE
        LD   E,L
        LD   B,A                ;step rate --> reg. B
TRKS11: ADD  HL,DE              ;counter = step count * step rate
        DJNZ TRKS11
TRKS12: LD   B,H                ;counter --> reg. BC
        LD   C,L
        ADD  HL,HL              ;counter * 2
        ADD  HL,BC              ;counter * 3
        LD   BC,15              ;adjust value for delay loop --> reg. BC
        ADD  HL,BC              ;adjust wait counter
        LD   (WAIT),HL          ;store wait counter (msecs of passed time)
        POP  HL                 ;restore ^FDC command reg
        OR   $SEEK              ;or step rate with "seek" command
        LD   (HL),A             ;issue seek command
TRKS13: CALL SELECT             ;select drive
        BIT  7,(HL)             ;drive not ready ?
        JR   NZ,READ2           ;jump to error exit
        BIT  0,(HL)             ;seek done ?
        JR   NZ,TRKS13          ;no, loop
        LD   BC,2000            ;load delay counter
        CALL DELAY              ;15 msec head settle delay
        LD   A,($FDTRK)         ;get current track
        LD   (IX+5),A           ;store in drive's DCT
        JP   TRKSEC             ;check track # again

;motor on / head load time:
WAITEN: LD   A,(DRIVE)          ;get drive #
        PUSH HL                 ;save ^FDC status register
        LD   HL,OLDDRV          ;^previous drive # --> reg. HL
        CP   (HL)               ;new drive # same as old drive # ?
        LD   (HL),A             ;store new drive #
        LD   A,(OLDSTAT)        ;get old FDC status
        RLCA                    ;drive rotating already
        JR   C,WAITE2           ;jump to motor on delay loop, if not
        JR   Z,WAITE6           ;jump if same drive #
WAITE1: LD   HL,50              ;50 msec head load time
        JR   WAITE3
WAITE2: BIT  7,(IX)             ;8 inch drive
        JR   NZ,WAITE1          ;jump if 8 inch drive
        LD   HL,1000            ;1 sec delay after motor on
WAITE3: LD   BC,(WAIT)          ;msecs of passed time --> reg. BC
        OR   A                  ;clear carry bit
        SBC  HL,BC              ;calculate remaining wait time
        JR   C,WAITE6           ;no further time to wait
        JR   Z,WAITE6
WAITE5: LD   BC,137             ;1 msec delay
        CALL DELAY
        DEC  HL
        LD   A,H
        OR   L
        JR   NZ,WAITE5          ;loop HL times
WAITE6: POP  HL                 ;restore ^FDC status register
        LD   A,(HL)             ;get FDC status
        RLCA                    ;drive rotating already ?
        JR   C,READ2            ;jump if not

;init READ/WRITE:
TASK1:  CALL SELECT             ;select drive
        LD   DE,$FDDATA         ;data register
        LD   A,(RDFLAG)
        OR   A                  ;READ or WRITE ?
        JR   Z,WRITE1           ;jump if WRITE

;read sector:
        LD   (HL),$RDSEC        ;issue "read" command
        LD   BC,6               ;56 usec delay
        CALL DELAY
        LD   BC,(BUFFER)        ;get buffer pointer
READ1:  BIT  1,(HL)             ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  1,(HL)             ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  0,(HL)             ;full sector transferred ?
        JR   Z,STATUS           ;yes, go end process
        BIT  1,(HL)             ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  7,(HL)             ;drive not ready ?
        JR   Z,READ1            ;no loop
READ2:  LD   A,4                ;error code 4 --> accu
        RET
READ3:  LD   A,(DE)             ;read char
        LD   (BC),A             ;put buffer char
        INC  BC                 ;bump buffer pointer
        JR   READ1

;write sector:
WRITE1: LD   (HL),$WRSEC        ;issue "write" command
        LD   BC,6               ;56 usec delay
        CALL DELAY
        LD   BC,(BUFFER)        ;get buffer pointer
WRITE2: LD   A,(BC)             ;get buffer char
WRITE3: BIT  1,(HL)             ;data request ?
        JR   NZ,WRITE4          ;yes, get byte
        BIT  1,(HL)             ;data request ?
        JR   NZ,WRITE4          ;yes, get byte
        BIT  0,(HL)             ;full sector transferred ?
        JR   Z,STATUS           ;yes, go end process
        BIT  1,(HL)             ;data request ?
        JR   NZ,WRITE4          ;yes, get byte
        BIT  7,(HL)             ;drive not ready ?
        JR   Z,WRITE3           ;no loop
        JR   READ2              ;jump to error exit
WRITE4: LD   (DE),A             ;write char
        INC  BC                 ;bump buffer pointer
        JR   WRITE2             ;put next byte

;test controller status:
STATUS: LD   A,(HL)             ;get FDC status
        BIT  6,A                ;write protect ?
        JR   Z,STATU1           ;jump if not
        LD   A,5                ;error code 5 --> accu
        RET
STATU1: BIT  5,A                ;hardware fault (WRITE) ?
                                ;sector   prot  (READ ) ?
        JR   Z,STATU2           ;jump if no
        LD   A,6                ;error code 6 --> accu
        RET
STATU2: AND  1CH                ;any errors ?
        RET  Z
        RES  0,(IX+1)           ;clear init bit in DCT
        LD   HL,TRIES           ;get tries counter
        DEC  (HL)               ;dec value
        JP   NZ,INIT            ;try again, reseek
        BIT  4,A                ;data record not found ?
        JR   Z,STATU3
        LD   A,7                ;error code 7 --> accu
        RET
STATU3: BIT  3,A                ;parity error ?
        JR   Z,STATU4
        LD   A,8                ;error code 8 --> accu
        RET
STATU4: LD   A,9                ;error code 9 --> accu
        RET

;put drive control table pointer in "IX":
GETDCT: PUSH DE                 ;save reg. DE
        LD   H,0                ;drive # --> reg. HL
        LD   L,A
        ADD  A,A                ; drive # * 2
        ADD  A,L                ; drive # * 3
        ADD  A,A                ; drive # * 6
        LD   L,A                ;(drive # * 6) --> reg. HL
        LD   DE,DCT             ;get drive table start
        ADD  HL,DE              ;add offset and get ^DCT
        PUSH HL                 ;^DCT --> reg. IX
        POP  IX
        POP  DE                 ;restore reg. DE
        RET                     ;return to caller

;select drive:
SELECT: LD   A,(DRIVE)          ;get drive #
        OR   A                  ;drive # zero ?
        LD   B,A                ;drive # --> reg. B
        LD   A,1                ;select code for drive zero
        JR   Z,SELEC1           ;jump if drive # zero
        RLCA                    ;rotate left accu
        DJNZ $-1                ;decrement drive #
SELEC1: BIT  6,(IX)             ;single or double sided ?
        JR   Z,SELEC2           ;jump if single sided
        LD   C,A                ;save select code
        LD   A,(SECTOR)         ;sector #       --> accu
        LD   B,(IX+3)           ; sectors/track --> reg. B
        SRL  B                  ;(sectors/track) / 2
        CP   B                  ;front or back side ?
        LD   A,C                ;restore select code
        JR   C,SELEC2           ;jump if front side
        SET  4,A                ;set side select bit
SELEC2: LD   ($FDSEL),A         ;select drive and side
        RET                     ;return to caller

DRIVE:  DEFS 1                  ;drive
TRACK:  DEFS 1                  ;track
SECTOR: DEFS 1                  ;sector
BUFFER: DEFS 2                  ;I/O buffer
OLDDRV: DEFB 0FFH               ;contains # of previous selected disk
OLDSTAT:DEFS 1			;contains drive status
TRIES:  DEFS 1                  ;counter for counting # of times to try I/O
                                ;after error occurs
RDFLAG: DEFS 1                  ;flag (0 = WRITE, 0FFH = READ)
WAIT:   DEFS 2                  ;counter for passed time


*EJECT
;*******************
;*  $ G E T T I M  *
;*******************

;entry: HL = address of a 21 bytes long buffer, containing on exit
;	     time & date in the form WWW MM/DD/YY HH:MM:SS

;		  WWW = weekday
;		   MM = month
;		   DD = day
;		   YY = year
;		   HH = hours
;		   MM = minutes
;		   SS = seconds		 

;get time & date in ASCII format:
$GETTIM:PUSH HL			;save ^user buffer
        CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer --> reg. IX

	LD   A,(IX+6)		;weekday      --> accu
	AND  7			;make binary
	LD   H,0		;weekday      --> reg. HL			
	LD   L,A
	LD   DE,DAYTAB		;base of weekday table --> reg. DE
	ADD  A,A		;calc table entry
	ADD  A,L
	LD   L,A
	ADD  HL,DE
	LD   DE,ATIMBUF		;^ASCII buffer 	       --> reg. DE	
	LD   BC,3		;length of table entry --> reg. BC
	LDIR			;move weekday into ASCII buffer
	INC  DE			;bump buffer ptr over space

	LD   A,(IX+2)		;month (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+3)		;month (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX+4)		;day (tenths) --> accu
	AND  '3'		;mask leapyear bit
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+5)		;day (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX)		;year (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+1)		;year (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over space		

	LD   A,(IX+7)		;hours (tenths) --> accu
	AND  '3'		;mask format bit 
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+8)		;hours (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon	

	LD   A,(IX+9)		;minutes (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+10)		;minutes (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon	

	LD   A,(IX+11)		;seconds (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+12)		;seconds (ones)   --> accu
	LD   (DE),A		;store them

	POP  DE			;restore ^user buffer
	LD   HL,ATIMBUF		;^(time & date buffer) 	      --> reg. HL
	LD   B,21		;length of time & date string --> reg. BC
	XOR  A			;function = read system memory
	JP   $XMOVE		;transfer time & date string and return

;read time & date from clock chip:
GETTIM: LD   HL,TIMBUF		;^temp buffer --> reg. HL
        CALL RTCFREE		;wait for read RTC
	LD   A,40H
	OUT  (0E1H),A		;turn on read mode
	LD   DE,10CFH		;register address displacement --> reg. D
				;register address	       --> reg. E
	LD   B,13		;byte counter 		       --> reg. B
GETTI1:	LD   A,E		;read date & time
	OUT  (0E0H),A
	SUB  D
	LD   E,A
	IN   A,(0E0H)	 	
	AND  0FH		;mask undesired bits
	OR   '0'		;make ASCII digit
	LD   (HL),A
	INC  HL			;bump ^(time & date)
	DJNZ GETTI1
	RET			;return to caller

DAYTAB:	DEFM 'SatSunMonTueWedThuFri'
TIMBUF:	DEFS 13
ATIMBUF:DEFM 'WWW MM/DD/YY HH:MM:SS'


*EJECT
;*******************
;*  $ S E T T I M  *
;*******************

;entry:  A = weekday (0 - 6, 0 = Sat)
;	 B = month   (MM)
;        D = hours   (HH)
;	 E = minutes (MM)
;	 H = day     (DD)
;	 L = year    (YY)


;set time and date in binary format:
$SETTIM:LD   IX,TIMBUF		;^temp buffer --> reg. IX
	LD   (IX+6),A		;weekday      --> buffer
	LD   A,L		;year (ones)  --> accu
	AND  0FH		;mask it
	LD   (IX+1),A		;year (ones)  --> buffer
	SRL  L			;shift reg. E four bits right
	SRL  L
	SRL  L
	SRL  L
	LD   (IX),L		;year  (tenths) --> buffer
	LD   A,B		;month (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+3),A		;month (ones)   --> buffer
	SRL  B			;shift reg. B four bits right
	SRL  B
	SRL  B
	SRL  B
	LD   (IX+2),B		;month (tenths) --> buffer
	LD   A,H		;day   (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+5),A		;day   (ones)   --> buffer
	SRL  H			;shift reg. D four bits right
	SRL  H
	SRL  H
	SRL  H
	LD   (IX+4),H		;day   (tenths) --> buffer
	LD   A,D		;hours (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+8),A		;hours (ones)	--> buffer
	SRL  D			;shift reg. H four bits right
	SRL  D
	SRL  D
	SRL  D
	LD   (IX+7),D		;hours   (tenths) --> buffer
	LD   A,E		;minutes (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+10),A		;minutes (ones)   --> buffer
	SRL  E			;shift reg. L four bits right
	SRL  E
	SRL  E
	SRL  E
	LD   (IX+9),E		;minutes (tenths) --> buffer
	LD   (IX+11),0		;seconds (tenths) --> buffer
	LD   (IX+12),0		;seconds (ones)   --> buffer
	LD   HL,TIMBUF		;^buffer	  --> reg. HL
        CALL RTCFREE		;wait for read RTC
	LD   DE,10D0H		;register address displacement --> reg. D
				;register address	       --> reg. E
	LD   B,13		;byte counter 		       --> reg. B
SETTI1: XOR  A			;set date & time
	OUT  (0E1H),A
       	LD   A,E
	SUB  D
	LD   E,A
	OR   (HL)
	OUT  (0E0H),A
	INC  HL			;bump ^(time & date)
	LD   A,80H
	OUT  (0E1H),A
	DJNZ SETTI1
	JP   GETTIM		;adjust clock chip and return to caller

RTCFREE:LD   A,(37E0H)		;interrogate interrupts
	OR   A
	JP   M,RTCFREE
RTCFR1:	LD   A,(37E0H)
	OR   A
	JP   P,RTCFR1
	RET	


*EJECT
;*****************
;*  $ X M O V E  *
;*****************

;entry:  A  = 0 read  system memory
;	   <> 0 write system meory
;	 B  =   byte count
;      	DE  =   destination address
;	HL  =   source      address

;read/write system memory:
$XMOVE:	LD   IX,(XMOVE)		;address of $XMOVE routine --> reg. IX
	JP   (IX)		;transfer user/system buffer and return

XMOVE	EQU  0FFF8H


*EJECT
;Winchester disk driver:

;WDC registers:
$DATA  	EQU  48H  		;data register	
$WPC    EQU  49H  		;write precomp register
$ERROR  EQU  49H  		;error register
$SECNO 	EQU  4BH  		;sector number register
$CYLLO  EQU  4CH  		;cylinder low register
$CYLHI  EQU  4DH  		;cylinder high register
$SDH	EQU  4EH		;size/drive/head register
$COMND  EQU  4FH		;command register
$STATUS	EQU  4FH		;status register

;WDC commands:
$REST   EQU  10H		;restore
$$READ 	EQU  20H		;read sector
$$WRITE	EQU  30H		;write sector
$DSEL	EQU  98H		;deselect drive


;*****************
;*  $ R E A D W  *
;*****************

;entry: A  = drive  number
;       B  = sector number
;       DE = track  number
;       HL = buffer pointer

;exit : A = error code
;	0 = NO ERROR
;	1 = ILLEGAL DRIVE #
;	2 = TRACK # TOO HIGH
;	3 = SECTOR # TOO HIGH
;	4 = DEVICE NOT AVAILABLE
;	7 = DATA RECORD NOT FOUND DURING READ
;	8 = PARITY ERROR DURING READ

;read a sector:
$READW:	LD   C,A		;save drive number
       	LD   A,0FFH
	JR   TASKW		;read sector


*EJECT
;*****************
;*  $ W R I T W  *
;*****************

;entry: A  = drive  number
;       B  = sector number
;       DE = track  number
;       HL = buffer pointer

;exit : A = error code
;	0 = NO ERROR
;	1 = ILLEGAL DRIVE #
;	2 = TRACK # TOO HIGH
;	3 = SECTOR # TOO HIGH
;	4 = DEVICE NOT AVAILABLE
;	6 = WRITE FAULT ON DISK DRIVE
;	7 = DATA RECORD NOT FOUND DURING WRITE
;	8 = PARITY ERROR DURING WRITE

;write a sector:
$WRITW:	LD   C,A		;save drive number
       	XOR  A


;dominant controller:
TASKW:	LD   (RDFLAG),A		;set/cear READ-flag
        LD   A,C      		;restore drive #
     	CP   3			;legal drive # ?
	JR   C,TRKNOW		;jump if yes
	LD   A,1		;error code 1 --> accu
	RET
TRKNOW:	LD   (DRIVE),A		;store drive #
	LD   (BUFFER),HL	;store buffer pointer
       	CALL GETWCT		;get control table ptr
	LD   A,D        	;track # (MSB) --> accu
      	CP   (IX+6)		;legal track # ?
	JR   C,SECNOW		;jump if yes
	JR   Z,CPLOW		;compare LSB's
TRKERR:	LD   A,2		;error code 2 --> accu
	RET
CPLOW:	LD   A,E      		;track (LSB) --> accu
	CP   (IX+5)		;legal track # ?
	JR   NC,TRKERR		;jump if not
SECNOW:	LD   A,B       		;sector # --> accu
	CP   (IX+4)		;legal sector # ?
	JR   C,INITW		;jump if yes
	LD   A,3		;error code 3 --> accu
	RET

;actual I/O handler:
INITW:	LD   (SECTOR),A		;store sector #
	LD   A,D		;track # (MSB) --> accu
	LD   C,E		;track # (LSB) --> reg. C
	LD   D,0   		;clear MSB of divisor
    	LD   E,(IX)  		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	LD   H,D 		;clear accumulator
	LD   L,D
	LD   B,16		;init counter
LOOP16: RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
	SBC  HL,DE		;subtract divisor
	JR   NC,$+3		;subtraction ok
	ADD  HL,DE		;restore accumulator
     	CCF			;complement carry flag
    	DJNZ LOOP16             ;counter = 0 ?
     	RL   C			;get last result bit
	RLA
	LD   B,A		;now reg. BC contains cylinder #
				;and reg.  L contains surface  #
	LD   A,(DRIVE)		;drive # --> accu
	ADD  A,A		;shift drive # 3 bits left
	ADD  A,A
	ADD  A,A
	ADD  A,L		;add surface #
	LD   L,A		;and save it
	LD   A,(IX+1)		;get sector length bits
	RRA
	AND  60H		;mask sector length bits
	ADD  A,L		;add surface # and drive #
	OR   80H		;set ECC error correction bit
	LD   L,A		;save drive select bits
	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,TRKSEW 		;yes, skip init process

;restore drive heads:
RESTOW:	IN   A,($STATUS)	;read WDC status
	AND  0C0H		;mask it
	CP   40H		;busy ?
	JR   NZ,RESTOW		;wait `til WDC is ready to accept a command
	OUT  ($SDH),A		;select drive
	LD   A,(IX)		;get step rate bits
	AND  0FH		;mask them
	OR   $REST		;or with "restore" command
	OUT  ($COMND),A		;restore drive heads
RESTO1: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;restore done ?
	JR   NZ,RESTO1 		;no, loop
      	SET  0,(IX+1)		;set init bit in WCT

;set track and sector:
TRKSEW: LD   A,(IX+2)		;set starting track for write precomp
	OUT  ($WPC),A
        LD   A,(SECTOR)		;sector # --> accu
	BIT  4,(IX)		;test number of first sector
	JR   Z,TRKSW1		;jump if zero
	INC  A			;else adjust sector #
TRKSW1:	OUT  ($SECNO),A         ;set sector #
	LD   A,C     		;set cylinder # (LSB)
	OUT  ($CYLLO),A
	LD   A,B                ;set cylinder # (MSB)
	OUT  ($CYLHI),A
	LD   A,L		;restore drive select bits
	OUT  ($SDH),A		;select drive

;init READ/WRITE:
	LD   HL,(BUFFER)	;get buffer pointer
	LD   E,(IX+1)		;get sector length bits
	LD   B,6
	SRL  E
	DJNZ $-2
	LD   C,$DATA		;init byte counter and data port number
	LD   A,(RDFLAG)		;READ or WRITE
	OR   A
	JR   Z,WRITW1		;jump if WRITE

;read sector:
      	LD   A,$$READ     	;issue "read" command
	OUT  ($COMND),A
READW1: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;read done ?
	JR   NZ,READW1  	;no, loop
	LD   A,E		;sector length bits --> accu
	OR   A   		;test sector length bits
	JR   Z,R256		;read 256 bytes
	DEC  A
	JR   Z,R512             ;read 512 bytes
        DEC  A
      	JR   Z,R1024		;read 1024 bytes
	LD   B,128 		;load new byte counter
      	JR   R256    		;read 128 bytes
R1024:  INIR		        ;transfer sector
	INIR
R512:   INIR
R256: 	INIR
        JR   WDCSTAT   		;read WDC status

;write sector:
WRITW1: LD   A,$$WRITE    	;issue "write" command
	OUT  ($COMND),A
	LD   A,E		;sector length bits --> accu
	OR   A   		;test sector length bits
	JR   Z,W256		;write 256 bytes
	DEC  A
	JR   Z,W512             ;write 512 bytes
        DEC  A
      	JR   Z,W1024		;write 1024 bytes
	LD   B,128 		;load new byte counter
      	JR   W256    		;write 128 bytes
W1024:  OTIR		        ;transfer sector
	OTIR
W512:   OTIR
W256: 	OTIR
WRITW2: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;write done ?
	JR   NZ,WRITW2   	;no, loop

;test controller status:
WDCSTAT:IN   A,($STATUS)	;get WDC status
	AND  1  		;any errors ?
	LD   C,A		;"no error" code --> reg. C
	JR   Z,DSEL             ;return if not
	IN   A,($ERROR)	        ;read WDC error register
	LD   L,A		;save error code
	AND  13H		;data record not found ?
       	JR   Z,WDCST1          
	LD   C,7 		;error code 7 --> reg. C
	JR   DSEL
WDCST1: LD   A,L		;restore error code
	AND  60H		;parity error ?
	JR   Z,WDCST2
	LD   C,8		;error code 8 --> reg. C
	JR   DSEL
WDCST2:	BIT  2,L                ;aborted command ?
        JR   Z,WDCST3
	LD   C,6 		;error code 6 --> reg. C
	JR   DSEL
WDCST3: IN   A,($STATUS)	;read status again
	BIT  6,A    		;drive not ready ?
        LD   C,4		;error code 4 --> reg. C
	JR   NZ,DSEL
       	LD   C,6		;error code 6 --> reg. C

DSEL:	LD   A,$DSEL 		;deselect drive
	OUT  ($SDH),A
	LD   A,C		;error code --> accu
	RET			;return to caller

;put drive control table pointer in "IX":
GETWCT: PUSH DE			;save reg. DE
	LD   H,0		;drive # --> reg. HL	
	LD   L,A		
	ADD  A,A		;drive # * 2
	ADD  A,L		;drive # * 3
	ADD  A,A		;drive # * 6
	ADD  A,L  		;drive # * 7	