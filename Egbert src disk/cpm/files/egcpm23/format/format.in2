(********************************************************************)
(*  FORMAT.IN2 : Gesamtliste drucken, Uebersicht, Daten anzeigen    *)
(********************************************************************)

(* 310391 Tilmann Reh *)

(* Erstellen einer sortierten Index/Namensliste fuer Ausgaben *)

type SortListTyp = record
                     nummer : integer;
                     name   : CharArray20;
                     end;
     SortListe   = array[1..1000] of SortListTyp;
var  SortListPtr : ^SortListe;
     SortBuf     : SortListTyp;
     Sortiert    : boolean;
     ListSize,Nr : integer;
     vs          : CharArray20;

{$A-}
procedure QuickSortList(anfang,ende:integer);
var li,re : integer;
begin
  li:=anfang; re:=ende;
  vs:=SortListPtr^[(li+re) shr 1].Name;
  repeat
    while SortListPtr^[li].Name<vs do li:=succ(li);
    while SortListPtr^[re].Name>vs do re:=pred(re);
    if li<=re then begin
      SortBuf:=SortListPtr^[li];
      SortListPtr^[li]:=SortListPtr^[re];
      SortListPtr^[re]:=SortBuf;
      li:=succ(li); re:=pred(re);
      end;
  until li>re;
  if re>anfang then QuickSortList(anfang,re);
  if li<ende then QuickSortList(li,ende);
  end;
{$A+}

procedure Sortieren;
var up : CharArray20;
    j  : byte;
begin
  seek(Datei,0);
  ListSize:=filesize(Datei) shl 7;
  Sortiert:=maxavail>=ListSize;
  if Sortiert then begin
    getmem(SortListPtr,ListSize);
    for xi:=1 to filesize(Datei) do begin
      blockread(Datei,AktForm,1);
      SortListPtr^[xi].Nummer:=xi;
      up:=AktForm.Name;
      for j:=1 to 20 do up[j]:=upcase(up[j]);
      SortListPtr^[xi].Name:=up;
      end;
    QuickSortList(1,filesize(Datei));
    end;
  end;

procedure FreeSortMemory;
begin
  freemem(SortListPtr,ListSize);
  end;

(*--------- LISTE AUF BILDSCHIRM -----------*)

procedure List;
label ExitList;
var Zeile,Spalte : byte;
begin
  clrscr; Zeile:=2; Spalte:=0;
  Sortieren;
  for xi:=1 to filesize(Datei) do begin
    gotoxy(succ(27*Spalte),Zeile);
    if Sortiert then Nr:=SortListPtr^[xi].Nummer else Nr:=xi;
    seek(Datei,pred(Nr));
    blockread(Datei,AktForm,1);
    write('<',Nr:2,'> ',AktForm.Name);
    Zeile:=succ(Zeile);
    if Zeile=22 then begin Zeile:=2; Spalte:=succ(Spalte); end;
    if (Spalte=3) then if not eof(Datei) then begin
      gotoxy(1,23); write('weiter mit RETURN, Abbruch mit ESC ');
      repeat read(kbd,xc) until xc in [^M,#27];
      if ch=#27 then goto ExitList;
      clrscr; Spalte:=0;
      end;
    end;
  gotoxy(1,23);
  WaitTaste;
ExitList: if Sortiert then FreeSortMemory;
  end;

(*--------- GESAMTLISTE AUSDRUCKEN ---------*)

procedure PrintOut;
const Den  : array[1..4,1..6] of char = ('    FM','   MFM','  ECMA','    HD');
      Mode : array[0..3,1..5] of char = ('   - ','  Sec','  Trk','  Hlf');
      X    : array[0..1,1..3] of char = ('  -','  X');

  (*--- Prozedur PrintDateTime liest Uhr und druckt Datum und Uhrzeit ---*)

  procedure PrintDateTime;
  const MonAnf : array[1..12] of integer
               = (0,31,59,90,120,151,181,212,243,273,304,334);
  var Min      : byte;       (* Diese Reihen-    ** Do NOT CHANGE  *)
      Hour     : byte;       (* folge auf KEINEN ** order of these *)
      Datum    : integer;    (* FALL aendern!!!  ** variables!!!   *)
      Jahr     : byte;
  begin
    xi:=BDOS(105,addr(Datum));
    xi:=365; Jahr:=78;
    while Datum>xi do begin
      Datum:=Datum-xi; Jahr:=succ(Jahr);
      if Jahr and 3=0 then xi:=366 else xi:=365;
      end;
    if (Jahr and 3=0) and (Datum>59) then Datum:=pred(Datum);
    xi:=12; while Datum<=MonAnf[xi] do xi:=pred(xi);
    writeln(lst,Datum-MonAnf[xi],'.',xi,'.',Jahr,'  ',
                Hour shr 4,Hour and 15,':',Min shr 4,Min and 15);
    end;

begin
  write(^m^j^m^j^m^j);
  Sortiert:=InputBoolean('Liste alphabetisch sortieren');
  if Sortiert then Sortieren;
  write(lst,'':15,'Gesamtliste Diskettenformate vom '); PrintDateTime; writeln(lst);
  write(lst,'':15,'Nr. Name                 Siz Trk SecGr Sec Dense SMod Hd0 Hd1 Psk Iv Ms TT  Skw Bls   Dir Off'^M^J);
  write(lst,'':15); for xi:=1 to 93 do write(lst,'='); writeln(lst);
  for xi:=1 to filesize(Datei) do begin
    if Sortiert then Nr:=SortListPtr^[xi].Nummer else Nr:=xi;
    seek(Datei,pred(Nr));
    blockread(Datei,AktForm,1);
    with AktForm do begin
      write(lst, Nr:17,'  ', Name, DiskSize:3, '"', Spuren:4,
                 Zpot[Sec_Shift+7]:6,Sec_Zahl:4, Den[Density],
                 Mode[Modus], Head[0]:4);
      if Modus>0 then write(lst,Head[1]:4) else write(lst,'   -');
      write(lst, Phys_Skew:4, X[Invers], X[Multi]);
      if TTrans=0 then write(lst,'  -') else write(lst,TTrans:3);
      writeln(lst, Skew:5, Zpot[BlockSize-3]:4,
                   Directory*Zpot[BlockSize+2]:6, Offset:4);
      end;
    end;
  if Sortiert then FreeSortMemory;
  end;

(*--------- FORMATDATEN ANZEIGEN -----------*)

procedure DisplaySectorList(ST:SkewTableTyp; Secs,Modus:byte);
var n : byte;
begin
  write('Sektorfolge: ');
  if Modus=1 then Secs:=Secs+Secs;
  for xi:=1 to Secs do begin
    n:=ST[xi];
    if (n<$80) or (Modus<>1) then write(n) else write('B',n and $7F);
    write(' ');
    end;
  writeln;
  end;

procedure DisplayPhysicalFormat(var f:Format; ShowModus:boolean);
begin
  with f do begin
    write(^M^J'Diskettengr|~e: ',DiskSize,' Zoll, ',Spuren,' Spuren (Tracks)'^M^J);
    write(Sec_Zahl,' Sektoren je ',Zpot[Sec_Shift+7],' Byte, ');
    case Density of
      1 : write('Single Density (FM)'^M^J);
      2 : write('Double Density (MFM)'^M^J);
      3 : write('Single/Double Density (ECMA)'^M^J);
      4 : write('High Density (HD)'^M^J);
      end;
    case Modus of
      0 : write('1 Seite');
      1 : begin write('2 Seiten'); if ShowModus then write(', Sektor}berlauf'); end;
      2 : write('2 Seiten, Spur}berlauf');
      3 : write('2 Seiten, Halbspur}berlauf');
      end;
    write(', Kopfnummer');
    if Modus=0 then write(' ',Head[0]) else write('n ',Head[0],'/',Head[1]);
    writeln(^M^J'physikalischer Skew ',Phys_Skew);
    end;
  end;

procedure Show;
begin
  InputFormatNumber;
  with AktForm do begin
    DisplayPhysicalFormat(AktForm,true);
    if boolean(Invers) then write('Invertierte Aufzeichnung'^M^J);
    if boolean(Multi) then write('Multisector-f{hig'^M^J);
    if TTrans>0 then writeln('Spur}bersetzung Nr. ',TTrans);
    writeln;
    if Skew>0 then writeln('logischer Skew ',Skew)
    else DisplaySectorList(SkewTable,Sec_Zahl,Modus);
    write('Blockgr|~e ',Zpot[BlockSize-3],'k'^M^J);
    write(Directory*Zpot[BlockSize+2],' Directory-Eintr{ge'^M^J);
    write(Offset,' reservierte Spur(en)'^M^J);
    end;
  writeln; WaitTaste;
  end;
