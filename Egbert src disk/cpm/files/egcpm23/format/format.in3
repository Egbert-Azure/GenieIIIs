(********************************************************************)
(*  FORMAT.IN3 : Formatdaten Editieren                              *)
(********************************************************************)

(* 120191 Tilmann Reh *)

procedure Edit(Nr:integer);
const Fact     : array[1..4] of byte = (1,2,2,4);
      IdamGap4 : array[1..4] of byte = (113,146,146,146);
      IDM      : array[1..4] of byte = (33,62,62,62);

var   n,gmin,bpt,bps,den : integer;
      alt                : boolean;

  procedure Select(text:WorkString; term:ByteSet; var zahl:byte);
  var altzahl : byte;
  begin
    altzahl:=zahl;
    repeat
      write(text:WL,' ');
      if alt then write('(',altzahl:2,') ');
      readln(zahl);
    until zahl in term;
    end;

begin
  xi:=filesize(Datei); alt:=Nr<xi;
  if alt then begin
    seek(Datei,Nr); blockread(Datei,AktForm,1);
    writeln('Format-Name: ',AktForm.Name); end
  else begin
    Nr:=xi; fillchar(AktForm,sizeof(AktForm),0);
    fillchar(AktForm.Name,sizeof(AktForm.Name),' '); end;
  with AktForm do begin
    write('Name des Formats (RETURN=}bernehmen):':WL,' '); readln(xs);
    if length(xs)>0 then StringToArray(xs,Name);
    select('Diskettengr|~e (3/5/8"):',[3,5,8],DiskSize);
    select('Spurzahl:',[25..85],Spuren);
    select('Density: 1=FM, 2=MFM, 3=FM/MFM, 4=HD:',[1..4],Density);
    select('Sektorgr|~e: 0=128, 1=256, 2=512, 3=1024 Byte:',[0..3],Sec_Shift);
    if (DiskSize=8) then bpt:=5208 else bpt:=3125;       (* Byte/Track FM   *)
    den:=Density;
    if (DiskSize=5) and (den=4) then begin den:=2; bpt:=5208; end;
    bpt:=Fact[den]*bpt-IdamGap4[den]-bpt div 50;         (* Den, IDAM, GAP4 *)
    bps:=Zpot[Sec_Shift+7]+IDM[den];                     (* Byte/Sector     *)
    gmin:=succ(bps div 50); if gmin<5 then gmin:=5;      (* GAP3 min : 2%   *)
    select('Phys. Sektoren pro Spur (einseitig):',
           [1..bpt div (bps+gmin)],Sec_Zahl);
    xi:=(bpt div Sec_Zahl - bps + gmin) shr 1;           (* GAP3 Mittelwert *)
    if xi>255 then Gap3:=255 else Gap3:=xi;
    select(']berlauf: 0=None, 1=Sektor, 2=Spur, 3=Halbspur:',[0..3],Modus);
    select('Kopfnummer Seite 0:',[0..255],Head[0]);
    if Modus>0 then select('Kopfnummer Seite 1:',[0..255],Head[1]);
    select('Physikalischer Skew:',[1..pred(Sec_Zahl)],Phys_Skew);
    select('Aufzeichnung: 0=Normal, 1=Invers:',[0,1],Invers);
    select('Multisector-f{hig: 0=Nein, 1=Ja:',[0,1],Multi);
    select('Spur}bersetzung Nr.: 1..4, 0=keine:',[0..4],TTrans);
    select('logischer Skew (0=Tabelle):',[0..pred(Sec_Zahl)],Skew);
    select('Blockgr|~e: 3=1k, 4=2k, 5=4k, 6=8k, 7=16k:',[3..7],BlockSize);
    str(Zpot[BlockSize+2],xs);
    select('Directory-Blocks (je '+xs+' Eintr.):',[1..16],Directory);
    select('Anzahl Offset-Spuren:',[0..pred(Spuren)],Offset);
    if Skew>0 then begin  (* SkewTabelle berechnen *)
      xi:=Sec_Zahl div ggt(Sec_Zahl,Skew);
      for n:=0 to pred(Sec_Zahl) do
        SkewTable[succ(n)]:=succ((n mod xi * Skew + n div xi) mod Sec_Zahl);
      if Modus=1 then for xi:=1 to Sec_Zahl do
        SkewTable[xi+Sec_Zahl]:=SkewTable[xi] or $80;
      end
    else begin  (* SkewTabelle eingeben *)
      n:=Sec_Zahl; if Modus=1 then n:=n+n;
      if alt then DisplaySectorList(SkewTable,Sec_Zahl,Modus);
      writeln('Neue Tabelle (RETURN=Ende):');
      xi:=1; repeat
        readln(xs);
        if length(xs)>0 then
          if upcase(xs[1])='B' then begin
            val(copy(xs,2,WL),bps,bpt);
            SkewTable[xi]:=bps or $80;
            end
          else begin val(xs,bps,bpt); SkewTable[xi]:=bps; end;
        xi:=succ(xi);
      until (xi>n) or (length(xs)=0);
      end;
    end;
  seek(Datei,Nr);
  blockwrite(Datei,AktForm,1);
  close(Datei); reset(Datei);
  end;

procedure Editieren;
begin
  clrscr;
  xi:=succ(filesize(datei));   (* <RETURN> = neues Format *)
  write('Format-Nummer (RETURN=Neu) ? '); readln(xi);
  Edit(pred(xi));
  end;
