;
; XRUN -- eXtended RUN
;
; Version:	2.2
; Revised:	08.04.90
; by:		Olaf Krumnow
;
; erweiterter Kommandoprozessor
; sucht entlang des Pfades nach Dateien mit dem Programmnamen, aber
; beliebiges Typs. Der gefundene Dateityp wird mit einer installierten
; Liste verglichen. Falls vorhanden, wird das dort installierte Kommando
; in die Kommandozeile geschrieben und damit ausgefuehrt.
; Bei komplettem Misserfolg wird ein Defaultkommando gestartet (sofern installiert),
; um auf einen weiteren Kommandoprozessor verzweigen zu koennen, z.B. ARUNZ, LX
;
;
; Revision History
;
vers		equ	22
; Version 2.2
; Olaf Krumnow  08.04.90
; added command $H for default disk/user
; fixed bug that prevent detecting filetypes with
; attributes set
;
;vers		equ	21
; Version 2.1
; Olaf Krumnow 16.02.90
; added cmdline parameters for adding information
; about the file, passing original cmdlines etc.
; $D = drive of file
; $U = user
; $B = drive and user (DU:)
; $F = filename.filetype
; $N = filename
; $T = filetype
; $! = full cmdline including cmdverb
; $* = cmdline excluding cmdverb (cmdtail)
;
;vers		equ	20
; Version 2.0
; Olaf Krumnow 15.02.90
; totally rewritten
; added ZCPR33 features
;
; Original Version
; Herbert zur Nedden 1989
;
;
; EQUATES
;

GERMAN		equ	1		; GERMAN language. Set to 0 for ENGLISH

FCB		equ	005ch		; default FCB addr
DEFCMD		equ	0080h		; CP/M default cmdline
CMDLEN		equ	30		; length for one installed cmd
SFIRST		equ	17		; BDOS-fct 'search for first'
SNEXT		equ	18		; BDOS-fct 'search for next'

;
; MACROS
;
Cmd		macro	s1,s2
		local	l1,l2
		if	NUL s2		;; is there a second parameter?
l1:		db	'&s1'		;; no, then first param is commandline
		ds	CMDLEN-($-l1),0	;; add NULLs up to CMDLEN chars
		else			;; two parameters
l1:		db	'&s1'		;; first param is filetype
		ds	3-($-l1),' '	;; add with spaces up to three chars
l2:		db	'&s2'		;; second param is commandline
		ds	CMDLEN-($-l2),0	;; add NULLs up to CMDLEN chars
		endif
		endm

;
; EXTERNALS
;
; - from Z3LIB
;
		.request z3lib
		ext	z3init, getcl1, getpath
		ext	putcl, putcst, getquiet
;
; - from SYSLIB
;
		.request syslib
		ext	initfcb, setdma, mafdc
		ext	print, pstr, crlf
		ext	retud, logud, bdos
		ext	sksp, sknsp


		cseg

; This code has been modified as suggested by Charles Irvine so that it will
; function correctly with interrupts enabled.

; This is header code that can be used at the beginning of a type-3-environment
; program so that it will abort with an error message when not loaded to the
; correct address (such as when a user tries to run it under CP/M or Z30).

Entry:
		jr	Start0			; Must use relative jump
		db	0			; Filler
		db	'Z3ENV',3		; Type-3 environment
Z3Env:		dw	0			; Filled in by Z33
		dw	Entry			; Intended load address

Start0:
		ld	hl,0			; Point to warmboot entry
		ld	a,(hl)			; Save the byte there
		di				; Protect against interrupts
		ld	(hl),0c9h		; Replace warmboot with a return opcode
		rst	0			; Call address 0, pushing RETADDR onto stack
RetAddr:
		ld	(hl),a			; Restore byte at 0
		dec	sp			; Get stack pointer to point
		dec	sp			; ..to the value of RETADDR
		pop	hl			; Get it into HL and restore stack
		ei				; We can allow interrupts again
		ld	de,RetAddr		; This is where we should be
		xor	a			; Clear carry flag
		push	hl			; Save address again
		sbc	hl,de			; Subtract -- we should have 0 now
		pop	hl			; Restore value of RETADDR
		jp	z,start			; If addresses matched, begin real code

		ld	de,NotZ33Msg-RetAddr	; Offset to message
		add	hl,de
		ex	de,hl			; Switch pointer to message into DE
		ld	c,9
		jp	0005h			; Return via BDOS print string function

NotZ33Msg:
	if GERMAN
		db	'Kein ZCPR3.3 oder hoeher.$'
	else
		db	'Not Z33+$'		; Abort message if not Z33-compatible
	endif

		;
		; installation area
		;
		;
		; internal QUIET flag
		; do logical OR with ZCPR3 QUIET flag to get
		; program quiet status
		; set to zero for not quiet
		; set to 0FFH for quiet
		;
		db	'[QUIET>'
QuietIns:	db	0
		
		;
		; root only
		; set to zero, to use full path
		; set to 0FFH, to use root of path only
		;
		db	'[ROOTONLY>'
RootOnly:	db	0
		
		;
		; internal path
		; set to zero to use the external path
		; set to 0FFH to use the internal path
		;
		db	'[USEINTPATH>'
UseIntPath:	db	0
		
		;
		; definition of internal path
		; use '$' for logged drive or user
		; terminate path with NULL
		;
		db	'[INTPATH>'
IntPath:	db	'$$'			; current d/u
		db	0			; end of path
		ds	10,0			; space for 5 more
		
		;
		; table of extensions and commands
		;
		db	'[EXTTABLE>'
ExtTable:	Cmd	<ZEX>,<ZEX $!>
		Cmd	<SUB>,<SUB $!>
		Cmd	<MAC>,<EM $!>
		Cmd	<PAS>,<EP $!>
		Cmd	<LBR>,<L -O $B$F $*>
		Cmd	<CHN>,<CHAINDU $B$!>
		
		db	0			; end of table
		ds	(CMDLEN+3)*10		; space for some more
		
		;
		; default command line to be executed
		; if no matching filetype is found
		;
		db	'[DEFCMD>'
DefCmdLine:	Cmd	<LX / $!>		; let's try LX for success
		
		;
		; end of installation area
		;
		;
		; start of program
		;
Start:
		ld	hl,(z3env)		; get env addr
		call	z3init			; init Z3LIB
		
		;
		; examine quiet status
		;
		call	getquiet		; read ZCPR3 quiet status
		ld	b,a			; store in B
		ld	a,(QuietIns)		; get installed value
		or	b			; if one of them is quiet, be quiet
		ld	(QuietFlag),a
		
		;
		; print banner (if not quiet)
		;
		jr	nz,m01			; skip if quiet
		call	print
		db	'XRUN '
		db	[vers / 10] + '0'
		db	'.'
		db	[vers mod 10] + '0'
	if GERMAN
		db	' -- erweiterter Kommandoprozessor'
	else
		db	' -- Extended Commandprocessor'
	endif
		db	13,10,0
		
m01:		;
		; test for help
		;
		ld	de,(FCB+1)		; first two chars of first param
		ld	hl,'//'			; string to test for
		or	a			;; clr cy
		sbc	hl,de			; test
		jr	z,Help
		ld	hl,'  '			; are there any parameters?
		or	a
		sbc	hl,de
		jr	nz,m0			; no, help poor fellow
		
Help:
		; give help
		;
		call	print
		db	13,10
	if GERMAN
		db	'Aufruf: XRUN kommandozeile'
	else
		db	'Usage: XRUN cmdline'
	endif
		db	13,10,0
		ret				; return to CCP
		
m0:		;
		; check for needed ZCPR33 abilities
		;
		; - Multiple Command Line
		;
		call	getcl1			; get addr of MCL
		ld	a,h
		or	l			; not available, if NULL
		jr	nz,m1
		
		call	print			; print always
	if GERMAN
		db	7,'Brauche Mehr-Kommando-Zeile',0
	else
		db	7,'Need Multiple Command Line',0
	endif
		jp	ErrExit			; an go home
		
m1:		;
		; - External Search Path
		;
		ld	a,(UseIntPath)		; force use of internal path?
		or	a
		jr	nz,m11			; yes, -->
		call	getpath			; get addr of external path
		jr	z,m11			; no path, so use internal path
		ld	a,(hl)			; is there any entry in the external path
		or	a
		jr	nz,m2			; if it is, use external path, else internal
m11:		ld	hl,IntPath		; addr of internal path
m2:		ld	(PathAdr),hl
		
		;
		; prepare FCB for search
		;
		ld	hl,FCB+9		; ptr to ft
		ld	(hl),'?'
		inc	hl
		ld	(hl),'?'
		inc	hl
		ld	(hl),'?'		; set default ft
		ld	de,FCB
;		call	initfcb			; init remaining fields in FCB
		
		;
		; save away disk/user
		;
		call	retud			; read disk and user
		ld	(DefUser),bc		; save it away
		ld	(CurDU),bc
		
		;
		; calc ptr to cmdtail
		;
		ld	hl,DEFCMD+2		; cpm cmd line
		call	sknsp			; skip over cmdname
		call	sksp			; skip over spaces
		ld	(TailPtr),hl		; store ptr
		;
		; if ROOTONLY, calculate addr of last path element
		;
		ld	a,(RootOnly)
		or	a
		jr	z,m3			; no, use full path
		ld	ix,(PathAdr)
m03:		ld	a,(ix+2)		; get byte after next entry
		or	a			; check for end of path
		jr	z,m031			; ok, so IX pts to root
		inc	ix
		inc	ix			; pt to next element
		jr	m03
m031:		ld	(PathAdr),ix		; save new addr

m3:		;
		; set DMA
		;
		ld	hl,DmaBuff
		call	setdma
		
		;
		; search for files along the path
		;
		ld	hl,(PathAdr)
		ld	a,(RootOnly)		; chk, if ROOTONLY
		or	a
		jr	z,SrchFst		; no, search current d/u first
PathLoop:	ld	a,(hl)			; get drive from path
		or	a			; end of path?
		jp	z,ExecDef		; yes, no file found
		dec	a			; A=1 --> A=0
		cp	'$'-1			; current drive?
		jr	nz,m41			; no, skip
		ld	a,(DefDisk)		; yes, get it
m41:		ld	b,a
		inc	hl
		ld	a,(hl)			; get user
		cp	'$'			; check for default
		jr	nz,m42			; no, skip
		ld	a,(DefUser)		; get default user
m42:		ld	c,a
		inc	hl			; pt to next path element
		ld	(CurDU),bc		; save it for cmds
		call	logud			; log into drive/user
SrchFst:	ld	c,SFIRST		; BDOS-fct 'search for first'
		
SrchLoop:	;
		; search logged directory for matching file
		;
		push	hl			; save path ptr
		ld	de,FCB			; load addr of FCB
		call	bdos			; search for first/next
		pop	hl			; restore path ptr
		cp	0ffh			; found?
		jp	z,PathLoop		; no, not in this d/u, check next
		push	hl			; save path ptr
		rept	5			; multiply A by 32
		add	a,a			; to pt to matching dir entry
		endm
		add	a,9			; add offset for ft
		ld	e,a
		ld	d,0			; into DE for 16-bit addition
		ld	hl,DmaBuff
		add	hl,de			; HL now pts to ft
		;
		; check file extent against table of extents
		;
		ld	de,ExtTable		; ptr to table of extents
ExtLoop:	ld	a,(de)			; end of table?
		or	a
		jr	z,NoMatch		; yes, -->
		ld	(ExtPtr),de		; save ptr for cmds
		ld	b,3
		push	hl
		push	de			; save ptr
		ex	de,hl
m5:		ld	a,(de)
		and	7fh			; mask out attribute bit
		cp	(hl)			; compare table against ft
		inc	hl
		inc	de			; increment pts
		jr	nz,WrongFT		; sorry, wrong ft
		djnz	m5			; try one more char
		ex	de,hl
		jr	StartCmd
		
WrongFT:	;
		; type does not match, try next entry
		;
		pop	de			; get back entryptr
		ld	hl,CMDLEN+3		; offst to next entry
		add	hl,de			; add
		ex	de,hl			; back to DE
		pop	hl			; restore sourceptr
		jr	ExtLoop			; and try again
		
		; 
NoMatch:	;
		; sorry, not an allowed ft
		;
		pop	hl			; restore path ptr
		ld	c,SNEXT			; BDOS-fct 'search for next'
		jp	SrchLoop		; search for another matching entry
		
StartCmd:	;
		; wow, there is a matching file
		; DE now pts to cmdline
		;
		pop	hl			; correct stack
		pop	hl			; need them no more
		pop	hl

Copy:		ld	hl,CmdBuff		; ptr to line buffer
		ex	de,hl
CopyLoop:	;
		; copy installed cmd line into buffer
		;
		ld	a,(hl)			; check for end of line
		or	a
		jp	z,StoreLine		; ok, ready with copying
		cp	'$'			; is it a cmd?
		jr	z,ChkCommand		; yes, -->
CopyOne:	ldi				; copy and adjust pts
		jr	CopyLoop		; continue copy
		
ChkCommand:	;
		; chk for a cmd
		;
		inc	hl			; pt to cmdchar
		ld	a,(hl)			; get char
		or	a			; end of line?
		jp	z,StoreLine		; ignore $
		push	hl			; save ptr to internal cmdline
		ld	bc,ChkReturn
		push	bc			; set ret addr
		cp	'!'			; full cmd line
		jp	z,AddFullLine
		cp	'*'			; cmd tail
		jp	z,AddTailLine
		cp	'D'			; disk
		jp	z,CopyDisk
		cp	'U'			; user
		jp	z,CopyUser
		cp	'B'			; disk and user and colon
		jp	z,CopyDU
		cp	'N'			; filename
		jp	z,CopyFileName
		cp	'T'			; filetype
		jp	z,CopyFileType
		cp	'F'			; filename.filetype
		jp	z,CopyFnFt
		cp	'H'			; default disk/user:
		jp	z,CopyDefDU
		jp	CopyOne			; else copy char as is
ChkReturn:	; returm here from subroutine
		pop	hl
		inc	hl			; skip cmdchar
		jp	CopyLoop
		
AddTailLine:	;
		; copy the original cmdtail to the new cmdline
		;
		ld	hl,(TailPtr)		; get ptr to cmdtail
CopyHLLoop:	ld	a,(hl)
		or	a
		jr	z,CmdEnd
		ldi				; copy char
		jr	CopyHLLoop
		
AddFullLine:	;
		; copy the complete original line to the new cmdline
		;
		ld	hl,DEFCMD+2		; original cmdline
		jr	CopyHLLoop
		
CopyFileName:	;
		; copy the original filename to the new cmdline
		;
		ld	hl,FCB+1		; original program name
		ld	bc,8			; 8 chars long
CopyLdir:	ld	a,(hl)
		cp	' '			; space ends string
		jr	z,CmdEnd
		ldi				; copy one char
		jp	pe,CopyLdir		; continue, if not complete
CmdEnd:		; continue with internal cmdline
		ret
		
CopyFileType:	;
		; copy filetype of matching file
		;
		ld	hl,(ExtPtr)		; matching file type
		ld	bc,3			; 3 chars long
		jr	CopyLdir		; copy it
		
CopyDisk:	;
		; store diskletter into cmdline
		;
		ld	a,(CurDU+1)		; get logged disk
CopyD:		add	a,'A'			; convert to letter
CopyA:		ld	(de),a
		inc	de			; pt to next char
		ret
		
CopyUser:	;
		; store usernumber into cmdline
		;
		ld	a,(CurDU)		; get logged user
CopyU:		call	mafdc			; write into cmdline
		ret
		
CopyDU:		;
		; store disk/user into cmdline
		;
		call	CopyDisk		; store Disk
		call	CopyUser		; store User
		ld	a,':'
		jr	CopyA			; store A
		
CopyDefDU:	;
		; store default disk/user into cmdline
		;
		ld	a,(DefUser+1)		; get def disk
		call	CopyD			; store into cmdline
		ld	a,(DefUser)		; get def user
		jr	CopyU			; store it

CopyFnFt:	;
		; copy filename.filetype into cmdline
		;
		call	CopyFileName		; copy name
		ld	a,'.'
		ld	(de),a
		inc	de			; store .
		jp	CopyFileType		; copy type
		
StoreLine:	;
		; store new command at beginning of multiple command line
		;
		xor	a
		ld	(de),a			; store ending zero
		ld	hl,CmdBuff		; pt to new cmd
		;
		; store the line ptd to by HL into mcl
		;
		call	putcl			; set as first cmd in mcl
		jr	nz,Success		; enough space in mcl, hoorah
		
		;
		; command line overflow: print msg and terminate with error
		;
		call	print
	if GERMAN
		db	7,'Komandozeilen-Ueberlauf',13,10,0
	else
		db	7,'Command Line Overflow',13,10,0
	endif
		jp	ErrExit
		
Success:	;
		; successful exit
		;
		ld	a,(QuietFlag)		; quiet?
		or	a
		jr	nz,m6			; yes, skip msg
		call	print
	if GERMAN
		db	'Starte Kommando: ',0
	else
		db	'Starting Command: ',0
	endif
		ld	hl,CmdBuff
		call	pstr			; print command to be executed
		call	crlf
m6:		jr	Exit
		
ExecDef:	;
		; no matching file found, so execute default cmd
		;
		ld	de,DefCmdLine		; pt to default cmd
		ld	a,(de)			; is it defined?
		or	a
		jp	nz,Copy			; yes, copy it into mcl
		
ErrExit:	;
		; no matching file and no default cmd
		; so set error flag and return to CCP
		;
		ld	a,6			; flag "ECP unable to process cmd"
		call	putcst			; set flag
Exit:		ld	bc,(DefUser)
		call	logud			; set logged drive/user
		ret				; return to CCP
		
;
; uninitialized data
;
		dseg
;
; buffer for directory sector
;
DmaBuff:	ds	128
;
; buffer for cmd to execute next
;
CmdBuff:	ds	256
;
; runtime variables
;
PathAdr:	ds	2			; startaddr of path

DefUser:	ds	1			; default user and disk
DefDisk:	ds	1			; DO NOT CHANGE SUCCESSION !
QuietFlag:	ds	1			; 0=not quiet

;
; some information for internal cmds
;
TailPtr:	ds	2			; pt to cmdline tail
ExtPtr:		ds	2			; pt to matching ext
CurDU:		ds	2			; currently logged d/u

		end
