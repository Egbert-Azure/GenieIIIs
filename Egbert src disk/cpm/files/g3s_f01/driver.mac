;******************************************************************************
;*  D R I V E R  *  C P M S Y S 1  *  T h o m a s   H o l t e  *  8 6 0 1 1 3 *
;******************************************************************************
;*									      *
;*	   I / O - D R I V E R S   F O R   T H E   G E N I E  I I I s	      *
;*	   ==========================================================	      *
;*									      *
;*		    M I C R O C O M P U T E R	S Y S T E M		      *
;*		    =======================================		      *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.1  *
;*									      *
;******************************************************************************

;-----------------------------------------------------------------------------
; [nderung  der  Cursorsteuerung  'ESC	xx  '  Befehle	zur  Worsdstar-
; kompatibilit{t und da ich mit ZCPR  arbeite.
;
; Falls jemand sich mal der Graficm|glichkeiten in einem Anwenderprogramm
; annimmt bitte ich um Nachricht.
; F.Chwolka
;-----------------------------------------------------------------------------



	.Z80
	.SALL

SASI	EQU  0			;must be true, if Xebec controller installed
WINCÈ    EQÕ   °                  ;musô bå truå iæ Winchesteò  oî  boarä (FCH)

	ASEG

;******************************************************************************
;*		  B A N K E D	P A R T   O F	D R I V E R S		      *
;******************************************************************************

	ORG  0000H		;start of 56K bank 0


;ASCII control codes:
NUL	EQU  00H		;null
SOH	EQU  01H		;start of heading
STX	EQU  02H		;start of text
ETX	EQU  03H		;end of text
EOT	EQU  04H		;end of transmission
ENQ	EQU  05H		;enquiry
ACK	EQU  06H		;acknowledge
BEL	EQU  07H		;bell
BS	EQU  08H		;backspace
HT	EQU  09H		;horizontal tabulation
LF	EQU  0AH		;line feed
VT	EQU  0BH		;vertical tabulation
FF	EQU  0CH		;form feed
CR	EQU  0DH		;carriage return
SO	EQU  0EH		;shift out
SI	EQU  0FH		;shift in
DLE	EQU  10H		;data link escape
DC1	EQU  11H		;device control 1ŠDC2	EQU  12H		;device control 2
DC3	EQU  13H		;device control 3
DC4	EQU  14H		;device control 4
NAK	EQU  15H		;negative acknowledge
SYN	EQU  16H		;synchronous idle
ETB	EQU  17H		;end of transmission block
CAN	EQU  18H		;cancel
EM	EQU  19H		;end of medium
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape
FS	EQU  1CH		;file separator
GS	EQU  1DH		;group separator
RS	EQU  1EH		;record separator
DEL	EQU  7FH		;delete


;common entry point for all driver routines
	PUSH BC			;save contents of reg. B & HL
	PUSH HL
	LD   B,0		;vector # * 2 --> reg. BC
	SLA  C
	LD   HL,DRITBL		;base of vector table --> reg. IX
	ADD  HL,BC		;calc table entry
	LD   C,(HL)		;get entry point of driver routine
	INC  HL
	LD   B,(HL)
	PUSH BC
	POP  IX
	POP  HL			;restore contents of reg. B & HL
	POP  BC
	JP   (IX)		;execute driver routine

	ORG  0036H		;interrupt entry point - 2
	DEFW 0			;checksumm of serial #
	JP   $INT		;jump to interrupt service routine

;table of driver addresses:
DRITBL:	DEFW $VDINIT		;initialize video  controller chip M6845
	DEFW $RSINIT		;initialize RS232C controller chip SIO
	DEFW $KBCHAR		;get a keyboard character if available
	DEFW $KBWAIT		;wait for keyboard character
	DEFW $VDCHAR		;display a character
	DEFW $PRSTAT		;test printer status
	DEFW $PRCHAR		;output a character to the printer
	DEFW $RSRCST		;test RS232C input status
	DEFW $RSRCV		;receive a character from the RS232C interface
	DEFW $RSTXST		;test RS232C output status
	DEFW $RSTX		;transmit a character to the RS232C interface
	DEFW $READ		;read a sector
	DEFW $WRITE		;write a sector
	DEFW $GETTIM		;get time and date in ASCII format
	DEFW $SETTIM		;set time and date in binary format
	DEFW $XMOVE		;read/write system data

IÆ WINCÈ                        ;##£ FCÈ onlù iæ winchesteò adapted
	DEFW $READW		;read a Winchester sector
	DEFW $WRITW		;write a Winchester sector
endif

$GTIME3:DEFW $GTIME3S		;get time and date in CP/M 3 formatŠ$STIME3:DEFW $STIME3S		;set time and date in CP/M 3 format
	DEFW $LDCHAR		;load character pattern
	DEFW $RSTCHR		;restore original character set
	DEFW $SCRNIO		;direct screen I/O
	DEFW $INIT		;general initialization routine
	DEFW $CLOCK		;display time continuously
	DEFW $DISP		;turn on/off graphic display
	DEFW $CLS		;clear graphic screen

	DEFW $PLOT		;plot dot    on graphic screen
	DEFW $POINT		;read dot  from graphic screen
	DEFW $LINE		;draw line   on graphic screen
	DEFW $CIRCLE		;draw circle on graphic screen
	DEFW $ARC		;draw arc    on graphic screen
	DEFW $FILL		;fill shape (not implemented yet)
	DEFW $COPY		;copy area


;EJECT
	ORG  0100H
;******************************************************************************
;*				  S Y S T A B				      *
;******************************************************************************

DELAY1:	DEFW 500		;500/determines debounce time (start of key press)
DELAY2:	DEFW 5000		;determines debounce time (end	 of key press)
DELAY3:	DEFW 25			;35/determines wait time until key autorepeats
DELAY4:	DEFW 3			;determines frequency of auto repeat
KEYTAB:	DEFW NBOARD		;contains ^(keyboard table)

;table contains codes for all caps (may be altered by user):
NBOARD:

;address 3801H (letter keys):
	DEFB '@','`',NUL	;@, SHIFT-@, CTRL-@
	DEFB 'a','A',SOH	;A, SHIFT-A, CTRL-A
	DEFB 'b','B',STX	;B, SHIFT-B, CTRL-B
	DEFB 'c','C',ETX	;C, SHIFT-C, CTRL-C
	DEFB 'd','D',EOT	;D, SHIFT-D, CTRL-D
	DEFB 'e','E',ENQ	;E, SHIFT-E, CTRL-E
	DEFB 'f','F',ACK	;F, SHIFT-F, CTRL-F
	DEFB 'g','G',BEL	;G, SHIFT-G, CTRL-G

;address 3802H (letter keys):
	DEFB 'h','H',BS		;H, SHIFT-H, CTRL-H
	DEFB 'i','I',HT		;I, SHIFT-I, CTRL-I
	DEFB 'j','J',LF		;J, SHIFT-J, CTRL-J
	DEFB 'k','K',VT		;K, SHIFT-K, CTRL-K
	DEFB 'l','L',FF		;L, SHIFT-L, CTRL-L
	DEFB 'm','M',CR		;M, SHIFT-M, CTRL-M
	DEFB 'n','N',SO		;N, SHIFT-N, CTRL-N
	DEFB 'o','O',SI		;O, SHIFT-O, CTRL-O

;address 3804H (letter keys):
	DEFB 'p','P',DLE	;P, SHIFT-P, CTRL-P
	DEFB 'q','Q',DC1	;Q, SHIFT-Q, CTRL-Q
	DEFB 'r','R',DC2	;R, SHIFT-R, CTRL-R
	DEFB 's','S',DC3	;S, SHIFT-S, CTRL-S
	DEFB 't','T',DC4	;T, SHIFT-T, CTRL-T
	DEFB 'u','U',NAK	;U, SHIFT-U, CTRL-UŠ	DEFB 'v','V',SYN	;V, SHIFT-V, CTRL-V
	DEFB 'w','W',ETB	;W, SHIFT-W, CTRL-W

;address 3808H (letter keys):
	DEFB 'x','X',CAN	;X, SHIFT-X, CTRL-X
	DEFB 'y','Y',EM		;Y, SHIFT-Y, CTRL-Y
	DEFB 'z','Z',SUB	;Z, SHIFT-Z, CTRL-Z
	DEFB '[','{',ESC	;[, SHIFT-[, CTRL-[
	DEFB '\','|',FS		;\, SHIFT-\, CTRL-\
	DEFB ']','}',GS		;], SHIFT-], CTRL-]
	DEFB '^','~',RS		;^, SHIFT-^, CTRL-^
	DEFB '_','^',RS		;_, SHIFT-_, CTRL-_

;address 3810H (number keys):
	DEFB '0','0',0		;0, SHIFT-0, CTRL-0
	DEFB '1','!',0		;1, SHIFT-1, CTRL-1
	DEFB '2','"',0		;2, SHIFT-2, CTRL-2
	DEFB '3','#',0		;3, SHIFT-3, CTRL-3
	DEFB '4','$',0		;4, SHIFT-4, CTRL-4
	DEFB '5','%',0		;5, SHIFT-5, CTRL-5
	DEFB '6','&',0		;6, SHIFT-6, CTRL-6
	DEFB '7','''',0		;7, SHIFT-7, CTRL-7

;address 3820H (number & special keys):
	DEFB '8','(',0		;8, SHIFT-8, CTRL-8
	DEFB '9',')',0		;9, SHIFT-9, CTRL-9
	DEFB ':','*',0		;:, SHIFT-:, CTRL-:
	DEFB ';','+',0		;;, SHIFT-;, CTRL-;
	DEFB ',','<',0		;,, SHIFT-,, CTRL-,
	DEFB '-','=',0		;-, SHIFT--, CTRL--
	DEFB '.','>',0		;., SHIFT-., CTRL-.
	DEFB '/','?',0		;/, SHIFT-/, CTRL-/

;address 3840H (special keys):
	DEFB CR,CR,0		;NEWLINE   , SHIFT-NEWLINE   , CTRL-NEWLINE
	DEFB DEL,0FCH,0		;CLEAR	   , SHIFT-CLEAR     , CTRL-CLEAR
	DEFB ESC,0FDH,0		;BREAK	   , SHIFT-BREAK     , CTRL-BREAK
	DEFB ENQ,VT,ETB		;STX/ UP-ARROW	, SHIFT-UP-ARROW  , CTRL-UP-ARROW
	DEFB CAN,ETX,SUB	;LF/ DOWN-ARROW, SHIFT-DOWN-ARROW, CTRL-DOWN-ARROW
	DEFB DC3,CAN,BS		;SOH/ LEFT-ARROW, SHIFT-LEFT-ARROW, CTRL-LEFT-ARROW
	DEFB EOT,HT,BEL		;ACK/ RGHT-ARROW, SHIFT-RGHT-ARROW, CTRL-RGHT-ARROW
	DEFB ' ',' ',0		;SPACE	   , SHIFT-SPACE     , CTRL-SPACE

;address 38A0H (function keys):
	DEFB 80H,80H,0		;F1, SHIFT-F1, CTRL-F1
	DEFB 81H,81H,0		;F2, SHIFT-F2, CTRL-F2
	DEFB 82H,82H,0		;F3, SHIFT-F3, CTRL-F3
	DEFB 83H,83H,0		;F4, SHIFT-F4, CTRL-F4
	DEFB 84H,84H,0		;F5, SHIFT-F5, CTRL-F5
	DEFB 85H,85H,0		;F6, SHIFT-F6, CTRL-F6
	DEFB 86H,86H,0		;F7, SHIFT-F7, CTRL-F7
	DEFB 87H,87H,0		;F8, SHIFT-F8, CTRL-F8

;address 38C0H (number keys [numeric keypad]):
	DEFB '0','0',0		;1, SHIFT-1, CTRL-1
	DEFB '1','1',0		;2, SHIFT-2, CTRL-2
	DEFB '2','3',0		;3, SHIFT-3, CTRL-3
	DEFB '3','3',0		;4, SHIFT-4, CTPL-4
	DEFB '4','4',0		;5, SHIFT-5, CTRL-5
	DEFB '5','5',0		;6, SHIFT-6, CTRL-6Š	DEFB '6','6',0		;7, SHIFT-7, CTRL-7
	DEFB '7','7',0		;8, SHIFT-8, CTRL-8

;address 3880H (function keys & escape key):
	DEFB 0,0,0		;SHIFT
	DEFB 0,0,0		;CTRL
	DEFB ESC,ESC,0		;ESC
	DEFB 8CH,8CH,0		;P5, SHIFT-P5, CTRL-P5
	DEFB 8BH,8BH,0		;P4, SHIFT-P4, CTRL-P4
	DEFB 8AH,8AH,0		;P3, SHIFT-P3, CTRL-P3
	DEFB 89H,89H,0		;P2, SHIFT-P2, CTRL-P2
	DEFB 88H,88H,0		;P1, SHIFT-P1, CTRL-P1

;address 38E0H (number & special keys [numeric keypad]):
	DEFB '8','8',0		;8 , SHIFT-8 , CTRL-8
	DEFB '9','9',0		;9 , SHIFT-9 , CTRL-9
	DEFB 0FEH,0FEH,0	;00, SHIFT-00, CTRL-00
	DEFB 0,0,0		;LOCK
	DEFB ',',',',0		;, , SHIFT-, , CTRL-,
	DEFB '-','-',0		;- , SHIFT-- , CTRL--
	DEFB '.','.',0		;. , SHIFT-. , CTRL-.
	DEFB 0,0FBH,0		;SHIFT-PRINT


;EJECT
;table contains codes for all caps (special WordStar version):
WBOARD:

;address 3801H (letter keys):
	DEFB '@','`',NUL	;@, SHIFT-@, CTRL-@
	DEFB 'a','A',SOH	;A, SHIFT-A, CTRL-A
	DEFB 'b','B',STX	;B, SHIFT-B, CTRL-B
	DEFB 'c','C',ETX	;C, SHIFT-C, CTRL-C
	DEFB 'd','D',EOT	;D, SHIFT-D, CTRL-D
	DEFB 'e','E',ENQ	;E, SHIFT-E, CTRL-E
	DEFB 'f','F',ACK	;F, SHIFT-F, CTRL-F
	DEFB 'g','G',BEL	;G, SHIFT-G, CTRL-G

;address 3802H (letter keys):
	DEFB 'h','H',BS		;H, SHIFT-H, CTRL-H
	DEFB 'i','I',HT		;I, SHIFT-I, CTRL-I
	DEFB 'j','J',LF		;J, SHIFT-J, CTRL-J
	DEFB 'k','K',VT		;K, SHIFT-K, CTRL-K
	DEFB 'l','L',FF		;L, SHIFT-L, CTRL-L
	DEFB 'm','M',CR		;M, SHIFT-M, CTRL-M
	DEFB 'n','N',SO		;N, SHIFT-N, CTRL-N
	DEFB 'o','O',SI		;O, SHIFT-O, CTRL-O

;address 3804H (letter keys):
	DEFB 'p','P',DLE	;P, SHIFT-P, CTRL-P
	DEFB 'q','Q',DC1	;Q, SHIFT-Q, CTRL-Q
	DEFB 'r','R',DC2	;R, SHIFT-R, CTRL-R
	DEFB 's','S',DC3	;S, SHIFT-S, CTRL-S
	DEFB 't','T',DC4	;T, SHIFT-T, CTRL-T
	DEFB 'u','U',NAK	;U, SHIFT-U, CTRL-U
	DEFB 'v','V',SYN	;V, SHIFT-V, CTRL-V
	DEFB 'w','W',ETB	;W, SHIFT-W, CTRL-W

;address 3808H (letter keys):
	DEFB 'x','X',CAN	;X, SHIFT-X, CTRL-XŠ	DEFB 'y','Y',EM		;Y, SHIFT-Y, CTRL-Y
	DEFB 'z','Z',SUB	;Z, SHIFT-Z, CTRL-Z
	DEFB '[','{',ESC	;[, SHIFT-[, CTRL-[
	DEFB '\','|',FS		;\, SHIFT-\, CTRL-\
	DEFB ']','}',GS		;], SHIFT-], CTRL-]
	DEFB '^','~',RS		;^, SHIFT-^, CTRL-^
	DEFB '_','^',RS		;_, SHIFT-_, CTRL-_

;address 3810H (number keys):
	DEFB '0','0',0		;0, SHIFT-0, CTRL-0
	DEFB '1','!',0		;1, SHIFT-1, CTRL-1
	DEFB '2','"',0		;2, SHIFT-2, CTRL-2
	DEFB '3','#',0		;3, SHIFT-3, CTRL-3
	DEFB '4','$',0		;4, SHIFT-4, CTRL-4
	DEFB '5','%',0		;5, SHIFT-5, CTRL-5
	DEFB '6','&',0		;6, SHIFT-6, CTRL-6
	DEFB '7','''',0		;7, SHIFT-7, CTRL-7

;address 3820H (number & special keys):
	DEFB '8','(',0		;8, SHIFT-8, CTRL-8
	DEFB '9',')',0		;9, SHIFT-9, CTRL-9
	DEFB ':','*',0		;:, SHIFT-:, CTRL-:
	DEFB ';','+',0		;;, SHIFT-;, CTRL-;
	DEFB ',','<',0		;,, SHIFT-,, CTRL-,
	DEFB '-','=',0		;-, SHIFT--, CTRL--
	DEFB '.','>',0		;., SHIFT-., CTRL-.
	DEFB '/','?',0		;/, SHIFT-/, CTRL-/

;address 3840H (special keys):
	DEFB CR,CR,0		;NEWLINE   , SHIFT-NEWLINE   , CTRL-NEWLINE
	DEFB 8DH,8EH,DEL	;CLEAR	   , SHIFT-CLEAR     , CTRL-CLEAR
				;CLEAR	     = erase to end of line
				;SHIFT-CLEAR = erase to start of line
				;CTRL -CLEAR = erase previous character
	DEFB NAK,0FDH,0		;BREAK	   , SHIFT-BREAK     , CTRL-BREAK
				;BREAK = abort current operation
	DEFB ENQ,8FH,90H	;UP-ARROW  , SHIFT-UP-ARROW  , CTRL-UP-ARROW
				;      UP-ARROW = cursor up
				;SHIFT-UP-ARROW = start of text
				;CTRL -UP-ARROW = start of screen
	DEFB CAN,91H,92H	;DOWN-ARROW, SHIFT-DOWN-ARROW, CTRL-DOWN-ARROW
				;      DOWN-ARROW = cursor down
				;SHIFT-DOWN-ARROW = end of text
				;CTRL -DOWN-ARROW = end of screen
	DEFB DC3,93H,SOH	;LEFT-ARROW, SHIFT-LEFT-ARROW, CTRL-LEFT-ARROW
				;      LEFT-ARROW = cursor left
				;SHIFT-LEFT-ARROW = start of line
				;CTRL -LEFT-ARROW = word left
	DEFB EOT,94H,ACK	;RGHT-ARROW, SHIFT-RGHT-ARROW, CTRL-RGHT-ARROW
				;      RIGHT-ARROW = cursor right
				;SHIFT-RIGHT-ARROW = end of line
				;CTRL -RIGHT-ARROW = word right
	DEFB ' ',' ',95H	;SPACE	   , SHIFT-SPACE     , CTRL-SPACE
				;CTRL-SPACE = hard space

;address 38A0H (function keys):
	DEFB SYN,SYN,0		;F1, SHIFT-F1, CTRL-F1
				;F1 = toggle insert mode
	DEFB SO,SO,0		;F2, SHIFT-F2, CTRL-F2
				;F2 = insert lineŠ	DEFB BEL,BEL,0		;F3, SHIFT-F3, CTRL-F3
				;F3 = delete character
	DEFB DC4,DC4,0		;F4, SHIFT-F4, CTRL-F4
				;F4 = delete word
	DEFB EM,EM,0		;F5, SHIFT-F5, CTRL-F5
				;F5 = delete line
	DEFB STX,STX,0		;F6, SHIFT-F6, CTRL-F6
				;F6 = reformat paragraph
	DEFB 96H,96H,0		;F7, SHIFT-F7, CTRL-F7
				;F7 = toggle hyphen help
	DEFB 97H,97H,0		;F8, SHIFT-F8, CTRL-F8
				;F8 = toggle right justifying

;address 38C0H (number keys [numeric keypad]):
	DEFB '0','0',0		;1, SHIFT-1, CTRL-1
	DEFB '1','1',0		;2, SHIFT-2, CTRL-2
	DEFB '2','3',0		;3, SHIFT-3, CTRL-3
	DEFB '3','3',0		;4, SHIFT-4, CTRL-4
	DEFB '4','4',0		;5, SHIFT-5, CTRL-5
	DEFB '5','5',0		;6, SHIFT-6, CTRL-6
	DEFB '6','6',0		;7, SHIFT-7, CTRL-7
	DEFB '7','7',0		;8, SHIFT-8, CTRL-8

;address 3880H (function keys & escape key):
	DEFB 0,0,0		;SHIFT
	DEFB 0,0,0		;CTRL
	DEFB ESC,ESC,0		;ESC
	DEFB ETX,ETX,0		;P5, SHIFT-P5, CTRL-P5
				;P5 = page down
	DEFB DC2,DC2,0		;P4, SHIFT-P4, CTRL-P4
				;P4 = page up
	DEFB SUB,SUB,0		;P3, SHIFT-P3, CTRL-P3
				;P3 = line down
	DEFB ETB,ETB,0		;P2, SHIFT-P2, CTRL-P2
				;P2 = line up
	DEFB HT,HT,0		;P1, SHIFT-P1, CTRL-P1
				;P1 = TAB

;address 38E0H (number & special keys [numeric keypad]):
	DEFB '8','8',0		;8 , SHIFT-8 , CTRL-8
	DEFB '9','9',0		;9 , SHIFT-9 , CTRL-9
	DEFB 0FEH,0FEH,0	;00, SHIFT-00, CTRL-00
	DEFB 0,0,0		;LOCK
	DEFB ',',',',0		;, , SHIFT-, , CTRL-,
	DEFB '-','-',0		;- , SHIFT-- , CTRL--
	DEFB '.','.',0		;. , SHIFT-. , CTRL-.
	DEFB 0,0FBH,0		;SHIFT-PRINT


;EJECT
VECTOR:	DEFW FKEYS		;function key vector

OFFSET	DEFL 0			;initialize offset

FKEYS:	REPT 13			;function key pointer
	DEFW F0+OFFSET
OFFSET	DEFL OFFSET+81
	 ENDM
	DEFW ERAEND,ERABEG,SOTXT,SOCRT,EOTXT,EOCRT
	DEFW SOLIN,EOLIN,HSPACE,HYPHEN,JSTIFYŠ
F0:
;	.XLIST
	REPT 13			;function key buffer
	DEFB 1
	REPT 80
	DEFB 0
	 ENDM
	 ENDM
	.LIST

;special WordStar part:
ERAEND:	DEFB 2			;erase to end of line
	DEFB DC1,'Y',0
ERABEG:	DEFB 2			;erase to start of line
	DEFB DC1,DEL,0
SOTXT:	DEFB 2			;start of text
	DEFB DC1,'R',0
SOCRT:	DEFB 2			;start of screen
	DEFB DC1,'E',0
EOTXT:	DEFB 2			;end of text
	DEFB DC1,'C',0
EOCRT:	DEFB 2			;end of screen
	DEFB DC1,'X',0
SOLIN:	DEFB 2			;start of line
	DEFB DC1,'S',0
EOLIN:	DEFB 2			;end of line
	DEFB DC1,'D',0
HSPACE:	DEFB 2			;hard space
	DEFB DLE,'O',0
HYPHEN:	DEFB 2			;toggle hyphen help
	DEFB SI,'H',0
JSTIFY:	DEFB 2			;toggle right justifying
	DEFB SI,'J',0


;EJECT
;table of control codes:
;  first byte = 0	single ASCII control code
;  first byte = 0FFH	escape sequence

TAB1S:	DEFB 0,BEL		;beep
	DEFB 0,BS		;cursor left
	DEFB 0,LF		;cursor down
	DEFB 0,VT		;cursor up
	DEFB 0,FF		;cursor right
	DEFB 0,CR		;carriage return
	DEFB 0,RS		;home cursor
TAB2S:	DEFB 0FFH,'='		;absolute cursor addressing

	DEFB 0FFH,'F'		;select window
	DEFB 0FFH,'I'		;set top line
	DEFB 0FFH,'J'		;set bottom line
	DEFB 0FFH,'K'		;set left column
	DEFB 0FFH,'L'		;set right column

TAB2E:	DEFB 0FFH,' '		;set erase character
	DEFB 0FFH,FF		;cursor off
	DEFB 0FFH,CR		;cursor on
	DEFB 0FFH,'A'		;ASCII character setŠ	DEFB 0FFH,'D'		;disable status line
	DEFB 0FFH,'E'		;enable status line
	DEFB 0FFH,'G'		;German character set
	DEFB 0FFH,'N'		;normal keyboard
	DEFB 0FFH,'O'		;WordStar keyboard
	DEFB 0FFH,'R'		;inverse display mode
	DEFB 0FFH,'S'		;normal display mode
	DEFB 0FFH,'X'		;turn on wrap around mode
	DEFB 0FFH,'Y'		;turn off wrap around mode

	DEFB 0FFH,'P'		;insert character
	DEFB 0FFH,'V'		;insert line
	DEFB 0FFH,'Q'		;delete char
	DEFB 0,CAN		;erase to end of line
	DEFB 0FFH,'W'		;delete line
	DEFB 0,EM		;erase to end of screen
TAB1E:	DEFB 0,SUB		;clear screen


;EJECT
	INCLUDE	FONT12		;font set


;drive control tables (5 inch):

;drive 0:
DCT:	DEFB 01110000B		;bit 7	 : reserved
				;bit 6	 : no. of	  0 = single sided
				;	   surfaces	  1 = double sided
				;bit 5	 : density	  0 = single density
				;			  1 = double density
				;bit 4	 : desity of	  0 = single density
				;	   first track	  1 = double density
				;bit 3	 : no. of first   0 = zero
				;	   sec. on track  1 = one
				;bit 2	 : steps per	  0 = one step
				;	   trk to trk	  1 = two steps
				;bits 1,0: track stepping rate
				;	   0 =	3 msec	  1 =  6 msec
				;	   2 = 10 msec	  3 = 15 msec
	DEFB 10000000B		;bits 7,6: sector length
				;	   0 = 128 bytes  1 =  256 bytes
				;	   2 = 512 bytes  3 = 1024 bytes
				;bit 5	 : 0 = new sector numbering on backside
				;	   1 = sector numbering continued on
				;	       backside
				;bit 0	 : drive status (used by disk driver --
				;			 do not alter)
	DEFB 2			;interleaving factor
	DEFB 20			;sector count per track
	DEFB 80			;number of usable tracks
	DEFB 0			;current track

;drive 1:
	DEFB 01110000B
	DEFB 10000000B
	DEFB 2
	DEFB 20
	DEFB 80
	DEFB 0Š
;drive 2:
	DEFB 01110000B,10000000B,2,20,80,0

;drive 3:
	DEFB 01110000B,10000000B,2,20,80,0


;drive control tables (8 inch):
;FRiTZ 1,2MB:
;drive 0:

	DEFB 01110000B		   ;No of first sect on track = 1
	DEFB 10000000B		   ;Sect numbering continued  on back
	DEFB 3
	DEFB 32
	DEFB 80
	DEFB 0

;drive 1:
	DEFB 01110000B,10000000B,3,32,80,0

;drive 2:
	DEFB 01110000B,10000000B,3,32,80,0

;drive 3:
	DEFB 01110000B,10000000B,3,32,80,0



TRYS:	DEFB 3			;# of times to try I/O until routine gives up


iæ WINCÈ                        » ##£ FCÈ 
 
;EJECT
;Winchester disk control tables:

;drive 0:
DCTW:	DEFB 01100000B		;bits 7-5: no. of surfaces
				;	   0 = one   head    4 = five  heads
				;	   1 = two   heads   5 = six   heads
				;	   2 = three heads   6 = seven heads
				;	   3 = four  heads   7 = eight heads
				;bit 4	 : no. of first      0 = zero
				;	   sector on track   1 = one
				;bits 3-0: track stepping rate
				;0 = 35  usec	 6 = 3.0 msec	11 = 5.5 msec
				;1 = 0.5 msec	 7 = 3.5 msec	12 = 6.0 msec
				;2 = 1.0 msec	 8 = 4.0 msec	13 = 6.5 msec
				;3 = 1.5 msec	 9 = 4.5 msec	14 = 7.0 msec
				;4 = 2.0 msec	10 = 5.0 msec	15 = 7.5 msec
				;5 = 2.5 msec
	DEFB 10000000B		;bits 7,6: sector length
				;	   0 =	256 bytes  1 = 512 bytes
				;	   2 = 1024 bytes  3 = 128 bytes
				;bit 0	 : drive status (used by disk driver --
				;			 do not alter)
	DEFB 32			;starting track for write precomp / 4
	DEFB 1			;interleaving factorŠ	DEFB 9			;sector count per track
	DEFW 1440		;number of usable tracks

;drive 1:
	DEFB 00100000B
	DEFB 10000000B
	DEFB 0FFH
	DEFB 1
	DEFB 9
	DEFW 612

;drive 2:
	DEFB 00100000B,01000000B,0,1,16
	DEFW 1224

endif

;EJECT
;powerup/reset parameters:

;powerup/reset marker:
POWUP:	DEFS 1

;table of video parameters:
VIDPAR:	DEFB 111		;horizontal total
	DEFB 80			;horizontal displayed
	DEFB 86			;h sync position
	DEFB 96			;h sync width
	DEFB 28			;vertical total
	DEFB 13			;v total adjust
	DEFB 25			;vertical displayed
	DEFB 27			;v sync position
	DEFB 1			;interlace mode (non interlace)
	DEFB 10			;max scan line address
	DEFB 6CH		;cursor start
	DEFB 13			;cursor end
	DEFB 0			;start address (H)
	DEFB 0			;start address (L)
	DEFB 0			;cursor (H)
	DEFB 0			;cursor (L)

;character set:
CHRSET:	DEFB 'A'		;'A' = ASCII  character set
				;'G' = German character set

;RS-232-C parameters:
SER0:	DEFB 11000100B
	DEFB 8

SER1:	DEFB 11000100B
	DEFB 8

;clock ?
CLOCK:	DEFB 1			;0 = software clock
				;1 = hardware clock


;EJECT
;*******************
;*  $ V D I N I T  *Š;*******************

;entry: HL = address of video parameter table

;  struct {
;	    char R0, R1, R2 , R3 , R4 , R5 , R6 , R7 ,
;		 R8, R9, R10, R11, R12, R13, R14, R15;
;	  } *HL;

;  R0  = This 8 bit write-only register determines the horizontal frequency of
;	 HS. It is the total of displayed plus non-displayed character time
;	 units minus one.
;  R1  = This 8 bit write-only register determines the number of displayed
;	 characters per horizontal line.
;  R2  = This 8 bit write-only register determines the horizontal sync position
;	 on the horizontal line.
;  R3  = This 4 bit write-only register determines the width of the HS pulse.
;	 It may not be apparent why this width needs to be programmed. However,
;	 consider that all timing widths must be programmed as multiples of the
;	 character clock period which varies. If HS width were fixed as an
;	 integral number of character times, it would vary with character rate
;	 and be out of tolerance for certain monitors. The rate programmable
;	 feature allows compensating HS width.
;  R4
;  R5  = The vertical frequency of VS is determined by both R4 and R5. The
;	 calculated number of character line times is usually an integer plus a
;	 fraction to get exactly a 50 or 60 Hz vertical refresh rate. The
;	 integer number of character line times minus one is programmed in the
;	 7 bit write-only Vertical Total Register (R4); the fraction is
;	 programmed in the 5 bit write-only Vertical Scan Adjust Register (R5)
;	 as a number of scan line times.
;  R6  = This 7 bit write-only register determines the number of displayed
;	 character rows on the CRT screen, and is programmed in character row
;	 times.
;  R7  = This 7 bit write-only register determines the vertical sync position
;	 with respect to the reference. It is programmed in character row
;	 times.
;  R8  = This 2 bit write-only register controls the raster scan mode. When bit
;	 0 and bit 1 are reset, or bit 0 is reset and bit 1 set, the non-
;	 interlace raster scan mode is selected. Two interlace modes are
;	 available. Both are interlaced 2 fields per frame. When bit 0 is set
;	 and bit 1 is reset, the interlace sync raster scan mode is selected.
;	 Also when bit 0 and bit 1 are set, the interlace sync and video raster
;	 scan mode is selected.
;  R9  = This 5 bit write-only register determines the number of scan lines per
;	 character row including spacing. The programmed value is a max address
;	 and is one less than the number of scan lines.
;  R10 = This 7 bit write-only register controls the cursor format. Bit 5 is
;	 the blink timing control. When bit 5 is low, the blink frequency is
;	 1/16 of the vertical field rate, and when bit 5 is high, the blink
;	 frequency is 1/32 of the vertical field rate. Bit 6 is used to enable
;	 a blink. The cursor start scan line is set by the lower 5 bits.
;  R11 = This 5 bit write-only register sets the cursor end scan line.
;  R12
;  R13 = Start Address Register is a 14 bit write-only register which
;	 determines the first address put out as a refresh address after
;	 vertical blanking. It consists of an 8 bit lower register (R13), and a
;	 6 bit higher register (R12).
;  R14
;  R15 = This 14 read/write register stores the cursor location. This registerŠ;	 consists of an 8 bit lower (R15) and 6 bit higher (R14) register.

$CRTREG	EQU  0F6H		;CRT controller address register
$CRTCMD	EQU  0F7H		;CRTC command register

;initialize the video controller chip M6845:
$VDINIT:LD   A,10H		;source      bank = 1
				;destination bank = 0
VDINIT1:LD   DE,$VIDPAR		;^temp buffer		   --> reg. DE
	LD   B,16		;length of parameter table --> reg. B
	CALL $XMOVE		;get video parameter table
	LD   BC,1000H		;CRTC register count	   --> reg.  B
				;CRTC start register	   --> reg.  C
	LD   HL,$VIDPAR		;^video parameter table    --> reg. HL
OUTCMD:	LD   A,C		;CRTC register no.	   --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,(HL)		;video parameter --> accu
	OUT  ($CRTCMD),A	;output CRTC command
	INC  HL			;bump ^video parameter
	INC  C			;increment CRTC register no.
	DJNZ OUTCMD		;output 16 parameters
	LD   A,($VIDPAR+10)	;get control byte for cursor start
	LD   (CURBEG),A		;store it for subsequent use
	RET			;return to caller

CURBEG:	DEFS 1			;temporary storage for cursor start byte
$VIDPAR:DEFS 16			;temporary buffer for video parameter table


;EJECT
;*******************
;*  $ R S I N I T  *
;*******************

;entry: B = number  of RS232C interface (0, 1)
;	A = data format
;	E = baud rate

;  A
;  Bit	  0: 0 = no   parity
;	     1 =      parity
;  Bit	  1: 0 = odd  parity
;	     1 = even parity
;  Bits 3-2: 1 = 1   stop bit
;	     2 = 1.5 stop bits
;	     3 = 2   stop bits
;  Bits 7-6: 0 = 5 bits word length
;	     1 = 7 bits word length
;	     2 = 6 bits word length
;	     3 = 8 bits word length

;	    Desired Baud Rate  | reg. E
;	  =====================|=======
;		 50	       |   2
;		 75	       |   3
;		110	       |  15
;		134.5	       |   4
;		150	       |  14
;		200	       |   5
;		300	       |  13Š;		600	       |   6
;	       1200	       |  11
;	       1800	       |  10
;	       2400	       |   7
;	       4800	       |   9
;	       9600	       |   8
;	      19200	       |   0


RATE	EQU  0F1H		;baud rate register
BTX	EQU  0F2H		;dual baud rate register

;calc initialization routine entry:
$RSINIT:LD   HL,RSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine

;RS232C initialization driver entry routine:
RSTAB:	DEFW RSINIA,RSINIB

;control register of SIO A:
WR0A	EQU  0D2H

RSINIA:	LD   C,A		;save data format
	AND  0C0H		;mask word length bits
	SET  0,A		;receiver enable
	LD   (WR3A),A		;load write register 3
	LD   A,C		;restore data format
	AND  0FH		;mask stop bits and parity
	SET  6,A		;x 16 clock mode
	LD   (WR4A),A		;load write register 4
	LD   A,C		;restore data format
	RRA
	AND  60H		;mask word length bits
	OR   88H		;set DTR, transmitter enable
	LD   (WR5A),A		;load write register 5
	LD   A,B		;relative port number --> accu
	OR   A
	IN   A,(RATE)		;read baud rates
	AND  0F0H		;mask baud rate of channel A
	LD   HL,INITBLA
	JR   RSINIB1

INITBLA:DEFB 1
	DEFB BTX
	DEFB 0
	DEFB 9
	DEFB WR0A
	DEFB 18H		;channel reset
	DEFB 1
	DEFB 0			;disable interrupts
	DEFB 4
WR4A:	DEFS 1Š	DEFB 5
WR5A:	DEFS 1
	DEFB 3
WR3A:	DEFS 1
	DEFB 0


;EJECT
;control register of SIO B:
WR0B	EQU  0D3H

RSINIB:	LD   C,A		;save data format
	AND  0C0H		;mask word length bits
	SET  0,A		;receiver enable
	LD   (WR3B),A		;load write register 3
	LD   A,C		;restore data format
	AND  0FH		;mask stop bits and parity
	SET  6,A		;x 16 clock mode
	LD   (WR4B),A		;load write register 4
	LD   A,C		;restore data format
	RRA
	AND  60H		;mask word length bits
	OR   88H		;set DTR, transmitter enable
	LD   (WR5B),A		;load write register 5
	LD   A,B		;relative port number --> accu
	OR   A
	IN   A,(RATE)		;read baud rates
	AND  0FH		;mask baud rate of channel B
	SLA  E			;shift baud rate code into upper nibble
	SLA  E
	SLA  E
	SLA  E
	LD   HL,INITBLB
RSINIB1:OR   E			;set baud rate
	OUT  (RATE),A		;output baud rate
RSINIB2:LD   A,(HL)
	OR   A			;end of table ?
	RET  Z			;return if yes
	LD   B,A		;byte count  --> reg. B
	INC  HL			;bump table pointer
	LD   C,(HL)		;port number --> reg. C
	INC  HL			;bump table pointer
	OTIR			;output bytes
	JR   RSINIB2		;output next byte stream

INITBLB:DEFB 1
	DEFB BTX
	DEFB 0
	DEFB 9
	DEFB WR0B
	DEFB 18H		;channel reset
	DEFB 1
	DEFB 0			;disable interrupts
	DEFB 4
WR4B:	DEFS 1
	DEFB 5
WR5B:	DEFS 1
	DEFB 3
WR3B:	DEFS 1
	DEFB 0Š

;EJECT
;*******************
;*  $ K B C H A R  *
;*******************

;exit: A = char (0 = no char available)

$SYS0	EQU  0F9H		;bank select port 0
$SYS1	EQU  0FAH		;bank select port 1

;get a keyboard character if available:
$KBCHAR:LD   A,(RDYKEY)		;active key ?
	OR   A
	RET  NZ			;return if yes
	DI			;disable the interrupts
	LD   A,(KLEN)		;A = buffer length
	OR   A			;jump if
	JR   Z,KBCHAR2		;buffer empty
	DEC  A			;dec the length
	LD   (KLEN),A		;save it
	LD   HL,(CPTR)		;HL = character pointer
	LD   A,(HL)		;A = key value
	LD   (RDYKEY),A		;store it
	INC  HL			;bump pointer
	LD   DE,KBUF+80		;DE = end of bufferr pointer
	EX   DE,HL		;swap the pointers
	SBC  HL,DE		;wrap around the buffer ?
	EX   DE,HL		;swap the pointers
	JR   NZ,KBCHAR1		;jump if no wrap around
	LD   HL,KBUF		;HL = new pointer
KBCHAR1:LD   (CPTR),HL		;save the pointer
KBCHAR2:EI			;reenable interrupts
	RET			;return

KLEN:	DEFB 0			;number of active keys
EPTR:	DEFW KBUF		;pointer to next free location
CPTR:	DEFW KBUF		;pointer to first active key
KBUF:	DEFS 80			;type ahead buffer

;EJECT
;this area makes the preliminary check of keyboard rows:
$SCAN:	IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11000110B		;enable memory mapped I/O
				;disable graphic page
				;enable keyboard
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	CALL SCAN		;scan keyboard
	LD   C,A		;code of scanned key --> reg. C
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A		;write it
	RET			;return to interrupt service routine

SCAN:	LD   HL,KEYHLD		;HL = keyboard work area ptr
	LD   IX,KEYBRD		;IX = row address table ptr
	LD   BC,38E0H		;BC = row A10 ptrŠ	LD   D,10		; E = column index
	LD   A,(BC)		;load row 10
	AND  0F7H		;mask out LOCK key
	LD   E,A		;8 column bits
	XOR  (HL)		;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E			;then test for active row
	JR   NZ,ACTIVE		;go if key active in row 10
	DEC  D			;decrement row index
	INC  HL			;eleven byte buffer indexed by row
	LD   C,(IX)		;row address (LSB) --> reg. C
	LD   A,(BC)		;load row 9
	AND  0FCH		;mask out SHIFT + CTRL keys
	LD   E,A		;8 column bits
	XOR  (HL)		;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E			;then test for active row
	JR   NZ,ACTIVE		;go if key active in row 9
	INC  IX			;increment ^row address table
	DEC  D			;decrement row index
CHKKEY:	INC  HL			;ten byte buffer indexed by row
	LD   C,(IX)		;row address (LSB) --> reg. C
	LD   A,(BC)		;load row N
	LD   E,A		;8 column bits
	XOR  (HL)		;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E			;then test for active row
	JR   NZ,ACTIVE		;go if key active in row N
	INC  IX			;increment ^row address table
	DEC  D			;decrement row index
	JP   P,CHKKEY		;try next row

;check for previous key:
	PUSH AF			;save column bits
	LD   HL,(OLDROW)	;^previous row	 --> reg. HL
	LD   A,(OLCLMN)		;old column bits --> accu
	AND  (HL)		;previous key active ?
	JR   NZ,PREV		;jump to wait/repeat procedure if yes
	XOR  A			;clear repeat mode
	LD   (REPEAT),A
	LD   H,A
	LD   L,A
	LD   (COUNT1),HL	;reset first counter
	LD   HL,(DELAY3)	;preset second counter
	LD   (COUNT2),HL
	POP  AF			;restore column bits
	RET			;no key depression - return

;delay routine until key autorepeats:
PREV:	PUSH AF			;save previous column bits
	PUSH HL			;save previous row
	LD   HL,(COUNT1)	;increment first counter
	INC  HL
	LD   (COUNT1),HL
	LD   DE,(COUNT2)	;and compare it with second counter
	LD   A,H
	CP   D
	JR   NZ,REST
	LD   A,L
	CP   EŠREST:	POP  HL			;restore previous row
	JR   NZ,RTN		;return if first counter <> second counter
	POP  AF			;restore previous column bits
	CPL			;clear previous row
	AND  (HL)
	LD   (HL),A
	LD   A,1		;set repeat mode
	LD   (REPEAT),A
	LD   HL,0		;clear first counter
	LD   (COUNT1),HL
	LD   HL,(DELAY4)	;initialize second counter
	LD   (COUNT2),HL
	POP  AF			;adjust stack pointer
	JR   SCAN		;scan keyboard again
RTN:	POP  AF			;restore column bits
	POP  AF
	RET			;no key active - return

;fist debounce routine:
ACTIVE:	LD   E,A		;save column bits
	PUSH BC			;save active row address
	LD   BC,(DELAY1)	;delay count value
	CALL DELAY		;delay for 7.33 milliseconds (may be varied)
	POP  BC			;restore row address
	LD   A,(BC)		;and reload original flags from active row
	AND  E			;then combine current flag bits with original
				;flag bits
	RET  Z			;rtn to caller if zero because row was not
				;active on 2nd test
	LD   (OLDROW),HL	;save row

;calculate ordinal number of pressed key:
	LD   A,D		;otherwise we have a legimately active row
	RLCA			;row index * 2
	RLCA			;row index * 4
	RLCA			;row index * 8
	LD   D,A		;save in D
	LD   C,1		;start with bit 0
AGAIN:	LD   A,C		;mask
	AND  E			;test for non-zero column
	JR   NZ,FOUND		;go if found
	INC  D			;bump column number
	RLC  C			;align mask
	JR   AGAIN		;try again
FOUND:	LD   A,C		;column bits --> accu
	LD   (OLCLMN),A		;store them
	LD   E,D		; row * 8 + column (0 - 7)  --> reg. DE
	LD   D,0
	LD   H,D		; row * 8 + column (0 - 7)  --> reg. HL
	LD   L,E
	ADD  HL,HL		;(row * 8 + column (0 - 7)) * 2
	ADD  HL,DE		;(row * 8 + column (0 - 7)) * 3

;get ASCII code of pressed key:
	LD   BC,(KEYTAB)	;^table of ASCII codes --> reg. BC
	ADD  HL,BC		;calculate ^ASCII code of pressed key
	LD   A,(3880H)		;load SHIFT bit
	BIT  0,A		;SHIFT ?
	JR   Z,CTRL		;jump if not
	INC  HL			;adjust table pointerŠ	JR   LOCK
CTRL:	BIT  1,A		;CTRL ?
	JR   Z,LOCK		;jump if not
	INC  HL			;adjust table pointer
	INC  HL
	LD   A,(HL)		;get ASCII code
	JR   DBOUNCE

;check if caps lock:
LOCK:	LD   A,(38E0H)		;load LOCK bit
	BIT  3,A		;LOCK ?
	JR   Z,UMLAUT		;jump if not
	LD   A,(HL)		;restore char
	CP   'a'		;is it a letter ?
	JR   C,DBOUNCE		;jump if not
	LD   A,(GERMAN)		;German character set ?
	OR   A
	LD   A,(HL)		;restore char
	JR   Z,UCAPS		;jump if US-ASCII
	CP   DEL
	JR   NC,DBOUNCE		;adjust to lower case
	JR   UCASE
UCAPS:	CP   '{'		;adjust to lower case
	JR   NC,DBOUNCE
UCASE:	AND  5FH		;force upper case
	JR   DBOUNCE

;check if German character set:
UMLAUT:	LD   A,(GERMAN)		;German character set ?
	OR   A
	LD   A,(HL)		;restore char
	JR   Z,DBOUNCE		;jump if US-ASCII
	LD   A,(3880H)		;load SHIFT bit
	BIT  0,A		;SHIFT ?
	LD   A,(HL)		;restore char
	JR   NZ,SHIFT		;jump if SHIFT
	CP   '['		;"Umlaut" ?
	JR   C,DBOUNCE		;jump if not
	CP   '_'
	JR   NC,DBOUNCE
	JR   FILTER
SHIFT:	CP   '{'		;"Umlaut" ?
	JR   C,DBOUNCE		;jump if not
	CP   DEL
	JR   NC,DBOUNCE
FILTER:	XOR  20H		;change to upper/lower case

;second debounce routine:
DBOUNCE:LD   D,A		;save character
	LD   A,(REPEAT)		;auto repeat ?
	OR   A
	JR   NZ,NBOUNCE		;no debounce if repeat mode
	LD   BC,(DELAY2)	;load delay count
	CALL DELAY		;delay
NBOUNCE:LD   A,D		;A = ASCII - like character
	RET			;return

KEYBRD:	DEFB 80H,0C0H,0A0H,40H,20H,10H,08H,04H,02H,01H
GERMAN:	DEFB 0			;switch bit to alter character set
				;(0 = US-ASCII, FF = German)ŠKEYHLD:	DEFB 0,0,0,0,0,0	;keyboard work area
	DEFB 0,0,0,0,0
COUNT1:	DEFW 0			;delay counters for auto repeat function
COUNT2:	DEFW 0
OLDROW:	DEFW 0			;temporary memory for keyboard driver
OLCLMN:	DEFB 0
RDYKEY:	DEFB 0			;key code memory
REPEAT:	DEFB 0			;repeat mode


;EJECT
;*******************
;*  $ K B W A I T  *
;*******************

;exit: A = char

;wait for a keyboard character:

;scan for special function key:
$KBWAIT:LD   A,(COUNT3)		;letter counter --> accu
	OR   A			;test it
	JR   Z,DZERO		;jump if counter empty
	DEC  A			;decrement counter
	LD   (COUNT3),A		;store it
	LD   HL,(FPTR)		;load letter pointer
	LD   A,(HL)		;load next letter
	INC  HL			;bump letter pointer
	LD   (FPTR),HL		;store it
	LD   C,A		;save active key
	LD   A,(HL)		;get next key
	LD   (RDYKEY),A		;store that sucker
	LD   A,C		;restore active key
	JP   TSTKEY+2

;scan for special key "00":
DZERO:	LD   HL,RDYKEY		;^scanned key --> reg. HL
	LD   A,(HL)		; scanned key --> accu
	CP   0FBH		;is it PRINT ?
	JR   Z,PRINT		;jump if yes
	CP   0FCH		;is it SHIFT - CLEAR ?
	JR   Z,ERASE		;jump if yes
	CP   0FDH		;is it SHIFT - BREAK ?
	JR   Z,GERSET		;jump if yes
	CP   0FEH		;is it "00" ?
	JR   C,FKEY		;jump if not
	INC  A			;bump "00"-counter
	LD   (HL),A		;store "00"-counter
	LD   A,'0'		;return one zero
	RET			;return to caller
PRINT:	PUSH HL			;save reg. HL
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	LD   HL,$SCREEN		;address of first screen location --> reg. HL
	LD   IX,(VDTABP)	;^current parameter table	  --> reg. IXŠ	LD   A,(IX)		;line count of screen		  --> reg. D
	LD   D,A
PRINT1:	LD   A,(IX+1)		;column count of screen 	  --> reg. B
	LD   B,A
PRINT2:	LD   A,(HL)		;screen character		  --> accu
	AND  7FH		;mask it
	INC  HL			;bump screen pointer
	CALL PRCHR0		;output character to printer 0
	DJNZ PRINT2		;repeat "column count" times
	LD   A,CR		;output a carriage return
	CALL PRCHR0
	LD   A,LF		;output a line feed
	CALL PRCHR0
	DEC  D			;decrement line counter
	JR   NZ,PRINT1		;print next line
	POP  HL			;restore reg. HL
	JR   GERSE3		;go on
ERASE:	LD   A,SUB
	PUSH HL
	CALL $VDCHAR		;clear screen
	POP  HL
	JR   GERSE3		;go on
GERSET:	PUSH HL
	LD   A,ESC
	CALL $VDCHAR
	LD   A,(GERMAN)		;load switch bit for changing char set
	CPL			;invert it
	LD   (GERMAN),A		;store it
	OR   A
	JR   Z,GERSE1
	LD   A,'G'		;load German character set
	JR   GERSE2
GERSE1:	LD   A,'A'		;load ASCII character set
GERSE2:	CALL $VDCHAR
	POP  HL
GERSE3:	XOR  A			;clear key code
	JR   TSTKEY

;test if function key:
FKEY:	BIT  7,A		;check if code >= 80H
	JR   Z,TSTKEY		;jump if not
	PUSH HL			;save ^key memory
	LD   C,A		;save key code
	LD   E,A
	LD   HL,VECTOR		;^function key vector --> reg. HL
	LD   A,(HL)		;function key vector = 0 ?
	LD   D,A		;save LSB of key vector
	INC  HL
	OR   (HL)
	JR   Z,FKEYEND		;jump if no special function
	LD   H,(HL)		;function key vector --> reg. HL
	LD   L,D
	LD   D,0
	SLA  E			;most significant 7 bits of code * 2
	ADD  HL,DE		;calculate vector address
	LD   A,(HL)		;no special function ?
	LD   E,A
	INC  HL
	LD   D,(HL)
	OR   DŠ	JR   Z,FKEYEND
	LD   A,(DE)		;vector --> accu
	LD   (COUNT3),A		;load counter
	INC  DE
	LD   (FPTR),DE		;load address of first function key character
	POP  HL			;adjust stack pointer
	JP   $KBWAIT
FKEYEND:LD   A,C		;restore original key code
	POP  HL			;restore ^key memory

;test key memory if legal code:
TSTKEY:	LD   (HL),0		;clear key memory
	OR   A			;legal key code ?
	RET  NZ			;return to caller

;scan keyboard:
	CALL $KBCHAR		;scan keyboard
	JP   $KBWAIT		;test if active key

COUNT3:	DEFB 0			;letter counter for function keys
FPTR:	DEFW 0			;letter pointer for function keys


;EJECT
;*******************
;*  $ V D C H A R  *
;*******************

;entry: A = char

$BUZZ	EQU  3860H		;buzzer address
$SCREEN	EQU  3800H		;address of first screen location

;character output routine:
$VDCHAR:LD   C,A		;save character
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	LD   A,C		;restore character

	LD   IX,(VDTABP)	;^^screen constants --> reg. IX
	LD   HL,ESCAPE		;test if escape sequence
	BIT  2,(HL)
	JR   NZ,ESCSQ2		;cursor addressing routine
	BIT  1,(HL)
	JR   NZ,ESCSQ1		;handle second byte of escape sequence
	BIT  0,(HL)
	JR   NZ,ESCSEQ		;handle first byte of escape sequence
	CP   ESC		;char = ESC ?
	JR   NZ,NORMAL		;jump if normal ASCII char
	SET  0,(HL)		;remark escape sequence
	RET

;handling of single byte ASCII's:
NORMAL:	CP   20H		;control char ?
	JR   C,CNTRLŠ	LD   L,A		;save char
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	LD   A,L		;restore char
	OR   A			;ASCII code > 80H ?
	JP   P,NORMAL1		;jump if not
	CP   0A0H		;ASCII code > 0A0H ?
	JR   NC,NORMAL1		;jump if yes
	SUB  80H		;convert code if special char
NORMAL1:OR   (IX+11)		;put invert mask over character
	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   (HL),A		;output char
	JP   CURRGT		;output cursor

;handling of control codes:
CNTRL:	OR   A			;control code = 0 ?
	RET  Z
	LD   HL,TAB1E+1		;^end of control code table --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length		    --> reg. BC
CAGAIN:	CPDR			;search char
	RET  NZ			;return to caller if not found
	INC  (HL)		;escape sequence ?
	DEC  (HL)
	JR   NZ,CAGAIN		;search next char
	JR   ESCEND

;first entry into escape sequence:
ESCSEQ:	RES  0,(HL)		;reset escape bit
	LD   HL,TAB1E+1		;^end of ESC-sequence-table-1 --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length		      --> reg. BC
EAGAIN:	CPDR			;search char
	RET  NZ			;return to caller if not found
	INC  (HL)		;escape sequence ?
	DEC  (HL)
	JR   Z,EAGAIN		;search next char
ESCEND:	LD   HL,CTRLJP		;jump vector --> reg. HL
	DEC  BC			;calc jump address
	ADD  HL,BC
	LD   C,(HL)		;jump address --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute function

;second entry into escape sequence:
ESCSQ1:	RES  1,(HL)		;reset second escape bit
	SUB  20H		;adjust line/column no.
	LD   D,A		;save it
	LD   A,(ESCCHR)		;load first byte of escape sequence
	LD   HL,TAB2E+1		;^end of ESC-sequence-table-2 --> reg. HL
	LD   BC,TAB2E-TAB2S+2	;table length		      --> reg. BC
	CPDR			;search char
	LD   HL,ESCJP		;^jump vector
	LD   A,D		;restore line/column no.
	JR   ESCEND+3

;third entry into escape sequence:
ESCSQ2:	RES  2,(HL)		;reset third escape bit
	SUB  20H		;adjust column no.Š	CP   (IX+7)		;legal column no. ?
	RET  NC			;return if not
	ADD  A,(IX+3)		;add left column
	LD   (IX+9),A		;store new column no.
	LD   A,(LINE)		;fetch new line no.
	ADD  A,(IX+2)		;add top line
	LD   (IX+8),A		;store it
	CALL OUTCUR		;output cursor
	JP   CURON+4		;turn on cursor

;handle first byte of two or three byte escape sequence:
ESC1ST:	LD   (ESCCHR),A		;store first byte of escape sequence
	LD   HL,ESCAPE
	SET  1,(HL)		;remark it
	RET

;handle second byte of three byte escape sequence:
ESC2ND:	CP   (IX+6)		;legal line no. ?
	RET  NC			;return if not
	LD   (LINE),A		;save new line
	LD   HL,ESCAPE
	SET  2,(HL)		;remark cursor addressing sequence
	RET

;beep:
BEEP:	IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11000110B		;enable memory mapped I/O
				;disable graphic page
				;enable buzzer
	OUT  ($SYS1),A		;write system byte 1

	LD   BC,0		;repeat counter --> reg. B
				;  wait counter --> reg. C
	DI			;force clean tone
BEEP1:	LD   A,($BUZZ)		;turn on buzzer
	PUSH BC			;save base value of wait counter
BUZZON:	NOP			;little delay for lower frequency
	NOP
	NOP
	DEC  C			;decrement wait counter
	JR   NZ,BUZZON		;wait `til end of buzz
	POP  BC			;restore wait counter
	DJNZ BEEP1		;turn on buzzer eleven times
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A		;write it
	RET

;cursor left:
CURLFT:	LD   A,(IX+3)		;left column --> accu
	CP   (IX+9)		; > current column ?
	JP   M,CURLFT1		;jump if not
	LD   A,(WRAP)		;wrap around mode ?
	OR   A
	RET  Z			;return if not
	LD   A,(IX+5)		;right column --> current column
	LD   (IX+9),A
	JR   CURUP
CURLFT1:DEC  (IX+9)		;decrement column no.
	JP   INSLI3Š
;cursor down:
CURDWN:	LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; >= bottom line ?
	JP   P,CURDW1		;scroll up if yes
	INC  (IX+8)		;increment line no.
	JP   OUTCUR
CURDW1:	LD   A,(IX+2)		;top line --> current line
	LD   (IX+8),A
	JP   SCRLU		;scroll window up one line

;cursor up:
CURUP:	LD   A,(IX+2)		;top line --> accu
	CP   (IX+8)		; >= current line ?
	RET  P			;return if yes
	DEC  (IX+8)		;decrement line
	JP   OUTCUR

;cursor right:
CURRGT:	LD   A,(IX+5)		;right column --> accu
	CP   (IX+9)		;right column >= current column ?
	RET  M			;return if cursor beyond right column
	PUSH AF			;save status reg.
	INC  (IX+9)		;increment column no.
	POP  AF			;restore status reg.
	JP   NZ,OUTCUR		;output cursor
	LD   A,(WRAP)		;wrap around mode ?
	OR   A
	JP   Z,CUROFF+4		;turn cursor off
	LD   A,(IX+3)		;left column  --> current column
	LD   (IX+9),A
	CALL OUTCUR		;output cursor
	JR   CURDWN		;perform line feed

;carriage return:
NEWLIN:	LD   A,(IX+3)		;left column  --> current column
	LD   (IX+9),A
	JP   INSLI3		;output cursor

;home cursor:
HOME:	LD   A,(IX+2)		;top line    --> current line
	LD   (IX+8),A
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	JP   OUTCUR		;output cursor

;select window:
WINDOW:	LD   C,A		;save window #
	LD   A,(STONOFF)	;status line enabled ?
	RET  NZ			;return if yes
	LD   A,C		;restore window #
	OR   A			;window # < 0 ?
	RET  M			;return if yes
	CP   8			;window # > 7 ?
	RET  NC			;return if yes
	ADD  A,A		;multiply window number by 13
	ADD  A,C
	ADD  A,A
	ADD  A,A
	ADD  A,CŠ	LD   B,0		;window number * 13 --> reg. BC
	LD   C,A
	LD   HL,VDTAB		;^screen constants  --> reg. HL
	ADD  HL,BC		;calc current table entry
	LD   (VDTABP),HL	;store it
	PUSH HL			;^screen constants  --> reg. IX
	POP  IX
	LD   A,(IX+12)		;cursor off ?
	OR   A
	JR   Z,WINDOW2		;jump if not
WINDOW1:CALL CUROFF+4		;turn off cursor
	JP   OUTCUR		;output cursor & return to caller
WINDOW2:LD   A,(IX+5)		;right column --> accu
	CP   (IX+9)		;right column >= current column ?
	JR   C,WINDOW1		;turn off cursor beyond right column
	CALL OUTCUR		;position cursor
	JR   CURON+4		;turn on cursor & return to caller

;set top line:
SETTOP:	CP   (IX)		;legal	line/column no. ?
	RET  NC			;return if not
	LD   B,A		;save line/column
	SUB  (IX+4)		;top	line   - bottom line
				;left	column - right	column
	NEG			;bottom line   - top	line
				;right	column - left	column
	JP   M,SETTO1		;jump if illegal top line/left column
	INC  A			;adjust line/column count
	LD   (IX+6),A		;store new line/column count
SETTO1:	LD   A,B		;restore line column
	RET  M
	LD   (IX+2),A		;store new top line/left column
	CP   (IX+8)		;current line	> top  line ?
				;current column > left column ?
	RET  C			;return to caller if yes
SETTO2:	LD   (IX+8),A		;store new current line/column
	LD   IX,(VDTABP)	;adjust ^screen constants
	JP   OUTCUR		;output cursor

;set bottom line:
SETBOT:	CP   (IX)		;legal	line/column no. ?
	RET  NC			;return if not
	LD   B,A		;save line/column
	SUB  (IX+2)		;bottom line   - top  line
				;right	column - left column
	JP   M,SETTO1		;jump if illegal bottom line/left column
	INC  A			;adjust line/column count
	LD   (IX+6),A		;store new line/column count
	LD   A,B		;restore line column
	LD   (IX+4),A		;store new bottom line/left column
	CP   (IX+8)		;current line	> bottom line ?
				;current column > right  column ?
	RET  P			;return to caller if not
	JR   SETTO2

;set left column:
SETLFT:	INC  IX			;adjust ^screen constants
	JR   SETTOP		;set left column

;set right column:ŠSETRGT:	INC  IX			;adjust ^screen constants
	JR   SETBOT		;set right column

;set erase character:
SETERA:	ADD  A,20H		;restore ASCII code of erase character
	CP   80H		;ASCII between 80H and 9FH ?
	JR   C,SETERA1
	CP   0A0H
	JR   NC,SETERA1
	RES  7,A		;make code between 00H and 1Fh
SETERA1:LD   (IX+10),A		;store new erase character
	RET			;return to caller

;turn off cursor:
CUROFF:	LD   (IX+12),0FFH	;store remark byte
	LD   A,10		;CRTC register no. --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,20H
	OUT  ($CRTCMD),A	;turn off cursor
	RET

;turn on cursor:
CURON:	LD   (IX+12),0		;clear remark byte
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	LD   A,(IX+12)		;load remark byte
	OR   A			;test remark byte
	RET  NZ			;no action if cursor is invisible
	LD   A,10		;CRTC register no. --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,(CURBEG)		;cursor image	   --> accu
	OUT  ($CRTCMD),A	;turn on cursor
	RET

;set ASCII character set:
SETASC:	XOR  A			;clear accu
SETAS1:	LD   (GERMAN),A		;set ASCII char set
	JP   SELCHR		;select ASCII character set and ret to caller

;disable status line:
STATOFF:LD   A,(STONOFF)	;status line enabled ?
	OR   A
	RET  Z			;return if not
	XOR  A			;clear marker
	LD   HL,VDTEMP		;restore screen parameter table
	JR   STATO1

;enable status line:
STATON:	LD   A,(STONOFF)	;status line already enabled ?
	OR   A
	RET  NZ			;return if yes
	CPL			;set marker
	LD   HL,(VDTABP)	;save screen parameter table
	LD   DE,VDTEMP
	LD   BC,13
	LDIR
	LD   HL,VDSTAT		;setup status line parameters
STATO1:	LD   DE,(VDTABP)
	LD   BC,13Š	LDIR
	LD   (STONOFF),A	;store marker
	JP   OUTCUR		;output cursor

;set German character set:
SETGER:	LD   A,0FFH		;set accu to ones
	JR   SETAS1		;set German char set

;switch on normal keyboard:
SETNKB:	LD   HL,NBOARD		;^normal key table  --> reg. HL
SETNK1:	LD   (KEYTAB),HL	;store it
	RET			;return to caller

;switch on WordStar keyboard:
SETWKB:	LD   HL,WBOARD		;^WordStar key table --> reg. HL
	JR   SETNK1

;turn on inverse display mode:
INVON:	LD   (IX+11),80H	;store invert mask
	RET

;turn off inverse display mode:
INVOFF:	LD   (IX+11),0		;clear invert mask
	RET

;turn on wrap around mode:
WRAPON:	LD   A,0FFH
	LD   (WRAP),A		;remember wrap around mode
	RET

;turn off wrap around mode:
WRAPOFF:XOR  A
	LD   (WRAP),A
	RET

;insert character:
INSCHR:	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   A,(IX+5)		;right column		 --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	JR   Z,INSCH1		;no columns to shift
	LD   B,0		;no of columns to shift --> reg. BC
	LD   C,A
	ADD  HL,BC		;now HL contains address of last column
	LD   D,H
	LD   E,L		;now DE contains address of last column
	DEC  HL			;now HL contains address of last column - 1
	LDDR			;shift rest of line right one char
	INC  HL			;now HL contains current cursor address
INSCH1:	LD   A,(IX+10)		;get erase char
	LD   (HL),A		;insert one space at current cursor location
	RET

;insert line:
INSLIN:	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	LD   A,(IX+4)		;bottom line --> accu
	SUB  (IX+8)		;calc. no. of lines to scroll
	LD   B,(IX+4)		;bottom line --> current line
	LD   (IX+8),BŠINSLI1:	JR   Z,INSLI2		;return if line count = 0
	CALL CALC		;calculate start position
	PUSH HL			;save it
	LD   D,0		;maximum column count --> reg. DE
	LD   E,(IX+1)
	SBC  HL,DE		;now HL contains ^(last line - 1)
	POP  DE			;restore ^last line
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll down one line
	DEC  (IX+8)		;decrement current line
	DEC  A			;decrement counter
	JR   INSLI1		;scroll down all lines
INSLI2:	CALL ERAEOLN		;erase current line
INSLI3:	CALL OUTCUR		;output cursor
	JP   CURON+4		;turn on cursor

;delete character:
DELCHR:	LD   HL,(CURADR)	;absolute screen address  --> reg. HL
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	JR   Z,INSCH1		;no columns to shift
	LD   B,0		;no. of columns to shift --> reg. BC
	LD   C,A
	LD   D,H
	LD   E,L		;now DE contains absolute screen address
	INC  HL			;now HL contains absolute screen address + 1
	LDIR			;shift rest of line left one char
	DEC  HL			;now HL contains address of last column
	JR   INSCH1		;insert one space at last column

;erase to end of line:
ERAEOLN:CALL CALC		;calculate absolute screen address
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;now accu contains number of columns to erase
	RET  M			;return if cursor beyond right column
	LD   C,(IX+10)		;get erase char
ERAEO1:	LD   (HL),C		;clear column
	INC  HL			;bump column ptr
	DEC  A			;decrement column counter
	JP   P,ERAEO1		;erase all columns right to the cursor
	RET

;delete line:
DELLIN:	LD   A,(IX+3)		;left  column --> current column
	LD   (IX+9),A
	LD   A,(IX+8)		;current line no. --> accu
	PUSH AF			;save it
	CALL SCRLU		;scroll rest of window up one line
	POP  AF
	LD   (IX+8),A		;restore current line
	JR   INSLI3		;output cursor

;erase to end of screen:
ERAEOS:	CALL ERAEOLN		;erase to end of first line
	LD   B,(IX+8)		;save current line
	LD   C,(IX+9)		;save current column
	PUSH BC
	LD   A,(IX+3)		;left column --> current columnŠ	LD   (IX+9),A
	LD   A,(IX+4)		;bottom line --> accu
	SUB  B			;now accu contains number of lines to erase
	LD   B,A		;counter --> reg. B
	JR   Z,ERAES2		;no further lines to erase
ERAES1:	INC  (IX+8)		;increment current line
	PUSH BC			;save counter
	CALL ERAEOLN		;erase current line
	POP  BC			;restore counter
	DJNZ ERAES1		;erase to end of whole window
ERAES2:	POP  BC
	LD   (IX+8),B		;restore original line	 no.
	LD   (IX+9),C		;restore original column no.
	RET

;clear screen:
ERAALL:	CALL HOME		;home cursor
	JR   ERAEOS		;clear to end of screen

;output cursor:
OUTCUR:	CALL CALC		;calculate absolute screen address
	LD   (CURADR),HL	;store it
	LD   DE,$SCREEN		;base address of video RAM --> reg. DE
	OR   A			;clear carry flag
	SBC  HL,DE		;subtract base address from current cursor
				;address
	LD   C,$CRTREG		;CRTC address register --> reg. C
	LD   A,14		;CRTC register number  --> accu
	OUT  (C),A		;select CRTC register
	INC  C			;CRTC command register --> reg. C
	OUT  (C),H		;output cursor address (MSB)
	INC  A			;increment CRTC register no.
	DEC  C			;decrement port number
	OUT  (C),A		;select CRTC register
	INC  C			;CRTC command register --> reg. C
	OUT  (C),L		;output cursor address (LSB)
	RET

;scroll up routine:
SCRLU:	LD   A,(IX+9)		;current column --> accu
	PUSH AF			;save it
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	LD   A,(IX+4)		;bottom line  --> accu
	SUB  (IX+8)		;calc. no. of lines to scroll
SCRLU1:	JR   Z,SCRLU2		;clear last line if count = 0
	CALL CALC		;calculate start position
	PUSH HL			;save it
	LD   D,0		;maximum column count --> reg. DE
	LD   E,(IX+1)
	ADD  HL,DE		;now HL contains address of line to scroll
	POP  DE			;restore ^line before
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll up one line
	INC  (IX+8)		;increment current line
	DEC  A			;decrement counter
	JR   SCRLU1		;scroll up all lines
SCRLU2:	CALL ERAEOLN		;clear last line
	POP  AF			;restore column no.Š	LD   (IX+9),A		;store it
	RET

;calculate absolute cursor address:
CALC:	LD   HL,$SCREEN		;address of first screen loc --> reg. HL
	LD   D,0		;maximum column count	     --> reg. DE
	LD   E,(IX+1)
	LD   B,(IX+8)		;current line		     --> reg. B
	DEC  B
	INC  B
	JR   Z,CALC2		;jump if line no. = 0
CALC1:	ADD  HL,DE
	DJNZ CALC1		;handle all lines
CALC2:	LD   E,(IX+9)		;current column --> reg. DE
	ADD  HL,DE		;now HL contains absolute screen address
	RET

;jump vectors:
CTRLJP:	DEFW BEEP,CURLFT,CURDWN,CURUP,CURRGT,NEWLIN,HOME,ESC1ST,ESC1ST,ESC1ST
	DEFW ESC1ST,ESC1ST,ESC1ST,ESC1ST,CUROFF,CURON,SETASC,STATOFF,STATON
	DEFW SETGER,SETNKB,SETWKB,INVON,INVOFF,WRAPON,WRAPOFF,INSCHR,INSLIN
	DEFW DELCHR,ERAEOLN,DELLIN,ERAEOS,ERAALL
ESCJP:	DEFW ESC2ND,WINDOW,SETTOP,SETBOT,SETLFT,SETRGT,SETERA

;table of screen constants:
VDTABP:	DEFW VDTAB
VDTAB:	REPT 8
	DEFB 24			;maximum line	count
	DEFB 80			;maximum column count
	DEFB 0			;top	 line
	DEFB 0			;left	 column
	DEFB 23			;bottom  line
	DEFB 79			;right	 column
	DEFB 24			;line	 count
	DEFB 80			;column  count
	DEFB 0			;current line
	DEFB 0			;current column
	DEFB ' '		;erase	 character
	DEFB 0			;0 = normal mode,  80H = inverse mode
	DEFB 0			;0 = cursor on	, 0FFH = cursor off
	 ENDM

;status line constants:
VDSTAT:	DEFB 25			;maximum line	count
	DEFB 80			;maximum column count
	DEFB 24			;top	 line
	DEFB 0			;left	 column
	DEFB 24			;bottom  line
	DEFB 79			;right	 column
	DEFB 1			;line	 count
	DEFB 80			;column  count
	DEFB 24			;current line
	DEFB 0			;current column
	DEFB ' '		;erase	 character
	DEFB 0			;0 = normal mode,  80H = inverse mode
	DEFB 0			;0 = cursor on	, 0FFH = cursor off

ESCAPE:	DEFB 0			;contains escape remarks
ESCCHR:	DEFB 0			;memory for escape char
LINE:	DEFB 0			;memory for line numberŠCURADR:	DEFW 3800H		;memory for absolute cursor address
WRAP:	DEFB 0			;0 = normal mode, 0FFH = wrap around mode
STONOFF:DEFB 0			;0 = status line off, 0FFH = status line on
VDTEMP:	DEFS 13			;temporary storage area for screen constants


;EJECT
;*******************
;*  $ P R S T A T  *
;*******************

;entry: B = number of Centronics interface (0, 1)

;exit : A = printer status
;	0 = printer ready
;    <> 0 = printer not ready

;calc entry of printer status routine:
$PRSTAT:LD   HL,PSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute printer status routine

;printer status routine entry table:
PSTAB:	DEFW PRSTA0,PRSTA1

;test status of printer 0:
$PTR0	EQU  0FDH		;printer port 0

PRSTA0:	IN   A,($PTR0)		;read printer status
	AND  0F0H		;mask it
	XOR  30H
	RET			;return to caller

;test status of printer 1:
$PTR1	EQU  0D5H		;printer port 1

PRSTA1:	IN   A,($PTR1)		;read printer status
	AND  0F0H		;mask it
	XOR  30H
	RET			;return to caller


;EJECT
;*******************
;*  $ P R C H A R  *
;*******************

;entry: A = char
;	B = number of Centronics interface (0, 1)

;calc entry of printer output routine:
$PRCHAR:LD   HL,POTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entryŠ	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute printer output routine

;printer output routine entry table:
POTAB:	DEFW PRCHR0,PRCHR1

;output a character to printer 0:
PRCHR0:	LD   C,A		;save char
	CALL PRSTA0		;test status of printer 0
	JR   NZ,PRCHR0+1	;wait for printer ready
	LD   A,C		;restore char
	OUT  ($PTR0),A		;print it
	RET			;return to caller

;output a character to printer 1:
$PTR1D	EQU  0D4H		;data port of PIO

PRCHR1:	LD   C,A		;save char
	CALL PRSTA1		;test status of printer 0
	JR   NZ,PRCHR1+1	;wait for printer ready
	LD   A,C		;restore char
	OUT  ($PTR1D),A		;output it
	XOR  A
	OUT  ($PTR1),A		;set STROBE
	INC  A
	OUT  ($PTR1),A		;clear STROBE

	RET			;return to caller


;EJECT
;*******************
;*  $ R S R C S T  *
;*******************

;entry: B = number of RS232C interface (0, 1)

;exit : A = input status
;	0 = no char available
;    <> 0 = char available

;calc entry of RS232C input status routine:
$RSRCST:LD   HL,RSSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine

;RS232C input status routine entry table:ŠRSSTAB:	DEFW RSRCSA,RSRCSB

;get input status of SIO A:
RSRCSA:	IN   A,(WR0A)		;read status
	AND  1			;character available ?
	RET  NZ			;return to caller if yes
	LD   B,A		;load counter
	LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0A),A		;request to send
RSRCSA1:IN   A,(WR0A)		;read status
	BIT  0,A		;character available ?
	JR   NZ,RSRCSA2		;jump if character ready
	DJNZ RSRCSA1		;scan 256 times
	LD   C,0		;no character available
	JR   RSRCSA3
RSRCSA2:LD   C,1		;character available
RSRCSA3:LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	OUT  (WR0A),A		;data terminal ready
	LD   A,C		;get input status
	RET

;get input status of SIO B:
RSRCSB:	IN   A,(WR0B)		;read status
	AND  1			;character available ?
	RET  NZ			;return to caller if yes
	LD   B,A		;load counter
	LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0B),A		;request to send
RSRCSB1:IN   A,(WR0B)		;read status
	BIT  0,A		;character available ?
	JR   NZ,RSRCSB2		;jump if character ready
	DJNZ RSRCSB1		;scan 256 times
	LD   C,0		;no character available
	JR   RSRCSB3
RSRCSB2:LD   C,1		;character available
RSRCSB3:LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	OUT  (WR0B),A		;data terminal ready
	LD   A,C		;get input status
	RET


;EJECT
;*****************
;*  $ R S R C V  *
;*****************

;entry: B = number of RS232C interface (0, 1)

;exit : A = char
Š;calc entry of RS232C input routine:
$RSRCV:	LD   HL,RSRTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine

;RS232C input routine entry table:
RSRTAB:	DEFW RSRCVA,RSRCVB

;read character from SIO A:
DRA	EQU  0D0H		;data register of SIO A

RSRCVA:	IN   A,(WR0A)		;read status
	BIT  0,A		;character available ?
	JR   NZ,RSRCVA2		;jump if yes
	LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0A),A		;request to send
RSRCVA1:IN   A,(WR0A)		;read status
	BIT  0,A		;character available ?
	JR   Z,RSRCVA1		;loop `til character ready
	LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	OUT  (WR0A),A		;data terminal ready
RSRCVA2:IN   A,(DRA)		;read character
	RET

;read character from SIO B:
DRB	EQU  0D1H		;data register of SIO A

RSRCVB:	IN   A,(WR0B)		;read status
	BIT  0,A		;character available ?
	JR   NZ,RSRCVB2		;jump if yes
	LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0B),A		;request to send
RSRCVB1:IN   A,(WR0B)		;read status
	BIT  0,A		;character available ?
	JR   Z,RSRCVB1		;loop `til character ready
	LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	OUT  (WR0B),A		;data terminal ready
RSRCVB2:IN   A,(DRB)		;read character
	RET


;EJECT
;*******************Š;*  $ R S T X S T  *
;*******************

;entry: B = number of RS232C interface (0, 1)

;exit : A = terminal status
;	0 = data terminal ready
;    <> 0 = data terminal not ready

;get output status of SIO:
$RSTXST:LD   A,WR0A		;control register of SIO A --> accu
	ADD  A,B		;add relative port number
	LD   C,A		;absolute port address --> reg. C
	LD   A,10H
	OUT  (C),A		;reset ext/status interrupts
	IN   A,(C)		;read status
	AND  2CH		;buffer empty, data set ready, clear to send ?
	SUB  2CH
	RET


;EJECT
;***************
;*  $ R S T X  *
;***************

;entry: A = char
;	B = number of RS232C interface (0, 1)

;write character to SIO:
$RSTX:	LD   E,A		;save character
	CALL $RSTXST		;test output status
	JR   NZ,$RSTX+1		;wait for CTS
	DEC  C
	DEC  C			;now reg. C points to data port
	OUT  (C),E		;output character
	RET


;EJECT
;disk driver:

;FDC registers:
$FDSEL	EQU  0E0H		;FDC select  register
$FDCMD	EQU  0ECH		;FDC command register
$FDSTAT	EQU  0ECH		;FDC status  register
$FDTRK	EQU  0EDH		;FDC track   register
$FDSIZ	EQU  0EEH		;FDC size    register
$FDSEC	EQU  0EEH		;FDC sector  register
$FDDATA	EQU  0EFH		;FDC data    register

;FDC commands:
$SEEK	EQU  10H		;seek
$RDSEC	EQU  88H		;read sector
$WRSEC	EQU  0A8H		;write sector
$SET8	EQU  0C0H		;set disk size to 5 inch
$FCINT	EQU  0D0H		;force interrupt
$DDDEN	EQU  0FFH		;set double density

Š;***************
;*  $ R E A D  *
;***************

;entry: A  = drive  number	     (lower nibble)
;	     bank   number of buffer (upper nibble)
;	B  = sector number
;	E  = track  number
;	HL = buffer pointer

;exit : A = error code
;	0 = NO ERROR
;	1 = ILLEGAL DRIVE #
;	2 = TRACK # TOO HIGH
;	3 = SECTOR # TOO HIGH
;	4 = DEVICE NOT AVAILABLE
;	6 = TRIED TO READ LOCKED/DELETED RECORD
;	7 = DATA RECORD NOT FOUND DURING READ
;	8 = PARITY ERROR DURING READ
;	9 = LOST DATA DURING READ

;read a sector:
$READ:	LD   C,A		;save drive #/bank #
	LD   A,0FFH		;set READ-flag
	JR   TASK


;EJECT
;*****************
;*  $ W R I T E  *
;*****************

;entry: A  = drive  number	     (lower nibble)
;	     bank   number of buffer (upper nibble)
;	B  = sector number
;	E  = track  number
;	HL = buffer pointer

;exit : A = error code
;	0 = NO ERROR
;	1 = ILLEGAL DRIVE #
;	2 = TRACK # TOO HIGH
;	3 = SECTOR # TOO HIGH
;	4 = DEVICE NOT AVAILABLE
;	5 = WRITE PROTECTED DISKETTE
;	6 = WRITE FAULT ON DISK DRIVE
;	7 = DATA RECORD NOT FOUND DURING WRITE
;	8 = PARITY ERROR DURING WRITE
;	9 = LOST DATA DURING WRITE

;write a sector:
$WRITE:	LD   C,A		;save drive #/bank #
	XOR  A			;clear READ-flag

;dominant controller:
TASK:	LD   (RDFLAG),A		;set/reset READ-flag
	LD   A,C		;restore drive/bank #
	RRA			;get bank number of transfer buffer
	RRA
	RRAŠ	RRA
	AND  0FH
	LD   (BANK),A		;store bank #
	LD   A,C		;restore drive/bank #
	AND  0FH		;mask drive #
	CP   8			;legal drive # ?
	JR   C,TRKNO		;jump if yes
	LD   A,1		;error code 1 --> accu
	RET
TRKNO:	LD   (DRIVE),A		;store drive #
	LD   (BUFFER),HL	;store buffer pointer
	CALL GETDCT		;get control table ptr
	LD   A,E		;track # --> accu
	CP   (IX+4)		;legal track # ?
	JR   C,SECNO		;jump if yes
	LD   A,2		;error code 2 --> accu
	RET
SECNO:	LD   (TRACK),A		;store track #
	LD   A,B		;sector # --> accu
	CP   (IX+3)		;legal sector # ?
	JR   C,TRYNO		;jump if yes
	LD   A,3		;error code 3 --> accu
	RET
TRYNO:	LD   (SECTOR),A		;store sector #
	LD   A,(TRYS)		;get # of err tries
	INC  A			;adjust it
	LD   (TRIES),A		;store in counter

;set double density & disk size to 8 inch:
	LD   A,$DDDEN		;set double density command
	BIT  5,(IX)		;density ?
	JR   NZ,SETDEN		;jump if double density
	DEC  A			;set single density
SETDEN:	OUT  ($FDCMD),A		;set density
	LD   C,$SET8		;set 8 inch command
	LD   A,(DRIVE)		;drive # --> accu
	CP   4			;disk size ?
	JR   NC,SETSIZ		;jump if 8 inch
	RES  6,C		;set 5 inch command
SETSIZ:	LD   A,C
	OUT  ($FDSIZ),A		;set disk size

;actual I/O handler:
INIT:	LD   HL,0		;clear wait counter
	LD   (WAIT),HL
	LD   A,$FCINT		;force interrupt
	OUT  ($FDCMD),A		;reset FDC
	IN   A,($FDSTAT)	;get FDC status
	LD   (OLDSTAT),A	;save drive status
	CALL SELECT		;select drive
	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,TRKSEC		;yes skip init process

;restore drive head:
	SET  0,(IX+1)		;set init bit in DCT
	LD   A,255		;max possible track # --> accu
	LD   (IX+5),A		;make current track # to 255
	XOR  A			;desired track # = 0
	JR   TRKSE8
Š;set track and sector:
TRKSEC:	LD   A,(TRACK)		;track # --> accu
	BIT  5,(IX)		;disk density ?
	JR   Z,TRKSE1		;jump if single density
	BIT  4,(IX)		;density of first track ?
	JR   NZ,TRKSE1		;jump if double density
	INC  A			;increment track #
TRKSE1:	BIT  2,(IX)		;step count from track to track
	JR   Z,TRKSE2		;jump if step count = 1
	ADD  A,A		;track # * 2
TRKSE2:	CP   (IX+5)		;same as current track
	JR   NZ,TRKSE6		;jump to SEEK cmd if not
	LD   C,A		;save track #
	LD   A,$FCINT		;force interrupt
	OUT  ($FDCMD),A
	LD   A,C		;restore track #
	BIT  2,(IX)		;step count from track to track
	JR   Z,TRKSE3		;jump if step count = 1
	SRL  A			;track # / 2
TRKSE3:	OUT  ($FDTRK),A		;adjust current track #
	LD   A,(SECTOR)		;sector # --> accu
	BIT  6,(IX)		;single or double sided ?
	JR   Z,TRKSE4		;jump if single sided
	BIT  5,(IX+1)		;sector numbering continued on backside ?
	JR   NZ,TRKSE4		;jump if yes
	LD   B,(IX+3)		; sectors/track --> reg. B
	SRL  B			;(sectors/track) / 2
	CP   B			;front or back side ?
	JR   C,TRKSE4		;jump if front side
	SUB  B			;adjust sector #
TRKSE4:	BIT  3,(IX)		;test number of first sector
	JR   Z,TRKSE5		;jump if zero
	INC  A			;else adjust sector #
TRKSE5:	OUT  ($FDSEC),A		;store sector # in FDC reg
	JR   WAITEN		;no SEEK
TRKSE6:	LD   C,A		;save track #
	SUB  (IX+5)		;subtract current track #
	JR   NC,TRKSE7
	NEG			;make result positive
TRKSE7:	LD   (WAIT),A		;store calculated step count
	LD   A,C		;restore track #
TRKSE8:	OUT  ($FDDATA),A	;store track # in FDC reg
	LD   A,$FCINT
	OUT  ($FDCMD),A		;reset FDC
	LD   A,(IX+5)		;current track from DCT
	OUT  ($FDTRK),A		;FDC track register
	LD   A,(IX)
	AND  3			;step rate --> accu
	PUSH AF			;save it
	LD   HL,(WAIT)		;get step count
	JR   Z,TRKS10		;jump if step rate = 3 msec
	LD   D,H		;step count --> reg. DE
	LD   E,L
	LD   B,A		;step rate --> reg. B
TRKSE9:	ADD  HL,DE		;counter = step count * step rate
	DJNZ TRKSE9
TRKS10:	LD   B,H		;counter --> reg. BC
	LD   C,L
	ADD  HL,HL		;counter * 2
	ADD  HL,BC		;counter * 3Š	LD   A,(DRIVE)		;drive # --> accu
	CP   4			;disk size ?
	JR   NC,TRKS11		;jump if 8 inch
	ADD  HL,HL		;counter * 6
TRKS11:	LD   BC,15		;adjust value for delay loop --> reg. BC
	ADD  HL,BC		;adjust wait counter
	LD   (WAIT),HL		;store wait counter (msecs of passed time)
	POP  AF			;restore step rate
	OR   $SEEK		;or step rate with "seek" command
	OUT  ($FDCMD),A		;issue seek command
TRKS12:	CALL SELECT		;select drive
	IN   A,($FDSTAT)	;get disk status
	BIT  7,A		;drive not ready ?
	JP   NZ,READ2		;jump to error exit
	BIT  0,A		;seek done ?
	JR   NZ,TRKS12		;no, loop
	LD   BC,4000		;load delay counter
	CALL DELAY		;15 msec head settle delay
	IN   A,($FDTRK)		;get current track
	LD   (IX+5),A		;store in drive's DCT
	JP   TRKSEC		;check track # again

;motor on / head load time:
WAITEN:	LD   A,(DRIVE)		;get drive #
	LD   HL,OLDDRV		;^previous drive # --> reg. HL
	CP   (HL)		;new drive # same as old drive # ?
	LD   (HL),A		;store new drive #
	LD   A,(OLDSTAT)	;get old FDC status
	RLCA			;drive rotating already
	JR   C,WAITE2		;jump to motor on delay loop, if not
	JR   Z,WAITE6		;jump if same drive #
WAITE1:	LD   HL,50		;50 msec head load time
	JR   WAITE3
WAITE2:	BIT  7,(IX)		;8 inch drive
	JR   NZ,WAITE1		;jump if 8 inch drive
	LD   HL,800		;500 msec delay after motor on
WAITE3:	LD   BC,(WAIT)		;msecs of passed time --> reg. BC
	OR   A			;clear carry bit
	SBC  HL,BC		;calculate remaining wait time
	JR   C,WAITE6		;no further time to wait
	JR   Z,WAITE6
WAITE5:	LD   BC,253		;1 msec delay
	CALL DELAY
	DEC  HL
	LD   A,H
	OR   L
	JR   NZ,WAITE5		;loop HL times
WAITE6:	IN   A,($FDSTAT)	;get FDC status
	RLCA			;drive rotating already ?
	JP   C,READ2		;jump if not

;init READ/WRITE:
TASK1:	CALL SELECT		;select drive
	LD   HL,(BUFFER)	;get buffer pointer
	LD   A,(RDFLAG)
	OR   A			;READ or WRITE ?
	PUSH AF			;save status
	LD   A,(BANK)		;bank # of transfer buffer --> accu
	JP   IO			;handle disk I/O in common memory
Š;test controller status:
STATUS:	IN   A,($FDSTAT)	;get FDC status
	BIT  6,A		;write protect ?
	JR   Z,STATU1		;jump if not
	LD   A,5		;error code 5 --> accu
	RET
STATU1:	BIT  5,A		;hardware fault (WRITE) ?
				;sector   prot	(READ ) ?
	JR   Z,STATU2		;jump if no
	LD   A,6		;error code 6 --> accu
	RET
STATU2:	AND  1CH		;any errors ?
	RET  Z
	RES  0,(IX+1)		;clear init bit in DCT
	LD   HL,TRIES		;get tries counter
	DEC  (HL)		;dec value
	JP   NZ,INIT		;try again, reseek
	BIT  4,A		;data record not found ?
	JR   Z,STATU3
	LD   A,7		;error code 7 --> accu
	RET
STATU3:	BIT  3,A		;parity error ?
	JR   Z,STATU4
	LD   A,8		;error code 8 --> accu
	RET
STATU4:	LD   A,9		;error code 9 --> accu
	RET

;put drive control table pointer in "IX":
GETDCT:	PUSH DE			;save reg. DE
	LD   H,0		;drive # --> reg. HL
	LD   L,A
	ADD  A,A		; drive # * 2
	ADD  A,L		; drive # * 3
	ADD  A,A		; drive # * 6
	LD   L,A		;(drive # * 6) --> reg. HL
	LD   DE,DCT		;get drive table start
	ADD  HL,DE		;add offset and get ^DCT
	PUSH HL			;^DCT --> reg. IX
	POP  IX
	POP  DE			;restore reg. DE
	RET			;return to caller

;select drive:
SELECT:	LD   A,(DRIVE)		;get drive #
	AND  3			;force # between 0 and 3
	OR   A			;drive # zero ?
	LD   B,A		;drive # --> reg. B
	LD   A,1		;select code for drive zero
	JR   Z,SELEC1		;jump if drive # zero
	RLCA			;rotate left accu
	DJNZ $-1		;decrement drive #
SELEC1:	BIT  6,(IX)		;single or double sided ?
	JR   Z,SELEC2		;jump if single sided
	LD   C,A		;save select code
	LD   A,(SECTOR)		;sector #	--> accu
	LD   B,(IX+3)		; sectors/track --> reg. B
	SRL  B			;(sectors/track) / 2
	CP   B			;front or back side ?
	LD   A,C		;restore select codeŠ	JR   C,SELEC2		;jump if front side
	SET  4,A		;set side select bit
SELEC2:	OUT  ($FDSEL),A		;select drive and side
	RET			;return to caller

DRIVE:	DEFS 1			;drive
TRACK:	DEFS 2			;track
SECTOR:	DEFS 1			;sector
BUFFER:	DEFS 2			;I/O buffer
OLDDRV:	DEFB 0FFH		;contains # of previous selected disk
OLDSTAT:DEFS 1			;contains drive status
TRIES:	DEFS 1			;counter for counting # of times to try I/O
				;after error occurs
RDFLAG:	DEFS 1			;flag (0 = WRITE, 0FFH = READ)
WAIT:	DEFS 2			;counter for passed time


;EJECT
;*******************
;*  $ G E T T I M  *
;*******************

;entry: HL = address of a 21 bytes long buffer, containing on exit
;	     time & date in the form WWW MM/DD/YY HH:MM:SS

;		  WWW = weekday
;		   MM = month
;		   DD = day
;		   YY = year
;		   HH = hours
;		   MM = minutes
;		   SS = seconds

;get time & date in ASCII format:
$GETTIM:DI			;critical phase
	PUSH HL			;save ^user buffer
	CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer --> reg. IX

	LD   A,(IX+6)		;weekday      --> accu
	AND  7			;make binary
	LD   H,0		;weekday      --> reg. HL
	LD   L,A
	LD   DE,DAYTAB		;base of weekday table --> reg. DE
	ADD  A,A		;calc table entry
	ADD  A,L
	LD   L,A
	ADD  HL,DE
	LD   DE,ATIMBUF		;^ASCII buffer	       --> reg. DE
	LD   BC,3		;length of table entry --> reg. BC
	LDIR			;move weekday into ASCII buffer
	INC  DE			;bump buffer ptr over space

	LD   A,(IX+2)		;month (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+3)		;month (ones)	--> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slashŠ
	LD   A,(IX+4)		;day (tenths) --> accu
	AND  '3'		;mask leapyear bit
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+5)		;day (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash

	LD   A,(IX)		;year (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+1)		;year (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over space

	LD   A,(IX+7)		;hours (tenths) --> accu
	AND  '3'		;mask format bit
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+8)		;hours (ones)	--> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon

	LD   A,(IX+9)		;minutes (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+10)		;minutes (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon

	LD   A,(IX+11)		;seconds (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+12)		;seconds (ones)   --> accu
	LD   (DE),A		;store them

	POP  DE			;restore ^user buffer
	LD   HL,ATIMBUF		;^(time & date buffer)	      --> reg. HL
	LD   B,21		;length of time & date string --> reg. BC
	LD   A,01H		;source bank	  = 0
				;destination bank = 1
	JP   $XMOVE		;transfer time & date string and return

;read time & date from clock chip:
GETTIM:	IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  10111111B		;1.78 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	LD   HL,TIMBUF		;^temp buffer --> reg. HL
	LD   DE,10C4H		;register address displacement --> reg. D
				;register address & read mode  --> reg. E
	LD   B,13		;byte counter		       --> reg. B
GETTI1:	LD   A,E		;read date & time
	OUT  (5BH),A
	SUB  DŠ	LD   E,A
	IN   A,(5AH)
	AND  0FH		;mask undesired bits
	OR   '0'		;make ASCII digit
	LD   (HL),A
	INC  HL			;bump ^(time & date)
	DJNZ GETTI1
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A		;write system byte 1
	RET			;return to caller

DAYTAB:	DEFM 'SatSunMonTueWedThuFri'
TIMBUF:	DEFS 13
ATIMBUF:DEFM 'WWW MM/DD/YY HH:MM:SS'


;EJECT
;*******************
;*  $ S E T T I M  *
;*******************

;entry:  A = weekday (0 - 6, 0 = Sat)
;	 B = month   (MM)
;	 D = hours   (HH)
;	 E = minutes (MM)
;	 H = day     (DD)
;	 L = year    (YY)


;set time and date in binary format:
$SETTIM:DI			;critical phase
	LD   IX,TIMBUF		;^temp buffer --> reg. IX
	LD   (IX+6),A		;weekday      --> buffer
	LD   A,L		;year (ones)  --> accu
	AND  0FH		;mask it
	LD   (IX+1),A		;year (ones)  --> buffer
	LD   A,L		;shift reg. L four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX),A		;year  (tenths) --> buffer
	LD   A,B		;month (ones)	--> accu
	AND  0FH		;mask it
	LD   (IX+3),A		;month (ones)	--> buffer
	LD   A,B		;shift reg. B four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+2),A		;month (tenths) --> buffer
	LD   A,H		;day   (ones)	--> accu
	AND  0FH		;mask it
	LD   (IX+5),A		;day   (ones)	--> buffer
	LD   A,H		;shift reg. H four bits right
	RRA
	RRA
	RRAŠ	RRA
	AND  0FH
	LD   (IX+4),A		;day   (tenths) --> buffer
	LD   A,D		;hours (ones)	--> accu
	AND  0FH		;mask it
	LD   (IX+8),D		;hours (ones)	--> buffer
	LD   A,D		;shift reg. D four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+7),A		;hours	 (tenths) --> buffer
	LD   A,E		;minutes (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+10),A		;minutes (ones)   --> buffer
	LD   A,E		;shift reg. E four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+9),A		;minutes (tenths) --> buffer
	LD   (IX+11),0		;seconds (tenths) --> buffer
	LD   (IX+12),0		;seconds (ones)   --> buffer
	LD   HL,TIMBUF		;^buffer	  --> reg. HL
	LD   DE,10D2H		;register address displacement --> reg. D
				;register address	       --> reg. E
	LD   B,13		;byte counter		       --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  10010111B		;disable graphic page
				;1.78 MHz clock frequency
	OR   00000101B		;disable memory mapped I/O
				;disable boot EPROM
	OUT  ($SYS1),A		;write system byte 1
SETTI1:	LD   A,E		;set date & time
	SUB  D
	LD   E,A
	OUT  (05BH),A
	LD   A,(HL)
	OUT  (5AH),A
	INC  HL			;bump ^(time & date)
	DJNZ SETTI1
	IN   A,($SYS1)		;read system byte 1
	OR   01000000B		;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	JP   GETTIM		;adjust clock chip and return to caller

»­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­-

» ##£ FCH
BANË:   defó ±                  » Banë selecô pointeò nacè hier
                                » verschoben
;EJECT

IÆ WINCH                         » ##£ FCH

;Winchester disk driver:

	COND SASI		;Xebec partŠ
MAXDRIVE EQU 2			;drive count

;DC registers:
WPORT0	EQU  00H		;SASI write port 0 - write data
WPORT1	EQU  01H		;SASI write port 1 - software reset
WPORT2	EQU  02H		;SASI write port 2 - cntlr select
RPORT0	EQU  00H		;SASI read  port 0 - read data
RPORT1	EQU  01H		;SASI read  port 1 - read status

;DC commands:
$TSTDRV	EQU  00H		;test drive ready
$REST	EQU  01H		;recalibrate
$STATUS	EQU  03H		;request sense status
$$READ	EQU  08H		;read
$$WRITE	EQU  0AH		;write
$INIDRV	EQU  0CH		;initialize drive characteristics

;DC status bits:
REQMASK	EQU  01H		;request mask for bit test
BUSYMASK EQU 02H		;busy	 mask for bit test
CDMASK	EQU  08H		;command/data bit position test
IOMASK	EQU  10H		;input/output bit mask
ERROR	EQU  02H		;test for an error

	 ELSE			;WD1002 part

MAXDRIVE EQU 3			;drive count

;WDC registers:
$DATA	EQU  50H		;data register
$WPC	EQU  51H		;write precomp register
$ERROR	EQU  51H		;error register
$SECNO	EQU  53H		;sector number register
$CYLLO	EQU  54H		;cylinder low register
$CYLHI	EQU  55H		;cylinder high register
$SDH	EQU  56H		;size/drive/head register
$COMND	EQU  57H		;command register
$STATUS	EQU  57H		;status register

;WDC commands:
$REST	EQU  10H		;restore
$$READ	EQU  20H		;read sector
$$WRITE	EQU  30H		;write sector
$DSEL	EQU  98H		;deselect drive

	ENDC


;EJECT
;*****************
;*  $ R E A D W  *
;*****************

;entry: A  = drive  number	     (lower nibble)
;	     bank   number of buffer (upper nibble)
;	B  = sector number
;	DE = track  number
;	HL = buffer pointer

;exit : A  = error status returned from controllerŠ;	 0 = NO ERROR
;	-1 = ILLEGAL DRIVE #
;	-2 = TRACK # TOO HIGH
;	-3 = SECTOR # TOO HIGH
;	else error code returned by controller

;read a sector:
$READW:	LD   C,A		;save drive/bank number
	LD   A,0FFH
	JR   TASKW		;read sector


;EJECT
;*****************
;*  $ W R I T W  *
;*****************

;entry: A  = drive  number	     (lower nibble)
;	     bank   number of buffer (upper nibble)
;	B  = sector number
;	DE = track  number
;	HL = buffer pointer

;exit : A  = error code
;	 0 = NO ERROR
;	-1 = ILLEGAL DRIVE #
;	-2 = TRACK # TOO HIGH
;	-3 = SECTOR # TOO HIGH
;	else error code returned by controller

;write a sector:
$WRITW:	LD   C,A		;save drive/bank number
	XOR  A


;dominant controller:
TASKW:	LD   (RDFLAG),A		;set/cear READ-flag
	LD   A,C		;restore drive/bank #
	RRA			;get bank number of transfer buffer
	RRA
	RRA
	RRA
	AND  0FH
	LD   (BANK),A		;store bank #
	LD   A,C		;restore drive/bank #
	AND  0FH		;mask drive #
	CP   MAXDRIVE		;legal drive # ?
	JR   C,TRKNOW		;jump if yes
	LD   A,-1		;error code 1 --> accu
	RET
TRKNOW:	LD   (DRIVE),A		;store drive #
	LD   (BUFFER),HL	;store buffer pointer
	CALL GETWCT		;get control table ptr
	LD   A,D		;track # (MSB) --> accu
	CP   (IX+6)		;legal track # ?
	JR   C,SECNOW		;jump if yes
	JR   Z,CPLOW		;compare LSB's
TRKERR:	LD   A,-2		;error code 2 --> accu
	RET
CPLOW:	LD   A,E		;track (LSB) --> accuŠ	CP   (IX+5)		;legal track # ?
	JR   NC,TRKERR		;jump if not
SECNOW:	LD   (TRACK),DE		;store track #
	LD   A,B		;sector # --> accu
	CP   (IX+4)		;legal sector # ?
	JR   C,INITW		;jump if yes
	LD   A,-3		;error code 3 --> accu
	RET

;actual I/O handler:
INITW:	LD   (SECTOR),A		;store sector #


;EJECT
	COND SASI		;Xebec part

	LD   A,(OLDW)		;number of previously accessed drive --> reg. C
	LD   C,A
	OR   A			;no drive previously accessed ?
	JP   P,INITW1		;select controller
	OUT  (WPORT1),A		;reset controller
INITW1:	LD   A,(DRIVE)		;drive # --> accu
	LD   (OLDW),A		;save it
	CP   C			;same as old drive ?
	JR   Z,INITW2		;no drive selection needed if yes

;select Winchester drive:
	LD   IY,WPARS		;^Winchster parameters --> reg. IY
	LD   H,(IX+6)		;track count --> reg. HL
	LD   L,(IX+5)
	LD   D,0		;clear MSB of divisor
	LD   E,(IX)		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	LD   (IY+2),E		;load head count
	CALL DIV		;calc cylinder count
	LD   (IY),H		;load cylinder count
	LD   (IY+1),L
	LD   (IY+3),H		;load starting cylinder
	LD   (IY+4),L		;for reduced write current
	LD   H,0		;calc startimg cylinder for write precomp
	LD   L,(IX+2)
	ADD  HL,HL
	ADD  HL,HL
	LD   (IY+5),H		;load starting cylinder for write precomp
	LD   (IY+6),L
	LD   A,$INIDRV		;initialize drive data
	CALL TASKOUT

	LD   HL,WPARS		;^Winchester parameters --> reg. HL
	LD   BC,8 SHL 8+WPORT0	;number of bytes	--> reg. B
				;SASI port 0		--> reg. C
	CALL REQWAIT		;wait for data request
SELDRV:	IN   A,(RPORT1)		;read status again
	AND  IOMASK+CDMASK+REQMASK
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,SELDRV1		;jump if data transfer finished
	CP   REQMASKŠ	JR   NZ,SELDRV		;wait for request
	OTIR			;load disk parameters
	JR   SELDRV

SELDRV1:CALL GETSTAT		;get error status
	JR   NZ,ERREXIT		;any errors ?

INITW2:	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,RWINI		;jump if yes

;restore drive heads:
RESTOW:	LD   A,$TSTDRV		;test drive ready
	CALL TASKOUT
	CALL GETSTAT		;get error status
	JR   NZ,RESTOW		;retry if drive not ready
	LD   A,$REST		;recalibrate drive
	CALL TASKOUT
	CALL GETSTAT		;get error status
	JR   NZ,ERREXIT		;any errors ?
	SET  0,(IX+1)		;set init bit in WCT


;EJECT
	 ELSE			;WD1002 part

	EX   DE,HL		;track #  --> reg. HL
	LD   D,0		;clear MSB of divisor
	LD   E,(IX)		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	CALL DIV		;cylinder # = track # / head count (HL)
				;surface #  = track # % head count (DE)
	LD   A,(DRIVE)		;drive # --> accu
	ADD  A,A		;shift drive # 3 bits left
	ADD  A,A
	ADD  A,A
	ADD  A,E		;add surface #
	LD   E,A		;and save it
	LD   A,(IX+1)		;get sector length bits
	RRA
	AND  60H		;mask sector length bits
	ADD  A,E		;add surface # and drive #
	OR   80H		;set ECC error correction bit
	LD   E,A		;save drive select bits
	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,TRKSEW		;yes, skip init process

;restore drive heads:
RESTOW:	IN   A,($STATUS)	;read WDC status
	AND  0C0H		;mask it
	CP   40H		;busy ?
	JR   NZ,RESTOW		;wait `til WDC is ready to accept a command
	OUT  ($SDH),A		;select drive
	LD   A,(IX)		;get step rate bits
	AND  0FH		;mask them
	OR   $REST		;or with "restore" command
	OUT  ($COMND),A		;restore drive heads
RESTO1:	IN   A,($STATUS)	;read WDC statusŠ	BIT  7,A		;restore done ?
	JR   NZ,RESTO1		;no, loop
	SET  0,(IX+1)		;set init bit in WCT

;set track and sector:
TRKSEW:	LD   A,(IX+2)		;set starting track for write precomp
	OUT  ($WPC),A
	LD   A,(SECTOR)		;sector # --> accu
	BIT  4,(IX)		;test number of first sector
	JR   Z,TRKSW1		;jump if zero
	INC  A			;else adjust sector #
TRKSW1:	OUT  ($SECNO),A		;set sector #
	LD   A,L		;set cylinder # (LSB)
	OUT  ($CYLLO),A
	LD   A,H		;set cylinder # (MSB)
	OUT  ($CYLHI),A
	LD   A,E		;restore drive select bits
	OUT  ($SDH),A		;select drive

;init READ/WRITE:
	LD   E,(IX+1)		;get sector length bits
	LD   B,6
	SRL  E
	DJNZ $-2
	LD   C,$DATA		;init byte counter and data port number

	ENDC

RWINI:	LD   HL,(BUFFER)	;get buffer pointer
	LD   A,(RDFLAG)		;READ or WRITE ?
	OR   A
	PUSH AF			;save status
	JR   Z,RWINI1		;jump if write
	LD   A,$$READ		;issue read command
	JR   RWINI2
RWINI1:	LD   A,$$WRITE		;issue write command

	COND SASI		;Xebec part

RWINI2:	CALL TASKOUT

	 ELSE

RWINI2:	OUT  ($COMND),A		;WD1002 part

	ENDC

	LD   A,(BANK)		;bank # of transfer buffer --> accu
	JP   IOW		;handle Winchester I/O in common memory

;test controller status:

	COND SASI		;Xebec part

WDCSTAT:CALL GETSTAT		;get status
	RET  Z			;return if no errors
ERREXIT:LD   A,$STATUS		;request sense status
	CALL TASKOUT

	CALL REQWAIT		;wait for data requestŠ	IN   A,(RPORT0)		;read error code
	LD   D,A		;save it temporarily
	IN   A,(RPORT0)		;skip rest
	IN   A,(RPORT0)
	IN   A,(RPORT0)
	CALL GETSTAT		;get status
	JR   NZ,ERREXIT

	LD   A,D		;restore error code
	AND  7FH
	RET

	 ELSE			;WD1002 part

WDCSTAT:IN   A,($STATUS)	;get WDC status
	AND  1			;any errors ?
	LD   C,A		;save error status
	JR   Z,DSEL		;return if no errors
	IN   A,($ERROR)		;read WDC error register
	LD   C,A		;save error code

DSEL:	LD   A,$DSEL		;deselect drive
	OUT  ($SDH),A
	LD   A,C		;error code --> accu
	RET			;return to caller

	ENDC

;put drive control table pointer in "IX":
GETWCT:	PUSH DE			;save reg. DE
	LD   H,0		;drive # --> reg. HL
	LD   L,A
	ADD  A,A		;drive # * 2
	ADD  A,L		;drive # * 3
	ADD  A,A		;drive # * 6
	ADD  A,L		;drive # * 7
	LD   L,A		;drive # * 7 --> reg. H
	LD   DE,DCTW		;get drive table start
	ADD  HL,DE		;add offset and get ^DCT
	PUSH HL			;^DCT --> reg. IX
	POP  IX
	POP  DE			;restore reg. DE
	RET			;return
» ##£ FCÈ Pointeò voò Winchesterroutinå verschoben
;BANK:	DEFS 1			;bank number of transfer buffer


;EJECT
	COND SASI		;Xebec part

;output a command to SASI controller:
TASKOUT:PUSH HL			;save regs. HL & IY
	PUSH IY			;save reg. IY
	LD   IY,DCCMD		;^command block --> reg. IY
	LD   (IY),A		;store command
	LD   A,(DRIVE)		;load drive #
	RRCA
	RRCA
	RRCA
	LD   (IY+1),A
	LD   DE,(TRACK)		;track #		 --> reg. DEŠ	LD   HL,0		;clear result
	LD   B,(IX+4)		;sectors/track		 --> reg. B
TASKO1:	ADD  HL,DE		;track # * sectors/track --> reg. HL
	DJNZ TASKO1
	LD   D,0		;sector #		 --> reg. DE
	LD   A,(SECTOR)
	LD   E,A
	ADD  HL,DE		;block # = track # * sectors/track + sector #
	LD   (IY+2),H		;load block #
	LD   (IY+3),L
	LD   A,(IX)		;get step rate ?
	AND  0FH
	LD   A,0
	JR   NZ,TASKO2		;jump if not
	LD   A,5		;set buffered step mode
TASKO2:	LD   (IY+5),A		;load control byte

TASKO3:	IN   A,(RPORT1)		;read status port
	AND  BUSYMASK		;mask busy bit
	JR   NZ,TASKO3		;jump, if busy
	LD   A,1		;cntlr default select code
	OUT  (WPORT0),A		;send it to transparent latch
TASKO4:	OUT  (WPORT2),A		;generate a select strobe
	IN   A,(RPORT1)		;get cntlr response
	AND  BUSYMASK		;isolate the busy mask
	JR   Z,TASKO4		;wait for cntlr busy

	LD   HL,DCCMD		;^command block --> reg. HL
	LD   BC,6 SHL 8+WPORT0	;byte count	--> reg. B
				;port number	--> reg. C
	CALL REQWAIT		;wait for controller request
	OTIR			;load command

	POP  IY			;restore regs. HL & IY
	POP  HL
	RET

;get status:
GETSTAT:CALL REQWAIT		;wait for request
	IN   A,(RPORT0)		;read in the status byte
	LD   C,A		;save status temporarily
	CALL REQWAIT		;wait for second byte
	IN   A,(RPORT0)		;get the null byte
	LD   A,C		;restore status to A
	AND  ERROR		;isolate the error bit
	RET

;Winchester drive parameters:
WPARS:	DEFS 2			;cylinder count
	DEFS 1			;head	  count
	DEFS 2			;starting cylinder for reduced write current
	DEFS 2			;starting cylinder for write precompensation
	DEFB 11			;length of ECC impulse

;command control block:
DCCMD:	DEFS 1			;opcode
	DEFS 1			;luno
	DEFS 2			;block number
	DEFB 1			;block count
	DEFS 1			;control fieldŠ
SENSE:	DEFS 4			;sense status bytes
OLDW:	DEFB 0FFH		;previously accessed drive

	ENDC
ENDIÆ                           » ##£ FCH

;EJECT
;*******************
;*  $ G T I M E 3  *
;*******************

;entry: HL = pointer to a 5 byte buffer containing on exit
;	     date and time in the form DDDDHHMMSS

;	      DDDD = number of days since January 1st, 1978 (binary    )
;		HH = hours				    (BCD format)
;		MM = minutes				    (BCD format)
;		SS = seconds				    (BCD format)

;get time & date in CP/M 3 format (software clock):
$GTIME3S:
	EX   DE,HL		;^user buffer --> reg. DE
	DI			;critical phase
	JP   GTIME5		;transfer time & date into caller's buffer

;get time & date in CP/M 3 format (hardware clock):
$GTIME3H:
	DI			;critical code (not reentrant)
	PUSH HL			;save ^user buffer
	CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer	--> reg. IX
	LD   IY,BINARY$DATE	;^result buffer --> reg. IY

	LD   A,(IX+7)		;hours (tenths) --> reg. C
	AND  3			;make binary
	RLCA			;hours (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	--> reg. C
	LD   A,(IX+8)		;hours (ones)	--> accu
	AND  0FH		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+2),A		;store BCD hours

	LD   A,(IX+9)		;minutes (tenths) --> reg. C
	AND  7			;make binary
	RLCA			;minutes (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+10)		;minutes (ones)   --> accu
	AND  0FH		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+3),A		;store BCD minutes

	LD   A,(IX+11)		;seconds (tenths) --> reg. C
	AND  7			;make binaryŠ	RLCA			;seconds (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+12)		;seconds (ones)   --> accu
	AND  0FH		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+4),A		;store BCD seconds

	LD   A,(IX+1)		;year (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;year (ones)   --> reg. C
	LD   A,(IX)		;year (tenths) --> accu
	AND  0FH		;make binary
	CALL BCDBIN		;convert BCD year to binary
	LD   (YEAR),A		;store it

	LD   A,(IX+3)		;month (ones)	--> accu
	AND  0FH		;make binary
	LD   C,A		;month (ones)	--> reg. C
	LD   A,(IX+2)		;month (tenths) --> accu
	AND  1			;make binary
	CALL BCDBIN		;convert BCD month to binary
	LD   (MONTH),A		;store it

	LD   A,(IX+5)		;day (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;day (ones)   --> reg. C
	LD   A,(IX+4)		;day (tenths) --> accu
	AND  3			;make binary
	CALL BCDBIN		;convert BCD day to binary
	LD   (DAY),A		;store it

	LD   A,(YEAR)		;binary year --> accu
	SUB  78			;subtract base year
	JR   NC,GTIME1		;result negative ?
	ADD  A,100		;correct year
GTIME1:	SRL  A			;year / 4 --> accu
	RR   C			;year % 4 --> reg. C
	SRL  A
	RR   C
	LD   B,6
GTIME2:	SRL  C
	DJNZ GTIME2
	LD   HL,0		;clear daycount
	OR   A			;year / 4 == 0 ?
	JR   Z,GTIME4		;no multiplication
	LD   B,A		;year / 4 --> reg. B
	LD   DE,1461		;number of days in 4 years --> reg. DE
GTIME3:	ADD  HL,DE		;daycount = year / 4 * 1461
	DJNZ GTIME3
GTIME4:	EX   DE,HL		;daycount --> reg. DE

;calc table index:
	LD   A,C		;year %  4    --> accu
	ADD  A,A		;accu *  2
	ADD  A,A		;accu *  4
	LD   C,A		;accu *  4    --> reg. C
	ADD  A,A		;accu *  8Š	ADD  A,C		;accu * 12
	LD   C,A		;accu * 12    --> reg. C
	LD   A,(MONTH)		;binary month --> accu
	DEC  A			;normalize
	ADD  A,C		;index = year % 4 * 12 + month - 1
	ADD  A,A		;make byte index
	LD   C,A		;table index	   --> reg. BC
	LD   HL,MONTAB		;base of day table --> reg. HL
	ADD  HL,BC		;add index
	LD   A,(HL)		;table[index]	   --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,A

	ADD  HL,DE		;daycount += table[index]
	LD   A,(DAY)		;binary day --> accu
	LD   C,A		;day	    --> reg. BC
	ADD  HL,BC		;now reg. HL contains number of days
				;since January 1st, 1978

	LD   (IY),L		;store daycount
	LD   (IY+1),H

	POP  DE			;restore ^user buffer
GTIME5:	LD   HL,BINARY$DATE	;^temporary buffer --> reg. HL
	LD   B,5		;buffer length	   --> reg. B
	LD   A,(INT)		;called from interrupt service routine ?
	OR   A
	LD   A,1		;source bank	  = 0
				;destination bank = 1
	JP   Z,$XMOVE		;move time & date into user buffer and return,
				;if not called from interrupt service routine

	LD   BC,5		;buffer length --> reg. BC
	LDIR			;no interbank move, if called from interrupt
	RET			;service routine

;convert BCD to binary:
BCDBIN:	ADD  A,A		;lower nibble *  2
	LD   B,A		;lower nibble *  2 --> reg. B
	ADD  A,A		;lower nibble *  4
	ADD  A,A		;lower nibble *  8
	ADD  A,B		;lower nibble * 10
	ADD  A,C		;add lower nibble
	RET

YEAR:	DEFS 1
MONTH:	DEFS 1
DAY:	DEFS 1


;EJECT
;*******************
;*  $ S T I M E 3  *
;*******************

;entry:  D = hours   (HH)
;	 E = minutes (MM)
;	HL = number of days since January 1st, 1978 (binary)
Š;set time & date in CP/M 3 format (software clock):
$STIME3S:
	DI			;critical phase
	LD   (BINARY$DATE),HL	;load binary date
	LD   HL,TIME$IN$BCD	;^BCD time --> reg. HL
	LD   (HL),D		;load BCD hours
	INC  HL
	LD   (HL),E		;load BCD minutes
	INC  HL
	LD   (HL),0		;reset BCD seconds
	RET			;return to caller

;set time & date in CP/M 3 format (hardware clock):
$STIME3H:
	PUSH DE			;save hours & minutes
	PUSH HL			;save daycount
	DEC  HL			;normalize

	XOR  A			;clear quotient
	LD   DE,1461		;number of days in 4 years --> reg. DE
STIME1:	SBC  HL,DE		;daycount / 1461	   --> accu
	JR   C,STIME2
	INC  A
	JR   STIME1
STIME2:	ADD  HL,DE		;adjust remainder
	EX   DE,HL		;remainder --> reg. DE
	ADD  A,A		;accu * 2
	ADD  A,A		;accu * 4
	LD   (YEAR),A		;year = daycount / 1461 * 4

;search table entry:
	LD   A,47		;last index	   --> accu
STIME3:	LD   H,0		;index #	   --> reg. HL
	LD   L,A
	ADD  HL,HL		;make byte index
	LD   BC,MONTAB		;dase of day table --> reg. BC
	ADD  HL,BC		;calc table entry
	LD   B,(HL)		;table[index]	   --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,B
	SBC  HL,DE		;daycount >= table index ?
	JR   C,STIME4		;if yes search finished
	JR   Z,STIME4
	DEC  A			;index = index - 1
	JP   P,STIME3

STIME4:	LD   B,0		;clear quotient
STIME5:	SUB  12			;index / 12 --> accu
	JR   C,STIME6
	INC  B			;increment quotient
	JR   STIME5
STIME6:	ADD  A,13		;adjust remainder and calc month
	LD   (MONTH),A		;store it
	LD   A,(YEAR)		;year --> accu
	ADD  A,B		;year += index / 12
	SUB  22			;normalize
	JR   NC,STIME7		;year negative ?
	ADD  A,100		;correct it
STIME7:	LD   (YEAR),A		;store itŠ	LD   A,L		;table[index] - daycount --> accu
	NEG			;daycount - table[index] --> accu
	INC  A			;day = daycount - table[index] + 1
	LD   (DAY),A		;store it

	POP  HL			;restore day count
	LD   A,H		;daycount (MSB)       --> accu
	LD   C,L		;daycount (LSB)       --> reg. C
	LD   DE,7		;no. of days per week --> reg. DE
	LD   HL,0		;clear accumulator
	LD   B,16		;init counter
STIME8:	RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
	SBC  HL,DE		;subtract divisor
	JR   NC,$+3		;subtraction ok
	ADD  HL,DE		;restore accumulator
	CCF			;complement carry flag
	DJNZ STIME8		;counter = 0 ?
	LD   A,L		;weekday no. --> accu
	PUSH AF			;save weekday

	LD   A,(MONTH)		;binary month --> accu
	CALL BINBCD		;convert to BCD format
	LD   D,A		;save month

	LD   A,(DAY)		;binary day --> accu
	CALL BINBCD		;convert to BCD format
	LD   H,A		;BCD day     --> reg. H
	LD   A,(YEAR)		;binary year --> accu
	RRA			;year / 4
	JR   C,STIME9
	RRA
	JR   C,STIME9
	SET  6,H		;set leapyear flag

STIME9:	LD   A,(YEAR)		;binary year --> accu
	CALL BINBCD		;convert to BCD format
	LD   L,A		;BCD year    --> reg. L

	LD   B,D		;BCD month   --> reg. B
	POP  AF			;weekday     --> accu
	POP  DE			;BCD hours   --> reg. D
				;BCD minutes --> reg. E
	SET  7,D		;set "24 hour" format
	JP   $SETTIM		;set time & date and return to caller

;convert binary to BCD:
BINBCD:	LD   C,0		;clear result
BINBC1:	SUB  10			;accu / 10
	JR   C,BINBC2
	INC  C			;increment quotient
	JR   BINBC1
BINBC2:	ADD  A,10		;adjust remainder
	LD   B,4
BINBC3:	SLA  C			;quotient --> upper nibble
	DJNZ BINBC3
	ADD  A,C		;add remainder
	RET
Š;day table:
;	     Jan  Feb  Mar  Apr  May  Jun  Jul	Aug  Sep  Oct  Nov  Dec
MONTAB:	DEFW 0000,0031,0059,0090,0120,0151,0181,0212,0243,0273,0304,0334  ;1978
	DEFW 0365,0396,0424,0455,0485,0516,0546,0577,0608,0638,0669,0699  ;1979
	DEFW 0730,0761,0790,0821,0851,0882,0912,0943,0974,1004,1035,1065  ;1980
	DEFW 1096,1127,1155,1186,1216,1247,1277,1308,1339,1369,1400,1430  ;1981


;EJECT
;*******************
;*  $ L D C H A R  *
;*******************

;entry:  A = ASCII code of character to be loaded (00 - 7F)
;	HL = address of dot matrix (16 bytes)

;load user character:
$LDCHAR:AND  7FH		;make seven bit ASCII code
	PUSH AF			;save ASCII code
	LD   DE,PATTERN		;^dot matrix	 --> reg. DE
	LD   B,16		;number of bytes --> reg. B
	LD   A,10H		;source bank	  = 1
				;destination bank = 0
	CALL $XMOVE		;load matrix
	POP  BC			;ASCII code --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	LD   A,B		;ASCII code --> accu
	LD   (3C00H),A		;load ASCII code
	LD   DE,PATTERN		;^dot matrix		     --> reg. DE
	LD   HL,8400H		;^first character	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
LDCHAR1:LD   A,(DE)		;get first scan line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ LDCHAR1		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	OR   80H		;set MSB
	LD   (3C00H),A		;reload code
	LD   DE,PATTERN		;^dot matrix		     --> reg. DE
	LD   HL,8400H		;^first character	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
LDCHAR2:LD   A,(DE)		;get first scan line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointerŠ	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ LDCHAR2		;load next scan line
	LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A
	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;disable character RAM
	OUT  ($SYS0),A		;write system byte 0
	RET			;return to caller
PATTERN:DEFS 16			;temporary storage area for dot matrix
SAVECH:	DEFS 1


;EJECT
;*******************
;*  $ R S T C H R  *
;*******************

;restore original character set:
$RSTCHR:IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	XOR  A			;reset code counter
	LD   DE,FONTSET		;^dot matrices --> reg. DE
RSTCHR1:LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
RSTCHR2:LD   A,(DE)		;get first scan line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ RSTCHR2		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	INC  A			;increment ASCII code
	JP   P,RSTCHR1		;load next character

;load inverted characters
	LD   DE,FONTSET		;^dot matrices --> reg. DE
RSTCHR3:LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
RSTCHR4:LD   A,(DE)		;get first scan line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,HŠ	LD   H,A
	DJNZ RSTCHR4		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	INC  A			;increment ASCII code
	JR   NZ,RSTCHR3		;load next character
	LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A

;select ASCII or national character set:
SELCHR:	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	LD   IX,NATIONAL	;^national codes --> reg. IX
	LD   A,(GERMAN)		;national char set ?
	OR   A
	JR   Z,SELCHR1		;jump if no
	LD   DE,FONTSET+136*16	;^dot matrices	--> reg. DE
	JR   SELCHR2
SELCHR1:LD   DE,FONTSET+128*16	;^dot matrices	--> reg. DE
SELCHR2:LD   A,(IX)		;character code --> accu
	OR   A			;end of table ?
	JR   Z,SELCHR4		;jump if yes
	INC  IX			;bump table ptr
	LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
SELCHR3:LD   A,(DE)		;get first scan line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ SELCHR3		;load next scan line
	JR   SELCHR2		;load next character

;load inverted characters:
SELCHR4:LD   IX,NATIONAL	;^national codes --> reg. IX
	LD   A,(GERMAN)		;national char set ?
	OR   A
	JR   Z,SELCHR5		;jump if no
	LD   DE,FONTSET+136*16	;^dot matrices	--> reg. DE
	JR   SELCHR6
SELCHR5:LD   DE,FONTSET+128*16	;^dot matrices	--> reg. DE
SELCHR6:LD   A,(IX)		;character code --> accu
	OR   A			;end of table ?
	JR   Z,SELCHR8		;jump if yes
	OR   80H		;make code of inverted char
	INC  IX			;bump table ptr
	LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
SELCHR7:LD   A,(DE)		;get first scan line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAMŠ	ADD  A,H
	LD   H,A
	DJNZ SELCHR7		;load next scan line
	JR   SELCHR6		;load next character

SELCHR8:LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A
	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;disable character RAM
	OUT  ($SYS0),A		;write system byte 0
	EI			;reenable interrupts
	RET			;return to caller


;codes of national character set:
NATIONAL:
	DEFM '@[\]{|}~'
	DEFB 0


;EJECT
;*******************
;*  $ S C R N I O  *
;*******************

;entry:  A = control code
;	     0	read  window
;	     1	write window
;	HL = address of user buffer
;	 D = 0	contiguous  buffer
;	     1	full screen buffer
;	 E = attribute
;	     0	normal	 display
;	     1	inverted display

;direct screen I/O:
$SCRNIO:LD   IX,(VDTABP)	;^screen constants --> reg. IX
	LD   (IOMODE),A		;save I/O mode
	PUSH HL			;save ^user buffer
	PUSH DE			;save buffer mode
	LD   A,(IX+8)		;save current line
	LD   (SLINE),A
	LD   A,(IX+9)		;save current column
	LD   (SCOLUMN),A
	LD   A,(IX+11)		;save current display mode
	LD   (SMODE),A
	LD   A,(IX+12)		;save cursor state
	LD   (SCUROFF),A
	LD   A,(WRAP)		;save "wrap around" mode
	LD   (SWRAP),A
	DEC  E			;test display mode
	JR   Z,SCRNIO1		;jump if inverse display mode
	CALL INVOFF		;turn on normal display mode
	JR   SCRNIO2
SCRNIO1:CALL INVON		;turn on inverse display mode
SCRNIO2:CALL CUROFF		;turn off cursor
	CALL WRAPOFF		;turn off "wrap around" mode
	CALL HOME		;home cursor

	POP  DE			;get buffer modeŠ	DEC  D			;calc buffer increment
	JR   Z,SCRNIO3		;jump if full screen buffer
	LD   A,(IX+7)		;buffer increment = column count
	JR   SCRNIO4
SCRNIO3:LD   A,(IX+1)		;buffer increment = maximum column count
	POP  DE			;get base address of screen buffer
	ADD  HL,DE		;add cursor address (returned from "HOME")
	PUSH HL			;save actual buffer address
SCRNIO4:LD   (BINC),A		;store buffer increment

;screen I/O:
	LD   A,(IOMODE)
	OR   A			;read or write screen ?
	JR   NZ,SCRNIO9		;jump if write screen


;EJECT
;read screen:
SCRNIO5:LD   IY,LINBUF		;^temp buffer --> reg. IY
	LD   B,(IX+7)		;column count --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1

SCRNIO6:PUSH BC			;save remaining column count
	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   A,(HL)		;character under cursor  --> accu
	AND  7FH		;mask it
	CP   (IX+10)		;erase character ?
	JR   NZ,SCRNIO7		;jump if not
	LD   A,' '		;convert it to space
SCRNIO7:CP   ' '		;graphic character ?
	JR   NC,SCRNIO8		;jump if not
	ADD  A,80H		;convert code of graphic character
SCRNIO8:LD   (IY),A		;store character
	INC  IY			;inc buffer pointer
	CALL CURRGT		;move cursor right
	POP  BC			;restore column count
	DJNZ SCRNIO6		;read next character

	IN   A,($SYS1)		;read system byte 1
	OR   01010101B		;disable memory mapped I/O
	OUT  ($SYS1),A		;write system byte 1
	LD   HL,LINBUF		;source      address --> reg. HL
	POP  DE			;destination address --> reg. DE
	PUSH DE
	LD   B,(IX+7)		;byte count	     --> reg. B
	LD   A,1		;source      bank = 0
				;destination bank = 1
	CALL $XMOVE		;transfer screen line into user buffer

	LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; == bottom line ?
	JR   Z,SCRNI12		;jump if yes

	CALL NEWLIN		;carriage returnŠ	CALL CURDWN		;line feed

	LD   HL,(BINC)		;buffer increment --> reg. HL
	LD   H,0
	POP  DE			;buffer pointer   --> reg. DE
	ADD  HL,DE		;increment buffer pointer
	PUSH HL			;save it
	JR   SCRNIO5		;read next line


;EJECT
;write screen:
SCRNIO9:POP  HL			;source      address --> reg. HL
SCRNI10:PUSH HL			;save it
	LD   DE,LINBUF		;destination address --> reg. HL
	LD   B,(IX+7)		;byte count	     --> reg. B
	LD   A,10H		;source      bank = 1
				;destination bank = 0
	CALL $XMOVE		;transfer screen line into user buffer

	LD   IY,LINBUF		;^temp buffer --> reg. IY
	LD   B,(IX+7)		;column count --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1

SCRNI11:PUSH BC			;save remaining column count
	LD   A,(IY)		;character --> accu
	CALL NORMAL		;display character
	INC  IY			;inc buffer pointer
	POP  BC			;restore column count
	DJNZ SCRNI11		;display next character

	IN   A,($SYS1)		;read system byte 1
	OR   01010101B		;disable memory mapped I/O
	OUT  ($SYS1),A		;write system byte 1

	LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; == bottom line ?
	JR   Z,SCRNI12		;jump if yes

	CALL NEWLIN		;carriage return
	CALL CURDWN		;line feed

	LD   HL,(BINC)		;buffer increment --> reg. HL
	LD   H,0
	POP  DE			;buffer pointer   --> reg. DE
	ADD  HL,DE		;increment buffer pointer
	JR   SCRNI10		;write next line


;EJECT
;restore old screen state:
SCRNI12:POP  HL			;adjust stack pointer
	LD   A,(SLINE)		;restore current line
	LD   (IX+8),AŠ	LD   A,(SCOLUMN)	;restore current column
	LD   (IX+9),A
	LD   A,(SMODE)		;restore current display mode
	LD   (IX+11),A
	LD   A,(SCUROFF)	;restore cursor state
	LD   (IX+12),A
	LD   A,(SWRAP)		;restore "wrap around" mode
	LD   (WRAP),A
	CALL OUTCUR		;position cursor
	JP   CURON+4		;turn on (?) cursor and return to caller

;temporary storage area:
SLINE:	DEFS 1			;current cursor line
SCOLUMN:DEFS 1			;current cursor column
SMODE:	DEFS 1			;current display mode
SCUROFF:DEFS 1			;current cursor state
SWRAP:	DEFS 1			;current "wrap around" mode
IOMODE:	DEFS 1			;read or write screen ?
BINC:	DEFS 1			;buffer pointer increment
LINBUF:	DEFS 80			;line buffer


;EJECT
;***************
;*  $ I N I T  *
;***************

;general initialization routine:
$INIT:	DI			;disable interrupts
	IM   1			;select interrupt mode 1 (RST 38H)
	IN   A,($SYS0)		;read system byte 0
	AND  00110011B		;enable bank 0
				;RTC interrupt only
	OUT  ($SYS0),A		;write system byte 0

	CALL $RSTCHR		;load character set

	XOR  A			;source bank	  = 0
				;destination bank = 0
	LD   HL,VIDPAR		;^video parameters --> reg. HL
	CALL VDINIT1		;initialize video controller chip MC6845

	LD   A,ESC		;select national character set
	CALL $VDCHAR
	LD   A,(CHRSET)
	CALL $VDCHAR

	LD   B,0		;# of RS232C interface --> reg. B
	LD   HL,(SER0)		;data format	       --> accu
	LD   A,L
	LD   E,H		;baud rate	       --> reg. E
	CALL $RSINIT		;initialize Z80 SIO A

	LD   B,1		;# of RS232C interface --> reg. B
	LD   HL,(SER1)		;data format	       --> accu
	LD   A,L
	LD   E,H		;baud rate	       --> reg. E
	CALL $RSINIT		;initialize Z80 SIO B

	LD   HL,PIO$INIT$TBL	;initialize Z80 PIOŠSTREAM$OUT:
	LD   A,(HL)
	OR   A
	JR   Z,$FCINIT
	LD   B,A
	INC  HL
	LD   C,(HL)
	INC  HL
	OTIR
	JR   STREAM$OUT		;now Z80 PIO acts as Centronics interface
PIO$INIT$TBL:
	DEFB 2,0D6H,0FH,07H
	DEFB 3,0D7H,0CFH,0F0H,07H
	DEFB 1,0D5H,01H
	DEFB 0

$FCINIT:LD   A,$FCINT		;initialize floppy disk controller chip WD2791
	OUT  ($FDCMD),A


;EJECT
;powerup/reset test:
	LD   A,10H		;source      bank    = 1
				;destination bank    = 0
	LD   HL,0038H		;source      address = interrupt entry point
	LD   DE,JUMP		;destination address = test variable
	LD   B,1		;byte count	     = 1
	CALL $XMOVE		;get byte from interrupt entry point in bank 1

	LD   A,(JUMP)		;JP ?
	CP   0C3H
	JR   NZ,$POWUP		;jump if power up
	XOR  A			;clear power up marker
	JR   $RESET
$POWUP:	LD   HL,1		;reset binary date
	LD   (BINARY$DATE),HL
	LD   HL,TIME$IN$BCD	;^BCD time --> reg. HL
	XOR  A
	LD   (HL),A		;reset BCD hours
	INC  HL
	LD   (HL),A		;reset BCD minutes
	INC  HL
	LD   (HL),A		;reset BCD seconds
	CPL			;set power up marker
$RESET:	LD   (POWUP),A

;set interrupt jump vectors:
	LD   A,3		;initialize bank number
$SETINT:LD   HL,0038H		;interrupt entry point --> reg. HL & DE
	LD   D,H
	LD   E,L
	LD   B,3		;byte count	       --> reg. B
	PUSH AF			;save bank number
	CALL $XMOVE		;transfer jump vector
	POP  AF			;restore bank number
	DEC  A			;decrement bank number
	JR   NZ,$SETINT		;load next interrupt entry point

;hardware clock ?
	LD   A,(CLOCK)Š	OR   A
	JR   Z,$CLSGR		;jump if not
	LD   HL,$GTIME3H	;alter entry vectors to
	LD   ($GTIME3),HL	;clock maintenance routine
	LD   HL,$STIME3H
	LD   ($STIME3),HL

;clear graphic pages:
$CLSGR:	XOR  A			;colour = black
	LD   B,A		;clear graphic page 0
	CALL $CLS
	XOR  A			;colour = black
	LD   B,1		;clear graphic page 1
	CALL $CLS

;calc number of graphic scan lines:
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   DE,(VIDPAR+6)	;number of text lines		    --> reg. DE
	LD   D,0
	LD   H,D
	LD   L,D
LOOP:	ADD  HL,DE		;calc total number of scan lines - 1
	DJNZ LOOP
	DEC  HL
	LD   (YMAX),HL		;store them

;build table of y-addresses:
	LD   BC,(VIDPAR+5)	;number of text lines --> reg. B
	LD   DE,YTAB		;^address table       --> reg. DE
	LD   HL,8000H		;^graphic screen      --> reg. HL
OLOOP:	PUSH BC			;save line counter
	LD   (YBASE),HL		;store base address
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
ILOOP:	LD   A,L		;calc y address
	LD   (DE),A
	INC  DE
	LD   A,H
	LD   (DE),A
	INC  DE
	LD   A,8
	ADD  A,H
	LD   H,A
	DJNZ ILOOP		;process next scan line
	LD   HL,(YBASE)		;bump base address
	LD   BC,80
	ADD  HL,BC
	POP  BC			;restore line counter
	DJNZ OLOOP		;process next text line

;build table of normalized y-addresses:
	LD   IX,YNTAB		;^address table --> reg. IX
	LD   DE,0		;initialize scan line counter

NOLOOP:	PUSH DE			;save it

	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   HL,0ŠNILOOP:	ADD  HL,DE		;y-coordinate * # of scan lines
	DJNZ NILOOP

	LD   DE,18		;load divisor
	CALL DIV
	LD   A,E		;remainder --> accu
	CP   9			;remainder >= 9 ?
	JR   C,$+3		;jump if not
	INC  HL			;round normalized y-coordinate

	ADD  HL,HL		;make word index
	LD   DE,YTAB		;^unnormalized address table --> reg. DE
	ADD  HL,DE		;calc entry address
	LD   A,(HL)		;copy table entry
	LD   (IX),A
	INC  IX
	INC  HL
	LD   A,(HL)
	LD   (IX),A
	INC  IX

	POP  DE			;restore scan line counter
	INC  DE			;increment it
	LD   HL,450		;total count of scan lines --> reg. HL
	CALL CMP		;reached ?
	JR   NZ,NOLOOP		;process next scan line if not
	RET

YBASE:	DEFS 2			;base address of graphic screen - 80
JUMP:	DEFS 1			;byte at 0038H in bank 1


;EJECT
;*****************
;*  $ C L O C K  *
;*****************

;entry: A =  0	clock display off
;	  <> 0	clock display on
;	B = line   number (0 - 24)
;	E = column number (0 - 79)

;set clock display on/off:
$CLOCK:	LD   IX,(VDTABP)	;^screen constants		  --> reg. IX
	LD   HL,$SCREEN		;address of first screen location --> reg. HL
	LD   C,E		;display column 		  --> reg. C
	LD   D,0		;maximum column count		  --> reg. DE
	LD   E,(IX+1)
	DEC  B			;calc absolute screen address
	INC  B
	JR   Z,CLOCK2
CLOCK1:	ADD  HL,DE
	DJNZ CLOCK1
CLOCK2:	LD   E,C
	ADD  HL,DE
	LD   (CLOCK$LOC),HL	;save display address
	LD   (CLOCKON),A	;set/reset display marker
	RET			;return to caller
CLOCKON:DEFB 0
CLOCK$LOC:Š	DEFS 2


;EJECT
;***************
;*  $ D I S P  *
;***************

;entry: A =  0	turn off graphic display
;	  <> 0	turn on  graphic display
;	B =  graphic page number (0, 1)

$DISP:	LD  C,A			;save accu
	IN  A,($SYS0)		;read system byte 0
	AND 00100001B		;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	INC B			;test page number
	DEC B
	JR  Z,DISP1		;jump if page 0
	SET 4,A			;select page 1
DISP1:	OUT ($SYS0),A		;write system byte 0

	IN  A,($SYS1)		;read system byte 1
	AND 11010101B		;7.2 MHz clock rate
				;disable graphic page
				;disable boot ROM
				;disable graphic display
				;disable memory mapped I/O
	INC C			;test display mode
	DEC C
	JR  Z,DISP2		;jump if no display
	SET 1,A			;enable graphic display
DISP2:	OUT ($SYS1),A		;write system byte 1
	RET			;return to caller


;EJECT
;*************
;*  $ C L S  *
;*************

;entry: A = 0  black
;	    1  white
;	B = graphic page number (0, 1)

;clear graphic page:
$CLS:	LD  C,A			;save colour
	IN  A,($SYS0)		;read system byte 0
	AND 00010001B		;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	INC B			;test page number
	DEC B
	JR  Z,CLS1		;jump if page 0
	SET 5,A			;select page 1
CLS1:	OUT ($SYS0),A		;write system byte 0
Š
	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	LD  A,C			;restore colour
	LD  HL,8000H		;^graphic memory	--> reg. HL
	LD  DE,8001H		;^graphic memory + 1	--> reg. DE
	LD  BC,7FFFH		;size of graphic memory --> reg. BC
	OR  A			;colour ?
	JR  Z,CLS2		;jump if black
	LD  A,0FFH		;select white
CLS2:	LD  (HL),A
	LDIR			;clear graphic page

	IN  A,($SYS1)		;read system byte 1
	AND 11010111B		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	RET			;return to caller


;EJECT
;***************
;*  $ P L O T  *
;***************

;entry:  A = 0	non-normalized (high nibble)
;	     1	    normalized
;	     0	black	       (low  nibble)
;	     1	white
;	 B = graphic page number (0, 1)
;	HL = y-coordinate (0 - YYY)
;	DE = x-coordinate (0 - 639)

$PLOT:	PUSH BC			;save graphic page #
	PUSH AF			;save colour
	PUSH DE			;save x-coordinate
	AND  0F0H		;normalize y-coordinate ?
	JR   Z,PLOT1		;jump if not

;normalize y-coordinate:
	EX   DE,HL		;y-coordinate		  --> reg. DE
	OR   A			;clear carry flag
	LD   HL,449		;maximum scan line number --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   C,PLOT2		;jump if overflow

	PUSH DE			;save x-coordinate

	ADD  HL,HL		;make word index
	LD   DE,YNTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL)Š	JR   PLOT4


;EJECT
PLOT1:	EX   DE,HL		;y-coordinate		  --> reg. DE
	OR   A			;clear carry flag
	LD   HL,(YMAX)		;maximum scan line number --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   NC,PLOT3		;jump if no overflow
PLOT2:	POP  HL			;adjust stack
	POP  HL
	RET

PLOT3:	PUSH DE			;save x-coordinate

	ADD  HL,HL		;make word index
	LD   DE,YTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL)

PLOT4:	POP  HL			;get x-coordinate
;divide x-coordinate by 8:
	XOR  A			;clear remainder
	SRL  H			;/ 2
	RR   L
	RRA
	SRL  H			;/ 4
	RR   L
	RRA
	SRL  H			;/ 8
	RR   L
	RRA

	LD   C,A		;save accu
	LD   A,H		;test MSB of result
	OR   A
	JR   NZ,PLOT2		;return if overflow
	LD   A,L		;test LSB of result
	CP   80
	JR   NC,PLOT2		;return if overflow
	LD   A,C		;restore accu

	ADD  HL,DE		;final result = y-address + x / 8
	SET  7,H		;select upper 32K page

	RRA			;build SET/RES instruction
	RRA
	OR   0C6H		;SET instruction
	POP  BC			;get colour
	BIT  0,B		;black or white ?
	JR   NZ,$+4		;jump if white
	AND  0BEH		;RES instruction
	LD   (SETRES),A		;load instruction

	IN   A,($SYS0)		;read system byte 0
	AND  00010001B		;enable bank 0
				;select graphic page 0Š				;RTC interrupt only
				;disable character RAM
	POP BC			;get  page number
	INC B			;test page number
	DEC B
	JR  Z,PLOT5		;jump if page 0
	SET 5,A			;select page 1
PLOT5:	OUT ($SYS0),A		;write system byte 0

	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	DEFB 0CBH		;SET/RES dot
SETRES:	DEFS 1

	IN  A,($SYS1)		;read system byte 1
	AND 11010111B		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	EI			;reenable interrupts
	RET			;return to caller

YMAX:	DEFS 2			;total number of scan lines
YTAB:	DEFS 800		;addresses of all y-coordinates
YNTAB:	DEFS 900		;address of all normalized y-coordinates


;EJECT
;*****************
;*  $ P O I N T  *
;*****************

;entry:  B = graphic page number (0, 1)
;	HL = y-coordinate (0 - YYY)
;	DE = x-coordinate (0 - 639)
;
;exit :  A = 0	black
;	     1	white

$POINT:	PUSH BC			;save graphic page #
	PUSH DE			;save x-coordinate

POINT1:	EX   DE,HL		;y-coordinate		    --> reg. DE
	OR   A			;clear carry flag
	LD   HL,(YMAX)		;total number of scan lines --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   NC,POINT3		;jump if no overflow
POINT2:	XOR  A			;clear accu
	POP  HL			;adjust stack
	RET

POINT3:	PUSH DE			;save x-coordinate

	ADD  HL,HL		;make word index
	LD   DE,YTAB		;^y-addresses --> reg. DEŠ	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL)

	POP  HL			;get x-coordinate
;divide x-coordinate by 8:
	XOR  A			;clear remainder
	SRL  H			;/ 2
	RR   L
	RRA
	SRL  H			;/ 4
	RR   L
	RRA
	SRL  H			;/ 8
	RR   L
	RRA

	LD   C,A		;save accu
	LD   A,H		;test MSB of result
	OR   A
	JR   NZ,POINT2		;return if overflow
	LD   A,L		;test LSB of result
	CP   80
	JR   NC,POINT2		;return if overflow
	LD   A,C		;restore accu

	ADD  HL,DE		;final result = y-address + x / 8
	SET  7,H		;select upper 32K page

	RRA			;build BIT instruction
	RRA
	OR   46H
	LD   (BITTST),A		;load instruction

	IN   A,($SYS0)		;read system byte 0
	AND  00010001B		;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	POP BC			;get  page number
	INC B			;test page number
	DEC B
	JR  Z,POINT4		;jump if page 0
	SET 5,A			;select page 1
POINT4:	OUT ($SYS0),A		;write system byte 0

	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	DEFB 0CBH		;BIT test
BITTST:	DEFS 1

	IN  A,($SYS1)		;read system byte 1
	RES 3,A			;disable graphic pageŠ	OUT ($SYS1),A		;write system byte 1
	EI			;reenable interrupts

	LD   A,0		;clear accu
	RET  Z			;accu = 0 if dot = black
	INC  A			;accu = 1 if dot = white
	RET			;return to caller


;EJECT
;***************
;*  $ L I N E  *
;***************

;entry:  A = 0	non-normalized (high nibble)
;	     1	    normalized
;	     0	black	       (low  nibble)
;	     1	white
;	 B = graphic page number (0, 1)
;	HL = ^coordinates (x1, y1, x2, y2)

;draw line:
$LINE:	PUSH BC			;save page number
	PUSH AF			;save mode & colour
	LD   A,10H		;source bank	  = 1
				;destination bank = 0
	LD   DE,X1		;^coordinates --> reg. DE
	LD   B,8		;byte count   --> reg. BC
	CALL $XMOVE		;get coordinates
	POP  AF			;get mode
	LD   C,A		;save colour
	AND  0F0H		;normalize y-coordinates ?
	LD   A,C		;restore colour
	PUSH AF			;save colour
	JR   Z,LINE4		;jump if not

;normalize y-coordinates:
	POP  AF			;get colour
	AND  0FH		;mask mode
	PUSH AF
	LD   B,2		;y1, y2
	LD   IX,Y1		;^first y-coordinate		    --> reg. IX
LINE1:	PUSH BC			;save counter
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   D,(IX+1)		;y-coordinate			    --> reg. DE
	LD   E,(IX)
	LD   HL,0
LINE2:	ADD  HL,DE		;y-coordinate * # of scan lines
	DJNZ LINE2

	LD   DE,18		;load divisor
	CALL DIV
	LD   A,E		;remainder --> accu
	CP   9			;remainder >= 9 ?
	JR   C,LINE3		;jump if not
	INC  HL			;round normalized y-coordinate
LINE3:	LD   (IX+1),H		;store normalized y-coordinate
	LD   (IX),L
	INC  IX			;get ^second y-coordinateŠ	INC  IX
	INC  IX
	INC  IX
	POP  BC			;restore counter
	DJNZ LINE1		;normalize second y-coordinate

;calc px and dx:
LINE4:	LD   HL,0		;clear pp
	LD   (PP),HL
	LD   HL,(X2)		;second x-coordinate --> reg. HL
	LD   DE,(X1)		;first	x-coordinate --> reg. DE
	CALL CMP		;x2 >= x1 ?
	JP   M,LINE5		;jump if x2 < x1
	LD   BC,1		;dx = 1
	JR   LINE6
LINE5:	LD   BC,-1		;dx = -1
	EX   DE,HL
LINE6:	LD   (DX),BC		;store dx
	OR   A
	SBC  HL,DE		;px = x2 - x1 + 1 (x1 - x2 + 1)
	INC  HL
	LD   (PX),HL

;calc py and dy:
	LD   HL,(Y2)		;second y-coordinate --> reg. HL
	LD   DE,(Y1)		;first	y-coordinate --> reg. DE
	CALL CMP		;y2 >= y1 ?
	JP   M,LINE7		;jump if y2 < y1
	LD   BC,1		;dy = 1
	JR   LINE8
LINE7:	LD   BC,-1		;dy = -1
	EX   DE,HL
LINE8:	LD   (DY),BC		;store dx
	OR   A
	SBC  HL,DE		;py = y2 - y1 + 1 (y1 - y2 + 1)
	INC  HL
	LD   (PY),HL

;plot first dot:
	CALL LPLOT		;plot first point of line

;py <= px:
	LD   HL,(PX)		;px --> reg. HL
	LD   DE,(PY)		;py --> reg. DE
	CALL CMP		;py <= px ?
	JP   M,YLIN		;jump if py > px
XLIN:	LD   HL,(X1)
	LD   DE,(X2)
	CALL CMP		;x1 == x2 ?
	JP   Z,ENDLIN		;break if yes
	LD   HL,(PP)		;pp += py
	LD   DE,(PY)
	ADD  HL,DE
	LD   (PP),HL
	LD   DE,(PX)
	CALL CMP		;pp >= px
	JP   M,XLIN1		;jump pp < px
	OR   A
	SBC  HL,DE		;pp -= px
	LD   (PP),HLŠ	LD   HL,(Y1)		;y1 += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (Y1),HL
XLIN1:	LD   HL,(X1)		;x1 += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (X1),HL
	CALL LPLOT		;plot next point of line
	JR   XLIN

;py > px:
YLIN:	LD   HL,(Y1)
	LD   DE,(Y2)
	CALL CMP		;y1 == y2 ?
	JR   Z,ENDLIN		;break if yes
	LD   HL,(PP)		;pp += px
	LD   DE,(PX)
	ADD  HL,DE
	LD   (PP),HL
	LD   DE,(PY)
	CALL CMP		;pp >= py
	JP   M,YLIN1		;jump pp < py
	OR   A
	SBC  HL,DE		;pp -= py
	LD   (PP),HL
	LD   HL,(X1)		;x1 += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (X1),HL
YLIN1:	LD   HL,(Y1)		;y1 += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (Y1),HL
	CALL LPLOT		;plot next point of line
	JR   YLIN

;end of draw line routine:
ENDLIN:	POP  HL			;adjust stack
	POP  HL
	RET

;plot (x1, y1):
LPLOT:	POP  HL			;skip return address
	POP  AF			;get colour
	POP  BC			;get graphic page
	PUSH BC			;save that suckers again
	PUSH AF
	PUSH HL			;save return address
	LD   HL,(Y1)		;y-coordinate --> reg. HL
	LD   DE,(X1)		;x-coordinate --> reg. DE
	JP   $PLOT

;variables for draw line, circle, and arc:
XM:	DEFS 2
YM:	DEFS 2
XX:
X1:	DEFS 2
YY:
Y1:	DEFS 2ŠX2:	DEFS 2
Y2:	DEFS 2
M1:
PX:	DEFS 2
M2:
PY:	DEFS 2
DD:
PP:	DEFS 2
N1:
XB:
XB1:	DEFS 2
N2:
XB2:	DEFS 2
II:
N3:	DEFS 2
P1:	DEFS 2
P2:	DEFS 2
DX:	DEFS 2
DY:	DEFS 2


;EJECT
;*******************
;*  $ C I R C L E  *
;*******************

;entry:  A = 0	black
;	     1	white
;	 B = graphic page number (0, 1)
;	HL = ^coordinates, radius (xm, ym, r)

;draw circle:
$CIRCLE:PUSH BC			;save page number
	SET  4,A		;force normalizing
	PUSH AF			;save colour & mode
	LD   A,10H		;source bank	  = 1
				;destination bank = 0
	LD   DE,XM		;^coordinates --> reg. DE
	LD   B,6		;byte count   --> reg. BC
	CALL $XMOVE		;get coordinates

	LD   HL,0		;dd = yy = 0
	LD   (DD),HL
	LD   (YY),HL
	LD   HL,(XX)		;m1 = 1 - (xx + xx)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	LD   (M2),HL		;m2 = 1
	OR   A
	SBC  HL,DE
	LD   (M1),HL

;EJECT
;plot first dots:
	LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym	 --> reg. HLŠ	CALL CPLOT

	LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym	 --> reg. HL
	CALL CPLOT

	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   DE,(XX)
	ADD  HL,DE
	LD   DE,(XM)		;xm	 --> reg. DE
	CALL CPLOT

	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	LD   DE,(XM)		;xm	 --> reg. DE
	CALL CPLOT

;EJECT
;circle loop:

;calc next coordinates:
CIRCLE1:LD   HL,(M1)		;p1 = m1 + d
	LD   DE,(DD)
	ADD  HL,DE
	LD   (P1),HL
	LD   HL,(M2)		;p2 = m2 + d
	ADD  HL,DE
	LD   (P2),HL

	LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
	LD   HL,(M2)		;m2 += 2
	INC  HL
	INC  HL
	LD   (M2),HL

	LD   HL,(P2)
	CALL ABS
	EX   DE,HL
	LD   HL,(P1)
	LD   DE,(M2)
	ADD  HL,DE
	CALL ABS
	CALL CMP		;jump if
	JR   C,CIRCLE2		;abs(p1 + m2) < abs(p2)

	LD   HL,(P2)		;dd = p2
	LD   (DD),HL
	JR   CIRCLE3

CIRCLE2:LD   HL,(XX)		;xx--
	DEC  HL
	LD   (XX),HLŠ	LD   HL,(P1)		;dd = p1 + m2
	LD   DE,(M2)
	ADD  HL,DE
	LD   (DD),HL
	LD   HL,(M1)		;m1 += 2
	INC  HL
	INC  HL
	LD   (M1),HL

;EJECT
;plot dots:
CIRCLE3:LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT

	LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT

	LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - yy --> reg. HL
	LD   BC,(YY)
	OR   A
	SBC  HL,BC
	CALL CPLOT

	LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - yy --> reg. HL
	LD   BC,(YY)
	OR   A
	SBC  HL,BC
	CALL CPLOT

	LD   HL,(XM)		;xm + yy --> reg. DE
	LD   DE,(YY)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   BC,(XX)
	ADD  HL,BC
	CALL CPLOT
Š	LD   HL,(XM)		;xm - yy --> reg. DE
	LD   DE,(YY)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   BC,(XX)
	ADD  HL,BC
	CALL CPLOT

	LD   HL,(XM)		;xm + yy --> reg. DE
	LD   DE,(YY)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   BC,(XX)
	OR   A
	SBC  HL,BC
	CALL CPLOT

	LD   HL,(XM)		;xm - yy --> reg. DE
	LD   DE,(YY)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   BC,(XX)
	OR   A
	SBC  HL,BC
	CALL CPLOT

	LD   HL,(XX)
	LD   DE,(YY)
	CALL CMP		;jump if
	JP   P,CIRCLE1		;xx >= yy

	POP  HL			;adjust stack
	POP  HL
	RET

;plot (xx, yy):
CPLOT:	POP  IX			;skip return address
	POP  AF			;get colour & mode
	POP  BC			;get graphic page
	PUSH BC			;save that suckers again
	PUSH AF
	PUSH IX			;save return address
	JP   $PLOT


;EJECT
;*************
;*  $ A R C  *
;*************

;entry:  A = 0	black
;	     1	white
;	 B = graphic page number (0, 1)
;	HL = ^coordinates (xm, ym, x1, y1, x2, y2)
Š;draw arc:
$ARC:	PUSH BC			;save page number
	SET  4,A		;force normalizing
	PUSH AF			;save colour & mode
	LD   A,10H		;source bank	  = 1
				;destination bank = 0
	LD   DE,XM		;^coordinates --> reg. DE
	LD   B,12		;byte count   --> reg. BC
	CALL $XMOVE		;get coordinates

	LD   HL,0		;dd = 0
	LD   (DD),HL
	LD   HL,(X1)		;xx = x1 - xm
	LD   DE,(XM)
	OR   A
	SBC  HL,DE
	LD   (XX),HL
	LD   HL,(X2)		;x2 -= xm
	OR   A
	SBC  HL,DE
	LD   (X2),HL
	LD   HL,(Y1)		;yy = y1 - ym
	LD   DE,(YM)
	OR   A
	SBC  HL,DE
	LD   (YY),HL
	LD   HL,(Y2)		;y2 -= xm
	OR   A
	SBC  HL,DE
	LD   (Y2),HL

;plot first dot:
	LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT


;EJECT
;arc loop:

;calc next coordinates:
ARC1:	LD   HL,(YY)
	BIT  7,H		;jump if
	JR   NZ,ARC2		;yy < 0
	LD   HL,-1		;dx = -1
	LD   (DX),HL
	LD   HL,(XX)		;m1 = 1 - (xx + xx)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	OR   A
	SBC  HL,DE
	JR   ARC3
ARC2:	LD   HL,(XX)		;m1 = 1 + xx + xx
	ADD  HL,HLŠ	EX   DE,HL
	LD   HL,1		;dx = 1
	LD   (DX),HL
	ADD  HL,DE
ARC3:	LD   (M1),HL

	LD   HL,(XX)
	BIT  7,H		;jump if
	JR   NZ,ARC4		;xx < 0
	LD   HL,(YY)		;m2 = 1 + yy + yy
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1		;dy = 1
	LD   (DY),HL
	ADD  HL,DE
	JR   ARC5
ARC4:	LD   HL,-1		;dy = -1
	LD   (DY),HL
	LD   HL,(YY)		;m2 = 1 - (yy + yy)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	OR   A
	SBC  HL,DE
ARC5:	LD   (M2),HL

	LD   DE,(DD)		;p2 = m2 + dd
	ADD  HL,DE
	LD   (P2),HL
	CALL ABS		;n3 = abs(p2)
	LD   (N3),HL
	LD   HL,(M1)		;p1 = m1 + d
	ADD  HL,DE
	LD   (P1),HL
	CALL ABS		;n1 = abs(p1)
	LD   (N1),HL
	LD   HL,(P1)		;n2 = abs(p1 + m2)
	LD   DE,(M2)
	ADD  HL,DE
	CALL ABS
	LD   (N2),HL

	LD   DE,(N1)
	CALL CMP		;jump if
	JR   C,ARC8		;n1 >= n2
	JR   Z,ARC8
	LD   HL,(N3)
	CALL CMP		;jump if
	JR   C,ARC6		;n1 >= n3
	JR   Z,ARC6

	LD   HL,(XX)		;xx += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (XX),HL
	LD   HL,(P1)		;dd = p1
	LD   (DD),HL
	JR   ARC9

ARC6:	LD   HL,(P2)		;dd = p2Š	LD   (DD),HL
ARC7:	LD   HL,(YY)		;yy += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (YY),HL
	JR   ARC9

ARC8:	LD   DE,(N3)
	CALL CMP		;jump if
	JP   P,ARC6		;n2 >= n3

	LD   HL,(XX)		;xx += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (XX),HL
	LD   HL,(P1)		;dd = p1 + m2
	LD   DE,(M2)
	ADD  HL,DE
	LD   (DD),HL
	JR   ARC7


;EJECT
;plot dot:
ARC9:	LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT

	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JP   NZ,ARC1		;xx != x2
	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   NZ,ARC1		;yy != y2

	POP  HL			;adjust stack
	POP  HL
	RET


;EJECT
;***************
;*  $ F I L L  *
;***************

;entry:  A = 0	non-normalized		(high nibble)
;	     1	    normalized
;	     graphic page number (0, 1) (low  nibble)
;	BC = ^fill pattern
;	HL = y-coordinate within shape
;	DE = x-coordinate within shape

;fill shape with user supplied pattern:Š$FILL	EQU  $			;not implemented yet


;EJECT
;***************
;*  $ C O P Y  *
;***************

;entry:  A = source	 page (high nibble)
;	     destination page (low  nibble)
;	     0 = graphic page 0
;	     1 = graphic page 1
;	     F = user buffer
;		 (user/user [FF] = invalid combination)
;	HL = ^parameter block (x1, y1, x2, y2, dx, dy
;			    or x2, y2, dx, dy
;			    or x1, y1, dx, dy)
;	DE = ^user buffer

;copy graphic area:
$COPY:	LD   (UBUF),DE		;save ^user buffer
	LD   C,A		;save source page
	AND  0FH		;mask it
	CP   0FH		;destination == user buffer ?
	JP   Z,COPY17		;jump if yes
	PUSH AF
	LD   A,C		;restore source page
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	CP   0FH		;source == user buffer ?
	JP   Z,COPY10		;jump if yes
	PUSH AF

	LD   A,10H		;source bank	  = 1
				;destination bank = 0
	LD   DE,X1		;^parameter block --> reg. DE
	LD   B,12		;byte count	  --> reg. BC
	CALL $XMOVE		;get coordinates

;EJECT
;copy on screen:

;setup variables:
	LD   HL,(X1)		;xb1 = x1
	LD   (XB1),HL
	LD   HL,(X2)		;xb2 = x2
	LD   (XB2),HL

;determine copy direction of x-coordinate:
	LD   DE,(X1)
	CALL CMP
	JR   C,COPY1		;jump if
	JR   Z,COPY1		;x1 >= x2
	LD   DE,(PX)		;xb2 += dx - 1
	DEC  DE
	ADD  HL,DE
	LD   (XB2),HLŠ	LD   HL,(XB1)		;xb1 += dx - 1
	ADD  HL,DE
	LD   (XB1),HL
	LD   HL,(X1)		;x1--
	DEC  HL
	LD   (X1),HL
	LD   HL,-1		;dx = -1
	JR   COPY2
COPY1:	LD   HL,(X1)		;x1 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X1),HL
	LD   HL,1		;dx = 1
COPY2:	LD   (PX),HL

;determine copy direction of y-coordinate:
	LD   HL,(Y1)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   P,COPY3		;y1 >= y2
	DEC  HL			;yy = --y1 + dy
	LD   (Y1),HL
	LD   DE,(PY)
	ADD  HL,DE
	LD   (YM),HL
	LD   HL,(Y2)		;y2 += dy - 1
	DEC  DE
	ADD  HL,DE
	LD   (Y2),HL
	LD   HL,-1		;dy = -1
	JR   COPY4
COPY3:	LD   (YM),HL		;yy = y1
	LD   DE,(PY)		;y1 += dy
	ADD  HL,DE
	LD   (Y1),HL
	LD   HL,1		;dy = 1
COPY4:	LD   (PY),HL

;EJECT
;copy area:
COPY5:	LD   HL,(YM)
	LD   DE,(Y1)
	CALL CMP		;jump if
	JR   Z,COPY8		;yy == y1

	LD   HL,(XB1)		;xx = xb1
	LD   (XM),HL
	LD   HL,(XB2)		;x2 = xb2
	LD   (X2),HL

COPY6:	LD   HL,(XM)
	LD   DE,(X1)
	CALL CMP		;jump if
	JR   Z,COPY7		;xx == x1

	POP  BC			;source page # --> reg. B
	PUSH BC
	LD   HL,(YM)		;y-coordinate  --> reg. HL
	LD   DE,(XM)		;x-coordinate  --> reg. DE
	CALL $POINT		;read source dotŠ
	POP  HL			;destination page # --> reg. B
	POP  BC
	PUSH BC
	PUSH HL
	LD   HL,(Y2)		;y-coordinate	    --> reg. HL
	LD   DE,(X2)		;x-coordinate	    --> reg. DE
	CALL $PLOT		;set destination dot

	LD   HL,(XM)		;xx += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (XM),HL
	LD   HL,(X2)		;x2 += dx
	ADD  HL,DE
	LD   (X2),HL
	JR   COPY6

COPY7:	LD   HL,(YM)		;yy += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (YM),HL
	LD   HL,(Y2)		;y2 += dy
	ADD  HL,DE
	LD   (Y2),HL
	JR   COPY5

COPY8:	POP  HL			;adjust stack
COPY9:	POP  HL
	RET

;EJECT
;copy from user buffer to screen:
COPY10:	LD   A,10H		;source bank	  = 1
				;destination bank = 0
	LD   DE,X2		;^parameter block --> reg. DE
	LD   B,8		;byte count	  --> reg. BC
	CALL $XMOVE		;get coordinates

;setup variables:
	LD   HL,(Y2)		;yy = y2
	LD   (YY),HL
	LD   HL,(X2)		;xb = x2
	LD   (XB),HL
	LD   HL,(PX)		;pp = dx / 8 + (dx % 8 != 0)
	LD   A,L
	SRL  H
	RR   L
	SRL  H
	RR   L
	SRL  H
	RR   L
	AND  7
	JR   Z,COPY11
	INC  HL
COPY11:	LD   (PP),HL
	LD   HL,(X2)		;x2 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X2),HLŠ	LD   HL,(Y2)		;y2 += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (Y2),HL

;EJECT
;copy area:
COPY12:	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JR   Z,COPY9		;yy == y2

	LD   HL,(UBUF)		;^user buffer --> reg. HL
	LD   DE,LINBUF		;^temp buffer --> reg. DE
	LD   A,(PP)		;byte count   --> reg. B
	LD   B,A
	LD   A,10H		;source bank	  = 1
				;destination bank = 0
	CALL $XMOVE		;get user bytes

	LD   HL,(XB)		;xx = xb
	LD   (XX),HL
	LD   HL,0		;ii = 0
	LD   (II),HL

COPY13:	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JR   Z,COPY16		;xx == x2

	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(II)		;divide buffer index by 8
	XOR  A
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	ADD  HL,DE		;now reg. HL contains byte address
	RRA			;build BIT instruction
	RRA
	OR   46H
	LD   (COPY14),A
	DEFB 0CBH		;BIT instruction
COPY14:	DEFS 1

	LD   A,0		;initialize colour (black)
	JR   Z,COPY15		;dont't change colour if tested bit = 0
	INC  A			;change colour (white)
COPY15:	POP  BC			;graphic page number # --> reg. B
	PUSH BC
	LD   HL,(YY)		;y-coordinate	       --> reg. HL
	LD   DE,(XX)		;x-coordinate	       --> reg. DE
	CALL $PLOT		;set dot

	LD   HL,(XX)		;xx++Š	INC  HL
	LD   (XX),HL
	LD   HL,(II)		;ii++
	INC  HL
	LD   (II),HL
	JR   COPY13

COPY16:	LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
	LD   HL,(UBUF)		;bump pointer to user buffer
	LD   DE,(PP)
	ADD  HL,DE
	LD   (UBUF),HL
	JP   COPY12

;EJECT
;copy from screen to user buffer:
COPY17:	LD   A,C		;restore source page
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	PUSH AF

	LD   A,10H		;source bank	  = 1
				;destination bank = 0
	LD   DE,X2		;^parameter block --> reg. DE
	LD   B,8		;byte count	  --> reg. BC
	CALL $XMOVE		;get coordinates

;setup variables:
	LD   HL,(Y2)		;yy = y2
	LD   (YY),HL
	LD   HL,(X2)		;xb = x2
	LD   (XB),HL
	LD   HL,(PX)		;pp = dx / 8 + (dx % 8 != 0)
	LD   A,L
	SRL  H
	RR   L
	SRL  H
	RR   L
	SRL  H
	RR   L
	AND  7
	JR   Z,COPY18
	INC  HL
COPY18:	LD   (PP),HL
	LD   HL,(X2)		;x2 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X2),HL
	LD   HL,(Y2)		;y2 += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (Y2),HL

;EJECT
;copy area:ŠCOPY19:	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   Z,COPY9		;yy == y2

	LD   HL,(XB)		;xx = xb
	LD   (XX),HL
	LD   HL,0		;ii = 0
	LD   (II),HL

COPY20:	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JR   Z,COPY22		;xx == x2

	POP  BC			;graphic page number # --> reg. B
	PUSH BC
	LD   HL,(YY)		;y-coordinate	       --> reg. HL
	LD   DE,(XX)		;x-coordinate	       --> reg. DE
	CALL $POINT		;read dot
	LD   C,A		;colour 	       --> reg. C

	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(II)		;divide buffer index by 8
	XOR  A
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	ADD  HL,DE		;now reg. HL contains byte address
	RRA			;build SET/RES instruction
	RRA
	OR   0C6H		;SET instruction
	BIT  0,C		;colour black or white ?
	JR   NZ,$+4		;jump if white
	AND  0BEH		;RES instruction
	LD   (COPY21),A		;load instruction
	DEFB 0CBH		;SET/RES instruction
COPY21:	DEFS 1

	LD   HL,(XX)		;xx++
	INC  HL
	LD   (XX),HL
	LD   HL,(II)		;ii++
	INC  HL
	LD   (II),HL
	JR   COPY20

COPY22:	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(UBUF)		;^user buffer --> reg. DE
	LD   A,(PP)		;byte count   --> reg. B
	LD   B,A
	LD   A,1		;source bank	  = 0
				;destination bank = 1
	CALL $XMOVE		;put user bytesŠ
	LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
	LD   HL,(UBUF)		;bump pointer to user buffer
	LD   DE,(PP)
	ADD  HL,DE
	LD   (UBUF),HL
	JP   COPY19

UBUF:	DEFS 2			;^user buffer


;EJECT
;division HL / DE, quotient --> HL, remainder --> DE:
DIV:	LD   A,H		;dividend (MSB) --> accu
	LD   C,L		;dividend (LSB) --> reg. C
	LD   HL,0		;clear accumulator
	LD   B,16		;init counter
DIV1:	RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
	SBC  HL,DE		;subtract divisor
	JR   NC,$+3		;subtraction ok
	ADD  HL,DE		;restore accumulator
	CCF			;complement carry flag
	DJNZ DIV1		;counter = 0 ?
	RL   C			;get last result bit
	RLA
	EX   DE,HL		;remainder --> reg. DE
	LD   H,A		;quotient  --> reg. HL
	LD   L,C
	RET

;compare HL with DE:
CMP:	PUSH HL			;save reg. HL
	OR   A			;clear carry flag
	SBC  HL,DE		;compare operands
	POP  HL			;restore reg. HL
	RET

;HL = abs(HL):
ABS:	BIT  7,H		;number positive ?
	RET  Z			;return if yes
	PUSH DE			;save reg. DE
	EX   DE,HL		;number --> reg. DE
	LD   HL,0
	OR   A			;clear carry flag
	SBC  HL,DE		;negate number
	POP  DE			;restore reg. DE
	RET


;EJECT
;******************************************************************************
;*	       I N T E R R U P T   S E R V I C E   R O U T I N E	      *
;******************************************************************************

INT1:	PUSH BC			;save user register set
	PUSH DEŠ	PUSH HL
	PUSH IX
	PUSH IY

;scan keyboard:
	CALL $SCAN		;scan the keyboard
	LD   A,C		;get code of pressed key
	OR   A			;key pressed ?
	JR   Z,RTC3		;jump if not
	LD   A,(KLEN)		;A = buffer length
	LD   B,A		;save it
	CP   80			;jump if
	JR   Z,RTC2		;it's full
	LD   A,(REPEAT)		;auto repeat ?
	OR   A
	JR   Z,RTC0		;jump if not
	LD   A,B		;restore buffer length
	OR   A			;buffer empty ?
	JR   NZ,RTC3		;return no repeated key if buffer not empty
RTC0:	LD   A,C		;get code of pressed key
	LD   HL,(EPTR)		;HL = next location pointer
	LD   (HL),A		;save the key
	INC  HL			;bump the pointer
	LD   DE,KBUF+80		;DE = end of buffer pointer
	EX   DE,HL		;swap the pointers
	SBC  HL,DE		;wrap around the buffer ?
	EX   DE,HL		;swap the pointers
	JR   NZ,RTC1		;jump if no wrap around
	LD   HL,KBUF		;HL = new pointer
RTC1:	LD   (EPTR),HL		;save the pointer
	LD   HL,KLEN		;HL = buffer length pointer
	INC  (HL)		;bump it
	JR   RTC3
RTC2:	CALL BEEP		;alarm

;clock maintenance routine:
RTC3:	LD   HL,RTC$TICK$COUNT	;downdate tick count
	DEC  (HL)
	JR   NZ,INT6		;is not at 0 yet
	LD   (HL),45		;one second has elapsed so
				;reset to original value

	LD   A,(CLOCK)		;hardware clock ?
	OR   A
	JR   NZ,INT2		;jump if yes

	LD   B,3		;maximum number of values to update
	LD   DE,TIME$IN$BCD$END	;DE -> seconds of BCD time
	LD   HL,UPDATE$TIME	;HL -> control table
RTC$UPDATE$DIGIT:
	LD   A,(DE)
	INC  A			;bump a time period, seconds
	DAA			;then minutes, then ours
	LD   (DE),A
	SUB  (HL)		;compare period to max. unit value
	JR   NZ,INT2		;jump if unit not max. value
	LD   (DE),A		;else reset period to zero
	DEC  DE			;and bump increment and
	INC  HL			;test addresses to next unit
	DJNZ RTC$UPDATE$DIGIT	;loop till periods incremented or no overflowŠ				;from one period to the next
	LD   HL,(BINARY$DATE)	;HL -> number of days since Jan 1st, 1978
	INC  HL			;bump day count
	LD   (BINARY$DATE),HL

;EJECT
INT2:	LD   A,(CLOCKON)
	OR   A			;display clock ?
	JR   Z,INT6		;jump if not
	LD   A,(CLOCK)		;hardware clock ?
	OR   A
	JR   Z,INT3		;jump if not
	LD   HL,BINARY$DATE	;^time & date buffer --> reg. HL
	LD   (INT),A		;mark interrupt service routine
	CALL $GTIME3H		;read hardware clock
	XOR  A
	LD   (INT),A
INT3:	LD   HL,TIME$IN$BCD	;^BCD	time --> reg. HL
	LD   DE,$ATIME		;^ASCII time --> reg. DE
	LD   B,3		;convert hours, minutes, and seconds
INT4:	CALL BCDASC
	DJNZ INT4
	IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11111110B		;enable memory mapped I/O
	OR   00010000B		;enable video RAM
	OUT  ($SYS1),A
	LD   HL,$ATIME		;^ASCII time	   --> reg. HL
	LD   DE,(CLOCK$LOC)	;^display location --> reg. DE
	LD   B,8		;byte count	   --> reg. B
INT5:	LD   A,(DE)		;get screen character
	AND  80H		;mask invert bit
	OR   (HL)		;over clock character
	LD   (DE),A		;display clock character
	INC  DE			;get next clock character
	INC  HL			;get next screen location
	DJNZ INT5		;display whole clock
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A

INT6:	POP  IY
	POP  IX
	POP  HL			;restore user register set
	POP  DE
	POP  BC
	JP   $INT1		;jump to end of interrupt service routine

;convert BCD to ASCII:
BCDASC:	LD   A,(HL)		;get high nibble
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	ADD  A,'0'		;convert it to ASCII
	LD   (DE),A		;store high digit
	LD   A,(HL)		;get low nibble
	AND  0FH		;get low nibble
	ADD  A,'0'		;convert to ASCII
	INC  DEŠ	INC  HL
	LD   (DE),A		;store low digit
	INC  DE			;bump over colon
	INC  DE
	RET

RTC$TICK$COUNT:
	DEFB 45
UPDATE$TIME:
	DEFB 60H		;BCD 60 seconds
	DEFB 60H		;BCD 60 minutes
	DEFB 24H		;BCD 24 hours
$ATIME:	DEFM 'HH:MM:SS'		;time in ASCII format
INT:	DEFB 0			;marker for interrupt service routine


;EJECT
;******************************************************************************
;*		  C O M M O N	P A R T   O F	D R I V E R S		      *
;******************************************************************************

	ORG  3500H
	.PHASE 0FE00H		;common memory

;time & date location will not be destroyed during reset:
BINARY$DATE:
	DEFW 1
TIME$IN$BCD:
	DEFB 0
	DEFB 0
TIME$IN$BCD$END:
	DEFB 0

;*****************
;*  $ X M O V E  *
;*****************

;entry:  A	upper nibble = source	   bank
;		lower nibble = destination bank
;	 B  =	byte count
;	DE  =	destination address
;	HL  =	source	    address

;interbank transfer:
$XMOVE:	LD   C,A		;save source/dest bank #'s
	IN   A,($SYS0)		;read system byte 0
	PUSH AF			;save current bank #
	LD   A,C		;restore source/dest bank #'s
	PUSH DE			;save destination address
	LD   C,B		;byte count --> reg. BC
	LD   B,0
	PUSH BC			;save byte count
	PUSH AF			;save destination bank number
	SRL  A			;get source bank number
	SRL  A
	SRL  A
	SRL  A
	CALL SWITCH		;select source bank
	LD   DE,SBUF		;^scratch buffer --> reg. DE
	LDIR			;transfer data from source buf to scratch bufŠ	POP  AF			;get destination bank number
	AND  0FH
	CALL SWITCH		;select destination bank
	POP  BC			;restore byte count
	LD   HL,SBUF		;^scratch buffer --> reg. HL
	POP  DE			;restore destination address
	LDIR			;transfer data from scratch buf to dest buf
	POP  AF			;restore current bank #
	OUT  ($SYS0),A		;select it
	RET

;select memory bank:
SWITCH:	RRCA			;lowest two bits --> highest two bits
	RRCA
	AND  0C0H
	OR   1
	LD   D,A		;save bank number
	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;RTC interrupt only
				;disable character RAM
	OR   D			;set bank number
	OUT  ($SYS0),A		;write system byte 0
	RET

SBUF:	DEFS 128		;scratch buffer


;EJECT
;entry to interrupt service routine:
	DEFS 64			;local stack
$INT:	LD   (SAVESP),SP	;save user stack
	LD   SP,$INT		;get local stack
	PUSH AF			;save user accu/status
	IN   A,($FDSEL)		;reset interrupt flipflop
	IN   A,($SYS0)		;get current bank #
	PUSH AF			;save it
	AND  00111111B		;enable bank 0
	OUT  ($SYS0),A		;select it
	JP   INT1		;perform interrupt service routine

$INT1:	POP  AF			;get user bank
	OUT  ($SYS0),A		;select it
	POP  AF			;restore user accu/status
	LD   SP,(SAVESP)	;restore user stack
	EI			;enable interrupts
	RET			;return to user task
SAVESP:	DEFS 2			;SP save area


;EJECT
;floppy disk I/O:
IO:	CALL SWITCH		;select bank of transfer buffer
	POP  AF			;restore status
	JR   Z,WRITE1		;jump if write

;read sector:
	LD   A,$RDSEC		;issue "read" command
	DI			;disable interrupts
	OUT  ($FDCMD),A
	LD   BC,12		;56 usec delayŠ	CALL DELAY
	LD   C,$FDDATA		;data register
READ1:	IN   A,($FDSTAT)	;get FDC status
	BIT  1,A		;data request ?
	JR   NZ,READ3		;yes, get byte
	BIT  0,A		;full sector transferred ?
	JR   Z,IOEND		;yes, go end process
	IN   A,($FDSTAT)	;get FDC status
	BIT  1,A		;data request ?
	JR   NZ,READ3		;yes, get byte
	BIT  7,A		;drive not ready ?
	JR   Z,READ1		;no loop
READ2:	LD   A,4		;error code 4 --> accu
	RET
READ3:	INI			;read char
	JR   READ1

;write sector:
WRITE1:	LD   A,$WRSEC		;issue "write" command
	DI			;disable interrupts
	OUT  ($FDCMD),A
	LD   BC,12		;56 usec delay
	CALL DELAY
	LD   C,$FDDATA		;data register
WRITE2:	IN   A,($FDSTAT)	;get FDC status
	BIT  1,A		;data request ?
	JR   NZ,WRITE3		;yes, put byte
	BIT  0,A		;full sector written ?
	JR   Z,IOEND		;yes, go end process
	IN   A,($FDSTAT)	;get FDC status
	BIT  1,A		;data request ?
	JR   NZ,WRITE3		;yes, put byte
	BIT  7,A		;drive not ready ?
	JR   Z,WRITE2		;no loop
	JR   READ2		;jump to error exit
WRITE3:	OUTI			;write char
	JR   WRITE2		;put next byte

IOEND:	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;enable bank 0
	OR   00000001B
	OUT  ($SYS0),A		;write system byte 0
	JP   STATUS		;check status

;delay for ((BC-1)*26+17)*2.255 T-states:
DELAY:	DEC  BC			;decrement cycle count
	LD   A,B		;test if count zero
	OR   C			;combine LSB/MSB of count
	JR   NZ,DELAY		;loop until delay count exhausted
	RET			;rtn to caller


;EJECT

iæ wincè                        » ##£ fch
;Winchester I/O:
IOW:	CALL SWITCH		;select bank of transfer buffer
	POP  AF			;restore status
	JR   Z,WRITW1		;jump if WRITE
Š;read sector:
	COND SASI		;Xebec part

	LD   BC,RPORT0		;SASI port 0  --> reg. C
	CALL REQWAIT		;wait for request from cntlr
READW1:	IN   A,(RPORT1)		;get cntlr status lines
	AND  IOMASK+CDMASK+REQMASK
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,WDBACK		;jump if data transfer finished
	CP   IOMASK+REQMASK
	JR   NZ,READW1		;wait for request
	INIR			;transfer memory bytes to sector buffer
	JR   READW1

	 ELSE			;WD1002 part

READW1:	IN   A,($STATUS)	;read WDC status
	BIT  7,A		;read done ?
	JR   NZ,READW1		;no, loop
	LD   A,E		;sector length bits --> accu
	OR   A			;test sector length bits
	JR   Z,R256		;read 256 bytes
	DEC  A
	JR   Z,R512		;read 512 bytes
	DEC  A
	JR   Z,R1024		;read 1024 bytes
	LD   B,128		;load new byte counter
	JR   R256		;read 128 bytes
R1024:	INIR			;transfer sector
	INIR
R512:	INIR
R256:	INIR
	JR   WDBACK		;jump back into banked memory

	ENDC

;write sector:
	COND SASI		;Xebec part

WRITW1:	LD   BC,WPORT0		;SASI port 0 --> reg. C
	CALL REQWAIT		;wait for cntlr request
WRITW2:	IN   A,(RPORT1)		;get cntlr status lines
	AND  IOMASK+CDMASK+REQMASK
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,WDBACK		;jump if data transfer finished
	CP   REQMASK
	JR   NZ,WRITW2		;wait for request
	OTIR			;transfer memory bytes to sector buffer
	JR   WRITW2

	 ELSE			;WD1002 part

WRITW1:	LD   A,E		;sector length bits --> accu
	OR   A			;test sector length bits
	JR   Z,W256		;write 256 bytes
	DEC  A
	JR   Z,W512		;write 512 bytes
	DEC  A
	JR   Z,W1024		;write 1024 bytes
	LD   B,128		;load new byte counterŠ	JR   W256		;write 128 bytes
W1024:	OTIR			;transfer sector
	OTIR
W512:	OTIR
W256:	OTIR
WRITW2:	IN   A,($STATUS)	;read WDC status
	BIT  7,A		;write done ?
	JR   NZ,WRITW2		;no, loop

	ENDC

WDBACK:	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;enable bank 0
	OR   00000001B
	OUT  ($SYS0),A		;write system byte 0
	JP   WDCSTAT

	COND SASI		;Xebec part

;wait for data request of SASI controller:
REQWAIT:IN   A,(RPORT1)		;get cntlr status bits
	AND  REQMASK		;isolate the contoller
	JR   Z,REQWAIT		;request and wait for it
	RET

	ENDC

endiæ                           » Endå falló Winchesteò falså oò true
	END
