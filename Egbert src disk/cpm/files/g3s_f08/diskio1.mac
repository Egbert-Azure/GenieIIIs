;******************************************************************************
;*  D I S K I O  *  C P M S Y S 4 f  *	T h o m a s   H o l t e * 8 5 0 9 2 5 *
;******************************************************************************
;*									      *
;*			    D I S K   H A N D L E R			      *
;*			    =======================			      *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

;------------------------------------------------------------------------------
; Anmerkungen:
;
; Aus verschiedenen Versionen zusammengelegt und Ansteuerung f}r Hard-Disk
; entfernt um Pseudo-Laufwerke zur Formatkonvertirung einzubinden. In den
; Originaldateien  DISKIO.MAC, TABLES.MAC und DRIVER.MAC sind dir Werte f}r
; das High-Density Format 'FRITZ' als Standartwerte einzutragen. Zur
; Portabilitaet waere eine identische Formatdefinition von Vorteil. Beim HD
; Format habe ich die Formatgr|~e durch Versuche festgelegt. Die Systemspur
; beinhaltet auf/f}r meine CPU 280 eine Formatangabe, so da~ das Format auf
; meinem anderen Rechner automatisch erkannt wird. Da nicht von High Density
; gebootet wird k|nnte man die Systemspur auch entfallen lassen. (siehe vorher).
;
; Fritz Chwolka, Saarstr.34, 5173 Aldenhoven (02464)8920
;
; Hier m|chte ich mich noch f}r das Entgegenkommen des Herrn Holte bedanken,
; welcher mir seine Originaldisketten zur Systemerstellung vertrauensvoll
; zusandte, wobei ich anschlie~end das Systembios bei Herrn Holte erstandt.
; Das BIOS darf unter beibehalten der COPYRIGHT - Meldung des Herrn HOLTE
; weitergegeben werden.
; Die Copyrechte der Firma Digital Research betreff dem CPM+ , hier speziell
; der ???????.SPR Dateien ist von obigen Aussagen unbeeintr{chtigt. Sie
; sollten auf jeden Fall eine Systemdiskette von Digital Research erworben
; haben, um so als Lizensnehmer die SPR-Systemdateien der Firma Digital
; Research zu nutzen.
; Bei Problemen oder Fragen bin ich unter obiger Adresse immer erreichbar und
; freue mich f}r jede Zuschrift.
;
; 1989 F.Chwolka
;
;-----------------------------------------------------------------------------

	.Z80

	TITLE 'CP/M 3 DISKETTE HANDLER'

	DSEG

;Disk drive dispatching tables for linked BIOS
;GLOBAL DS0,MF0,MF1,FD0,IBMPC,KDS,RAM,RAIR,ALPHAP3,DRIVEP

	GLOBAL	MF0,MF1,HD0,HD1,IBMPC,KDS,RAM,RAIR,ALPHAP3,DRIVEP

;Variables containing parameters passed by BDOS
	EXTERNAL @DTBL,@ADRV,@RDRV,@DMA,@TRK,@SECT,@DBNK,@CBNK

;System control block variables
	EXTERNAL @ERDME		; BDOS error mode

	EXTERNAL ?PMSG		; Print message ^HL up to 0, saves reg. BC & DE
	EXTERNAL ?PDERR		; Print BIOS disk error header
	EXTERNAL ?CONIN,?CONO	; Con in and out
	EXTERNAL ?CONST		; Get console status

	EXTERNAL ?BANK,?USERF

;ASCII control codes:
SUB	EQU	1AH		; Substitute
ESC	EQU	1BH		; Escape



;**Extended Disk Parameter Headers (XDPHs)

;High Density & 8 Zoll:
;---------------------:
;HD0:
;---:
	DEFW	FD$WRITE
	DEFW	FD$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	4		; Relative drive four
	DEFB	0		; Drive type
				; 0 = floppy disk
				; 1 = floppy disk (special format)
				; 2 = Winchester
				; 3 = Winchester (cartridge)
				; 4 = RAM disk
HD0:	DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPBHD0		; Disk parameter block
	DEFW	0FFFEH,0FFFEH	; CSV, ALV, DIRBCB, DTABCB, HASH
	DEFW	0FFFEH,0FFFEH	; Alloc'd by GENCPM
	DEFW	0FFFEH
	DEFB	0		; Hash bank
;-------------------------------
;HD1:
;---:
	DEFW	FD$WRITE
	DEFW	FD$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	5		; Relative drive fife
	DEFB	0		; Drive type
				; 0 = floppy disk
				; 1 = floppy disk (special format)
				; 2 = Winchester
				; 3 = Winchester (cartridge)
				; 4 = RAM disk
HD1:	DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPBHD0		; Disk parameter block
	DEFW	0FFFEH,0FFFEH	; CSV, ALV, DIRBCB, DTABCB, HASH
	DEFW	0FFFEH,0FFFEH	; Alloc'd by GENCPM
	DEFW	0FFFEH
	DEFB	0		; Hash bank
;--------------------------------

;Double Density
	DEFW	FD$WRITE
	DEFW	FD$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	0		; Relative drive zero
	DEFB	0		; Drive type
				; 0 = floppy disk
				; 1 = floppy disk (special format)
				; 2 = Winchester
				; 3 = Winchester (cartridge)
				; 4 = RAM disk
MF0:	DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPB01		; Disk parameter block
	DEFW	0FFFEH,0FFFEH	; CSV, ALV, DIRBCB, DTABCB, HASH
	DEFW	0FFFEH,0FFFEH	; Alloc'd by GENCPM
	DEFW	0FFFEH
	DEFB	0		; Hash bank

	DEFW	FD$WRITE
	DEFW	FD$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	1,0		; Relative drive one
MF1:	DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPB01		; Disk parameter block
	DEFW	0FFFEH,0FFFEH	; CSV, ALV, DIRBCB, DTABCB, HASH
	DEFW	0FFFEH,0FFFEH	; Alloc'd by GENCPM
	DEFW	0FFFEH
	DEFB	0		; Hash bank

;EJECT
;RAM disk:
;--------:
	DEFW	M$WRITE
	DEFW	M$READ
	DEFW	FD$LOGIN
	DEFW	M$INIT0
	DEFB	0,4
RAM:	DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPBC		; Disk parameter block
	DEFW	0		; No CSV
	DEFW	0FFFEH,0FFFEH	; ALV, DIRBCB alloc'd by GENCPM
	DEFW	0FFFFH		; No data buffer
	DEFW	0FFFEH		; HASH alloc'd by GENCPM
	DEFB	0		; Hash bank

;----------------------------------------------------------------
; Formatdefinitionen:
; F}r Sonderformate wird Drive B als relatives laufwerk genutzt.
;----------------------------------------------------------------

;
;IBM PC format:
;-------------:
	DEFW	I$WRITE
	DEFW	I$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	1,1		; Relative drive one
IBMPC:	DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPB8		; Disk parameter block
	DEFW	CSV3,ALV3	; Checksumm vector, allocation vector
	DEFW	DIBCBH,DTBCBH	; BCB list header
	DEFW	0FFFFH		; No HASH
	DEFB	0		; Hash bank
IDCT:	DEFB	01111100B
	DEFB	10000000B
	DEFB	1,16,40

;Kontron KDS format:
;------------------:
	DEFW	K$WRITE
	DEFW	K$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	1,1		; Relative drive one
KDS:	DEFW	XLTA		; Translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPBA		; Disk parameter block
	DEFW	CSV3,ALV3	; Checksumm vector, allocation vector
	DEFW	DIBCBH,DTBCBH	; BCB list header
	DEFW	0FFFFH		; No HASH
	DEFB	0		; Hash bank
KDCT:	DEFB	01111000B
	DEFB	01000000B
	DEFB	1,32,77


;EJECT
;RAIR format:
;-----------:
	DEFW	R$WRITE
	DEFW	R$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	1,1		; Relative drive one
RAIR:	DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPBD		; Disk parameter block
	DEFW	CSV3,ALV3	; Checksumm vector, allocation vector
	DEFW	DIBCBH,DTBCBH	; BCB list header
	DEFW	0FFFFH		; No HASH
	DEFB	0		; Hash bank
RDCT:	DEFB	01111000B
	DEFB	10000000B
	DEFB	2,20,80

;EJECT
;alphaTronic P3/P4 format:
;------------------------:
	DEFW	A$WRITE
	DEFW	A$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	1,1		; Relative drive one
ALPHAP3:DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPBE		; Disk parameter block
	DEFW	CSV3,ALV3	; Checksumm vector, allocation vector
	DEFW	DIBCBH,DTBCBH	; BCB list header
	DEFW	0FFFFH		; No HASH
	DEFB	0		; Hash bank
ADCT:	DEFB	01111000B
	DEFB	11000000B
	DEFB	1,10,80


;EJECT

;EJECT
;virtual disk drive P:
;--------------------:
	DEFW	P$WRITE
	DEFW	P$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	1,1		; Relative drive one
DRIVEP:	DEFW	XLTF		; Translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPBF		; Disk parameter block
	DEFW	CSVF,ALVF	; Checksumm vector, allocation vector
	DEFW	DIBCBH,DTBCBH	; BCB list header
	DEFW	0FFFFH		; No HASH
	DEFB	0		; Hash bank
PDCT:	DEFB	01110000B
	DEFB	10000000B
	DEFB	2,20,80

;sector translation tables:
XLT3:	DEFB	0,6,12,18,24,4,10,16,22,2,8,14,20
	DEFB	1,7,13,19,25,5,11,17,23,3,9,15,21

XLTA:	DEFB	0,3,6,9,12,15,2,5,8,11,14,1,4,7,10,13

XLTF:	DEFB	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
	DEFB	17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33
	DEFB	34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51

;checksumm vector:
CSV3:	DEFS	64
CSVF:	DEFS	64

;allocation vectors:
ALV3:	DEFS	99
ALVF:	DEFS	100

;BCB list header:
DIBCBH:	DEFW	DIRBCB
DTBCBH:	DEFW	DTABCB

;directory control block:
DIRBCB:	DEFB	0FFH
	DEFS	9
	DEFW	DIRBUF
	DEFB	0
	DEFW	0

;data control block:
DTABCB:	DEFB	0FFH
	DEFS	9
	DEFW	DTABUF
	DEFB	0
	DEFW	0

;directory buffer:
DIRBUF:	DEFS	1024

;data buffer:
DTABUF:	DEFS	1024


;EJECT
	CSEG			; DPB must be resident

; Durch den resistenden Diskparameter Block und die gro~e Anzahl an
; Sonderformaten mu~te ich die Festplattenansteuerung entfernen. Momentan
; wird eine Festplatte mit OMTI-Controller installiert, welcher als
; inteligenter Controller nicht allzu viel Platz im BIOS beansprucht.
; Bei Interesse bitte nachfragen!
; Vielleicht erstellt jemand mal ein Programm um ohne neubooten die Formate
; zwecks Konvertierung zu {ndern.

;Disk Parameter Blocks (DPB)

;Double Density Holte:
;--------------------:
DPB01:	DEFW	80		; 128 byte records per track
	DEFB	4,15		; Block shift and mask
	DEFB	0		; Extent mask
	DEFW	389		; Maximum block number
	DEFW	191		; Maximum directory entry number
	DEFB	0E0H,0		; Alloc vector for directory
	DEFW	48		; Checksum size
	DEFW	2		; Offset for system tracks
	DEFB	2,3		; Physical sector size shift and mask



;--------------------------------------:
; High Density FRITZ 1,28MB -----------:
;--------------------------------------:

DPBHD0:	DEFW	80H		; 128 byte records per track
	DEFB	4,0FH		; Block shift and mask
	DEFB	0		; Extent mask
	DEFW	631		; Maximum block number
	DEFW	0FFH		; Maximum directory entry number
	DEFB	0F0H,0		; Alloc vector for directory
	DEFW	40H		; Checksum size
	DEFW	1		; Offset for system tracks
	DEFB	2,3		; Physical sector size shift and mask

;RAMDISK:
;-------:
DPBC:	DEFW	447		; 128 byte records per track
	DEFB	3,7		; Block shift and mask
	DEFB	0		; Extent mask
	DEFW	110		; Maximum block number
	DEFW	31		; Maximum directory entry number
	DEFB	80H,0		; Alloc vector for directory
	DEFW	8000H		; Checksum size
	DEFW	0		; Offset for system tracks
	DEFB	0,0		; Physical sector size shift and mask

;VIRTUELLES DRIVE -P-:
;--------------------:
DPBF:	DEFW	80		; 128 byte records per track
	DEFB	4,15		; Block shift and mask
	DEFB	0		; Extent mask
	DEFW	394		; Maximum block number
	DEFW	191		; Maximum directory entry number
	DEFB	0E0H,0		; Alloc vector for directory
	DEFW	48		; Checksumm size
	DEFW	1		; Offset for system tracks
	DEFB	2,3		; Physical sector size shift and mask

;--------------:
; Sonderformate:
;==============:
;IBM PC:
;------:
DPB8:	DEFW	32		; 128 byte records per track
	DEFB	4,15		; Block shift and mask
	DEFB	1		; Extent mask
	DEFW	157		; Maximum block number
	DEFW	63		; Maximum directory entry number
	DEFB	80H,0		; Alloc vector for directory
	DEFW	16		; Checksum size
	DEFW	1		; Offset for system tracks
	DEFB	2,3		; Physical sector size shift and mask

;KONTRON KDS:
;-----------:
DPBA:	DEFW	32		; 128 byte records per track
	DEFB	4,15		; Block shift and mask
	DEFB	0		; Extent mask
	DEFW	299		; Maximum block number
	DEFW	255		; Maximum directory entry number
	DEFB	0F0H,0		; Alloc vector for directory
	DEFW	64		; Checksum size
	DEFW	4		; Offset for system tracks
	DEFB	1,1		; Physical sector size shift and mask

;RAIR:
;----:
DPBD:	DEFW	4		; 128 byte records per track
	DEFB	4,15		; Block shift and mask
	DEFB	0		; Extent mask
	DEFW	390		; Maximum block number
	DEFW	127		; Maximum directory entry number
	DEFB	0C0H,0		; Alloc vector for directory
	DEFW	32		; Checksum size
	DEFW	36		; Offset for system tracks
	DEFB	2,3		; Physical sector size shift and mask

;ALPHATRONIK P3/4:
;----------------:
DPBE:	DEFW	80		; 128 byte records per track
	DEFB	4,15		; Block shift and mask
	DEFB	0		; Extent mask
	DEFW	394		; Maximum block number
	DEFW	127		; Maximum directory entry number
	DEFB	0C0H,0		; Alloc vector for directory
	DEFW	32		; Checksum size
	DEFW	1		; Offset for system tracks
	DEFB	3,7		; Physical sector size shift and mask



;EJECT
	DSEG			; Rest in banked memory

;hard disk init routine:
;da keine harddisk vorhanden zur ]bersicht hier geloescht

;EJECT
;RAM disk init routine:
;---------------------:
POWUP	EQU	111DH		; Power up/reset marker

M$INIT0:LD	A,(POWUP)	; Power up ?
	OR	A
	RET	Z		; Return if not

;clear RAM disk:
	LD	C,32		; Entry count		 --> reg. C
	LD	DE,128		; ^first directory entry --> reg. DE
CLRNXT:	PUSH	BC		; Save remaining entry count
	PUSH	DE		; Save ^directory entry
	LD	HL,CLRBYT	; ^E5		   --> reg. HL
	LD	BC,1 SHL 8+15	; Byte count	   --> reg. B
				; Function #	   --> reg. C
	LD	A,2		; Source      bank # = 0
				; Destination bank # = 2
	CALL	?USERF		; Clear current entry
	POP	HL		; ^current directory entry --> reg. HL
	LD	DE,32		; Offset to next entry	   --> reg. DE
	ADD	HL,DE		; Add offset
	EX	DE,HL		; ^next directory entry    --> reg. DE
	POP	BC		; Restore entry count
	DEC	C		; Decrement it
	JR	NZ,CLRNXT	; Clear next entry
	RET
CLRBYT:	DEFB	0E5H


;EJECT
;hard disk read routine:
;			 > gel|scht , da keine harddisk vorhanden
;hard disk write routine:
;
; falls mal vorhanden diskio.mac (Original) auf HD-Format erweitern
; und nur wenn n|tig Pseudo-Drives F-O einbinden zur Formatkonvertierung.


;EJECT
;disk read routine:
FD$READ:LD	A,(@SECT)	; Sector number 	--> reg. B
	LD	B,A
	LD	A,(@TRK)	; Track number		--> reg. E
	LD	E,A
FD$REA1:LD	A,(@RDRV)	; Relative drive number --> reg. C
	LD	C,A
	LD	A,(@DBNK)	; DMA bank --> accu (upper nibble)
	SLA	A
	SLA	A
	SLA	A
	SLA	A
	OR	C		; Set drive number
	LD	HL,(@DMA)	; User buffer address	--> reg. HL
	LD	C,11		; Function number	--> reg. C
	CALL	?USERF		; Read physical disk sector
	LD	(DISK$STATUS),A	; Save status for error messages
	OR	A		; Any errors ?
	JP	NZ,RDERR
	RET

;suppress error message if BDOS is returning errors to application ...
RDERR:	LD	A,(@ERDME)
	INC	A
	JR	Z,R$HARD$ERROR

;had permanent error, print message like:
;	BIOS Error on d: T-nn, S-nn, <type>, Retry ?
	CALL	?PDERR		; Print message header
	LD	HL,(DISK$STATUS) ; Get status byte from last error
	LD	H,0
	DEC	L
	ADD	HL,HL		; Make byte offset
	LD	BC,R$ERROR$TABLE ; Point at table of message addresses
	ADD	HL,BC
	LD	A,(HL)		; Get specific message address
	INC	HL
	LD	H,(HL)
	LD	L,A
	CALL	?PMSG		; Print message
	LD	HL,ERROR$MSG	; Print "<BEL>, Retry (Y/N) ? "
	CALL	?PMSG
	CALL	U$CONIN$ECHO	; Get operator response
	LD	C,A		; Save response
	LD	HL,MSG$END	; Disable status line
	CALL	?PMSG
	LD	A,C		; Restore response
	CP	'Y'		; Yes, then retry 10 more times
	JP	Z,FD$READ
R$HARD$ERROR:			; Otherwise,
	LD	A,1		; Return hard error to BDOS
	RET


;EJECT
;disk write routine:
FD$WRITE:
	LD	A,(@SECT)	; Sector number 	--> reg. B
	LD	B,A
	LD	A,(@TRK)	; Track number		--> reg. E
	LD	E,A
FD$WRI1:LD	A,(@RDRV)	; Relative drive number --> reg. C
	LD	C,A
	LD	A,(@DBNK)	; DMA bank --> accu (upper nibble)
	SLA	A
	SLA	A
	SLA	A
	SLA	A
	OR	C		; Set drive number
	LD	HL,(@DMA)	; User buffer address	--> reg. HL
	LD	C,12		; Function number	--> reg. C
	CALL	?USERF		; Write physical disk sector
	LD	(DISK$STATUS),A	; Save status for error messages
	OR	A		; Any errors ?
	JP	NZ,WRERR
	RET

;suppress error message if BDOS is returning errors to application ...
WRERR:	LD	A,(@ERDME)
	INC	A
	JR	Z,W$HARD$ERROR

;had permanent error, print message like:
;	BIOS Error on d: T-nn, S-nn, <type>, Retry ?
	CALL	?PDERR		; Print message header
	LD	HL,(DISK$STATUS) ; Get status byte from last error
	LD	H,0
	DEC	L
	ADD	HL,HL		; Make byte offset
	LD	BC,W$ERROR$TABLE ; Point at table of message addresses
	ADD	HL,BC
	LD	A,(HL)		; Get specific message address
	INC	HL
	LD	H,(HL)
	LD	L,A
	CALL	?PMSG		; Print message
	LD	HL,ERROR$MSG	; Print "<BEL>, Retry (Y/N) ? "
	CALL	?PMSG
	CALL	U$CONIN$ECHO	; Get operator response
	LD	C,A		; Save response
	LD	HL,MSG$END	; Disable status line
	CALL	?PMSG
	LD	A,C		; Restore response
	CP	'Y'		; Yes, then retry 10 more times
	JP	Z,FD$WRITE
W$HARD$ERROR:			; Otherwise,
	LD	A,(DISK$STATUS)	; Return hard error to BDOS
	CP	5		; Diskette write protected ?
	LD	A,1		; Common error code
	RET	NZ
	INC	A

;no login and init procedures:
;da harddisk nicht eingebunden:
FD$LOGIN:
FD$INIT:
	RET

U$CONIN$ECHO:			; Get console input, echo it, and shift to
				; Upper case
	CALL	?CONST		; See if any character already struck
	OR	A
	JR	Z,U$C1
	CALL	?CONIN		; Yes, eat and try again
	JR	U$CONIN$ECHO
U$C1:	CALL	?CONIN
	PUSH	AF
	LD	C,A
	CALL	?CONO
	POP	AF
	CP	'A'
	RET	C
	AND	0DFH		; Make upper case
	RET

DISK$STATUS:
	DEFS	1		; Last error status code for messages
;EJECT

; READ unds WRITE Routinen f}r obige Fremdformate zur Track}bersetzung etc.

;IBM PC format:
;-------------:

I$READ:	LD	A,0FFH		; Mark READ
	JR	I$TASK
I$WRITE:XOR	A		; Mark WRITE
I$TASK:	LD	(A$MODE),A
	LD	A,(IBMPC-2)	; Relative drive number    --> accu
	ADD	A,A		; *2
	LD	C,A		; Save it
	ADD	A,A		; *4
	ADD	A,C		; *6
	LD	B,0		; Relative drive # * 6	   --> reg. BC
	LD	C,A
	LD	HL,DCT		; ^drive control table	   --> reg. HL
	ADD	HL,BC		; Calc real pointer
	PUSH	HL		; Save DCT pointer
	LD	DE,TDCT		; ^temporary storage area  --> reg. DE
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Save disk parameters of drive B:
	LD	HL,IDCT		; ^parameters for drive I: --> reg. HL
	POP	DE		; DCT pointer		   --> reg. DE
	PUSH	DE		; Save DCT pointer again
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Load disk parameters of drive I:
	LD	A,(@TRK)	; Track number --> accu
	SUB	40		; >= 40 ?
	JR	NC,I$TASK1	; Jump if yes
	ADD	A,40		; Restore track number
	LD	E,A		; Store it
	LD	A,(@SECT)	; Sector number --> accu
	JR	I$TASK2
I$TASK1:LD	E,A		; Save it
	LD	A,40		; Build new track # (counts backward)
	SUB	E
	DEC	A
	LD	E,A		; Store it
	LD	A,(@SECT)	; Sector number --> accu
	ADD	A,8		; Adjust it
I$TASK2:LD	B,A		; Store sector number

	LD	A,(A$MODE)	; Read or write ?
	OR	A
	JR	Z,I$TASK3	; Jump if write
	CALL	FD$REA1		; Read sector
	JR	I$TASK4
I$TASK3:CALL	FD$WRI1		; Write sector

I$TASK4:LD	HL,TDCT		; Restore original disk parameters
	POP	DE
	LD	BC,5
	LDIR
	LD	HL,IDCT+1	; Get drive status
	SET	0,(HL)		; Set init bit
	RET


;EJECT
;Kontron KDS format:
K$READ:	LD	A,0FFH		; Mark READ
	JR	K$TASK
K$WRITE:XOR	A		; Mark WRITE
K$TASK:	LD	(A$MODE),A
	LD	A,(KDS-2)	; Relative drive number    --> accu
	ADD	A,A		; *2
	LD	C,A		; Save it
	ADD	A,A		; *4
	ADD	A,C		; *6
	LD	B,0		; Relative drive # * 6	   --> reg. BC
	LD	C,A
	LD	HL,DCT		; ^drive control table	   --> reg. HL
	ADD	HL,BC		; Calc real pointer
	PUSH	HL		; Save DCT pointer
	LD	DE,TDCT		; ^temporary storage area  --> reg. DE
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Save disk parameters of drive B:
	LD	HL,KDCT		; ^parameters for drive K: --> reg. HL
	POP	DE		; DCT pointer		   --> reg. DE
	PUSH	DE		; Save DCT pointer again
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Load disk parameters of drive K:
	LD	A,(@TRK)	; Track number --> accu
	SUB	77		; >= 77 ?
	JR	NC,K$TASK1	; Jump if yes
	ADD	A,77		; Restore track number
	LD	E,A		; Store it
	LD	A,(@SECT)	; Sector number --> accu
	JR	K$TASK2
K$TASK1:LD	E,A		; Save it
	LD	A,(@SECT)	; Sector number --> accu
	ADD	A,16		; Adjust it
K$TASK2:LD	B,A		; Store sector number

	LD	A,(A$MODE)	; Read or write ?
	OR	A
	JR	Z,K$TASK3	; Jump if write
	CALL	FD$REA1		; Read sector
	JR	K$TASK4
K$TASK3:CALL	FD$WRI1		; Write sector

K$TASK4:LD	HL,TDCT		; Restore original disk parameters
	POP	DE
	LD	BC,5
	LDIR
	LD	HL,KDCT+1	; Get drive status
	SET	0,(HL)		; Set init bit
	RET


;EJECT
;RAM disk I/O routines
M$READ:	LD	A,0FFH		; Switch on read flag
	JR	TASKM
M$WRITE:XOR	A		; Clear read flag
TASKM:	LD	(RDFLAG),A
	LD	A,(@TRK)	; Track # --> accu
	ADD	A,2		; Calc source bank #
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	HL,@DBNK	; Get destination bank #
	ADD	A,(HL)
	PUSH	AF		; Save bank numbers
	LD	DE,(@DMA)	; DMA address --> reg. DE
	LD	HL,(@SECT)	; Sector #    --> reg. HL
	INC	HL		; Adjust it
	LD	B,7		; Sector # * 128
	ADD	HL,HL
	DJNZ	$-1
	LD	BC,128 SHL 8+15	; Sector length --> reg. B
				; Function #	--> reg. C
	LD	A,(RDFLAG)	; Read or write ?
	OR	A
	JR	NZ,TASKM1	; Jump if read
	POP	AF		; Restore bank numbers
	RLCA			; Swap bank numbers
	RLCA
	RLCA
	RLCA
	PUSH	AF		; Push bank numbers again
	EX	DE,HL
TASKM1:	POP	AF		; Restore bank numbers
	CALL	?USERF		; Transfer "sector"
	XOR	A
	RET
RDFLAG:	DEFS	1


;EJECT
;RAIR format:
R$READ:	LD	A,0FFH		; Mark READ
	JR	R$TASK
R$WRITE:XOR	A		; Mark WRITE
R$TASK:	LD	(A$MODE),A
	LD	A,(RAIR-2)	; Relative drive number    --> accu
	ADD	A,A		; *2
	LD	C,A		; Save it
	ADD	A,A		; *4
	ADD	A,C		; *6
	LD	B,0		; Relative drive # * 6	   --> reg. BC
	LD	C,A
	LD	HL,DCT		; ^drive control table	   --> reg. HL
	ADD	HL,BC		; Calc real pointer
	PUSH	HL		; Save DCT pointer
	LD	DE,TDCT		; ^temporary storage area  --> reg. DE
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Save disk parameters of drive B:
	LD	HL,RDCT		; ^parameters for drive L: --> reg. HL
	POP	DE		; DCT pointer		   --> reg. DE
	PUSH	DE		; Save DCT pointer again
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Load disk parameters of drive O:
	LD	A,(@TRK)	; Track # (LSB) 		     --> reg. C
	LD	C,A
	LD	A,(@TRK+1)	; Track # (MSB) 		     --> accu
	LD	DE,20		; Number of physical sectors / track --> reg. DE
	LD	HL,0		; Clear accumulator
	LD	B,16		; Init counter
R$TASK1:RL	C		; Rotate result left
	RLA
	ADC	HL,HL		; Shift left
	SBC	HL,DE		; Subtract divisor
	JR	NC,$+3		; Subtraction ok
	ADD	HL,DE		; Restore accumulator
	CCF			; Restore carry flag
	DJNZ	R$TASK1		; Counter = 0 ?
	RL	C		; Get last result bit
	RLA
	LD	E,C		; Now reg. E contains track #
	LD	B,L		; Now reg. B contains sector #

	LD	A,(A$MODE)	; Read or write ?
	OR	A
	JR	Z,R$TASK3	; Jump if write
	CALL	FD$REA1		; Read sector
	JR	R$TASK4
R$TASK3:CALL	FD$WRI1		; Write sector

R$TASK4:LD	HL,TDCT		; Restore original disk parameters
	POP	DE
	LD	BC,5
	LDIR
	LD	HL,RDCT+1	; Get drive status
	SET	0,(HL)		; Set init bit
	RET



;EJECT
;alphaTronic P3/P4 format:
A$READ:	LD	A,0FFH		; Mark READ
	JR	A$TASK
A$WRITE:XOR	A		; Mark WRITE
A$TASK:	LD	(A$MODE),A
	LD	A,(ALPHAP3-2)	; Relative drive number    --> accu
	ADD	A,A		; *2
	LD	C,A		; Save it
	ADD	A,A		; *4
	ADD	A,C		; *6
	LD	B,0		; Relative drive # * 6	   --> reg. BC
	LD	C,A
	LD	HL,DCT		; ^drive control table	   --> reg. HL
	ADD	HL,BC		; Calc real pointer
	PUSH	HL		; Save DCT pointer
	LD	DE,TDCT		; ^temporary storage area  --> reg. DE
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Save disk parameters of drive B:
	LD	HL,ADCT		; ^parameters for drive O: --> reg. HL
	POP	DE		; DCT pointer		   --> reg. DE
	PUSH	DE		; Save DCT pointer again
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Load disk parameters of drive O:
	LD	A,(@SECT)	; Sector number --> accu
	LD	B,A		; Sector number --> reg. B
	CP	5
	LD	A,(@TRK)	; Track number	--> accu
	LD	E,A		; Track number	--> reg. E
	JR	C,A$TASK1	; Jump if sector # is lower than 5
	OR	A		; Track 0 ?
	JR	NZ,A$TASK2	; Jump if not track 0
	INC	E		; Convert track # to 1
	LD	A,B		; Sector # --> accu
	SUB	5		; Convert it
	LD	B,A		; Store it
	JR	A$TASK2
A$TASK1:DEC	A		; Track 1 ?
	JR	NZ,A$TASK2	; Jump if not track 1
	LD	E,A		; Convert track # to 0
	LD	A,B		; Sector # --> accu
	ADD	A,5		; Convert it
	LD	B,A		; Store it
A$TASK2:LD	A,(@RDRV)	; Relative drive number --> reg. C
	LD	C,A
	LD	A,(@DBNK)	; DMA bank --> accu (upper nibble)
	SLA	A
	SLA	A
	SLA	A
	SLA	A
	OR	C		; Set drive number
	LD	HL,(@DMA)	; User buffer address	--> reg. HL
	LD	D,A		; Save drive/bank #
	LD	A,(A$MODE)	; Read or write ?
	OR	A
	LD	A,D		; Restore drive/bank #
	JR	Z,A$TASK3	; Jump if write

	LD	C,11		; Function number	--> reg. C
	CALL	?USERF		; Read physical disk sector
	LD	(DISK$STATUS),A	; Save status for error messages
	OR	A		; Any errors ?
	CALL	NZ,RDERR
	JR	A$TASK4

A$TASK3:LD	C,12		; Function number	--> reg. C
	CALL	?USERF		; Write physical disk sector
	LD	(DISK$STATUS),A	; Save status for error messages
	OR	A		; Any errors ?
	CALL	NZ,WRERR

A$TASK4:LD	HL,TDCT		; Restore original disk parameters
	POP	DE
	LD	BC,5
	LDIR
	LD	HL,ADCT+1	; Get drive status
	SET	0,(HL)		; Set init bit
	RET
A$MODE:	DEFS	1		; Mark READ/WRITE

;EJECT
;------------------:
;virtual disk drive:

; DriveControllTable mu~ f}r Konfig eine feste Adresse haben.
DCT	EQU	10D7H		; Drive control table (SYSTAB)

P$READ:	LD	IX,FD$READ	; Read	routine vector	   --> reg. IX
	JR	P$TASK
P$WRITE:LD	IX,FD$WRITE	; Write routine vector	   --> reg. IX
P$TASK:	LD	A,(DRIVEP-2)	; Relative drive number    --> accu
	ADD	A,A		; *2
	LD	C,A		; Save it
	ADD	A,A		; *4
	ADD	A,C		; *6
	LD	B,0		; Relative drive # * 6	   --> reg. BC
	LD	C,A
	LD	HL,DCT		; ^drive control table	   --> reg. HL
	ADD	HL,BC		; Calc real pointer
	PUSH	HL		; Save DCT pointer
	LD	DE,TDCT		; ^temporary storage area  --> reg. DE
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Save disk parameters of drive B:
	LD	HL,PDCT		; ^parameters for drive P: --> reg. HL
	POP	DE		; DCT pointer		   --> reg. DE
	PUSH	DE		; Save DCT pointer again
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Load disk parameters of drive P:
	LD	HL,P$RET	; Return address	   --> reg. HL
	PUSH	HL		; Push it
	JP	(IX)		; Jump to driver
P$RET:	LD	HL,TDCT		; Restore original disk parameters
	POP	DE
	LD	BC,5
	LDIR
	LD	HL,PDCT+1	; Get drive status
	SET	0,(HL)		; Set init bit
	RET
TDCT:	DEFS	5		; Temporary storage area


;EJECT
;tables of pointers to error message strings
R$ERROR$TABLE:
	DEFW	R1MSG
	DEFW	R2MSG
	DEFW	R3MSG
	DEFW	R4MSG
	DEFW	R5MSG
	DEFW	R6MSG
	DEFW	R7MSG
	DEFW	R8MSG
	DEFW	R9MSG

W$ERROR$TABLE:
	DEFW	W1MSG
	DEFW	W2MSG
	DEFW	W3MSG
	DEFW	W4MSG
	DEFW	W5MSG
	DEFW	W6MSG
	DEFW	W7MSG
	DEFW	W8MSG
	DEFW	W9MSG

R1MSG:	DEFM	' Illegal drive #,'
	DEFB	0
R2MSG:	DEFM	' Track # too high,'
	DEFB	0
R3MSG:	DEFM	' Sector # too high,'
	DEFB	0
R4MSG:	DEFM	' Device not available,'
	DEFB	0
R5MSG:	DEFB	0
R6MSG:	DEFM	' Locked/deleted record,'
	DEFB	0
R7MSG:	DEFM	' Data record not found,'
	DEFB	0
R8MSG:	DEFM	' Parity error during read,'
	DEFB	0
R9MSG:	DEFM	' Lost data during read,'
	DEFB	0

W1MSG:	DEFM	' Illegal drive #,'
	DEFB	0
W2MSG:	DEFM	' Track # too high,'
	DEFB	0
W3MSG:	DEFM	' Sector # too high,'
	DEFB	0
W4MSG:	DEFM	' Device not available,'
	DEFB	0
W5MSG:	DEFM	' Write protected diskette,'
	DEFB	0
W6MSG:	DEFM	' Write fault on disk drive,'
	DEFB	0
W7MSG:	DEFM	' Data record not found,'
	DEFB	0
W8MSG:	DEFM	' Parity error during write,'
	DEFB	0
W9MSG:	DEFM	' Lost data during write,'
	DEFB	0

ERROR$MSG:
	DEFM	' Retry (Y/N) ? '
	DEFB	0

MSG$END:DEFB	SUB,ESC,'D',0

	END

