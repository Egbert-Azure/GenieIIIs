ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее LABEL      a           6 W6 W MSDOS   IN2   $              MSDOS   IN3                  !6 W6 W  …>   Ќ>    MSDOS   PAS   1  	 
          PARK    COM   E            PARK    PAS                 !бP>    >  Њ$>    XCPM3   LIB   3             DISKIO1 MAC   Ђ         DISKIO1 MAC                !ЇЇ'>  ЇЇ6>              DRVTBL1 MAC                    FREMD   COM   
!                FREMD   Z80   x" # $ % & ' ( ) !> >  љ#>  Ѓ>    HD2     MAC   L* + , - .        HDCHAR  MAC   /                HDDTBL  ASM   0               !  >    >  >>    HDNDF   Z80   1 2              HDTEST  Z80   13 4 5 6          HOLTE   Z3T   7               !Ѓ>  Ѓ>  „>    HOLTE   Z80   8 9              MSDOS   COM   Ђ: ; < = > ? @ A  MSDOS   COM  B C             !„>  …>              MSDOS   IN0   =D E F G          MSDOS   IN1   $H I J            DISKIOHDMAC   ЂK L M N O P Q R !бI>  >    >    DISKIOHDMAC  cS T U V W X Y   еDISKIO  MAC   ЂZ [ \ ] ^ _ ` a еDISKIO  MAC  b               !          > >             еDRVTBL  MAC   c                ALIAS   CMD   8d e f g          DEFAULT Z3P   h i             !> >  J>   Ё>     DEFAULT Z3T   j                ZFILER  CMD   k l             еDRIVER  MAC  Ђ„ … † ‡ € ‰ Љ ‹ !ѓ#>!  …T>!             еDRIVER  MAC  ЂЊ Ќ Ћ Џ ђ ‘ ’ “ еDRIVER  MAC  Ђ” • – —  ™ љ ›  DRVTBLHDMAC   ©               !                    ЇЇ#>   еDRIVER  MAC  Ђњ ќ ћ џ   Ў ў Ј еDRIVER  MAC  Ђ¤ Ґ ¦ § Ё Є « ¬ еDRIVER  MAC	  p­ ® Ї ° ± І і   !                               $TEMP$        Ђґ µ ¶ · ё № є » $TEMP$       )ј Ѕ ѕ           BNKBDOS3SPR   jї А Б В Г Д Е   !x>            x>   BNKBIOS MAC   ЂЖ З И Й К Л М Н BNKBIOS MAC  О               BOOT    MAC   'П Р С           !x>            x>	   BOOTER  MAC   7Т У Ф Х         BOOTGEN SUB   Ц               CHARIO  MAC   &Ч Ш Щ           !x>	  x>	  x>	   CPM3    SUB   Ъ               CPM3    SYS   ЂЫ Ь Э Ю Я а б в CPM3    SYS   г д             !x>	  x>	             CPMLDR  REL   е ж             DISKIO  MAC   Ђз и й к л м н о DISKIO  MAC  п               !x>    >             DRIVER  MAC   Ђр с т у ф х ц ч DRIVER  MAC  Ђш щ ъ ы ь э ю я DRIVER  MAC  Ђ ! >                       DRIVER  MAC  Ђ	
DRIVER  MAC  ЂDRIVER  MAC  Ђ!                               DRIVER  MAC  Ђ !"#$%&'DRIVER  MAC  Ђ()*+,-./DRIVER  MAC  Ђ01234567!                               DRIVER  MAC	  p89:;<=>  DRVTBL  MAC   ?              FONT12  MAC   V@ABCDE    !          x>  x>   GENCPM  DAT   FG            LDRBIOS MAC   ЂHIJKLMNOMODEBAUDMAC   P              !x>  x>  x>   MOVE    MAC   $QRS          RESBDOS3SPR   T              SCB     MAC   U              !x>  x>  x>   е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               е                               е                               е                               !                               (***********************************************************
**   MSDOS.IN2 :  Schreiben der MS-DOS-Diskette           **
***********************************************************)

(* CP/M-File suchen. Sucht nach Datei des Namens SUCHNAME *)
(* (mit Wildcards). Wenn gefunden, wird CPMNAME auf den   *)
(* tatsaechlichen Dateinamen gesetzt.                     *)

procedure scan_cpmdir(first:boolean);
type zeiger  = ^element;
     element = record
                 name : string14;
                 next : zeiger;
                 end;
var fcb                 : array[0..12] of byte;
    buf                 : array[0..127] of byte;
    i,j                 : integer;
    neu,erster,p,anfang : zeiger;
begin
  if first then begin    (* FIFO-Liste mit Namen aufbauen *)
    relog(cpmdrive);
    mark(anfang);
    new(erster); neu:=erster;
    fcb[0]:=succ(cpmdrive);
    move(suchname[1],fcb[1],11);
    fcb[12]:=0;
    BDOS(26,addr(buf));               (* Set DMA *)
    i:=BDOS(17,addr(fcb));            (* Search for First *)
    p:=erster;
    if i=$FF then erster:=nil;
    while i<>$FF do begin
      neu^.name:='           ';
      for j:=1 to 11 do
        neu^.name[j]:=chr(buf[i shl 5+j] and $7F);
      p:=neu; new(neu); p^.next:=neu;
      i:=BDOS(18);                     (* Search for Next *)
      end;
    p^.next:=nil;
    release(neu);
    p:=erster;
    relog(msdrive);
    end;
  gefunden:=p<>nil;              (* ab hier FIFO auslesen *)
  if gefunden then begin
    cpmname:=p^.name;
    p:=p^.next;
    end
  else release(anfang);                  (* FIFO loeschen *)
  end;

(* Leeren MS-DOS-Directory-Eintrag suchen. GEFUNDEN wird *)
(* entsprechend gesetzt. Name und Daten der Datei werden *)
(* in den Eintrag eingesetzt. Neue Directory wird auf    *)
(* Diskette geschrieben.                                 *)

procedure make_eintrag(name:string14; length,start:integer);
var i : integer;
begin
  gefunden:=false;
  i:=0;
  dirsec:=pred(dirstart);
  diroff:=-32;
  repeat
    diroff:=(diroff+32) mod psize;
    if diroff=0 then begin
      dirsec:=succ(dirsec);
      rwsector(msdrive,dirsec,false,addr(dirbuf));
      end;
    i:=succ(i);
    gefunden:=dirbuf[diroff] in [0,$E5];
  until gefunden or (i=eintraege);
  if gefunden then begin
    move(name[1],dirbuf[diroff],11);
    fillchar(dirbuf[diroff+$0B],21,0);
    dirbuf[diroff+$0B]:=$20;
    dirbuf[diroff+$1A]:=lo(start);
    dirbuf[diroff+$1B]:=hi(start);
    dirbuf[diroff+$1C]:=length and 1 shl 7;
    dirbuf[diroff+$1D]:=lo(length shr 1);
    dirbuf[diroff+$1E]:=hi(length shr 1);
    rwsector(msdrive,dirsec,true,addr(dirbuf));
    end;
  end;

(* einzelnes File von CP/M nach MS-DOS kopieren *)

procedure schreib;
var gruppe,next,m,n,laenge : integer;
begin
  assign(datei,chr(cpmdrive+$41)+':'+cpmname);
  reset(datei);
  cpmlength:=filesize(datei);
  if msspace<128.0*cpmlength then writeln(diskfull)
  else begin
    gruppe:=firstfreecluster(1);
    make_eintrag(msname,cpmlength,gruppe);
    laenge:=cpmlength;
    while laenge>0 do begin
      n:=succ(bufgr) shr 7;
      if n>laenge then n:=laenge;
      laenge:=laenge-n;
      relog(cpmdrive);
      blockread(datei,datbuf,n);
      relog(msdrive);
      m:=pred(n shl 7) div clsize;
      for n:=0 to m do begin
        rwcluster(gruppe,true,addr(datbuf[n*clsize]));
        if (n=m) and (laenge=0) then next:=$FFF
          else next:=firstfreecluster(gruppe);
        fat_setzen(gruppe,next);
        gruppe:=next;
        end;
      end; {while}
    writefat;
    end;
  end;

procedure writefile;
begin
  generate_suchname;
  if length(suchname)=0 then begin
    repeat
      write('CP/M - Dateiname : ');
      readln(suchname);
    until length(suchname)>0;
    write('MS-DOS-Dateiname : ');
    readln(msname);
    if length(msname)=0 then msname:=suchname;
    end
  else msname:=suchname;
  suchname:=expand(suchname);
  scan_cpmdir(true);
  if not gefunden then writeln(nofile)
  else if wildcard(suchname) then begin
    writeln(copying);
    while gefunden do begin
      msname:=cpmname;
      cpmname:=compress(cpmname);
      writeln(cpmname);
      schreib;
      scan_cpmdir(false);
      end;
    end
  else begin
    msname:=expand(msname);
    cpmname:=compress(cpmname);
    schreib;
    scan_cpmdir(false);  (* um FIFO zu loeschen *)
    end;
  end;

ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее(***********************************************************
**   MSDOS.IN3 :  ERASE und CHANGENAME (Rename)           **
***********************************************************)

procedure erase;

  procedure killfile;  (* FAT wird nicht geschrieben ! *)
  var gruppe,next : integer;
  begin
    gruppe:=startgruppe;
    dirbuf[diroff]:=$E5;
    repeat
      next:=fat_eintrag(gruppe);
      fat_setzen(gruppe,0);
      gruppe:=next;
    until gruppe>=$FF8;
    rwsector(msdrive,dirsec,true,addr(dirbuf));
    end;

var antwort : string14;
begin
  generate_suchname;
  while length(suchname)=0 do begin
    write('Dateiname f}r ERASE : ');
    readln(suchname);
    end;
  suchname:=expand(suchname);
  scan_msdir(true);
  if not gefunden then writeln(nofile)
  else if wildcard(suchname) then begin
    repeat
      write('Wirklich l|schen (J/N) ? ');
      readln(antwort);
    until length(antwort)>0;
    if antwort[1] in ['J','j'] then begin
      while gefunden do begin
        killfile;
        scan_msdir(false);
        end;
      writefat;
      end;
    end
  else begin
    killfile;
    writefat;
    end;
  end;

procedure rename;
var neuname : string14;
begin
  suchname:=copy(befehl,1,14);
  i:=pos(' ',befehl);
  if i=0 then neuname:=''
  else neuname:=copy(befehl,succ(i),14);
  i:=pos(' ',suchname);
  if i>0 then delete(suchname,i,14);
  i:=pos(' ',neuname);
  if i>0 then delete(neuname,i,14);
  while length(suchname)=0 do begin
    write('Alter Dateiname : ');
    readln(suchname);
    end;
  while length(neuname)=0 do begin
    write('Neuer Dateiname : ');
    readln(neuname);
    end;
  suchname:=expand(suchname);
  neuname:=expand(neuname);
  if wildcard(suchname) or wildcard(neuname) then
    writeln('Wildcards unzul{ssig !')
  else begin
    scan_msdir(true);
    if gefunden then begin
      move(neuname[1],dirbuf[diroff],11);
      rwsector(msdrive,dirsec,true,addr(dirbuf));
      end;
    end;
  end;

program MS_DOS_Emulation;

const bufgr    = 32767;                     (* Datenpuffer *)
      fatgr    = 2047;                      (* FAT-Puffer  *)
      titel    = ^M^J'MS-DOS-Emulator V1.2 vom 26.8.87'^M^J;
      befehle1 = 'Befehle: Change, Dir, Erase, Help, New,'^M^J;
      befehle2 = '         Protocol, Quit, Read, Write';
      nofile   = 'No File';
      copying  = '- Copying :';
      diskfull = 'Error : Disk Full';

type tbuff     = array[0..1023] of byte;    (* Sektorpuffer *)
     string14  = string[14];
     anystring = string[255];

(* MS-DOS-Verwaltungsbezogene Variablen *)

var  fatbuf                                 : array[0..fatgr] of byte;
     datbuf                                 : array[0..bufgr] of byte;
     dirbuf                                 : tbuff;
     dirsec,diroff,bufcl                    : integer;

(* MS-DOS-Formatbezogene Variablen *)

     psize,clsize,dirstart,datstart,
     reservsec,eintraege,sektoren,fatsecs,
     secptrk,heads,maxclnum                 : integer;
     secpcl,fatzahl,medium                  : byte;

(* MS-DOS-Dateibezogene Variablen *)

     msname                                 : string14;
     startgruppe,datum,zeit                 : integer;
     datlength                              : real;

(* CP/M-Dateibezogene Variablen *)

     cpmname                                : string14;
     datei                                  : file;
     cpmlength                              : integer;

(* Variablen des Hauptprogramms und zur allgemeinen Verwaltung *)

     msdrive,cpmdrive,logdrive,i            : byte;
     befehl                                 : anystring;
     cmd                                    : char;
     suchname                               : string14;
     gefunden,exit,print                    : boolean;

{$I MSDOS.IN0 }  (* Utilities                 *)
{$I MSDOS.IN1 }  (* MS-DOS Diskette lesen     *)
{$I MSDOS.IN2 }  (* MS-DOS Diskette schreiben *)
{$I MSDOS.IN3 }  (* MS-DOS Erase und Rename   *)

procedure conout(ch:char); external $339;
procedure lstout(ch:char); external $32F;

procedure co(ch:char);
begin
  conout(ch);
  lstout(ch);
  end;

(*********************************************************************
**                        H E L P                                   **
*********************************************************************)

procedure help;

  procedure waittaste;
  var ch : char;
  begin
    write('Beliebige Taste bet{tigen ');
    read(kbd,ch);
    write(^M,'':30);
    end;

begin
  writeln(titel,befehle1,befehle2);
  write(
^M^J'Befehle bestehen generell aus einem Buchstaben. Hinter dem Befehls-',
^M^J'buchstaben kann sofort ein Dateiname folgen, welcher aber auch durch',
^M^J'ein oder mehrere Leerzeichen vom Befehl getrennt sein oder ganz fehlen',
^M^J'darf. Es existieren folgende Befehle :'^M^J,
^M^J'C : CHANGENAME, besser bekannt als RENAME. Es werden zwei Dateinamen',
^M^J'    eingegeben, wovon der erste der Alte und der zweite der Neue ist.',
^M^J'    Fehlende Dateinamen werden explizit abgefragt. Wildcards sind in',
^M^J'    keinem der beiden Namen erlaubt.'^M^J,
^M^J'D : DIRECTORY, gibt die Directory der MS-DOS-Diskette aus. Wildcards',
^M^J'    sind erlaubt, au~erdem kann durch Eingabe eines ''F'' unmittelbar',
^M^J'    nach dem Befehl die Option ''FULL'' gesetzt werden, welche f}r alle',
^M^J'    Files die Dateil{nge sowie Datum- und Zeiteintrag ausgibt. Wird',
^M^J'    kein Dateiname angegeben, so werden alle Files angezeigt.'^M^J,
^M^J'E : ERASE, l|scht das angegebene File. Wildcards sind erlaubt.'^M^J^J);
  waittaste;
  write(
  ^M'H : HELP, augenblicklich aktiver Programmteil.'^M^J,
^M^J'N : NEW, loggt neue (andere) MS-DOS-Diskette ein (FAT wird gelesen und',
^M^J'    logische Parameter werden gesetzt).'^M^J,
^M^J'P : PROTOCOL, schaltet Printer-Echo an bzw. aus.'^M^J,
^M^J'Q : QUIT, Ausgang zum Betriebssystem CP/M.'^M^J,
^M^J'R : READ, Datei(en) von MS-DOS lesen und nach CP/M schreiben. Wird kein',
^M^J'    Dateiname angegeben, werden Quell- und Zielname explizit erfragt,',
^M^J'    wobei diese verschieden sein d}rfen. Ansonsten wird die angegebene',
^M^J'    Datei unter gleichem Namen kopiert. Werden Wildcards benutzt, so',
^M^J'    wird der Dateiname grunds{tzlich von MS-DOS }bernommen.'^M^J,
^M^J'W : WRITE, Datei(en) von CP/M lesen und nach MS-DOS schreiben. Dateien',
^M^J'    werden genau wie bei READ angegeben, bei Wildcards wird immer der',
^M^J'    CP/M-Name }bernommen.'^M^J,
^M^J'Bei den Kopierbefehlen ist zu beachten, da~ unter CP/M die Dateil{ngen',
^M^J'nur Vielfache von 128 sein k|nnen, deshalb werden die Dateien in der',
^M^J'Regel etwas l{nger beim Kopieren, au~erdem m}ssen u.U. Dateiende-Zeichen',
^M^J'angef}gt werden.'^M^J^J);
  end;

(*********************************************************************
**               H A U P T P R O G R A M M                          **
*********************************************************************)

begin
  print:=false;
  writeln(titel,befehle1,befehle2);
    writeln(^M^J'Laufwerk mit MS-DOS-Diskette : P ');
    msdrive:=15;
  repeat
    write('Laufwerk mit CP/M - Diskette : ');
    readln(befehl);
    cpmdrive:=ord(upcase(befehl[1]))-$41;
  until (cpmdrive in [0..7]) and (cpmdrive<>msdrive);
  writeln('Hinweis: phys. Disk-Parameter m}ssen korrekt gesetzt sein !'^M^J);
  logdrive:=BDOS(25);
  mslogin;
  repeat
    repeat
      write('MSDOS>');
      readln(befehl);
    until length(befehl)>0;
    for i:=1 to length(befehl) do befehl[i]:=upcase(befehl[i]);
    cmd:=befehl[1];
    exit:=cmd='Q';
    delete(befehl,1,1);
    while (length(befehl)>0) and (befehl[1]=' ') do delete(befehl,1,1);
    case cmd of
      'C' : rename;
      'D' : directory;
      'E' : erase;
      'H' : help;
      'N' : mslogin;
      'P' : begin
              print:=not print;
              if print then conoutptr:=addr(co)
              else conoutptr:=addr(conout);
              end;
      'Q' : ;
      'R' : readfile;
      'W' : writefile;
      else writeln(^G,cmd,'?');
      end;
  until exit;
  relog(logdrive);
  end.
 write('Laufwerk mit CP/M - Diskette : ');
    readln(befehl);
    cpmdrive:=ord(upcase(befehl[1]))-$41;
  until (cpmdrive in [0..7]) and (cpmdrive<>msdrive);
  writeln('Hinweis: phys. Disk-Parameter m}ssen korrekt gesetzt sein !'^M^J);
  logdrive:=BDOS(25);
  mslogin;
  repeat
    repeat
      write('MSDOS>');
      readln(befehl);
    until length(befehl)>0;
    for iееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееГг Z3ENVЂпght (C) 1985 BORLAND Inc  ѓB                                           HOLTE-CP/M-Pluss0/92P  A             a            =                 c     VWM    Tcv  R0m  Ssr   ~·7И#хе~Нйбс= ф·ЙН
 ЙoеН¦ ЙюЂЬlФ…жое!пе!й"бгхЕХ~#·(еНйбфСБсгЙ}ґИ:$‡‡‡ггггЕТБ= ф+иНРШ*ОЯхЕХе!ЁН6!ўНР*єФбСБсЙхЕХе!ґйхЕХе!®ах:а ·(ЕХеЇ2а !ИН6бСБсЙх:а юя(цЕХе>я2а !ВгхЕХе!јЪхЕХеер !‹ н°С:ћO:њ‚ХНЭС:џO:ќѓНЭ!р НР* НбСБсЙ!р  	л!›45(Й!+/–0ь†хyю0(снЙ
d!kГ6!{Г6 Н`ж Н`o& Й ф  	 бБе:Э ·(ХЕН  |µ(Нвю НвюКХ БС* й"Т x2Э y·(>Г28 !ь"9 !¦   н°!ѕё  н°Їog2Р "Ф "Ц >~2С 2а ЙГГ!Г:Г0Г5Г+Г:Г!Б ‚ C Д Е Б ЕХеЭеэехo& еН¦ сэбЭббСБЙЕХеЭеэеНЈ }ля н[Т ю (ъ!e Н|Н§юA8юQ0Gю: xЦ@Ї!\ w#(Нѓ ю?(ю*(ю.(НxН_ю. Н_!h 6 #ыЙ(ю?(	ю*(Нѓ(w#йЙ>?> w#ьЙН§ю 8еЕ!™ н±БбЙїЙ .,;:=?*[]<>{}юaШю{РЦ Й|Нµ}хНѕсжЖђ'О@'ГКЇ7Л|А|·}И>яЙ2Ш ЕН°Б* ·нBЪ© лСщ ь	"Ж Їog"О 2Ь >Г2Щ !Я "Ъ л"М йе*Ж ·нB"Ж н[Д ·нRлбЪvн°Й*Ж н°"Ж ЩЙ^#V#Х^#V#N#FбЙЭблO /o&я9щлн°ЭйСO /o&я9щлн°йЭбл!ая9щлЕ(Їьн°Б> ђ‘(GЇьЭйЭб!ая9щ Їw#ьЭйЭбEН»¶wЭйЭбС}“8ч<OCН»_AЇіЛ#0¶w#ЇуЭxжшЖo& 9xж<GЇ7эЙеЩлгs#r#Сs#r#q#pЙЭбxл!  D9Nе	#г№8y#·(Oн°бщЭйЭбx!  D9Nе	#^#VЬЭблh& D9н°!  9щЭйЭб!  9^#Vh& D9н°!" зЭблx/o&я9щp#H лн°Эй·нRШ>ђГ( ·нR·нB0	Й>‘Г( ·нRлкrрш  ЙХл·нRлбл·нR! И+ЙНахН±	р·нR! А+ЙНахН±	рНs! Р+ЙНахН±	рНs! ИШ+ЙНафН±	пНs!  ИШ#ЙНафН±	пНs! Ш+ЙНахН±	рT]KBл!  z·> S>)л)л0	= цЙ|µК
|ЄхНЃлНЃлDMЇgo>нjнB0	7?ЛЛ= рлсрHеН“Л<ЛСлНлЛzИ5НbИ)эЙНbИЛ<ЛъЙлz· {ю0G·ЙЇgoЙл|Є|ъєА}»ЙЙЛ|И|/g}/o#Й}жo& ЙнKК н[И ЕХxAJS ЛЛЛЛблбнJDM!йb"И л!6нJ"К DMЙ 'НгиНгd Нг
Нг}Ї<нR0ы= ИЖ0Эw Э#ЙЭ~ Ц$O!   Э#Э~ Н§Ц08)ю
8 !Цю
8ю0T])Ш)Ш T]Ш)Ш_ ШЛy·И|‡ЙЭббе}& #9NЃ8wл!  DнB9щлен°лб+Oнёл#щЭй>Г* ЭбНЙWбНЮ	_бе}“8(є8J `9{‚T]=o`9yнёл	Ї<k-& 9wщЭйЭббе}& #9щo& ЭйЭб!  T9^K#е^C#ееэбСбyђ8<OЕХеѕ(бСБ# т!  #мСбБ!  9лнRэщЭйЭбНЙOбНЮ	_б~“8(‘8х~‘w PT]	с<Oн°sЭйЭбНЮ	OСнSи !  9х†8ё8xсW^‘8/<ozѓ8ё}8x“8&‘8#<·(ЕХ*и _ B	СХеPлбOнёСБz<(Ox‘<»8{·(*и  	л! 9Oн°!  T9^щЭйЭбб-Вgl& Эй! T9^~6#wЙ! T9^K#е^C#ееэбСбЇё(№ x№бСэщХйѕ ц#з|· }·А>Г* Н
Р>Г( Н‚
хН­Н
нЩ}·Щ>К( Нц
ЯЩЛxЩВ‰
Щ}·ЩИЩЕХеЩ}· ЩЛёTЕЛшЇЩЛш}Щ•(0нD=ЩН{,= щ(ЩсжЂ Н“0%Н|·, 7 НЗ?х(8ЩН­Лx 	Н‡- цНsс8Лё·ЩбСБЩЙЩЛxЩВ
Нђ
Н
Ш,-ИxоЂGЙЩ}·ЩКs}·ИЩ…ЩНNЕХеЭ9НsЩ.Щ>Э#Эn Л0Н“Н|= сЩ-Щ еЭnыЛx 	Н€,-(-ссс·сЩБбЩЭбЛё°G,-МsЙ}·ИЩ•Щ?НNеееЭ9Щ.Щ>НЗ8Н­?Л= ЭuЭ+Щ-Щ(>Н‡0ЯН­·бН‡8НЗ?бСБЛx Н€љ, —7•8ЖЂ8ЖЂ8oЭгЩеЕxЛшЩЁжЂхЛшЭеЭ!  ЙбШЇoGOW_gЙ·ЛЛЛЛЛЙ·ЛЛЛЛЛЙ|Щ„Щg{Щ‹Щ_zЩЉЩWyЩ‰ЩOxЩ€ЩGЙ|Щ”Щg{Щ›Щ_zЩљЩWyЩ™ЩOxЩЩGЙxЩёЩАyЩ№ЩАzЩєЩА{Щ»ЩА|ЩјЩЙЩxЩЁткxЙЛx(НфИ?Й}ЩЅЩА·ИГЗ}ЦЃЪs<ю(РЩЕХеНs7Н|= щЩ|Щ¤Щg{ЩЈЩ_zЩўЩWyЩЎЩOxЩ ЩGГ|
ЩЕХеЩН­ЩНюЩН‚
л}·ИЛx>В( Н­}ЖЂЛ/ЖЂoЦхЩЕХеНц
Н
-ЕХеН‚
}бСБЩбСБгјг0гсЩЙЩНЏ-Н‚
ЩНЏ,Щ}юlШЕЛёНаБ8	Нц
Н5Н
Лx(Н
Щ-ЩНах8Н‚
Щ-ЩНа8Щ,Н‚
}юl8;ЩЄ*ЄЄ!ЄН
ЭеЭ!>Н5ЭбН­Н
Н
ЕХеЩН­--Щ-Н
ЩбСБЩН‚
,,с,-ИШxоЂGЙgЄ?+2Чn¶*п8tР Рz€€€€~«ЄЄЄЄ,->К( ЛxВ( ЩН™Щ}.Ѓ•хНц
ЩН‡ЩН‚
ЕХеЩ,Н
ЩбСБНц
ЭеЭ!Ќ>Н5Эб,ЩНЈ-ЩН
сЕХеo& 0%Н	Щ,Н
ЩбСБН
}юgЪsЙ}ЉќШ‰}йў‹.:}Ћг8Ћc~I’$I~НМММL«ЄЄЄ*ЩНЈЩ·ЛxхЛёНц
}ю€0GЕХе,НСеЛ<Л}бхН	,-(-ЩсбСБхН‚
ЭеЭ!>НJЭбс0
хЩН™ЩН
с…o8	сИЩН‡Гц
б>Г( m.`1pF,юеt6|‰„!wS<яГ.zТ}[•|%ёFXc~ьпэuЂТчr1}·ИЭеЩН‡ЩЇЛx(<ЛёхНа8ЩНц
сЛяхЩПЋй!~JЩНа0Н/OЭ!П>Щ ЭНtЩНа8= мЩ ЭЩЩНoЛшН
ЕХеНtН
ЩН‡Н
ЩбСБНц
ЭеН/ЭбЩНoН
с0
хЩНЏ-Н‚
сЭбЛOИЛшЙзПМTцфў0	jБ‘
ЂµћЉoDЂ‚,:НЂjБ‘
Ѓ     Ђ!ўЪI}иў‹.є}Ћг8Ћc~I’$I’~НМММL«ЄЄЄЄЭ!>ЕХехН­Н
сНJЩбСБГ
хЩНoхЩЕХеНoН
ЩбСБЩН
с= йЩН‡Г
 ЭЭn ЭfЭ^ЭVЭNЭFЙ!Ѓ DLT\ЙIўЪ!‚!Й53у!ЃъЙr1ч!ЂТЙЕХеЩбСБЙН“!Ђ > Лx Л#ЛЛЛ-= рoЛёЙЛxЩН‡(Лш-Н
·Л}(ЛxЛш>ЏЅ8(Н{,уН{`iИГ„!  Й>’Г( |µКsЛ|НЃ>ђ)=Л|(ъDM  boАЛёЙНЙл 8ю8НЙЩЛxЩ(’0Їю	8>	<WХЩэ!] ЭеНмЭбСOz<Л{ Ѓтlэ6  ю8>ХНЃСЛx(>-НжЛ{(a Лy(НдНЪтђz·(>.Нж(Нд чъІНЪчЛ{И>EНж>+Л|(|нDg>-Нж|/Ц
0ыЖ:Эp Э#э~ э#· э+>0Эw Э#Йэе,- э6 0э#шЇГ~ЕЛё}ЩЦЂoџgM Нц |юЩ <эw нDНA}юЃ0Нґэ5 Лш>„•. (Н{Л= шэ~ х>xжЖ0эw э#xжGЕХеЛ%Н€Л%Н€лгСгнZлбгнJDMбЛ%Н€= ИсБэбЙэеб_ ~6 ю5Шъќ+~<wю:Ш6 с61#6 ЙЩ  ЩНsЭ~ Н§ю. ЩЛp7АЛрЩЭ#кюE(!Н:0TНґШЩЕo& Н	Нк	ЩБШЛp(ЩЧНШЩЛаЭ#Э~ ю+(ю- ЛиЭ#Н7?ШOЭ#Н70
Э#Wy‡‡Ѓ‡‚OЛh(yнDOЩЩyЖЂюZШю¦?ШЕЭеyНAЭбЩБЩЙЭ~ Ц0?Рю
Йх·тHнDхЛ?Л?<!ъя = ьлЭ!xЭНtсж(хНґс= шс·т
ЩГц
Ѓ     Ћ   @›   ј>Ё ҐФh¶їЙГ¬Елx-РНОВSЮщx9?л+Ё­ЕшЙ{О—@}·ИЛшЕХ|Н{Н{„gгнZлбгнJDMб0Н|,7И}ЖoЛёЙ Н@ѕ #шyоO!@ 9щi& Эй Н@ л ¶ѕ в#чЪН@¶w#щлщЭйН@/¦w#шпН@¦w#щгэбЭб!  9л!  E9эйЭб!! 9~·(Ї+FН»¦!" 9щ!  (#Эй>Ї2и эб*Т НгЇб"в эе|· >"2Р Й:и ·(
Н· *в wЙНу*в 6  л!\ $ н°Й!зЕен[Т ю (ъН§–(
бБ г·Й#лББю:А~ЙCONБTRMБKBD‚LSTCAUXДUSRЕ>Ї2и Нj:Р ·А*в Л®~жАН1:Р ·А*в :и ·ЂЂ(@ q##pЙН[*в  л:и ·(
ХН СсЕН Б<Аx2Р Й*в  6 #ыЙ"в ~жАЛv(
>НЗНЛ~И*в е лН б< >я2Р 6 Йг"д ге!В "в бЙг"д г"в Л~А>2Р Йг"д г"в ЛvА>2Р Й>Їг"д ге!В "в Л®хНйс·(НвбЙ !С ~ю8>~O6~*Т "Ф  Нвwю(6ю(2ю(-ю()ю(6ю(8ю 0ю Щ:Э ·(УЭ*д Г yє(И~#НКАъю+Н  (±п(« 6Нв6#6
#"Ц Й*в :Р · y~Лo pж .##~·теН»б(е. 6бЇw4Ж._ ~ю =*в ##55= *Ф н[Ц ·нR8яНл*Ф ~#"Ф = НЈ }== НЇ }Нµ }*в Ло#w+Й#~+Й>Йе*в ~жю('Нlю!0ю(Л®с] ЕХНlСБю!8Л®пЇбЙЭ!] Э~ ·И ю-АЭ#Й8Э~ ·И>2Р 7ЙеНlЛ®бwЙ>ЇOЕНсБН%ИЕеНшСБН7ШМ„лs #rлЙНсН%ИЕеН¤ЩбБН7ШЩМђ
ЩГТел ЕХНlСБю(ю(Л®кбqЙНlю(Л®ю
(ю пНlю
 Л®Й*в O:Р ·А~ж ##е~Ж._ qб4р(ю(б Ее=К¦ ==К© =К¬ ГІ *и :к ѕИ4^ qЙ*в ##~·И6 Н»И>р2Р Й}ГЗБСЕЭ*Т Л|(Н„ллЛ|(	Н„Э6 -Э#ХНЗбНЙн[Т Эеб·нRMл‘8(Gе> ЕНЗБчбAИ~ЕеНЗбБ#уБСЩбСБЩЕЭ*Т ХН(ѕБСЕНЙЛC!ў ї!¦ёTRUEFALSEНЙ! 9N#НZСщХЙб~#·(G~ЕеНЗбБ#хй>НЗ>
ГЗ  "в Л~(ХНlС»(ю(ю!0(Л®и! Й!  Й>Ї2и нSж Н{:Р ·АН1:Р ·А*в 6Р##w w#w$ w#wЦя:и · е ЇН
б##N#F*ж ·нBИ>ђ2Р ЙеЇw#w#н[ж s#rб >Г
"в ~жАИНЇ*в - Їw#wФяw## >Н
НЇГ‚г"д г"в ~жАА>2Р Й:Р ·АеН[л·нRб0ЇН
*в  4А#4Й>™2Р Й:Р ·АеН[·нR> *в  4 #4(>бН
Иб>т2Р Й2й л*в Лf(/Л¦:й ЛG(##~++· :й ЛO x· y·ъDЕХ!Н»СБ Q*в :й ЛG(Ло##~Ж.Х_ СЦ.Н›н вg<т]=<Н›*в ##жw ЕХеНЇбСБ Х+ С4 #4x±ВлЙ>™>р2Р Йх:й ЛG(лсЙ"в НЇИж"*в ЛжЛnИЛ®*в еЕ0 лН Бб лН ·ЙБСнSв ЕеН[С·нR8@*в  	N#F#s#rН- 	0}ж)лнjлS\*в ##w+ 	N#Fл·нB	ИХеНЇСбr+sЙ>‘2Р ЙХЩбЩ!  T]>)лнjлЩ)Щ0	0= пЙН^·нR!  А#ЙН^лЙ*в  ^#V#ХN#F#^#VбЙ>Ї2и Н±:Р ·АН1:Р ·А*в 6Ае л#Н б- ЇNw#FwЦяq#p#6Ђ#w#w#wЙ"в ~жАИГ‚>">!DM!р "ж ЭбСбЭеЕНюБ:Р ·А*р нBИ:й ю!>™(>р2Р Й>">!"ж ЭбБСбЭе2й "в ~жАК±*ж Їw#wx±(9ЕХН *в  л:й OН СБ· Х*в - 4 #4С!Ђ л*ж 4 #4Г*в - N#FЪяq#pьяV+^л·нBРлq#pЙБСнSв ЕеН[С·нRЪ'*в  	s#r$ 	s#rЙНMА лН <А?эб*Т НгЇбэеНMАеНубе л!\  н°б елН С<(	!\ $ н°Й>2Р Й>Ї2и НMА:Ш ·>!(л*в  \ $ н°\ Н <(П!4°  н° :и · н[1 Г° ХН \ Н С!Ђ л·(й7"в ~жИ> 2Р Й"ж нSи лб"в Ns#Frл·нB(Zл#\ :Ь  н°Їье\ Н С<(?*ж "} нKи ЕХН \ !Н СБ· !*} #"} !Ђ лx± Ы\ Н *в  йЭ*в >рГ* НЙюР2Ь Й"р лбг"т {жь_!Ю "ш Э*Ю ЭnЭf}ґ(HнR0Эn ЭfеЭ"ш Эбг 
Э^ ЭVЭеMDЭn ЭfЭеЭЭu ЭtЭqЭpЭеС*ш s#rС*т s#rЙЭеб"Д *р  	ЭеБ	ЪvнKЖ нB  !  Ъ1>яГ( лбг~#fo{жь_л"р *Ю еЭб·нR0RЭn Эfе·нR0ЭбрбХэбнKр эqэpэu эtЭs ЭrЭебЭNЭFН(	Э^ ЭVХЭбЭебЭNЭFЭ^ ЭV*Ю нSЮ ХЭбЭu ЭtнKр ЭqЭpл	·нRАХэб*Д ·нR(э~ Эw э~Эwэnэf	ЭuЭtЇЙЭеб"Д 6 #ыЙНL*ф ЙНL*ц Й!  "ф "ц Э*Ю ЭNЭFy°(*ф 	"ф *ц ·нB0нCц Эn ЭfеЭбШ*Ж ыя	н[Д ·нRШл*ф "ф *ц ·нRРнSц Йн[Д s#rЙ^#Vл"Д "Ю 6 #ыЙ>ЇO"и Їw2Р x2к *в "н !G"в б"д б Н'Нz*н "в *д й>Ї2м "и *в "н !G"в б"д б"к !\ НгЇ*к :м · НOНs!Р ~6 ·go(Эеб\ нRл*и s#rЈЖ н_2Л ЙлЭбБбx±(sx±(T]н°ЭйDMЭбСбx±(фнR0н	л	лнёЭйU(НћЭбO /o&я9щq#л(н°Эй !Ђ >Fё0# (~ю (ю	 #п](~ю (ю	(#п}“( Хi& TЙСБХ-a%ГЈ}Н§oЙ* й!Р ~6 o& ЙН|µИ:Э хЇ2Э Н!с2Э }юАЭб :Р ·ИЭб_Эб_ХН{СЇ2Э *О |µЭебнKМ нB 	"О · ХХеНЩ Сz· Н^C
User break += Н
I/O Н
Run-time Н error  {НµН, PC= *О Н°НNot enough memory Н
Program aborted
 :Ш ·Кm'Г  бССй1 ! яНe!:#=я>НХГЄ"!A Mнhе! С|ўg}Јo}2e*e& е! СНЂЛEК !Й!B е!  Бнi!  е! СНgzіКj!Х}2\Н !!@ е!qе*\& Сn& Бнi*\& #СГ=!ЙНњН»Read Result !НОН ! е! СНgzіКЩ!Х}2SН !!@ Mнh}2R*S& Нње! Н'Н *R& Нње! Н'НОН *S& #СГђ!ЙН !!@ Mнh}2G!  }2H*G& е! С|ўg}Јoе!  СН“ЛEКB"! }2q!  }2r!  }2s!  }2t! }2u! }2vН(!Нk!! }2H*H& }2Q*Q& Йэбб"Eэе! }2q!  }2r!bе! СНе!А С|ўg}Јo}2s!bе! СНF}2t! }2u! }2vН(!НЪ!л*EsЙНњН»Parking Heads on Track # 610 !НОН !pеНQ"*p& ЛEК#НњН»Heads incorrectly parked  !НОН НњНОН НњН»Command completed !НОН ГХ eads on Track # 610 !НОН !pеНQ"*p& ЛEКvНњН»Heads incorrectly p(НћЭбO /o&я9щq#л(н°Эй !Ђ >Fё0# (~ю (ю	 #п](~ю (ю	(#п}“( Хi& TЙСБХ-a%ГЈ}Н§oЙ* й!Р ~6 o& ЙН|µИ:Э хЇ2Э Н!с2Э }юАЭб :Р ·ИЭб_Эб_ХН{СЇ2Э *О |µЭебнKМ нB 	"О · ХХеНЩ Сz· Н^C
User break += Н
I/O Н
Run-time Н error  {НµН, PC= *О Н°НNot enough memory Н
Program aborted
 :Ш ·Кm'Г  бССй1 ! яНe!:#=я>НХГЄ"ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееprogram parkhd;
var  cfield:  record
                 command:    byte;
                 address:    byte;
                 sector:     byte;
                 track:      byte;
                 bcount:     byte;
                 termin:     byte
              end;
     cfarray:                array [0..5]   of byte absolute cfield;
     error:                  boolean;
     park_cyl:               integer;
{ ==================================================================== }
procedure wait_controller_ready;
var  status:  byte;
begin
  repeat
    status:=port[$41] and 1;
  until status=1
end;
{ -------------------------------------------------------------------- }
procedure send_command;
var  i:  byte;
begin
  port[$42]:=0;                 { select controller }
  for i:= 0 to 5 do begin       { send command with }
    wait_controller_ready;        { parameters }
    port[$40]:=cfarray[i]
  end
end;
{ -------------------------------------------------------------------- }
procedure read_result;
var  i,x:  byte;
begin
  writeln ('Read Result !');
  for i:=1 to 4 do begin
    wait_controller_ready;
    x:=port[$40];
    write (i:8);
    writeln (x:8)
    {  if i=4 then res[i]:=res[i]+port[$40]  }
    {  else res[i]:=port[$40];  }
    {  if i=3 then   }
    {  if res[i] >= 64 then res[i+1]:=(res[i] div 64)*2  }
    {  else res[i+1]:=0  }
  end
end;
{ -------------------------------------------------------------------- }
function  error_check:  boolean;
var  err:     boolean;
     status:  byte;
begin
  wait_controller_ready;        {  wait until controller is ready  }
  status:=port[$40];            {  read controller status  }
  err:=false;                   {  reset error flag  }
  if status and 2 <> 0 then begin
     cfield.command:=3;         {  in case of error read error info  }
     cfield.address:=0;         {  from controller  }
     cfield.sector:=0;
     cfield.track:=0;
     cfield.bcount:=1;
     cfield.termin:=2;
     send_command;
     read_result;
     err:=true                  {  set error flag  }
  end;
  error_check:=err
end;
{ -------------------------------------------------------------------- }
procedure park_heads  (var err: boolean);
const  park_cyl = 610;          { heads parking position }
begin
   cfield.command:=$0b;
   cfield.address:=0;
   cfield.sector:=((park_cyl div 4) and $c0);
   cfield.track:=park_cyl mod 256;
   cfield.bcount:=1;
   cfield.termin:=$02;
   send_command;
   err:=error_check             { test controller status }
end;
{ -------------------------------------------------------------------- }
begin      {Hauptprogramm}
    writeln ('Parking Heads on Track # 610 !');
    park_heads (error);
    if error then begin
      writeln ('Heads incorrectly parked  !');
      writeln;
    end;
    writeln ('Command completed !')
end.
  }
     cfield.sector:=0;
     cfield.track:=0;
     cfield.bcount:=1;
     cfield.termin:=2;
     send_command;
     reaееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;	Macro Definitions for CP/M3 BIOS Data Structures.

	; dtbl	<dph0,dph1,...>		- drive table

	; dph	translate$table,	- disk parameter header
	;	disk$parameter$block,
	;	checksum$size,			(optional)
	;	alloc$size			(optional)

	; skew	sectors,		- skew table
	;	skew$factor,
	;	first$sector$number

	; dpb	physical$sector$size,	- disk parameter block
	;	physical$sectors$per$track,
	;	number$tracks,
	;	block$size,
	;	number$dir$entries,
	;	track$offset,
	;	checksum$vec$size		(optional)


;	Drive Table.  Contains 16 one word entries.

dtbl macro ?list
    local ?n
?n  set 0
    irp ?drv,<?list>
?n  set ?n+1
	dw	?drv
    endm

    if ?n > 16
.' Too many drives.  Max 16 allowed'
	exitm
    endif

    if ?n < 16
	rept (16-?n)
	dw	0
	endm
    endif
 endm

dph macro ?trans,?dpb,?csize,?asize
    local ?csv,?alv
	dw ?trans		; translate table address
	db 0,0,0,0,0,0,0,0,0	; BDOS Scratch area
	db 0			; media flag
	dw ?dpb			; disk parameter block
    if not nul ?csize
	dw ?csv			; checksum vector
    else
	dw 0FFFEh		; checksum vector allocated by
    endif			; GENCPM
    if not nul ?asize
	dw ?alv			; allocation vector
    else
	dw 0FFFEh		; alloc vector allocated by GENCPM
    endif
	dw 0fffeh,0fffeh,0fffeh	; dirbcb, dtabcb, hash alloc'd
				; by GENCPM
	db 0			; hash bank

    if not nul ?csize
?csv	ds	?csize		; checksum vector
    endif
    if not nul ?asize
?alv	ds	?asize		; allocation vector
    endif

    endm

dpb macro ?psize,?pspt,?trks,?bls,?ndirs,?off,?ncks
    local ?spt,?bsh,?blm,?exm,?dsm,?drm,?al0,?al1,?cks,?psh,?psm
    local ?n
;; physical sector mask and physical sector shift
    ?psh	set 0
    ?n		set ?psize/128
    ?psm	set ?n-1
	rept 8
	?n	set ?n/2
 	    if ?n = 0 
	    exitm
	    endif
	?psh	set ?psh + 1
	endm
    ?spt	set ?pspt*(?psize/128)

    ?bsh	set 3
    ?n		set ?bls/1024
	rept 8
	?n	set ?n/2
	    if ?n = 0
	    exitm
	    endif
	?bsh	set ?bsh + 1
	endm
    ?blm	set ?bls/128-1
    ?size	set (?trks-?off)*?spt
    ?dsm	set ?size/(?bls/128)-1

    ?exm	set ?bls/1024
	if ?dsm > 255
	    if ?bls = 1024
.'Error, can''t have this size disk with 1k block size'
	    exitm
	    endif
	?exm	set ?exm/2
	endif
    ?exm	set ?exm-1
    ?all	set 0
    ?n		set (?ndirs*32+?bls-1)/?bls
	rept ?n
	?all	set (?all shr 1) or 8000h
	endm
    ?al0	set high ?all
    ?al1	set low ?all
    ?drm	set ?ndirs-1
    if not nul ?ncks
    	?cks	set ?ncks
    else
	?cks	set ?ndirs/4
    endif
	dw	?spt		; 128 byte records per track
	db	?bsh,?blm	; block shift and mask
	db	?exm		; extent mask
	dw	?dsm		; maximum block number
	dw	?drm		; maximum directory entry number
	db	?al0,?al1	; alloc vector for directory
	dw	?cks		; checksum size
	dw	?off		; offset for system tracks
	db	?psh,?psm	; physical sector size shift
				; and mask
    endm

; updated version of dpb macro to be used with hard disk's
; with drive capacities much greater than 300 kb

hdpb macro ?psize,?pspt,?trks,?bls,?ndirs,?off,?ncks
     local ?spt,?bsh,?blm,?exm,?dsm,?drm,?al0,?al1,?cks,?psh,?psm
     local ?n
;; physical sector mask and physical sector shift
    ?psh	set 0
    ?n		set ?psize/128
    ?psm	set ?n-1
	rept 8
	?n	set ?n/2
 	    if ?n = 0 
	    exitm
	    endif
	?psh	set ?psh + 1
	endm
    ?spt	set ?pspt*(?psize/128)

    ?bsh	set 3
    ?n		set ?bls/1024
	rept 8
	?n	set ?n/2
	    if ?n = 0
	    exitm
	    endif
	?bsh	set ?bsh + 1
	endm
    ?blm	set ?bls/128-1

    if ?psize  >  ?bls
       ?n	set ?psize/?bls
       ?dsm	set (((?trks - ?off) * ?pspt) * ?n) - 1
    endif

    if ?psize  <= ?bls
       ?n	set ?bls / ?psize
       ?dsm	set (((?trks - ?off) * ?pspt) / ?n) - 1
    endif

    ?exm	set ?bls/1024
	if ?dsm > 255
	    if ?bls = 1024
.'Error, can''t have this size disk with 1k block size'
	    exitm
	    endif
	?exm	set ?exm/2
	endif
    ?exm	set ?exm-1
    ?all	set 0

    ?n		set (?ndirs + (?bls/32)-1)/(?bls/32)
    if  ?n = 0
    endif
    if  ?n > 16
    endif

	rept ?n
	?all	set (?all shr 1) or 8000h
	endm
    ?al0	set high ?all
    ?al1	set low ?all
    ?drm	set ?ndirs-1
    if not nul ?ncks
    	?cks	set ?ncks
    else
	?cks	set ?ndirs/4
    endif

    if not nul ?nocheck
	?cks	set ?cks or 8000h
    endif

	dw	?spt		; 128 byte records per track
	db	?bsh,?blm	; block shift and mask
	db	?exm		; extent mask
	dw	?dsm		; maximum block number
	dw	?drm		; maximum directory entry number
	db	?al0,?al1	; alloc vector for directory
	dw	?cks		; checksum size
	dw	?off		; offset for system tracks
	db	?psh,?psm	; physical sector size shift
				; and mask
    endm

;
gcd macro ?m,?n
	    ;;	greatest common divisor of m,n
		    ;;	produces value gcdn as result
		    ;;	(used in sector translate table generation)
    ?gcdm	set ?m	;;variable for m
    ?gcdn	set ?n	;;variable for n
    ?gcdr	set 0	;;variable for r
	rept 65535
	?gcdx	set ?gcdm/?gcdn
	?gcdr	set ?gcdm - ?gcdx*?gcdn
	    if ?gcdr = 0
	    exitm
	    endif
	?gcdm	set ?gcdn
	?gcdn	set ?gcdr
	endm
    endm

skew macro ?secs,?skf,?fsc
;;	generate the translate table
    ?nxtsec	set 0	;;next sector to fill
    ?nxtbas	set 0	;;moves by one on overflow
    gcd %?secs,?skf
    ;;	?gcdn = gcd(?secs,skew)
    ?neltst	set ?secs/?gcdn
    ;;	neltst is number of elements to generate
    ;;	before we overlap previous elements
    ?nelts	set ?neltst	;;counter
	rept ?secs	;;once for each sector
	db	?nxtsec+?fsc
	?nxtsec	set ?nxtsec+?skf
	    if ?nxtsec >= ?secs
	    ?nxtsec	set ?nxtsec-?secs
	    endif
	?nelts	set ?nelts-1
	    if ?nelts = 0
	    ?nxtbas	set ?nxtbas+1
	    ?nxtsec	set ?nxtbas
	    ?nelts	set ?neltst
	    endif
	endm
    endm

skew1 macro ?secs,?skf,?fsc
;;	generate the translate table
;;	with bit 8 high (usefull for twosided disks)
    ?nxtsec	set 0	;;next sector to fill
    ?nxtbas	set 0	;;moves by one on overflow
    gcd %?secs,?skf
    ;;	?gcdn = gcd(?secs,skew)
    ?neltst	set ?secs/?gcdn
    ;;	neltst is number of elements to generate
    ;;	before we overlap previous elements
    ?nelts	set ?neltst	;;counter
	rept ?secs	;;once for each sector
	db	?nxtsec+?fsc or 80h
	?nxtsec	set ?nxtsec+?skf
	    if ?nxtsec >= ?secs
	    ?nxtsec	set ?nxtsec-?secs
	    endif
	?nelts	set ?nelts-1
	    if ?nelts = 0
	    ?nxtbas	set ?nxtbas+1
	    ?nxtsec	set ?nxtbas
	    ?nelts	set ?neltst
	    endif
	endm
    endm

t ?secs	;;once for each sector
	db	?nxtsec+?fsc
	?nxtsec	set ?nxtsec+?skf
	    if ?nxtsec >= ?secs
	    ?nxtsec	set ?nxtsec-ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;******************************************************************************
;*  D I S K I O  *  C P M S Y S 4 f  *	T h o m a s   H o l t e * 8 5 0 9 2 5 *
;******************************************************************************
;*									      *
;*			    D I S K   H A N D L E R			      *
;*			    =======================			      *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

;------------------------------------------------------------------------------
; Anmerkungen:
;
; Aus verschiedenen Versionen zusammengelegt und Ansteuerung f}r Hard-Disk
; entfernt um Pseudo-Laufwerke zur Formatkonvertirung einzubinden. In den
; Originaldateien  DISKIO.MAC, TABLES.MAC und DRIVER.MAC sind dir Werte f}r
; das High-Density Format 'FRITZ' als Standartwerte einzutragen. Zur
; Portabilitaet waere eine identische Formatdefinition von Vorteil. Beim HD
; Format habe ich die Formatgr|~e durch Versuche festgelegt. Die Systemspur
; beinhaltet auf/f}r meine CPU 280 eine Formatangabe, so da~ das Format auf
; meinem anderen Rechner automatisch erkannt wird. Da nicht von High Density
; gebootet wird k|nnte man die Systemspur auch entfallen lassen. (siehe vorher).
;
; Fritz Chwolka, Saarstr.34, 5173 Aldenhoven (02464)8920
;
; Hier m|chte ich mich noch f}r das Entgegenkommen des Herrn Holte bedanken,
; welcher mir seine Originaldisketten zur Systemerstellung vertrauensvoll
; zusandte, wobei ich anschlie~end das Systembios bei Herrn Holte erstandt.
; Das BIOS darf unter beibehalten der COPYRIGHT - Meldung des Herrn HOLTE
; weitergegeben werden.
; Die Copyrechte der Firma Digital Research betreff dem CPM+ , hier speziell
; der ???????.SPR Dateien ist von obigen Aussagen unbeeintr{chtigt. Sie
; sollten auf jeden Fall eine Systemdiskette von Digital Research erworben
; haben, um so als Lizensnehmer die SPR-Systemdateien der Firma Digital
; Research zu nutzen.
; Bei Problemen oder Fragen bin ich unter obiger Adresse immer erreichbar und
; freue mich f}r jede Zuschrift.
;
; 1989 F.Chwolka
;
; Zus{tzlich rumgepfuscht hat Volker Dose. Zum einen um das PROF #4 Format
; lesen zu k|nnen, und zum anderen um eine Harddisk mit OMTI-Controller
; lesen zu k|nnen. 
; Die Harddiskroutine f}r 10MByte Platte mit 2 K|pfen und 612 Cylindern
; wird jetzt eingebunden. Die Routinen sind die BIOS Sources von
; Helmut Bernhardt aus HD2.MAC. Der DPB wurde mit XCPM3.LIB aus 
; HDDTBL.ASM errechnet.
;
;
;
;-----------------------------------------------------------------------------

	.Z80

	TITLE 'CP/M 3 DISKETTE HANDLER'

	DSEG

;Disk drive dispatching tables for linked BIOSЉ;GLOBAL DS0,MF0,MF1,FD0,IBMPC,KDS,RAM,RAIR,ALPHAP3,DRIVEP

	GLOBAL	MF0,MF1,DS0,RAM,PROF,DRIVEP

;Variables containing parameters passed by BDOS
	EXTERNAL @DTBL,@ADRV,@RDRV,@DMA,@TRK,@SECT,@DBNK,@CBNK

;System control block variables
	EXTERNAL @ERDME		; BDOS error mode

	EXTERNAL ?PMSG		; Print message ^HL up to 0, saves reg. BC & DE
	EXTERNAL ?PDERR		; Print BIOS disk error header
	EXTERNAL ?CONIN,?CONO	; Con in and out
	EXTERNAL ?CONST		; Get console status

	EXTERNAL ?BANK,?USERF
;Harddiskroutinen aus HD2.MAC

        external hdwrit,hdread,hdlogi,hdinit,hd1ini

 
;ASCII control codes:
SUB	EQU	1AH		; Substitute
ESC	EQU	1BH		; Escape



;**Extended Disk Parameter Headers (XDPHs)


;Double Density
	DEFW	FD$WRITE
	DEFW	FD$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	0		; Relative drive zero
	DEFB	0		; Drive type
				; 0 = floppy disk
				; 1 = floppy disk (special format)
				; 2 = Winchester
				; 3 = Winchester (cartridge)
				; 4 = RAM disk
MF0:	DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPB01		; Disk parameter block
	DEFW	0FFFEH,0FFFEH	; CSV, ALV, DIRBCB, DTABCB, HASH
	DEFW	0FFFEH,0FFFEH	; Alloc'd by GENCPM
	DEFW	0FFFEH
	DEFB	0		; Hash bank

	DEFW	FD$WRITE
	DEFW	FD$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	1,0		; Relative drive one
MF1:	DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPB01		; Disk parameter block
	DEFW	0FFFEH,0FFFEH	; CSV, ALV, DIRBCB, DTABCB, HASHЉ	DEFW	0FFFEH,0FFFEH	; Alloc'd by GENCPM
	DEFW	0FFFEH
	DEFB	0		; Hash bank

;EJECT
;RAM disk:
;--------:
	DEFW	M$WRITE
	DEFW	M$READ
	DEFW	FD$LOGIN
	DEFW	M$INIT0
	DEFB	0,4
RAM:	DEFW	0		; No translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPBC		; Disk parameter block
	DEFW	0		; No CSV
	DEFW	0FFFEH,0FFFEH	; ALV, DIRBCB alloc'd by GENCPM
	DEFW	0FFFFH		; No data buffer
	DEFW	0FFFEH		; HASH alloc'd by GENCPM
	DEFB	0		; Hash bank

;
;XDPH f}r Harddisk 10MB
	DEFW	hdwrit
	DEFW	hdread
	DEFW	FD$LOGIN
	DEFW	hdinit
	DEFB	0		;relative Drive zero
	DEFB	2		;drive type
				; 0 : floppy disk
				; 1 : floppy disk (special format)
				; 2 : Winchester
				; 3 : Winchester (cartridge)
				; 4 : Ramdisk
DS0:	DEFW	0		;no translation table
	DEFW	0,0,0,0		;BDOS scratch area
	DEFB	0,0		;media flag
	DEFW	DPBHD		;disk parameter block
	DEFW	0		;no CSV
	DEFW	0FFFEH,0FFFEH	;ALV, DIRBCB, DTABCB, HASH
	DEFW	0FFFEH,0FFFEH	;allocated by GENCPM
	DEFB	0		;hash bank
							



;----------------------------------------------------------------
; Formatdefinitionen:
; F}r Sonderformate wird Drive B als relatives laufwerk genutzt.
;----------------------------------------------------------------

;EJECT
;PROF #4 Format
;------------------------:
	DEFW	A$WRITE
	DEFW	A$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	1,1		; Relative drive one
PROF:   DEFW	XLTO		; No translation tableЉ	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPBE		; Disk parameter block
	DEFW	CSV3,ALV3	; Checksumm vector, allocation vector
	DEFW	DIBCBH,DTBCBH	; BCB list header
	DEFW	0FFFFH		; No HASH
	DEFB	0		; Hash bank
ADCT:	DEFB	01111000B
	DEFB	10000000B
	DEFB	2,20,80


;EJECT

;EJECT
;virtual disk drive P:
;--------------------:
	DEFW	P$WRITE
	DEFW	P$READ
	DEFW	FD$LOGIN
	DEFW	FD$INIT
	DEFB	1,1		; Relative drive one
DRIVEP:	DEFW	XLTF       	; Translation table
	DEFW	0,0,0,0		; BDOS scratch area
	DEFB	0,0		; Media flag
	DEFW	DPBF		; Disk parameter block
	DEFW	CSVF,ALVF	; Checksumm vector, allocation vector
	DEFW	DIBCBH,DTBCBH	; BCB list header
	DEFW	0FFFFH		; No HASH
	DEFB	0		; Hash bank
PDCT:	DEFB	01110000B
	DEFB	10000000B
	DEFB	2,10,80

;sector translation tables:

XLTF:	DEFB	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
	DEFB	17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33
	DEFB	34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51

XLTO:   DEFB    0,2,4,6,8,1,3,5,7,9,10,12,14,16,18,11,13,15,17,19

;checksum vectors
CSV3:   DEFS    34  
CSVF:   DEFS    64

  
;allocation vectors:
ALV3:   DEFS     99 
ALVF:	DEFS	100

;BCB list header:
DIBCBH:	DEFW	DIRBCB
DTBCBH:	DEFW	DTABCB

;directory control block:
DIRBCB:	DEFB	0FFH
	DEFS	9
	DEFW	DIRBUF
	DEFB	0
	DEFW	0Љ
;data control block:
DTABCB:	DEFB	0FFH
	DEFS	9
	DEFW	DTABUF
	DEFB	0
	DEFW	0

;directory buffer:
DIRBUF:	DEFS	1024

;data buffer:
DTABUF:	DEFS	1024


;EJECT
	CSEG			; DPB must be resident


;Disk Parameter Blocks (DPB)

;Double Density Holte:
;--------------------:
DPB01:	DEFW	80		; 128 byte records per track
	DEFB	4,15		; Block shift and mask
	DEFB	0		; Extent mask
	DEFW	389		; Maximum block number
	DEFW	191		; Maximum directory entry number
	DEFB	0E0H,0		; Alloc vector for directory
	DEFW	48		; Checksum size
	DEFW	2		; Offset for system tracks
	DEFB	2,3		; Physical sector size shift and mask




;RAMDISK:
;-------:
DPBC:	DEFW	447		; 128 byte records per track
	DEFB	3,7		; Block shift and mask
	DEFB	0		; Extent mask
	DEFW	110		; Maximum block number
	DEFW	31		; Maximum directory entry number
	DEFB	80H,0		; Alloc vector for directory
	DEFW	8000H		; Checksum size
	DEFW	0		; Offset for system tracks
	DEFB	0,0		; Physical sector size shift and mask

;VIRTUELLES DRIVE -P-:
;--------------------:
DPBF:	DEFW	80		; 128 byte records per track
	DEFB	5,31		; Block shift and mask
	DEFB	3		; Extent mask
	DEFW	191		; Maximum block number
	DEFW	255		; Maximum directory entry number
	DEFB	192,0		; Alloc vector for directory
	DEFW	64		; Checksumm size
	DEFW	3		; Offset for system tracks
	DEFB	3,7		; Physical sector size shift and mask

;:---------------------:Љ;:HARDISK 10MByte      :
;:---------------------:
DPBHD: 	DEFB  	088H,000H   ;SPT= 136      128 Byte records/track
	DEFB	005H        ;BSH=   5      block shift factor  
        DEFB    01FH        ;BLM=  31      block mask   
	DEFB	001H        ;EXM=   1      extend mask  
        DEFB    01BH,00AH   ;DSM=2587      maximum block number 
	DEFB	0FFH,007H   ;DRM=2047      maximum directory number
	DEFB	0FFH        ;AL0= 255      allocation vector 0
        DEFB    0FFH        ;AL1= 255      allocation vector 1
	DEFВ	000H,080И   ;CKSЅ   °      checksuн sizе iу zero
                            ;              ,permanently mounted
	DEFB	002H,000H   ;OFF=   2      reserved tracks 
 	DEFB	002H        ;PSH=   2      physical sector shift
	DEFB	003H        ;PHM=   3      physical record mask 

;das hei~t auf Deutsch:
;			512 Bytes/Sector
;			 34 Sectoren/Zylinder (2 K|pfe*17 Sec/Cyl)
;			611 Cylinder/Laufwerk
;			4KB Blockgr|~e
;		       2048 Directory Eintr{ge
;			  2 Reservierte Systemspur
;		      8000h Flag f}r nonremovable medium 			


	
;PROF #4 
;----------------:
DPBE:	DEFW	80		; 128 byte records per track
	DEFB	4,15		; Block shift and mask
	DEFB	0		; Extent mask
	DEFW	384		; Maximum block number
	DEFW	127		; Maximum directory entry number
	DEFB	0C0H,0		; Alloc vector for directory
	DEFW	32		; Checksum size
	DEFW	3		; Offset for system tracks
	DEFB	2,3		; Physical sector size shift and mask



;EJECT
	

          DSEG

;EJECT
;RAM disk init routine:
;---------------------:
POWUP	EQU	111DH		; Power up/reset marker

M$INIT0:LD	A,(POWUP)	; Power up ?
	OR	A
	RET	Z		; Return if not

;clear RAM disk:
	LD	C,32		; Entry count		 --> reg. C
	LD	DE,128		; ^first directory entry --> reg. DE
CLRNXT:	PUSH	BC		; Save remaining entry count
	PUSH	DE		; Save ^directory entry
	LD	HL,CLRBYT	; ^E5		   --> reg. HLЉ	LD	BC,1 SHL 8+15	; Byte count	   --> reg. B
				; Function #	   --> reg. C
	LD	A,2		; Source      bank # = 0
				; Destination bank # = 2
	CALL	?USERF		; Clear current entry
	POP	HL		; ^current directory entry --> reg. HL
	LD	DE,32		; Offset to next entry	   --> reg. DE
	ADD	HL,DE		; Add offset
	EX	DE,HL		; ^next directory entry    --> reg. DE
	POP	BC		; Restore entry count
	DEC	C		; Decrement it
	JR	NZ,CLRNXT	; Clear next entry
	RET
CLRBYT:	DEFB	0E5H
          


;EJECT

          DSEG


;EJECT
;disk read routine:
FD$READ:LD	A,(@SECT)	; Sector number 	--> reg. B
	LD	B,A
	LD	A,(@TRK)	; Track number		--> reg. E
	LD	E,A
FD$REA1:LD	A,(@RDRV)	; Relative drive number --> reg. C
	LD	C,A
	LD	A,(@DBNK)	; DMA bank --> accu (upper nibble)
	SLA	A
	SLA	A
	SLA	A
	SLA	A
	OR	C		; Set drive number
	LD	HL,(@DMA)	; User buffer address	--> reg. HL
	LD	C,11		; Function number	--> reg. C
	CALL	?USERF		; Read physical disk sector
	LD	(DISK$STATUS),A	; Save status for error messages
	OR	A		; Any errors ?
	JP	NZ,RDERR
	RET

;suppress error message if BDOS is returning errors to application ...
RDERR:	LD	A,(@ERDME)
	INC	A
	JR	Z,R$HARD$ERROR

;had permanent error, print message like:
;	BIOS Error on d: T-nn, S-nn, <type>, Retry ?
	CALL	?PDERR		; Print message header
	LD	HL,(DISK$STATUS) ; Get status byte from last error
	LD	H,0
	DEC	L
	ADD	HL,HL		; Make byte offset
	LD	BC,R$ERROR$TABLE ; Point at table of message addresses
	ADD	HL,BC
	LD	A,(HL)		; Get specific message address
	INC	HL
	LD	H,(HL)Љ	LD	L,A
	CALL	?PMSG		; Print message
	LD	HL,ERROR$MSG	; Print "<BEL>, Retry (Y/N) ? "
	CALL	?PMSG
	CALL	U$CONIN$ECHO	; Get operator response
	LD	C,A		; Save response
	LD	HL,MSG$END	; Disable status line
	CALL	?PMSG
	LD	A,C		; Restore response
	CP	'Y'		; Yes, then retry 10 more times
	JP	Z,FD$READ
R$HARD$ERROR:			; Otherwise,
	LD	A,1		; Return hard error to BDOS
	RET


;EJECT
;disk write routine:
FD$WRITE:
	LD	A,(@SECT)	; Sector number 	--> reg. B
	LD	B,A
	LD	A,(@TRK)	; Track number		--> reg. E
	LD	E,A
FD$WRI1:LD	A,(@RDRV)	; Relative drive number --> reg. C
	LD	C,A
	LD	A,(@DBNK)	; DMA bank --> accu (upper nibble)
	SLA	A
	SLA	A
	SLA	A
	SLA	A
	OR	C		; Set drive number
	LD	HL,(@DMA)	; User buffer address	--> reg. HL
	LD	C,12		; Function number	--> reg. C
	CALL	?USERF		; Write physical disk sector
	LD	(DISK$STATUS),A	; Save status for error messages
	OR	A		; Any errors ?
	JP	NZ,WRERR
	RET

;suppress error message if BDOS is returning errors to application ...
WRERR:	LD	A,(@ERDME)
	INC	A
	JR	Z,W$HARD$ERROR

;had permanent error, print message like:
;	BIOS Error on d: T-nn, S-nn, <type>, Retry ?
	CALL	?PDERR		; Print message header
	LD	HL,(DISK$STATUS) ; Get status byte from last error
	LD	H,0
	DEC	L
	ADD	HL,HL		; Make byte offset
	LD	BC,W$ERROR$TABLE ; Point at table of message addresses
	ADD	HL,BC
	LD	A,(HL)		; Get specific message address
	INC	HL
	LD	H,(HL)
	LD	L,A
	CALL	?PMSG		; Print message
	LD	HL,ERROR$MSG	; Print "<BEL>, Retry (Y/N) ? "
	CALL	?PMSG
	CALL	U$CONIN$ECHO	; Get operator responseЉ	LD	C,A		; Save response
	LD	HL,MSG$END	; Disable status line
	CALL	?PMSG
	LD	A,C		; Restore response
	CP	'Y'		; Yes, then retry 10 more times
	JP	Z,FD$WRITE
W$HARD$ERROR:			; Otherwise,
	LD	A,(DISK$STATUS)	; Return hard error to BDOS
	CP	5		; Diskette write protected ?
	LD	A,1		; Common error code
	RET	NZ
	INC	A

FD$LOGIN:
FD$INIT:
	RET

U$CONIN$ECHO:			; Get console input, echo it, and shift to
				; Upper case
	CALL	?CONST		; See if any character already struck
	OR	A
	JR	Z,U$C1
	CALL	?CONIN		; Yes, eat and try again
	JR	U$CONIN$ECHO
U$C1:	CALL	?CONIN
	PUSH	AF
	LD	C,A
	CALL	?CONO
	POP	AF
	CP	'A'
	RET	C
	AND	0DFH		; Make upper case
	RET

DISK$STATUS:
	DEFS	1		; Last error status code for messages
;EJECT




;EJECT
;RAM disk I/O routines
M$READ:	LD	A,0FFH		; Switch on read flag
	JR	TASKM
M$WRITE:XOR	A		; Clear read flag
TASKM:	LD	(RDFLAG),A
	LD	A,(@TRK)	; Track # --> accu
	ADD	A,2		; Calc source bank #
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	HL,@DBNK	; Get destination bank #
	ADD	A,(HL)
	PUSH	AF		; Save bank numbers
	LD	DE,(@DMA)	; DMA address --> reg. DE
	LD	HL,(@SECT)	; Sector #    --> reg. HL
	INC	HL		; Adjust it
	LD	B,7		; Sector # * 128
	ADD	HL,HLЉ	DJNZ	$-1
	LD	BC,128 SHL 8+15	; Sector length --> reg. B
				; Function #	--> reg. C
	LD	A,(RDFLAG)	; Read or write ?
	OR	A
	JR	NZ,TASKM1	; Jump if read
	POP	AF		; Restore bank numbers
	RLCA			; Swap bank numbers
	RLCA
	RLCA
	RLCA
	PUSH	AF		; Push bank numbers again
	EX	DE,HL
TASKM1:	POP	AF		; Restore bank numbers
	CALL	?USERF		; Transfer "sector"
	XOR	A
	RET
RDFLAG:	DEFS	1




;EJECT
;PROF #4 format:
A$READ:	LD	A,0FFH		; Mark READ
	JR	A$TASK
A$WRITE:XOR	A		; Mark WRITE
A$TASK:	LD	(A$MODE),A
	LD	A,(PROF-2)	; Relative drive number    --> accu
	ADD	A,A		; *2
	LD	C,A		; Save it
	ADD	A,A		; *4
	ADD	A,C		; *6
	LD	B,0		; Relative drive # * 6	   --> reg. BC
	LD	C,A
	LD	HL,DCT		; ^drive control table	   --> reg. HL
	ADD	HL,BC		; Calc real pointer
	PUSH	HL		; Save DCT pointer
	LD	DE,TDCT		; ^temporary storage area  --> reg. DE
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Save disk parameters of drive B:
	LD	HL,ADCT		; ^parameters for drive O: --> reg. HL
	POP	DE		; DCT pointer		   --> reg. DE
	PUSH	DE		; Save DCT pointer again
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Load disk parameters of drive O:
	LD	A,(@SECT)	; Sector number --> accu
	LD	B,A		; Sector number --> reg. B
	CP	5
	LD	A,(@TRK)	; Track number	--> accu
	LD	E,A		; Track number	--> reg. E
	JR	C,A$TASK1	; Jump if sector # is lower than 5
	OR	A		; Track 0 ?
	JR	NZ,A$TASK2	; Jump if not track 0
	INC	E		; Convert track # to 1
	LD	A,B		; Sector # --> accu
	SUB	5		; Convert it
	LD	B,A		; Store it
	JR	A$TASK2
A$TASK1:DEC	A		; Track 1 ?
	JR	NZ,A$TASK2	; Jump if not track 1Љ	LD	E,A		; Convert track # to 0
	LD	A,B		; Sector # --> accu
	ADD	A,5		; Convert it
	LD	B,A		; Store it
A$TASK2:LD	A,(@RDRV)	; Relative drive number --> reg. C
	LD	C,A
	LD	A,(@DBNK)	; DMA bank --> accu (upper nibble)
	SLA	A
	SLA	A
	SLA	A
	SLA	A
	OR	C		; Set drive number
	LD	HL,(@DMA)	; User buffer address	--> reg. HL
	LD	D,A		; Save drive/bank #
	LD	A,(A$MODE)	; Read or write ?
	OR	A
	LD	A,D		; Restore drive/bank #
	JR	Z,A$TASK3	; Jump if write

	LD	C,11		; Function number	--> reg. C
	CALL	?USERF		; Read physical disk sector
	LD	(DISK$STATUS),A	; Save status for error messages
	OR	A		; Any errors ?
	CALL	NZ,RDERR
	JR	A$TASK4

A$TASK3:LD	C,12		; Function number	--> reg. C
	CALL	?USERF		; Write physical disk sector
	LD	(DISK$STATUS),A	; Save status for error messages
	OR	A		; Any errors ?
	CALL	NZ,WRERR

A$TASK4:LD	HL,TDCT		; Restore original disk parameters
	POP	DE
	LD	BC,5
	LDIR
	LD	HL,ADCT+1	; Get drive status
	SET	0,(HL)		; Set init bit
	RET
A$MODE:	DEFS	1		; Mark READ/WRITE

;EJECT
;------------------:
;virtual disk drive:

; DriveControllTable mu~ f}r Konfig eine feste Adresse haben.
DCT	EQU	10D7H		; Drive control table (SYSTAB)

P$READ:	LD	IX,FD$READ	; Read	routine vector	   --> reg. IX
	JR	P$TASK
P$WRITE:LD	IX,FD$WRITE	; Write routine vector	   --> reg. IX
P$TASK:	LD	A,(DRIVEP-2)	; Relative drive number    --> accu
	ADD	A,A		; *2
	LD	C,A		; Save it
	ADD	A,A		; *4
	ADD	A,C		; *6
	LD	B,0		; Relative drive # * 6	   --> reg. BC
	LD	C,A
	LD	HL,DCT		; ^drive control table	   --> reg. HL
	ADD	HL,BC		; Calc real pointer
	PUSH	HL		; Save DCT pointerЉ	LD	DE,TDCT		; ^temporary storage area  --> reg. DE
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Save disk parameters of drive B:
	LD	HL,PDCT		; ^parameters for drive P: --> reg. HL
	POP	DE		; DCT pointer		   --> reg. DE
	PUSH	DE		; Save DCT pointer again
	LD	BC,5		; Number of bytes	   --> reg. BC
	LDIR			; Load disk parameters of drive P:
	LD	HL,P$RET	; Return address	   --> reg. HL
	PUSH	HL		; Push it
	JP	(IX)		; Jump to driver
P$RET:	LD	HL,TDCT		; Restore original disk parameters
	POP	DE
	LD	BC,5
	LDIR
	LD	HL,PDCT+1	; Get drive status
	SET	0,(HL)		; Set init bit
	RET
TDCT:	DEFS	5		; Temporary storage area


;EJECT
;tables of pointers to error message strings
R$ERROR$TABLE:
	DEFW	R1MSG
	DEFW	R2MSG
	DEFW	R3MSG
	DEFW	R4MSG
	DEFW	R5MSG
	DEFW	R6MSG
	DEFW	R7MSG
	DEFW	R8MSG
	DEFW	R9MSG

W$ERROR$TABLE:
	DEFW	W1MSG
	DEFW	W2MSG
	DEFW	W3MSG
	DEFW	W4MSG
	DEFW	W5MSG
	DEFW	W6MSG
	DEFW	W7MSG
	DEFW	W8MSG
	DEFW	W9MSG

R1MSG:	DEFM	' Illegal drive #,'
	DEFB	0
R2MSG:	DEFM	' Track # too high,'
	DEFB	0
R3MSG:	DEFM	' Sector # too high,'
	DEFB	0
R4MSG:	DEFM	' Device not available,'
	DEFB	0
R5MSG:	DEFB	0
R6MSG:	DEFM	' Locked/deleted record,'
	DEFB	0
R7MSG:	DEFM	' Data record not found,'
	DEFB	0
R8MSG:	DEFM	' Parity error during read,'
	DEFB	0
R9MSG:	DEFM	' Lost data during read,'Љ	DEFB	0

W1MSG:	DEFM	' Illegal drive #,'
	DEFB	0
W2MSG:	DEFM	' Track # too high,'
	DEFB	0
W3MSG:	DEFM	' Sector # too high,'
	DEFB	0
W4MSG:	DEFM	' Device not available,'
	DEFB	0
W5MSG:	DEFM	' Write protected diskette,'
	DEFB	0
W6MSG:	DEFM	' Write fault on disk drive,'
	DEFB	0
W7MSG:	DEFM	' Data record not found,'
	DEFB	0
W8MSG:	DEFM	' Parity error during write,'
	DEFB	0
W9MSG:	DEFM	' Lost data during write,'
	DEFB	0

ERROR$MSG:
	DEFM	' Retry (Y/N) ? '
	DEFB	0

MSG$END:DEFB	SUB,ESC,'D',0

	END

ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;******************************************************************************
;*  D R V T B L  *  C P M S Y S 4 e  *  T h o m a s   H o l t e * 8 5 0 9 2 5 *
;******************************************************************************
;*									      *
;*  			     D R I V E   T A B L E			      *
;*                           =====================                            *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	GLOBAL @DTBL
        EXTERNAL MF0,MF1,DS0,RAM,PROF,DRIVEP


@DTBL:	DEFW MF0,MF1,DS0,0,0,0,0,0
	DEFW 0,0,0,0,RAM,0,PROF,DRIVEP
	DEFW RAM

	END
 found,'
	DEFB	0
W8MSG:	DEFM	' Parity error during write,'
	DEFB	0
W9MSG:	DEFM	' Lost data during write,'
	DEFB	0

ERROR$MSG:
	DEFM	' Retry (Y/N) ? '
	DEFB	0

MSG$END:DEFB	SUB,ESC,'D',0

	END

ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее!‚ о
 н°г	Н !"кою (>ѕ #ф*к 	~ю ("каQ	Н нSк	Н *к 	лю  к Н 2шН  	^#VнSм НWш! н[м НKш*к 	^#V* ХНKшб 	е НWшл*м 	 НKшб 	е НWшС*  OНKш*кј
 н°Є	Н  Н 
RFREMD.COMS stellt Laufwerk P auf fremde Formate um.
  Nur lauff{hig auf Genie IIIs mit Holte CP/M + !
$
Falschen Formatnamen angegeben  !!!!!!!!!!!!
Folgende Formatnamen sind erlaubt :

$
Das neue Format           ist jetzt f}r Laufwerk P g}ltig !
$                                                   S80 DSDD  $‡D80 DSDD  $СPROF#4    $ALPHA     $FIBM-PC    $ђKONTRON   $ЪRAIR      $VORTEX    $K P ї я А @  pЂ
P3 	
 !"#$%&'()*+,-./012P З я А @   pЂ
P3 	
 !"#$%&'()*+,-./012P   А    xЂP 	
P  Љ А    xА
P3 	
 !"#$%&'()*+,-./012  ќ ? Ђ   |Ђ(3 	
 !"#$%&'()*+,-./012   +я р @  x@ M 	
  † А   $ xЂP3 	
 !"#$%&'()*+,-./012H °  Ђ    xЂP3 	
 !"#$%&'()*+,-./012                                                                                                           rk P auf fremde Formate um.
  Nur lauff{hig auf Genie IIIs mit Holte CP/M + !
$
Falschen Formatnamen angegeben  !!!!!!!!!!!!
Folgende Formatnamen sind erlaubt :

$
Das neue Format           ist jetzt f}r Laufwerk P g}ltig !
$                     ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;*******************************************************************************
;*         								       *
;*                          F R E M D . C O M 				       *
;*									       *
;*									       *	
;*               Utility f}r Genie IIIs mit Holte CP/M Plus.		       *
;*									       *
;* 									       *
;*									       *
;*   Dieses File enth{lt die Beschreibungen f}r verschiedene Fremdformate      *
;*   die mit dem HOLTE-CP/M gelesen werden k|nnen. Die fremde Diskette	       *
;*   wird in Laufwerk P eingeloggt. Anders als beim KONFIG mu~ nicht neu       *
;*   gebootet werden, weil die zu {nderden Parameter im Speicher gepatcht      *
;*   werden. Das HOLTE-CP/M ben|tigt folgende Informationen, um fremde         *
;*   Formate lesen zu k|nnen:						       *
;*									       *
;*      1. Den DPB Diskettenparameterblock                                     *
;*      2. Die DTB Drive control table 					       *
;*      3. Die Sector translation table					       *
;*									       *
;*   Sie m}ssen vorerst von Hand erstellt werden.                              *
;* 									       *
;*******************************************************************************


bel	equ	  07h			;auf dem Bildschirm auszugebende
cr	equ	  0dh			;Zeichen
lf	equ	  0ah
esc	equ	  1bh

bdos	equ	0005h			;Adresse des BDOS-Calls

wboot	equ	  00h			;BDOS-Funktion Warmstart
prtstr	equ	  09h			;BDOS-Funktion String ausgeben
dirbios	equ	   50			;BDOS-Funktion direkter BIOS-Aufruf


xmove	equ    0f857h			;BIOS-Funktion Interbankmemorymove
move	equ    0f84bh			;BIOS-Funktion Speicherverschieben

xtail	equ	0082h			;Hier steht der eingegebene Name


	org	100h


start	ld	hl,xtail		;der eingegebene name mu~ erst
	ld	de,nambuff		;gesichert werden, da CP/M ihn 
	ld	bc,10			;sonst }berschreibt
	ldir
	ld	de,hallo		;DE zeigt auf Hallomeldung
	ld	c,prtstr		;BDOS-Call #9 gibt String aus bis	
	call	bdos			;Endekennung '$'
					;Jetzt muss der Name erkannt werden

	ld	hl,startlist		;HL zeigt auf Beginn der Namensliste
	ld	(buff),hl		;zwischenspeichern
loopy	ld	de,nambuff		;DE zeigt auf eingegeben Namen
loopx	ld	a,(de)			;Ist das Ende dieses Namens schon
	cp	00h			;erreicht ? Dann steht dort 00h
	jr	z,einstell		;Also wurde ein g}ltiger Name eingegeben
	cp	(hl)			;sonst mit Listeneintrag vergleichen
	jr	nz,dernicht		;bei falschem Buchstaben n{chsten Eintrag
	inc	hl			;war aber richtig, also Zeiger DE und
	inc	de			;HL ein byte weiterstellen
	jr	loopx			;und so weiter und so fort
dernicht
	ld	hl,(buff)		;der Zeiger wird wieder auf den Anfang
	ld	bc,13			;des Eintrages gestellt, dann wird 13
	add	hl,bc			;Zeichen weitergestellt, hier ist
	ld	a,(hl)			;entweder 00h als Endekennung oder
	cp	00			;der Beginn eines neuen Eintrages
	jr	z,falsename		;Wenn kein Name erkannt wurde, FEHLER
	ld	(buff),hl		;HL wieder zwischenspeichern
	jr	loopy
	


; FALSENAME
;	 :  ist ein falscher Name eingegeben worden, wird die Liste aller
;	    g}ltigen Namen ausgegeben.		

falsename				;Unterprogramm, falls falscher
					;Fremdformatname eingegeben wurde 
	ld	de,err1			;Fehlermeldungzeichenkette
	ld	c,prtstr		;BDOS-Call #9, String ausgeben
	call	bdos
	ld	de,startlist		;erstes Element in der Liste der
loop	ld	(buff),de		;zul{ssigen Namen, wird zwischen-
	ld	c,prtstr		;gespeichert um sp{ter incrementiert
	call	bdos			;zu werden. Alle Namen werden ausgegeben
	ld	hl,(buff)		;bis zur Endekennung '00'. Die Namen
	ld	bc,13			;sind 13 bytes weit entfernt.
	add	hl,bc			;HL zeigt jetzt auf n{chsten Namen
	ex	de,hl			;bzw. '00'. DE wird mit HL geladen
	ld	a,(de)			;wegen BDOS-Call #9
	cp	00
	jr	nz,loop			;Schleife bis letzter Name ausgegeben
	ld	c,wboot			;wurde, dann Warmstart, zur}ck
	call	bdos			;ins Betriebssystem


; EINSTELL  :  Hier wird der jeweilige Parameterblock dann ins RAM
;	       }bertragen.


einstell
	ld	c,dirbios		;Zuerst wird }ber ein BDOS-Call die
					;Adresse der DRIVETABLE geholt, hier
					;stehen die Adressen aller DPH's
	ld	de,biospb		;Zum BDOS-Call wird ein Parameterblock
	call	bdos			;}bergeben.HL+30 zeigt dann auf den 
	ld	bc,30			;XDPH von Laufwerk P. Der Inhalt von
	add	hl,bc			;HL wird nach DE kopiert, DE enth{lt 
	ld	e,(hl)			;dann die Adresse des XDPH's. Sie wird
	inc	hl			;in buff2 zwischengespeichert. 
	ld	d,(hl)			;
	ld	(buff2),de		;
	ld	bc,0100h		;Es soll ein Speicherladevorgang von
	call	xmove			;Bank 0 nach Bank 1 vorgenommen werden
	ld	hl,buf4			;buf4 ist die Zieladresse, kopiert wird
	ld	de,(buff2)		;der komplette XDPH, um Zugriff auf DPB
	ld	bc,dphend-buf4		;und Adresse der Skewtabelle zu haben
	call	move			;Speicherladeoperation ausf}hren

; jetzt wird zuerst der DPB ins Common }bertragen
	
	ld	hl,(buff)		;HL zeigt auf den Namen des gew{hlten
	ld	bc,11			;Formates, nach 11 Bytes kommt die
	add	hl,bc			;Adresse des dazugeh|rigen Parameter-
	ld	e,(hl)			;blockes, angefangen mit dem DPB
	inc	hl			;de zeigt auf den zu ladenden DPB
	ld	d,(hl)			;
	ld	hl,(dpb)		;HL zeigt auf den g}ltigen DPB im Common
	ld	bc,17			;So ein DPB ist 17 Bytes gro~
	push	de			;DE zeigt auf den Beginn des Parameter-
	call	move			;blockes und wird noch ben|tigt	
		
; jetzt wird die DCT des Formates }bertragen

	pop	hl			;Da ist wieder der Parameterblockanfang
	ld	bc,17			;Der DPB ist 17 Bytes lang, jetzt kommt
	add	hl,bc			;die Drive Control Table
	push	hl			;Diese Adresse wird wieder gespeichert
	ld	bc,0001			;von Bank 1 nach Bank 0
	call	xmove			;sollen die Daten verladen werden
	ex	de,hl			;DE ist Quelladresse			
	ld	hl,(buff2)		;adresse des XPDH in Bank 0
	ld	bc,25			;Nach dem XDPH von Drive P kommt sein
	add	hl,bc			;DCT, dort soll es hin gehen
	ld	bc,5			;5 bytes
	call	move			;und weg damit 
		
; und jetzt die Skewtabelle noch r}ber und fertig !!!!!!!!

	pop	hl			;jetzt wird die L{nge der zu kopierenden 
	ld	bc,5			;Skewtabelle ermittelt, sie kommt direkt
	add	hl,bc			;nach dem DCT
	push	hl			;zwischenspeichern
	ld	bc,0001			;Interbank move von Bank 1 zu Bank 0
	call	xmove

	pop	de			
	ld	a,(de)			;L{nge der Skewtabellle
	inc	de			;zeigt jetzt auf den Beginn der Skew-
	ld	hl,(buf4)		;tabelle, Die Adresse der Tabelle 
	ld	b,0			;steht als erstes word des XDPH's
	ld	c,a			;Die L{nge war im Accu gespeichert
 	call	move			;und r}ber damit, und schon fertig
	
	
		
; jetzt den Erfolg der Aktion melden	

	ld	hl,(buff)		;zeigt auf den Namen des gew{hlten
	ld	de,eintrag		;Formates, er wird in den Ausgabe-
	ld	bc,10			;string reinkopiert
	ldir
	ld	de,gutis		;zeigt auf die Meldung
	ld	c,prtstr		;BDOS-Call String ausgeben
	call	bdos			;ausf}hren
	ld	c,wboot			;und mit Warmstart zur}ck
	call	bdos		 	;ins Betriebssystem	

; Liste der auszugebenden Zeichenketten

hallo	db	cr,lf,esc,'R','FREMD.COM',esc,'S',' stellt Laufwerk P auf fremde Formate um.',cr,lf
	db	'  Nur lauff{hig auf Genie IIIs mit Holte CP/M + !',cr,lf,'$'
err1	db	cr,lf,bel,bel,'Falschen Formatnamen angegeben  !!!!!!!!!!!!',cr,lf
err2	db	'Folgende Formatnamen sind erlaubt :',cr,lf,lf,'$'
gutis	db	cr,lf,'Das neue Format '
eintrag	ds	10	
	db	'ist jetzt f}r Laufwerk P g}ltig !',cr,lf,'$'



; Zwischenbuffer f}r Registerpaar DE oder HL
buff	dw	0000h
buff2	dw	0000h			;enth{lt die Adresse des XDPH von LW P
nambuff	ds	10			;hier wird der gew{hlte Name vor dem
					;]berschreiben dutch das CP/M gesichert


	
biospb					;Der BIOS PARAMETER BLOCK mu~ angegeben
fnum	db	22			;werden, wenn }ber BDOS-Call 50 ein
ainh	db	00			;direkter BIOS-Aufruf stattfinden soll
bcinh	dw	0000h			;Hier werden zu }bergebende Parameter
deinh	dw	0000h			;abgelegt.
hlinh	dw	0000h			;Die Funktionsnummer fnum=22 heisst	
					;halt hole ^DRVTBL
buf4	dw	0000			;Puffer f}r den XDPH von Laufwerk P
	dw	0,0,0,0
	db	0,0
dpb	dw	0000
	dw	0000,0000
	dw	0000,0000
	dw	0000
	db	0
dct	db	0
	db	0
	db	0
	db	0
	db	0
dphend					;Ende diese Puffers



; Liste der m|glichen Fremdformate
; Die L{nge der Zeichenkette ist auf 10 beschr{nkt.
	   
startlist

	db	'S80 DSDD  ','$'
	dw	s80dsdd
	db	'D80 DSDD  ','$'
	dw	d80dsdd
	db	'PROF#4    ','$'
	dw	prof4
	db	'ALPHA     ','$'
	dw	alpha
	db	'IBM-PC    ','$' 
	dw	ibmpc
	db	'KONTRON   ','$'
	dw	kontron
	db	'RAIR      ','$'
	dw	rair
	db	'VORTEX    ','$'
	dw	vortex
	db	00	
	
endlist

s80dsdd	dw	0050h		; SPT : 128 byte records / track
	db	  05h		; BSH : block shift
	db	  1fh		; BSM : block mask
	db	  03h		; EXM : extend mask
	dw	00bfh		; DSM : maximum block number
	dw	00ffh		; DRM : maximum directory entry number
	db	 0c0h		; AL0 : allocation vector 0
	db	  00h		; AL1 : allocation vector 1
	dw	0040h		; CKS : checksum size
	dw	  03h		; OFF : offset for system tracks
	db	  03h		; PSH : physical sector size shift
	db	  07h		; PHM : physical sector size mask
	
	db	  70h		; Byte 1 der drive control table
	db	  80h
	db	  02		; interleavingfaktor
	db	  10		; sector count / track
	db	  80		; number of usable tracks
	
	db	  51		; l{nge der Skewtabelle
				; Skewtabelle

	db	  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
	db	  20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36
	db	  37,38,39,40,41,42,43,44,45,46,47,48,49,50
	
	
	
d80dsdd	dw	0050h		; SPT : 128 byte records / track
	db	  05h		; BSH : block shift
	db	  1fh		; BSM : block mask
	db	  03h		; EXM : extend mask
	dw	00c7h		; DSM : maximum block number
	dw	00ffh		; DRM : maximum directory entry number
	db	 0c0h		; AL0 : allocation vector 0
	db	  00h		; AL1 : allocation vector 1
	dw	0040h		; CKS : checksum size
	dw	  00h		; OFF : offset for system tracks
	db	  03h		; PSH : physical sector size shift
	db	  07h		; PHM : physical sector size mask
	
	db	  70h		; Byte 1 der drive control table
	db	  80h
	db	  02		; interleavingfaktor
	db	  10		; sector count / track
	db	  80		; number of usable tracks
	
	db	  51		; l{nge der Skewtabelle
				; Skewtabelle

	db	  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
	db	  20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36
	db	  37,38,39,40,41,42,43,44,45,46,47,48,49,50
	

prof4	dw	0050h		; SPT : 128 byte records / track
	db	  04h		; BSH : block shift
	db	  0fh		; BSM : block mask
	db	  00h		; EXM : extend mask
	dw	017fh		; DSM : maximum block number
	dw	007fh		; DRM : maximum directory entry number
	db	 0c0h		; AL0 : allocation vector 0
	db	  00h		; AL1 : allocation vector 1
	dw	0020h		; CKS : checksum size
	dw	  03h		; OFF : offset for system tracks
	db	  02h		; PSH : physical sector size shift
	db	  03h		; PHM : physical sector size mask
	
	db	  78h		; Byte 1 der drive control table
	db	  80h
	db	  02		; interleavingfaktor
	db	  20		; sector count / track
	db	  80		; number of usable tracks
	
	db	  20		; l{nge der Skewtabelle
				; Skewtabelle

	db	  0,2,4,6,8,1,3,5,7,9,10,12,14,16,18,11,13,15,17,19		


alpha 	dw	0050h		; SPT : 128 byte records / track
	db	  04h		; BSH : block shift
	db	  0fh		; BSM : block mask
	db	  00h		; EXM : extend mask
	dw	018ah		; DSM : maximum block number
	dw	007fh		; DRM : maximum directory entry number
	db	 0c0h		; AL0 : allocation vector 0
	db	  00h		; AL1 : allocation vector 1
	dw	0020h		; CKS : checksum size
	dw	  01h		; OFF : offset for system tracks
	db	  03h		; PSH : physical sector size shift
	db	  07h		; PHM : physical sector size mask
	
	db	  78h		; Byte 1 der drive control table
	db	 0c0h
	db	  01		; interleavingfaktor
	db	  10		; sector count / track
	db	  80		; number of usable tracks
	
	db	  51		; l{nge der Skewtabelle
				; Skewtabelle

	db	  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
	db	  20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36
	db	  37,38,39,40,41,42,43,44,45,46,47,48,49,50
	


ibmpc	dw	0020h		; SPT : 128 byte records / track
	db	  04h		; BSH : block shift
	db	  0fh		; BSM : block mask
	db	  01h		; EXM : extend mask
	dw	009dh		; DSM : maximum block number
	dw	003fh		; DRM : maximum directory entry number
	db	  80h		; AL0 : allocation vector 0
	db	  00h		; AL1 : allocation vector 1
	dw	0010h		; CKS : checksum size
	dw	  01h		; OFF : offset for system tracks
	db	  02h		; PSH : physical sector size shift
	db	  03h		; PHM : physical sector size mask
	
	db	  7ch		; Byte 1 der drive control table
	db	  80h
	db	    1		; interleavingfaktor
	db	   18		; sector count / track
	db	   40		; number of usable tracks
	
	db	  51		; l{nge der Skewtabelle
				; Skewtabelle

	db	  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
	db	  20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36
	db	  37,38,39,40,41,42,43,44,45,46,47,48,49,50
	


kontron	dw	0020h		; SPT : 128 byte records / track
	db	  04h		; BSH : block shift
	db	  0fh		; BSM : block mask
	db	  00h		; EXM : extend mask
	dw	012bh		; DSM : maximum block number
	dw	00ffh		; DRM : maximum directory entry number
	db	 0f0h		; AL0 : allocation vector 0
	db	  00h		; AL1 : allocation vector 1
	dw	0040h		; CKS : checksum size
	dw	  04h		; OFF : offset for system tracks
	db	  01h		; PSH : physical sector size shift
	db	  01h		; PHM : physical sector size mask
	
	db	  78h		; Byte 1 der drive control table
	db	  40h
	db	    1		; interleavingfaktor
	db	   32		; sector count / track
	db	   77		; number of usable tracks
	
	db	   16		; l{nge der Skewtabelle
				; Skewtabelle

	db	  0,3,6,9,12,15,2,5,8,11,14,1,4,7,10,13


rair	dw	0004h		; SPT : 128 byte records / track
	db	  04h		; BSH : block shift
	db	  0fh		; BSM : block mask
	db	  00h		; EXM : extend mask
	dw	0186h		; DSM : maximum block number
	dw	007fh		; DRM : maximum directory entry number
	db	 0c0h		; AL0 : allocation vector 0
	db	  00h		; AL1 : allocation vector 1
	dw	0020h		; CKS : checksum size
	dw	  24h		; OFF : offset for system tracks
	db	  02h		; PSH : physical sector size shift
	db	  03h		; PHM : physical sector size mask
	
	db	  78h		; Byte 1 der drive control table
	db	  80h
	db	    2		; interleavingfaktor
	db	   20		; sector count / track
	db	   80		; number of usable tracks
	
	db	  51		; l{nge der Skewtabelle
				; Skewtabelle

	db	  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
	db	  20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36
	db	  37,38,39,40,41,42,43,44,45,46,47,48,49,50
	



vortex	dw	0048h		; SPT : 128 byte records / track
	db	  05h		; BSH : block shift
	db	  1fh		; BSM : block mask
	db	  03h		; EXM : extend mask
	dw	00b0h		; DSM : maximum block number
	dw	007fh		; DRM : maximum directory entry number
	db	 080h		; AL0 : allocation vector 0
	db	  00h		; AL1 : allocation vector 1
	dw	0020h		; CKS : checksum size
	dw	  01h		; OFF : offset for system tracks
	db	  02h		; PSH : physical sector size shift
	db	  03h		; PHM : physical sector size mask
	
	db	  78h		; Byte 1 der drive control table
	db	  80h
	db	  01		; interleavingfaktor
	db	  18		; sector count / track
	db	  80		; number of usable tracks
	
	db	  51		; l{nge der Skewtabelle
				; Skewtabelle

	db	  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19
	db	  20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36
	db	  37,38,39,40,41,42,43,44,45,46,47,48,49,50
	





	end	start
	
		 	ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее	title	'hard-disk handler'

;************************************************
;*	H D  2 . M A C	Version : 3.2		*
;*	Created	:	19-oct-87		*
;*	by	:	Peter Petersen		*
;*	Rev	:	22-oct-87..17-aug-89	*
;*	weiter dran geschnitzt:			*
;*	...08.07.90	H. Bernhardt		*
;*      November 92     V.Dose                  *
;*            pderr ge{ndert f}r Genie IIIs     *
;*            angepasst an Harddisk 10 MByte    *
;*                                              *
;************************************************

; CP/M-80 Version 3     ---  Modular BIOS  ---

; Harddisk I/O routines for standardized BIOS interface
; DPH und DPB in DTBL.ASM

true	equ	-1
false	equ	 0
bel     equ    07h
sub     equ    1AH
esc     equ    1BH

   
	public	hdwrit,hdread,hdlogi,hdinit,hd1ini

; Variables containing parameters passed by BDOS

	external	@adrv,@rdrv,@dbnk,@dma,@trk,@sect
	external	@cbnk,@erdme,?pderr
	external        ?bank	        	;log. Bank (in A) einschalten

; Utility routines in standard BIOS

	external	?pmsg		; print message @<HL> up to 0,
	            			; saves <BC> & <DE>
        external        ?conin,?cono    ; console input and output
        external        ?const          ; get console status

; definition of hd-controller port-addresses and control-data

hdport	equ	040h		; hd-controller base address

hdstat	equ	hdport+1	; hard disk status port
hdres	equ	hdport+1	; hard disk reset function
hdsel	equ	hdport+2	; hard disk select function
hdconf	equ	hdport+2	; hard disk configuration port
hdmask	equ	hdport+3	; hard disk DMA- and Interrupt-mask

        .z80
	cseg			; residente Ruinen zum
  				; Verholen von/zu Banks
hdrd:	ld	hl,(@dma)	; set buffer address
	ld	a,(@dbnk)
	call	?bank
	ld	bc,hdport	; get hd port address
	inir			; 512 Beitz reinziehen
	inirЉ	jr	termcmd1	; if yes quit loop

hdwr:	ld	hl,(@dma)	; set buffer address
	ld	a,(@dbnk)
	call	?bank
	ld	c,hdport	; get hd port address
	outi			; get first data byte
hdwrlp:	in	a,(hdstat)	; get hdc status
	cp	0cfh		; test if transfer is terminated
	jr	z,termcmd1	; if yes quit loop
	cp	0c9h		; data requested  ?
	jr	nz,hdwrlp	; loop if not
wr_dat:	outi			; write data
	jr	hdwrlp		; and loop

termcmd1:			; aus dem Common heraus noch
	xor	a		; schnell Bank 0 einschalten
	call	?bank
	jp	termcmd		; und den Job abschliessen

	dseg

; harddisk READ and WRITE entry points.
; these entries are called with the following arguments :
;	 relative drive number	in @rdrv	 (8 bits)
;	 absolute drive number	in @adrv	 (8 bits)
;	 disk transfer address	in @dma		(16 bits)
;	 disk transfer bank	in @dbnk	 (8 bits)
;	 disk track address	in @trk		(16 bits)
;	 disk sector address	in @sect	(16 bits)
;	 pointer to XDPH	in <DE>
; they transfer the appropriate data, perform retries
; if necessary, then return an error code in <A>

hdread:	ld	hl,readmsg	; point at ' Read '
	call	hdrw_common	; prepare command descriptor
	di			; disable interrupts
	ld	bc,0508h	; get length and command
	call	hdscmd		; send command
rd1:	in	a,(hdstat)	; get hdc status
	cp	0cfh		; test if status is to send
	jp	z,termcmd	; skip if yes
	cp	0cbh		; test transfer direction
	jr	nz,rd1		; loop until o. k.
	jp	hdrd		; sektor holen

hdwrit:	ld	hl,writemsg	; point to ' Write '
	call	hdrw_common
	di			; disable interrupts
	ld	bc,050ah	; get length and command
	call	hdscmd		; send command
wr1:	in	a,(hdstat)	; get hdc status
	cp	0cfh		; test if status is to send
	jr	z,termcmd	; skip if yes
	cp	0c9h		; test transfer direction
	jr	nz,wr1		; loop until o. k.
	jp	hdwr		; sektkorken wegdruecken

termcmd:
	ei			; test termination of command
	ld	b,0		; set retry count to 256Љtr1:	in	a,(hdstat)	; get hdc status
	cp	0cfh		; ready to read status  ?
	jr	z,tr2		; skip if o. k.
	djnz	tr1		; else retry b times
	ld	hl,hdmsg2	; print error mesage
	jr	tr3

tr2:	in	a,(hdport)	; get command status
	and	2		; to test completion
	ret	z

	ld	hl,hdmsg1	; else print terminate error
tr3:	out	(hdres),a	; reset hdc
	call	dskerr		; print bios error message
	ld	a,1
	ret

hdinit:	out	(hdres),a	; reset hard-disk controller
get_st:	in	a,(hdstat)	; get status
	cp	0c0h		; test if hdc is idle
	jr	nz,get_st	; else loop until hdc is idle

setmsk:	xor	a		; clear accu and send mask to disable
	out	(hdmask),a	; interrupt and dma from hard-disk

w0:	in	a,(hdstat)	; get status
	cp	0c0h		; and wait until hdc is idle
	jr	nz,w0

;	init hd controller with hd-drive-characteristics

trpara:	ld	hl,ifield	; point to init-parameter field
	ld	bc,050ch	; get command to set hd characteristics
	call	hdscmd		; send command
	ld	hl,hd_charact	; point to table of hd characteristics
	ld	c,hdport	; get hd port
	ld	b,8		; get length of table
tr_p1:	in	a,(hdstat)	; get hdc status
	cp	0c9h		; request for data --> hdc  ?
	jr	nz,tr_p1	; loop until hdc requests for data
	jr	nx1		; else send data from data table

nxtbyt:	call	wcr		; wait for controller ready
nx1:	ld	a,(hl)		; get byte from table
	out	(c),a		; send byte to hd controller
	inc	hl		; increment pointer
	djnz	nxtbyt		; loop until done

;	test if command successfully completed

rdy1:	in	a,(hdstat)	; get hdc status
	cp	0cfh		; test if status is to be send
	jr	nz,rdy1		; loop until o. k.
	in	a,(hdport)	; get command status state
	bit	2,a		; test if correctly terminated
	jr	z,pri_ok	; skip if o. k.
	out	(hdres),a	; reset controller
	ld	hl,hdmsg1	; else print hd-init-error
	jp	print		; and return

pri_ok:	ld	hl,iniok	; print init o. k.Љ	jp	print


;	prepare command descriptor block setting cylinder,
;	sector and head addresses
;
;  Byte  |  D7  | D6  | D5  | D4  | D3  | D2  | D1  | D0  |
;----------------------------------------------------------
;   0    |  Command-Class   |       Operation-Code        |
;   1    | cyl10   0    LUN |         Head Number         |   head
;   2    | cyl9  cyl8 |         Sector Number             |   sect
;   3    |      Cylinder Number, Low Byte (cyl7-0)        |   cylind
;   4    |     Interleave or Block Count (always 1)       |   bcount
;   5    |          Control Byte  (always 2)              |   termin
;


hdrw_common:
	ld	(hdc_rw),hl	; save name of operation
	ld	bc,(@trk)	; get track #
	ld	a,c		; get lsb of track #
	ld	(cylind),a	; set lsb of track #
	ld	c,0
	rr	b		; move high byte of track #
	rr	c		; into bits 7 and 6 of C
	rr	b
	rr	c
	ld	b,0		; head count
	ld	a,(@sect)	; sector # (only low byte significant)
fdhead:	cp	17		; find head #
	jr	c,hds0		; if head 0
	sub	17		; else convert to sector # and head #
	inc	b		; next head, if more than 26 secs
	jr	fdhead
hds0:	or	c
	ld	(sect),a	; set sector and track msb
	ld	a,b		; head #
	ld	(head),a
	ret
	
; suppress error message if BDOS is returning errors to application...

dskerr:
	ld	a,(@erdme) 
	cp	0ffh 
	jr	nz,pr_err
	pop	af		; correct stack
harderror:
	ld	a,1		; get hard-error code
	ei			; enable interrupts
	ret			; and return to bdos

; Had permanent error, print message like :
; BIOS Err on d: T-nn, S-mm, <operation> <type>, Retry ?

pr_err:	call	?pderr		; print message header
        ld      hl,(hdc_rw)     ; READ oder WRITE
        call    ?pmsg  
        call    frageab         ; Eingabe holen
        ld      hl,msgend       ; Statuszeile aus
print:  call    ?pmsg  Љhdlogi:	ret			; dummy vector, hard-disk login

; get console input, echo it and shift to uppercase

frageab:  call ?const
          or   a
          jr   z,istda
          call ?conin
          jr   frageab
istda:    call ?conin
          push af
          ld   c,a
          call ?cono
          pop  af
          cp   'A'
          ret  c
          and  0dfh
          ret
     


; hard disk subroutines

; wait controller ready
wcr:	push	bc		; save bc
	ld	b,0		; set retry count to 256
wcr1:	in	a,(hdstat)	; get hd controller status
	bit	0,a		; test for data request
	jr	nz,wcr2		; quit if request
	djnz	wcr1		; else wait for request
wcr2:	pop	bc		; restore bc
	ret

;hd send command	hl -->	parameterlist
;			b  -->	count
;			c  -->	command
hdscmd:	in	a,(hdstat)	; get hdc status
	cp	0c0h		; to test if hdc is idle
	jr	z,hdc_id	; skip if o. k.
	out	(hdres),a	; else reset hdc
	jr	hdscmd		; and try again
hdc_id:	out	(hdsel),a	; select hd controller
	ld	hl,cfield	; set pointer to command field
	call	wcr		; wait for controller ready
	ld	a,c		; get command
	out	(hdport),a	; to send it
nxtpar:	call	wcr		; wait for controller ready
	ld	a,(hl)		; fetch next parameter
	out	(hdport),a	; to send it
	inc	hl		; increment parameter pointer
	djnz	nxtpar		; and loop until done
hd1ini:	ret

;  hard disk data area
cfield:				; hdc command field
head:	db	0		; selected head, lun and c10
sect:	db	0		; sector #, c8 and c9
cylind:	db	0		; cylinder #  < modulo 256 >
bcount:	db	1		; block count
termin:	db	2		; step rate --> 25 us
Љhd_charact:			; drive characteristics
				; 612 cylinders, 2 heads 
	db	2		; last cylinder  (msb)
	db	99		; last cylinder  (lsb)
	db	2		; 2 heads
	db	0,0		; start cyl reduced wr current
	db	0,0		; start cyl wr precomp
	db	0		; always zero

ifield:	db	0,0,0,0,0	; hard disk init-parameter field

;	error message components
hdc_rw:		dw	readmsg
readmsg:	db	', Read ',0
writemsg:	db	', Write ',0
hdmsg1:		db	7
		db	'Hard Disk Error'
		db	0
hdmsg2:		db	7
		db	'Command Terminate Error'
		db	0
iniok:		db	'Harddisk innischelleist'
		db	13,10,0		
msgend:         db      sub,esc,'D',0
       



	end
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее
hd_charact:			; drive characteristics
				; 612 cylinders, 2 heads 
	db	2		; last cylinder  (msb)
	db	99		; last cylinder  (lsb)
	db	2		; 2 heads
	db	0,0		; start cyl reduced wr current
	db	0,0		; start cyl wr precomp
	db	0		; always zero

ifield:	db	0,0,0,0,0	; hard disk init-parameter field
	99		; last cylinder  (lsb)
	db	2		; 2 heads
	db	0,0		; start cyl reduced wr current
	db	0,0		; start cyl wr precomp
	db	0		ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;Um den richtigen DPB in DISKIO1.MAC einzubauen,mu~ er zun{chst
;mit XCPM3.LIB errechnet werden. Dies besorgt RMAC.
;
;  RMAC hddtbl $pz sz
;
;
 
     title 'DPH f}r Harddisk 10 MByte'


	maclib	xcpm3


hdsk0	dph	0,hddph0



hddph0	hdpb	512,34,611,4096,2048,2,8000h


	end
	
	end
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;	HDNDF/SRC
;	02.11.92
;
;	Dieses Programm formattiert die Festplatte
;	Eingestellt f}r 2 K|pfe, 10 Mb - Harddisk
;	daten von mir ge{ndert am 17.02.92
;	ske-faktor		=>  03h
;	write-comp. ab		=>  0080h
;	reduced current ab	=>  0080h
;	anzahl zylind.		=>  612d(0264h)
;
;       auf CP/M umgeschrieben von mir
;       soll mit 'E5h' formatiert werden.


    
;PROGRAMM ZUR BEHANDLUNG DER HARD-DISK
hddata	EQU	0040H
hdstat	EQU	0041H		;STATUSREGISTER DES CRT'S
hdres	EQU	0041H		;RESETFUNKTION  DES CRT'S
hdsel	EQU	0042H		;SELECTIERT CONTROLLER
hdconf	EQU	0042H		;CONFIGURATION DER HARDDISK
hdmask	EQU	0043H		;DMA MASKE DES CONTROLLERS
hdisk	EQU	00FAH		;CONFIGURATION DER HARDDISK
rtcnt	EQU	0020D		;VERSUCHE VON DISK ZU BOOTEN

	ORG	100h
start	CALL	char
	LD	A,0e5h		;F}llbyte f}r die Sektoren
	CALL	fill		;Sektorpuffer der HD mit E5 f}llen
	JP	form		;Platte formattieren und zur}ck
	
;UP WARTET BIS CONTROLLER FERTIG IST
wcr	IN	A,(hdstat)	;STATUS LESEN
	BIT	0,A		;KONTROLLER BEREIT ?
	JR	Z,wcr		;NEIN DANN SPRUNG
	RET

;UP COMMANDO AN KONTROLLER PARAMETER: (HL); ANZAHL:B;COMANNDO:C
hdscmd	OUT	(hdsel),A	;CONTROLLER SELECTIEREN
	CALL	wcr		;CONTROLLER FERTIG ?
	LD	A,C		;COMANNDO IN ACCU
	OUT	(hddata),A	;UND AN CONTROLLER
	LD	C,40h
nxbhd	CALL	wcr
	OUTI			;)		;NAECHSTER PARAMETER
	JR	NZ,nxbhd
	RET

;UP TESTET OB FEHLER VORHANDEN AUSGABE:A=0 KEIN FEHLER
err	CALL	wcr
	IN	A,(hddata)	;SATUS EINLESEN
	BIT	1,A		;DATENRICHTUNG
	JR	Z,aus		;FALSCHE DATENRICHTUNG
	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	HL,errda	;COMMANDO FUER STATUSABFRAGE
	LD	BC,0503H	;5 DATEN KOMMANDO 03
	CALL	hdscmd		;KOMANNDO AN CONTROLLER
	CALL	wcr
	LD	C,hddata	;Datenport
	IN	A,(C)		;Fehlercode lesen
	CALL	wcr
	IN	B,(C)
	CALL	wcr
	IN	B,(C)
	CALL	wcr
	IN	B,(C)
	POP	BC
	POP	DE
	POP	HL
	RET
aus	XOR	A
	RET

;UP CHARAKTERISTIK DES LAUFWERKS UEBERMITTELN
char	XOR	A
	OUT	(hdres),A	;DISK-RESET
	OUT	(hdmask),A	;DMA SPERREN
	PUSH	HL
	PUSH	DE
	PUSH	BC
	LD	HL,charda	;KOMMANDO SET CHAR.
	LD	BC,050CH	;5 DATEN KOMANNDO 0CH
	CALL	hdscmd		;KOMANNDO AN HARDDISK
	LD	B,8		;ANZAHL DER DATEN
	LD	HL,hdchar	;LAUFWERKPARAMETER@
	LD	C,40h
loop	CALL	wcr
	OUTI
	JR	NZ,loop
	CALL	err		;FEHLER?
	POP	BC
	POP	DE
	POP	HL
	RET

;UP SECTORBUFFER MIT DATEN (IN A) FUELLEN
fill	PUSH	HL
	PUSH	BC
	PUSH	AF
	LD	HL,fillda
	LD	BC,050FH
	CALL	hdscmd
	POP	AF
	LD	HL,200h
	LD	B,A
	LD	C,hddata
LOOP5	CALL	wcr
	OUT	(C),B
	DEC	HL
	LD	A,L
	OR	H
	JR	NZ,LOOP5
	POP	BC
	POP	HL
	CALL	err
	RET

;UP HARDDISK FORMATIEREN
form	PUSH	HL
	PUSH	DE
	PUSH	BC
	PUSH	AF
	LD	HL,formda
	LD	BC,0504H
	CALL	hdscmd
	CALL	err
	POP	AF
	POP	BC
	POP	DE
	POP	HL
	RET

;DATEN FUER DIE KOMMANDOS
errda	DEFB	00	;ADRESSE (KOPF)
	DEFB	00	;SECTOR
	DEFB	00	;TRACK
	DEFB	01	;BCOUNT
	DEFB	02	;TERMIN
charda	DEFB	00
	DEFB	00
	DEFB	00
	DEFB	00
	DEFB	00
writda	DEFB	00
sect	DEFB	00
cylind	DEFB	00
	DEFB	01
	DEFB	02
readda	DEFB	00
	DEFB	00
	DEFB	00
	DEFB	01
	DEFB	02
fillda	DEFB	00
	DEFB	00
	DEFB	00
	DEFB	00
	DEFB	00
formda	DEFB	00
	DEFB	00
	DEFB	00
skew	DEFB	02	;SKEWFAKTOR
	DEFB	0C2H
hdchar	DEFB	02	;LETZTER ZYLINDER
	DEFB	63h
	DEFB	02	;ANZAHL DER KOEPFE
	DEFB	00	;ERSTER ZYLINDER FUER REDUCED CURRENT
	DEFB	80
	DEFB	00	;ERSTER TRACK FUER PRECOMPENSATION
	DEFB	80h
	DEFB	00
hderr1	CALL	char
	POP	DE
	POP	BC
	POP	HL
	LD	A,1
	RET
hderr2	CALL	char
	POP	DE
	POP	BC
	POP	HL
	LD	A,2
	RET
	END 	start
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;Testprogramm um die HARDDISK anzusprechen. Hiermit sollen einige
;Grundfunktionen, wie ]bermitteln der HD-Spezifikationen, eine
;bestimmte Spur anfahren zun{chst jedenfalls, getestet werden.


hddata   equ    0040h             ;Datenport des Controllers    IN/OUT
hdstat   equ    0041h             ;Statusregister               IN 
hdres    equ    0041h             ;Reset des HDC                OUT
hdsel    equ    0042h             ;selektiert den HDC           OUT
hdconf   equ    0042h             ;Jumper auf HDC               IN
hdmask   equ    0043h             ;DMA Maske des HDC            OUT
bdos     equ    0005h
 
         org    100h

;Zun{chst einige Unterroutinen
;HDSCMD : Kommando an HDC, HL : Daten, B : Anzahl, C : Befehl

begin    jp     start
  
;hdc_id   in     a,(hdstat)        ;get HDC Status
;         cp     0c0h              ;to test if HDC is idle
;         jr     hdc_id          ;skip if O.K.
;         out    (hdres),a         ;else reset HDC
;         jr     hdscmd            ;and try again  

;hdscmd   out    (hdsel),a         ;Controller selektiern
;         call   wcr               ;wait for controller ready
;         ld     a,c               ;get command
;         out    (hddata),a        ;to send it
;nxtpar   call   wcr               ;wait for contoller ready
;         ld     a,(hl)            ;fetch next parameter
;         out    (hddata),a        ;to send it
;         inc    hl                ;increment parameter pointer
;         djnz   nxtpar            ;and loop until done
;hd1ini   ret
hdscmd   out    (hdsel),a
         nop
         call   wcr
         call   wcr
         ld     a,c
         out    (hddata),a
         nop
nxtbyt   call   wcr
         call   wcr
         ld     a,(hl)
         out    (hddata),a
         inc    hl
         djnz   nxtbyt
         ret
                          
           
         
;WCR  Warten bis Controller fertig
wcr      push   bc                ;save BC     
         ld     b,0               ;set retry counter to 256
wcr1     in     a,(hdstat)        ;Statusbyte in Accu
         bit    0,a               ;Kontroller bereit ?
         jr     nz,wcr2           ;falls nicht, weiter warten
         djnz   wcr1              ;wait for request
wcr2     pop    bc                ;restore BC
         ret                      ;sonst zur}ck
         
;Platz f}r die Daten, die zum Controller geschickt werden
head     db     00h               ;Kopfnummer
sector   db     00h               ;Sector und MSB der Tracknummer
track    db     00h               ;LSB der Tracknummer
         db     01h               ;Bcount, immer 1
         db     02h               ;Termin, immer 2
         
;CHAR  Laufwerkscharacteristik }bermitteln
char     xor    a                 ;Accu l|schen
         out    (hdres),a         ;Reset des HDC
         out    (hdmask),a        ;DMA sperren
         push   hl
         push   de
         push   bc
         ld     hl,chaerr
         ld     bc,050ch          ;5 Daten,Befehl 0Ch
         call   hdscmd            ;auf den HDC geben
         ld     b,8               ;8 Bytes
         ld     hl,hdchar         ;Laufwerkscharacteristik
         ld     c,40h             ;Port 40 (hddata)
chloop   call   wcr
         call   wcr               ;Warten auf HDC
         outi                     ;OUT 40,(B) dann DEC B und INC HL
         jr     nz,chloop
         call   err
         pop    bc
         pop    de
         pop    hl
         ret
         
;Laufwerksparameter  MiniScribe 10MByte
hdchar   db     02h               ;Letzter Cylinder MSB
         db     62h               ;Letzter Cylinder LSB
         db     02h               ;Anzahl der K|pfe
         dw     0080h             ;Erster Cylinder Reduced Current
         dw     0080h             ;Ertzer Cylinder Write Precompensation
chaerr   db     00h
         db     00h
forma    db     00h
         db     00h
         db     00h
ske      db     00h
         db     0c2h
         
; ERR  Fehlerpr}fung
err      call   wcr               ;ist der Controller bereit?
         call   wcr
         in     a,(hddata)        ;Statusbyte einlesen
         bit    1,a               ;Fehlerbit testen
         ret    z                 ;falls kein Fehler
         ld     hl,chaerr         ;Kommando Statusabfrage
         ld     bc,0503h          ;5 Daten, Befehl 03
         call   hdscmd            ;Kommando abschicken
         call   wcr
         call   wcr               ;auf HDC warten
         ld     c,(hddata)        ;Datenport des Controllers
         in     a,(c)             ;Fehlernummer lesen
         call   wcr
         call   wcr
         in     b,(c)             ;Dummy, es m}ssen aber 4 Bytes
         call   wcr               ;gelesen werden
         call   wcr
         in     b,(c)
         call   wcr
         call   wcr
         in     b,(c)
         ret

;RECA  Datenblock um Track 0 anzufahren
reca     db     00h
         db     00h
         db     00h
         db     00h
         db     02h
         
           
start    call   char              ;zun{chst wird einfach die Laufwerks-
                                  ;characteristik }bermittelt und
                                  ;zur}ck gesprungen.
                                  ;Das m}~te ohne Absturz m|glich sein
         jr     tr30
         
         
         ld     hl,reca           ;Recalibrate Daten
         ld     bc,0501h          ;5 Bytes, Commando 01
         call   hdscmd
         
tr30     ld     a,30h             ;track Nr 30
         ld     (track),a
         ld     hl,head           ;zeigt auf die Daten
         ld     bc,050bh          ;5 Bytes, Befehl 0bh (Spur anfahren)
         call   hdscmd
         
         call   err
         
         ret
           
tr70     ld     a,70h             ;track Nr. 70
         ld     (track),a
         ld     hl,head
         ld     bc,050bh
         call   hdscmd
         
         ret
         
          
         end   start
         
         
                                                         ;characteristik }bermittelt und
                                  ;zur}ck gesprungen.
                                  ;Das m}~te ohne Absturz m|glich sein
         jr     tr30
         
         
         ld     hl,reca           ;Recalibrate Daten
         ld     bc,0501h          ;5 Bytes, Commando 01
         call   hdscmd
         
tr30     ld ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееHOLTE-CP/M + 8 
    =%+ %+   R S   W V           Ћ Ќ Њ ‹ Ѓ Ђ  — † … ‚ ѓ „                                      ld     bc,050bh          ;5 Bytes, Befehl 0bh (Spur anfahren)
         call   hdscmd
         
         call   err
         
         ret
           
tr70     ld     a,70h             ;track Nr. 70
         ld     (track),a
         ld     hl,head
         ld     bc,050bh
         call   hdscmd
         
         ret
         
          
         end   start
      ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;
; Z3TCAP file:  Z3TCAP.Z80
;
ESC	EQU	27		; Escape character
;
; The first character in the terminal name must not be a space.  For
; Z3TCAP.TCP library purposes only, the name terminates with a space
; and must be unique in the first eight characters.
;
TNAME:	DB	'HOLTE-CP/M + '	; Name of terminal (13 chars)
;
GOFF:	DB	GOELD-TNAME	; Graphics offset from Z3TCAP start
;
; Terminal configuration bytes B14 and B15 are defined and bits assigned
; as follows.  The remaining bits are not currently assigned.  Set these
; bits according to your terminal configuration.
;
;	B14 b7: Z3TCAP Type.... 0 = Standard TCAP  1 = Extended TCAP
;
;	bit:	76543210
B14:	DB	00000000B	; Configuration byte B14
;
;	B15 b0: Standout....... 0 = Half-Intensity 1 = Reverse Video
;	B15 b1: Power Up Delay. 0 = None           1 = Ten-second delay
;	B15 b2: No Auto Wrap... 0 = Auto Wrap      1 = No Auto Wrap
;	B15 b3: No Auto Scroll. 0 = Auto Scroll    1 = No Auto Scroll
;	B15 b4: ANSI........... 0 = ASCII          1 = ANSI
;
;	bit:	76543210
B15:	DB	00000001B	; Configuration byte B15
;
; Single character arrow keys or WordStar diamond
;
	DB	'K'-40H		; Cursor up
	DB	'J'-40H		; Cursor down
	DB	'L'-40H		; Cursor right
	DB	'H'-40H		; Cursor left
;
; Delays (in ms) after sending terminal control strings
;
	DB	0		; CL delay
	DB	0		; CM delay
	DB	0		; CE delay
;
; Strings start here
;
CL:	DB	'Z'-40H,0       ; Home cursor and clear screen
CM:	DB	ESC,'=%+ %+ ',0 ; Cursor motion macro
CE:	DB	'X'-40H,0       ; Erase from cursor to end-of-line
SO:	DB	ESC,'R',0       ; Start standout mode
SE:	DB	ESC,'S',0       ; End standout mode
TI:	DB	0               ; Terminal initialization
TE:	DB	0               ; Terminal deinitialization
;
; Extensions to standard Z3TCAP
;
LD:	DB	ESC,'W',0       ; Delete line at cursor position
LI:	DB	ESC,'V',0       ; Insert line at cursor position
CD:	DB	'Y'-40H,0       ; Erase from cursor to end-of-screen
;
; The attribute string contains the four command characters to set
; the following four attributes for this terminal in the following
; order:  	Normal, Blink, Reverse, Underscore
;
SA:	DB	0               ; Set screen attributes macro
AT:	DB	0               ; Attribute string
RC:	DB	0               ; Read current cursor position
RL:	DB	0               ; Read line until cursor
;
; Graphics TCAP area
;
GOELD:	DB	0		; Graphics On/Off delay in ms
;
; Graphics strings
;
GO:	DB	0                 ; Graphics mode On
GE:	DB	0                 ; Graphics mode Off
CDO:	DB	ESC,0CH,0         ; Cursor Off
CDE:	DB	ESC,0DH,0         ; Cursor On
;
; Graphics characters
;
GULC:	DB	8EH,0		; Upper left corner
GURC:	DB	8DH,0		; Upper right corner
GLLC:	DB	8CH,0		; Lower left corner
GLRC:	DB	8BH,0		; Lower right corner
GHL:	DB	81H,0		; Horizontal line
GVL:	DB	80H,0		; Vertical line
GFB:	DB	7FH,0		; Full block
GHB:	DB	97H,0		; Hashed block
GUI:	DB	86H,0   	; Upper intersect
GLI:	DB	85H,0		; Lower intersect
GIS:	DB	82H,0		; Mid intersect
GRTI:	DB	83H,0		; Right intersect
GLTI:	DB	84H,0		; Left intersect
;
;  Fill remaining space with zeros
;
	 REPT	128-($-TNAME)
	DB	0
	 ENDM

	END
;
; End of Z3TCAP
;
rsor position
RL:	DB	0               ; Read line until cursor
;
; Graphics TCAP area
;
GOELD:	DB	0		; Graphics On/Off delay in ms
;
; Graphics strings
;
GO:	DB	0                 ; Graphics mode On
GE:	DB	0                 ; Graphics mode Off
CDOееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееГг Z3ENVЂпght (C) 1985 BORLAND Inc  ѓB                                           HOLTE-CP/M-Pluss0/92P  A             a            =                 c     VWM    Tcv  R0m  Ssr   ~·7И#хе~Нйбс= ф·ЙН
 ЙoеН¦ ЙюЂЬlФ…жое!пе!й"бгхЕХ~#·(еНйбфСБсгЙ}ґИ:$‡‡‡ггггЕТБ= ф+иНРШ*ОЯхЕХе!ЁН6!ўНР*єФбСБсЙхЕХе!ґйхЕХе!®ах:а ·(ЕХеЇ2а !ИН6бСБсЙх:а юя(цЕХе>я2а !ВгхЕХе!јЪхЕХеер !‹ н°С:ћO:њ‚ХНЭС:џO:ќѓНЭ!р НР* НбСБсЙ!р  	л!›45(Й!+/–0ь†хyю0(снЙ
d!kГ6!{Г6 Н`ж Н`o& Й ф  	 бБе:Э ·(ХЕН  |µ(Нвю НвюКХ БС* й"Т x2Э y·(>Г28 !ь"9 !¦   н°!ѕё  н°Їog2Р "Ф "Ц >~2С 2а ЙГГ!Г:Г0Г5Г+Г:Г!Б ‚ C Д Е Б ЕХеЭеэехo& еН¦ сэбЭббСБЙЕХеЭеэеНЈ }ля н[Т ю (ъ!e Н|Н§юA8юQ0Gю: xЦ@Ї!\ w#(Нѓ ю?(ю*(ю.(НxН_ю. Н_!h 6 #ыЙ(ю?(	ю*(Нѓ(w#йЙ>?> w#ьЙН§ю 8еЕ!™ н±БбЙїЙ .,;:=?*[]<>{}юaШю{РЦ Й|Нµ}хНѕсжЖђ'О@'ГКЇ7Л|А|·}И>яЙ2Ш ЕН°Б* ·нBЪ© лСщ ь	"Ж Їog"О 2Ь >Г2Щ !Я "Ъ л"М йе*Ж ·нB"Ж н[Д ·нRлбЪvн°Й*Ж н°"Ж ЩЙ^#V#Х^#V#N#FбЙЭблO /o&я9щлн°ЭйСO /o&я9щлн°йЭбл!ая9щлЕ(Їьн°Б> ђ‘(GЇьЭйЭб!ая9щ Їw#ьЭйЭбEН»¶wЭйЭбС}“8ч<OCН»_AЇіЛ#0¶w#ЇуЭxжшЖo& 9xж<GЇ7эЙеЩлгs#r#Сs#r#q#pЙЭбxл!  D9Nе	#г№8y#·(Oн°бщЭйЭбx!  D9Nе	#^#VЬЭблh& D9н°!  9щЭйЭб!  9^#Vh& D9н°!" зЭблx/o&я9щp#H лн°Эй·нRШ>ђГ( ·нR·нB0	Й>‘Г( ·нRлкrрш  ЙХл·нRлбл·нR! И+ЙНахН±	р·нR! А+ЙНахН±	рНs! Р+ЙНахН±	рНs! ИШ+ЙНафН±	пНs!  ИШ#ЙНафН±	пНs! Ш+ЙНахН±	рT]KBл!  z·> S>)л)л0	= цЙ|µК
|ЄхНЃлНЃлDMЇgo>нjнB0	7?ЛЛ= рлсрHеН“Л<ЛСлНлЛzИ5НbИ)эЙНbИЛ<ЛъЙлz· {ю0G·ЙЇgoЙл|Є|ъєА}»ЙЙЛ|И|/g}/o#Й}жo& ЙнKК н[И ЕХxAJS ЛЛЛЛблбнJDM!йb"И л!6нJ"К DMЙ 'НгиНгd Нг
Нг}Ї<нR0ы= ИЖ0Эw Э#ЙЭ~ Ц$O!   Э#Э~ Н§Ц08)ю
8 !Цю
8ю0T])Ш)Ш T]Ш)Ш_ ШЛy·И|‡ЙЭббе}& #9NЃ8wл!  DнB9щлен°лб+Oнёл#щЭй>Г* ЭбНЙWбНЮ	_бе}“8(є8J `9{‚T]=o`9yнёл	Ї<k-& 9wщЭйЭббе}& #9щo& ЭйЭб!  T9^K#е^C#ееэбСбyђ8<OЕХеѕ(бСБ# т!  #мСбБ!  9лнRэщЭйЭбНЙOбНЮ	_б~“8(‘8х~‘w PT]	с<Oн°sЭйЭбНЮ	OСнSи !  9х†8ё8xсW^‘8/<ozѓ8ё}8x“8&‘8#<·(ЕХ*и _ B	СХеPлбOнёСБz<(Ox‘<»8{·(*и  	л! 9Oн°!  T9^щЭйЭбб-Вgl& Эй! T9^~6#wЙ! T9^K#е^C#ееэбСбЇё(№ x№бСэщХйѕ ц#з|· }·А>Г* Н
Р>Г( Н‚
хН­Н
нЩ}·Щ>К( Нц
ЯЩЛxЩВ‰
Щ}·ЩИЩЕХеЩ}· ЩЛёTЕЛшЇЩЛш}Щ•(0нD=ЩН{,= щ(ЩсжЂ Н“0%Н|·, 7 НЗ?х(8ЩН­Лx 	Н‡- цНsс8Лё·ЩбСБЩЙЩЛxЩВ
Нђ
Н
Ш,-ИxоЂGЙЩ}·ЩКs}·ИЩ…ЩНNЕХеЭ9НsЩ.Щ>Э#Эn Л0Н“Н|= сЩ-Щ еЭnыЛx 	Н€,-(-ссс·сЩБбЩЭбЛё°G,-МsЙ}·ИЩ•Щ?НNеееЭ9Щ.Щ>НЗ8Н­?Л= ЭuЭ+Щ-Щ(>Н‡0ЯН­·бН‡8НЗ?бСБЛx Н€љ, —7•8ЖЂ8ЖЂ8oЭгЩеЕxЛшЩЁжЂхЛшЭеЭ!  ЙбШЇoGOW_gЙ·ЛЛЛЛЛЙ·ЛЛЛЛЛЙ|Щ„Щg{Щ‹Щ_zЩЉЩWyЩ‰ЩOxЩ€ЩGЙ|Щ”Щg{Щ›Щ_zЩљЩWyЩ™ЩOxЩЩGЙxЩёЩАyЩ№ЩАzЩєЩА{Щ»ЩА|ЩјЩЙЩxЩЁткxЙЛx(НфИ?Й}ЩЅЩА·ИГЗ}ЦЃЪs<ю(РЩЕХеНs7Н|= щЩ|Щ¤Щg{ЩЈЩ_zЩўЩWyЩЎЩOxЩ ЩGГ|
ЩЕХеЩН­ЩНюЩН‚
л}·ИЛx>В( Н­}ЖЂЛ/ЖЂoЦхЩЕХеНц
Н
-ЕХеН‚
}бСБЩбСБгјг0гсЩЙЩНЏ-Н‚
ЩНЏ,Щ}юlШЕЛёНаБ8	Нц
Н5Н
Лx(Н
Щ-ЩНах8Н‚
Щ-ЩНа8Щ,Н‚
}юl8;ЩЄ*ЄЄ!ЄН
ЭеЭ!>Н5ЭбН­Н
Н
ЕХеЩН­--Щ-Н
ЩбСБЩН‚
,,с,-ИШxоЂGЙgЄ?+2Чn¶*п8tР Рz€€€€~«ЄЄЄЄ,->К( ЛxВ( ЩН™Щ}.Ѓ•хНц
ЩН‡ЩН‚
ЕХеЩ,Н
ЩбСБНц
ЭеЭ!Ќ>Н5Эб,ЩНЈ-ЩН
сЕХеo& 0%Н	Щ,Н
ЩбСБН
}юgЪsЙ}ЉќШ‰}йў‹.:}Ћг8Ћc~I’$I~НМММL«ЄЄЄ*ЩНЈЩ·ЛxхЛёНц
}ю€0GЕХе,НСеЛ<Л}бхН	,-(-ЩсбСБхН‚
ЭеЭ!>НJЭбс0
хЩН™ЩН
с…o8	сИЩН‡Гц
б>Г( m.`1pF,юеt6|‰„!wS<яГ.zТ}[•|%ёFXc~ьпэuЂТчr1}·ИЭеЩН‡ЩЇЛx(<ЛёхНа8ЩНц
сЛяхЩПЋй!~JЩНа0Н/OЭ!П>Щ ЭНtЩНа8= мЩ ЭЩЩНoЛшН
ЕХеНtН
ЩН‡Н
ЩбСБНц
ЭеН/ЭбЩНoН
с0
хЩНЏ-Н‚
сЭбЛOИЛшЙзПМTцфў0	jБ‘
ЂµћЉoDЂ‚,:НЂjБ‘
Ѓ     Ђ!ўЪI}иў‹.є}Ћг8Ћc~I’$I’~НМММL«ЄЄЄЄЭ!>ЕХехН­Н
сНJЩбСБГ
хЩНoхЩЕХеНoН
ЩбСБЩН
с= йЩН‡Г
 ЭЭn ЭfЭ^ЭVЭNЭFЙ!Ѓ DLT\ЙIўЪ!‚!Й53у!ЃъЙr1ч!ЂТЙЕХеЩбСБЙН“!Ђ > Лx Л#ЛЛЛ-= рoЛёЙЛxЩН‡(Лш-Н
·Л}(ЛxЛш>ЏЅ8(Н{,уН{`iИГ„!  Й>’Г( |µКsЛ|НЃ>ђ)=Л|(ъDM  boАЛёЙНЙл 8ю8НЙЩЛxЩ(’0Їю	8>	<WХЩэ!] ЭеНмЭбСOz<Л{ Ѓтlэ6  ю8>ХНЃСЛx(>-НжЛ{(a Лy(НдНЪтђz·(>.Нж(Нд чъІНЪчЛ{И>EНж>+Л|(|нDg>-Нж|/Ц
0ыЖ:Эp Э#э~ э#· э+>0Эw Э#Йэе,- э6 0э#шЇГ~ЕЛё}ЩЦЂoџgM Нц |юЩ <эw нDНA}юЃ0Нґэ5 Лш>„•. (Н{Л= шэ~ х>xжЖ0эw э#xжGЕХеЛ%Н€Л%Н€лгСгнZлбгнJDMбЛ%Н€= ИсБэбЙэеб_ ~6 ю5Шъќ+~<wю:Ш6 с61#6 ЙЩ  ЩНsЭ~ Н§ю. ЩЛp7АЛрЩЭ#кюE(!Н:0TНґШЩЕo& Н	Нк	ЩБШЛp(ЩЧНШЩЛаЭ#Э~ ю+(ю- ЛиЭ#Н7?ШOЭ#Н70
Э#Wy‡‡Ѓ‡‚OЛh(yнDOЩЩyЖЂюZШю¦?ШЕЭеyНAЭбЩБЩЙЭ~ Ц0?Рю
Йх·тHнDхЛ?Л?<!ъя = ьлЭ!xЭНtсж(хНґс= шс·т
ЩГц
Ѓ     Ћ   @›   ј>Ё ҐФh¶їЙГ¬Елx-РНОВSЮщx9?л+Ё­ЕшЙ{О—@}·ИЛшЕХ|Н{Н{„gгнZлбгнJDMб0Н|,7И}ЖoЛёЙ Н@ѕ #шyоO!@ 9щi& Эй Н@ л ¶ѕ в#чЪН@¶w#щлщЭйН@/¦w#шпН@¦w#щгэбЭб!  9л!  E9эйЭб!! 9~·(Ї+FН»¦!" 9щ!  (#Эй>Ї2и эб*Т НгЇб"в эе|· >"2Р Й:и ·(
Н· *в wЙНу*в 6  л!\ $ н°Й!зЕен[Т ю (ъН§–(
бБ г·Й#лББю:А~ЙCONБTRMБKBD‚LSTCAUXДUSRЕ>Ї2и Нj:Р ·А*в Л®~жАН1:Р ·А*в :и ·ЂЂ(@ q##pЙН[*в  л:и ·(
ХН СсЕН Б<Аx2Р Й*в  6 #ыЙ"в ~жАЛv(
>НЗНЛ~И*в е лН б< >я2Р 6 Йг"д ге!В "в бЙг"д г"в Л~А>2Р Йг"д г"в ЛvА>2Р Й>Їг"д ге!В "в Л®хНйс·(НвбЙ !С ~ю8>~O6~*Т "Ф  Нвwю(6ю(2ю(-ю()ю(6ю(8ю 0ю Щ:Э ·(УЭ*д Г yє(И~#НКАъю+Н  (±п(« 6Нв6#6
#"Ц Й*в :Р · y~Лo pж .##~·теН»б(е. 6бЇw4Ж._ ~ю =*в ##55= *Ф н[Ц ·нR8яНл*Ф ~#"Ф = НЈ }== НЇ }Нµ }*в Ло#w+Й#~+Й>Йе*в ~жю('Нlю!0ю(Л®с] ЕХНlСБю!8Л®пЇбЙЭ!] Э~ ·И ю-АЭ#Й8Э~ ·И>2Р 7ЙеНlЛ®бwЙ>ЇOЕНсБН%ИЕеНшСБН7ШМ„лs #rлЙНсН%ИЕеН¤ЩбБН7ШЩМђ
ЩГТел ЕХНlСБю(ю(Л®кбqЙНlю(Л®ю
(ю пНlю
 Л®Й*в O:Р ·А~ж ##е~Ж._ qб4р(ю(б Ее=К¦ ==К© =К¬ ГІ *и :к ѕИ4^ qЙ*в ##~·И6 Н»И>р2Р Й}ГЗБСЕЭ*Т Л|(Н„ллЛ|(	Н„Э6 -Э#ХНЗбНЙн[Т Эеб·нRMл‘8(Gе> ЕНЗБчбAИ~ЕеНЗбБ#уБСЩбСБЩЕЭ*Т ХН(ѕБСЕНЙЛC!ў ї!¦ёTRUEFALSEНЙ! 9N#НZСщХЙб~#·(G~ЕеНЗбБ#хй>НЗ>
ГЗ  "в Л~(ХНlС»(ю(ю!0(Л®и! Й!  Й>Ї2и нSж Н{:Р ·АН1:Р ·А*в 6Р##w w#w$ w#wЦя:и · е ЇН
б##N#F*ж ·нBИ>ђ2Р ЙеЇw#w#н[ж s#rб >Г
"в ~жАИНЇ*в - Їw#wФяw## >Н
НЇГ‚г"д г"в ~жАА>2Р Й:Р ·АеН[л·нRб0ЇН
*в  4А#4Й>™2Р Й:Р ·АеН[·нR> *в  4 #4(>бН
Иб>т2Р Й2й л*в Лf(/Л¦:й ЛG(##~++· :й ЛO x· y·ъDЕХ!Н»СБ Q*в :й ЛG(Ло##~Ж.Х_ СЦ.Н›н вg<т]=<Н›*в ##жw ЕХеНЇбСБ Х+ С4 #4x±ВлЙ>™>р2Р Йх:й ЛG(лсЙ"в НЇИж"*в ЛжЛnИЛ®*в еЕ0 лН Бб лН ·ЙБСнSв ЕеН[С·нR8@*в  	N#F#s#rН- 	0}ж)лнjлS\*в ##w+ 	N#Fл·нB	ИХеНЇСбr+sЙ>‘2Р ЙХЩбЩ!  T]>)лнjлЩ)Щ0	0= пЙН^·нR!  А#ЙН^лЙ*в  ^#V#ХN#F#^#VбЙ>Ї2и Н±:Р ·АН1:Р ·А*в 6Ае л#Н б- ЇNw#FwЦяq#p#6Ђ#w#w#wЙ"в ~жАИГ‚>">!DM!р "ж ЭбСбЭеЕНюБ:Р ·А*р нBИ:й ю!>™(>р2Р Й>">!"ж ЭбБСбЭе2й "в ~жАК±*ж Їw#wx±(9ЕХН *в  л:й OН СБ· Х*в - 4 #4С!Ђ л*ж 4 #4Г*в - N#FЪяq#pьяV+^л·нBРлq#pЙБСнSв ЕеН[С·нRЪ'*в  	s#r$ 	s#rЙНMА лН <А?эб*Т НгЇбэеНMАеНубе л!\  н°б елН С<(	!\ $ н°Й>2Р Й>Ї2и НMА:Ш ·>!(л*в  \ $ н°\ Н <(П!4°  н° :и · н[1 Г° ХН \ Н С!Ђ л·(й7"в ~жИ> 2Р Й"ж нSи лб"в Ns#Frл·нB(Zл#\ :Ь  н°Їье\ Н С<(?*ж "} нKи ЕХН \ !Н СБ· !*} #"} !Ђ лx± Ы\ Н *в  йЭ*в >рГ* НЙюР2Ь Й"р лбг"т {жь_!Ю "ш Э*Ю ЭnЭf}ґ(HнR0Эn ЭfеЭ"ш Эбг 
Э^ ЭVЭеMDЭn ЭfЭеЭЭu ЭtЭqЭpЭеС*ш s#rС*т s#rЙЭеб"Д *р  	ЭеБ	ЪvнKЖ нB  !  Ъ1>яГ( лбг~#fo{жь_л"р *Ю еЭб·нR0RЭn Эfе·нR0ЭбрбХэбнKр эqэpэu эtЭs ЭrЭебЭNЭFН(	Э^ ЭVХЭбЭебЭNЭFЭ^ ЭV*Ю нSЮ ХЭбЭu ЭtнKр ЭqЭpл	·нRАХэб*Д ·нR(э~ Эw э~Эwэnэf	ЭuЭtЇЙЭеб"Д 6 #ыЙНL*ф ЙНL*ц Й!  "ф "ц Э*Ю ЭNЭFy°(*ф 	"ф *ц ·нB0нCц Эn ЭfеЭбШ*Ж ыя	н[Д ·нRШл*ф "ф *ц ·нRРнSц Йн[Д s#rЙ^#Vл"Д "Ю 6 #ыЙ>ЇO"и Їw2Р x2к *в "н !G"в б"д б Н'Нz*н "в *д й>Ї2м "и *в "н !G"в б"д б"к !\ НгЇ*к :м · НOНs!Р ~6 ·go(Эеб\ нRл*и s#rЈЖ н_2Л ЙлЭбБбx±(sx±(T]н°ЭйDMЭбСбx±(фнR0н	л	лнёЭйU(НћЭбO /o&я9щq#л(н°Эй !Ђ >Fё0# (~ю (ю	 #п](~ю (ю	(#п}“( Хi& TЙСБХ-a%ГЈ}Н§oЙ* й!Р ~6 o& ЙН|µИ:Э хЇ2Э Н!с2Э }юАЭб :Р ·ИЭб_Эб_ХН{СЇ2Э *О |µЭебнKМ нB 	"О · ХХеНЩ Сz· Н^C
User break += Н
I/O Н
Run-time Н error  {НµН, PC= *О Н°НNot enough memory Н
Program aborted
 :Ш ·Кm'Г  бССй1 !†б яНe!!LQв>НХГЇHэбб"аSб"вSб"дSб"жSб"иSэе!РS"ШS*иSл*ШSs*ШS е*жSлбs*ШS е*дSлбs#r*ШS е*вSлбs#r*ШS е*аSлбs#r!  "ОS*иS ·нRК¶! ·нRК¶! ·нRК¶!  ·нR·нBЪ¶!	  ·нR·нBЪ¶!	 ·нRВЛ!!2 е!РSлБН o& "ОSГ"	 ·нRКэ! ·нRКэ! ·нRКэ! ·нRКэ! ·нRВ"!2 е!РSлБН "ОSГ"!2 е!РSлБН *ОS"кS*кSЙэбб"ЗSб}2ЙSб"КSб"МSэе*КSе*jUСННЛEКv"НњН»Fehler ! Sektor : *КSе!  Н'НОН Г”#*КS+"КS*КSе*fUСН"ЅS*КSе*fUСНF"»S!	 е!  е*МSе! е!  еН !"№S! е!  е*»Sе*№S^#Vле!  еН !"»S! е!  е! е!  е!  еН !"№S!
 е!  е*ЅSе!  е!  еН !"№S! е!  е*»Sе!  е!  еН !"№S! е!  е*ЗSе!  е!  еН !"№S! е! е!  е!  е!  еН !"№S*ЙS& ЛEКz#! е!  е!  е!  е!  еН !"№SГ”#! е!  е!  е!  е!  еН !"№SЙэбб"ґSб}2¶Sб"·Sэе*·Sе! Сл·нRе*aU& СНце*pUС"·S!  е*aU& +СНgzіК$Х"ЄS*U& е*·Sе*ЄSСе*¶S& е*ґSе*ЄSе*vUСНцСеН%"*ЄS#СГУ#Й!	 е!  е*U& е!  е!  еН !" S! е*U& лБН ! еБН " S!Ђ е* S n& СНO"vU! "jU! "fU*U& е! е!  е!~UеН%"!~Uе! Сn& е!~Uе! Сn& е! СНOС"ћS*vUе*ћSСН“ЛEКЩ$НњН»
Boot-Record defekt !НОН ГЗ&!~Uе! Сn& }2aU!~Uе! Сn& е!~Uе! Сn& е! СНOС"nU!~Uе! Сn& }2`U!~Uе! Сn& е!~Uе! Сn& е! СНOС"lU!~Uе! Сn& е!~Uе! Сn& е! СНOС"jU!~Uе! Сn& }2_U!~Uе! Сn& "hU!~Uе! Сn& "dU!~Uе! Сn& е*dUСНц"fU*nUе*hUе*`U& СНцСе! С"rU*rUе!  е*lUСНце*vUСНС"pU*jUе*pU+Сл·нRе*aU& СНе! С"bU*aU& е*vUСНц"tU!Ѓ     ЕХе!яН	ЩбСБНк	ЕХе*tUН	ЩбСБН 
НЯ"xU*vUе*hUСНце!я#СННЛEКЂ&НњН»
FAT zu gro~ !НОН ГЗ&! е*hUСНgzіКЗ&Х" S*U& е*nUе* SСе!  е!~Ще*vUе* S+СНцСеН%"* S#СГ‹&Йэбб}2ќSэе!	 е!  е*ќS& е! е!  еН !"“S! е*ќS& лБН Йэбб"ЏSэе*ЏSе!Ѓ    @ЩбН	Ны	НЯ"…S!~Ще*…SСn& е!~Ще*…S#Сn& е! СНOС"…S*ЏSНЊЛEКb'*…Sе! СНW"‘SГs'*…Sе!яС|ўg}Јo"‘S*‘SЙэбб"ЃSб"ѓSэе*ѓSе!Ѓ    @ЩбН	Ны	НЯ"wS!~Ще*wSСn& е!~Ще*wS#Сn& е! СНOС"uS*ѓSНЊЛEКт'*uSе! С|ўg}Јo"uS*ЃSе! СНO"ЃSГ(*uSе! рС|ўg}Јo"uS*uSе*ЃSС|Іg}іo"uS!~Ще*wSСе*uS& лбs!~Ще*wS#Се*uSl& лбsЙэбб"qSэе*qS#"qS*qSеНь&е!  СНЂЛEКC(*qS"sS*sSЙ! е*`U& СНgzіКг(Х"_S*nUе*_S+е*hUСНцС"[S! е*hUСНgzіКЪ(Х"]S*U& е*[Sе*]SСе! е!~Ще*vUе*]S+СНцСеН%"*]S#СГћ(*_S#СГu(Й!      Щ!ESНТ! е*bUСНgzіКB)Х"KS*KSеНь&е!  СНЂЛEК9)!ESН-ЕХе*tUН	ЩбСБНк	Щ!ESНТ*KS#СГя(!ESН-Щ!USНТ!USН-Й! е!4SлБН !. е*U& лБН *U& еНИ&!€     ЕХе!‘     ЕХе!4Sе! Сn& Н	ЩбСБНы	ЕХе!‰     ЕХе!4Sе! Сn& Н	ЩбСБНы	ЩбСБНк	ЕХе!4Sе!  Сn& Н	ЩбСБНк	ЩбСБНы	Щ!?SНТ!?SН-Й!яSН;! е! Нl!пSНг!  e.е!пSН;Ні}2яT*яT& е!  СННЛEКO*!пSе*яT& е! НфЙэб!SНгэе!? e.е!SН;Ніе!  СННе!* e.е!SН;Ніе!  СННС}іo}2+S*+S& Йэб!цRНгэеНN           !ЭRНг! }2мR! е!цRН;Н¤СНgzіК|+Х}2нR!цRе*нR& Сn& . ·нRВ+!	 }2мRГq+* ·нRВG+!ЭRе*мR& Се!? лбs*мR& #}2мR*мR& еН‚!	 Н’! Н’НPЛEК+Гq+!ЭRе*мR& Се!цRе*нR& Сn& Нелбs*мR& #}2мR*нR& #СГЦ*!ЭRН;!SНгэб!SН;эеЙэб!їRНгэе! е!	 СНwzіКе+Х"µR!їRе*µRСn& е!  СНЂЛEКЬ+!їRе*µRе! Нф*µR+СГ¬+!їRН;Н¤е! СННЛEК,!. e.е!їRе!	 Н!	! е! СНwzіКR,Х"µR!їRе*µRСn& е!  СНЂЛEКI,!їRе*µRе! Нф*µR+СГ,!їRН;!ОRНгэб!ОRН;эеЙэб!–RНг!ҐRНгэе! }2ЊR! е! СНgzіКо,Х}2ЌR!ҐRе*ЌR& Сn& е!? СН“е!ҐRе*ЌR& Сn& е!–Rе*ЌR& Сn& СН“С}ЈoЛEКг,!  }2ЊR*ЌR& #СГ‘,!–Rе! Сn& еН‚!е Н’!  Н’НPЛEК-!  }2ЊR*ЊR& }2ґR*ґR& Йэбб}2‹Rэе!  }2оS*‹R& ЛEК\-!  }2ЂR!  "ЃR*rU+"|U!ая"zU*ЂR& }оoе*оS& }оoС}ЈoЛEКM.*zUе!  Се*vUСНF"zU*zUе!  СНЂЛEКё-*|U#"|U*U& е*|Uе!  е!~UеН%"*ЃR#"ЃRНN           !qRНг!~Uе*zUСе!qRе! Се! Нe!пSН;!qRН;Нk,е!~Uе*zUе! ССn& е!( СН“С}Јo}2оS!~Uе*zUСn& е!  СНЂе*ЃRе*lUСНЂС}іo}2ЂRГ\-*оS& ЛEК{/!qRН;!PUНг!~Uе*zUе! ССn& е!~Uе*zUе! ССn& е! СНOС"JU!~Uе*zUе! ССn& е!~Uе*zUе! ССn& е! СНOС"LU!~Uе*zUе! ССn& е!~Uе*zUе! ССn& е! СНOС"NU!‘     ЕХе!~Uе*zUе! ССn& Н	ЩбСБНы	ЕХе!‰     ЕХе!~Uе*zUе! ССn& Н	ЩбСБНы	ЩбСБНк	ЕХе!~Uе*zUе! ССn& Н	ЩбСБНк	Щ!DUНТЙ!  "gR!  "cR!  }2bR!яSН;Н¤е!  СННе!яSе! Сn& е!F СНЂС}ЈoЛEКУ/!яSе! е! Нф! }2bR!яSН;Н¤е!  СННе!яSе! Сn& е!  СНЂС}ЈoЛEК0!яSе! е! НфГУ/Н*!пSН;Н¤е!  СНЂЛEК;0НN*.*!пSНг!пSН;Н›*!пSНг! еН(-*оS& ЛEК02*cR#"cR*bR& }оoЛEК«0*gRе! СНFе!  СНЂЛEКћ0Нњ*U& е!A СН#Н НњН» : Н Нњ!PUН;! е! Нl!  Н«!  Н#!PUН;!	 е! Нl!  Н«Н *bR& ЛEКю1!DUН-НњЕХе!	 е!  НzН *LUе!  СНЂЛEК)1НњНN !
 Н«Н ГЌ1*LUе! С|ўg}ЈoНње! Н'!. Н#*LUе! СНWе! С|ўg}Јoе! Н'!. Н#!P е*LUе!	 СНWСе!d СНFе! Н'Н *JUе!  СН“ЛEКы1*JUе! СНWНње! Н'!: Н#*JUе! СНWе!? С|ўg}Јoе! Н'!: Н#*JUе! СНOе!? С|ўg}Јoе! Н'Н Г2*gR#"gR*gRе! СНFе!  СНЂЛEК&2НњНОН !  еН(-ГS0*gRе! СНFе!  СННЛEКQ2НњНОН *cRНње!	 Н'Н»
 Datei(en)Нд(ЕХе!‹     ЩбСБН 
НЯе!
 Н'Н»k freiНОН Й!DUН-ЕХеНV)ЩбСБНЧЛEКЦ2НњН»Error : Disk FullНОН Г4!DUН-ЕХе!Ѓ     ЩбСБНу	ЕХе!€     ЩбСБН 
НЯ#"VR!Uе*U& е!A Се!: e.еНЈ	Н>!5UН;Н>Нq!UНpН *NU"XR*VRе!  СННЛEК	4!  "RR*RRе*xUСНбе*XRе!шСНбС}ЈoЛEКЁ3*XRе!  е!~Yе*RRе*tUСНцСеН•#*XRеНь&"XR*RR#"RRГW3*RRе*tUСНце! СНW"TR*TRе*VRСННЛEКФ3*VR"TR*U& еНИ&!Uе!~Yе*TRН»Н *U& еНИ&*VRе*TRСл·нR"VRГA3!UН±Н *U& еНИ&ЙН*!пSН;!5UНг!пSН;Н¤е!  СНЂЛEКУ4НњН»MS-DOS-Dateiname : Н !пSНМНЏН !пSН;Н¤е!  СННЛEКC4НњН»CP/M - Dateiname : Н !5UНМНЏН !5UН;Н¤е!  СНЂЛEКУ4!пSН;!5UНг!пSН;Н›*!пSНг! еН(-*оS& }оoЛEК5НњН»No FileНОН Гy5!пSН;НP*ЛEКv5НњН»- Copying :НОН *оS& ЛEКs5!PUН;Н•+!5UНг!5UН;Нњ!  Н«НОН Нќ2!  еН(-Г65Гy5Нќ2Йэбб}2IRэе*IR& ЛEКп6*U& еНИ&!ЁQН¤!¬Qе! Нж*¬Q"®Q!4Rе!  Се*U& #лбs!пSе! Се!4Rе! Се! Нe!4Rе! Се!  лбs! е!ґQлБН ! е!4RлБН o& "ІQ*¬Q"ЄQ*ІQе!я СНЂЛEК#6!  "¬Q*ІQе!я СН“ЛEКК6НN           *®QНг! е! СНgzіК™6Х"°Q*®Qе*°QСе!ґQе*ІQе! СНOе*°QССn& е! С|ўg}Јoлбs*°Q#СГU6*®Q"ЄQ!®Qе! Нж*ЄQ е*®Qлбs#r! еБН o& "ІQГ#6*ЄQ е!  лбs#r!®QН¬*¬Q"ЄQ*U& еНИ&*ЄQе!  СН“}2оS*оS& ЛEК'7*ЄQН;!5UНг*ЄQ ^#Vл"ЄQГ-7!ЁQН¬Йэбб"•Qб"—Q!™QНгэе!  }2оS!  "‹Q*rU+"|U!ая"zU*zUе!  Се*vUСНF"zU*zUе!  СНЂЛEКњ7*|U#"|U*U& е*|Uе!  е!~UеН%"*‹Q#"‹Q!~Uе*zUСn& еН‚!  Н’!е Н’НP}2оS*оS& е*‹Qе*lUСНЂС}іoЛEК\7*оS& ЛEКд8!™Qе! Се!~Uе*zUСе! Нe!~Uе*zUе! ССе! е!  НO!~Uе*zUе! ССе!  лбs!~Uе*zUе! ССе*•Q& лбs!~Uе*zUе! ССе*•Ql& лбs!~Uе*zUе! ССе*—Qе! С|ўg}Јoе! СНOлбs!~Uе*zUе! ССе*—Qе! СНW& лбs!~Uе*zUе! ССе*—Qе! СНWl& лбs*U& е*|Uе! е!~UеН%"Й!Uе*U& е!A Се!: e.еНЈ	Н>!5UН;Н>Нq!UНqН !UН^"UНд(ЕХе!€     ЕХе*UН	ЩбСБНы	ЩбСБНкЛEКl9НњН»Error : Disk FullНОН ГЏ:! еН;("ЃQ!PUН;*Uе*ЃQеН.7*U"yQ*yQе!  СННЛEКЊ:!я#е! СНW"{Q*{Qе*yQСННЛEКВ9*yQ"{Q*yQе*{QСл·нR"yQ*U& еНИ&!Uе!~Yе*{QНїН *U& еНИ&*{Qе! СНO+е*tUСН"}Q!  е*}QСНgzіК‰:Х"{Q*ЃQе! е!~Yе*{Qе*tUСНцСеН•#*{Qе*}QСНЂе*yQе!  СНЂС}ЈoЛEКe:!я"QГo:*ЃQеН;("Q*ЃQе*QеНw'*Q"ЃQ*{Q#СГ:ГЌ9Нh(ЙН*!пSН;Н¤е!  СНЂЛEК<;НњН»CP/M - Dateiname : Н !пSНМНЏН !пSН;Н¤е!  СННЛEК©:НњН»MS-DOS-Dateiname : Н !PUНМНЏН !PUН;Н¤е!  СНЂЛEК9;!пSН;!PUНгГJ;!пSН;!PUНг!пSН;Н›*!пSНг! еНz5*оS& }оoЛEК‡;НњН»No FileНОН Г'<!пSН;НP*ЛEКы;НњН»- Copying :НОН *оS& ЛEКш;!5UН;!PUНг!5UН;Н•+!5UНг!5UН;Нњ!  Н«НОН Не8!  еНz5Г­;Г'<!PUН;Н›*!PUНг!5UН;Н•+!5UНгНе8!  еНz5ЙГ‚<*NU"_Q!~Uе*zUСе!е лбs*_QеНь&"]Q*_Qе!  еНw'*]Q"_Q*_Qе!шСН¦ЛEКA<*U& е*|Uе! е!~UеН%"ЙН*!пSН;Н¤е!  СНЂЛEКМ<НњН»Dateiname f}r ERASE : Н !пSНМНЏН Г…<!пSН;Н›*!пSНг! еН(-*оS& }оoЛEК	=НњН»No FileНОН ГҐ=!пSН;НP*ЛEКџ=НњН»Wirklich l|schen (J/N) ? Н !NQНМНЏН !NQН;Н¤е!  СННЛEК=!NQе! Сn& еН‚!J Н’!j Н’НPЛEКњ=*оS& ЛEК™=Н+<!  еН(-Г‚=Нh(ГҐ=Н+<Нh(Й!яSН;! е! Нl!пSНг!  e.е!яSН;Ні}2яT*яT& е!  СНЂЛEКу=НN !7QНгГ>!яSН;*яT& #е! Нl!7QНг!  e.е!пSН;Ні}2яT*яT& е!  СННЛEКD>!пSе*яT& е! Нф!  e.е!7QН;Ні}2яT*яT& е!  СННЛEКz>!7Qе*яT& е! Нф!пSН;Н¤е!  СНЂЛEКЅ>НњН»Alter Dateiname : Н !пSНМНЏН Гz>!7QН;Н¤е!  СНЂЛEК ?НњН»Neuer Dateiname : Н !7QНМНЏН ГЅ>!пSН;Н›*!пSНг!7QН;Н›*!7QНг!пSН;НP*е!7QН;НP*С}іoЛEКd?НњН»Wildcards unzul{ssig !НОН Г¤?! еН(-*оS& ЛEК¤?!7Qе! Се!~Uе*zUСе! Нe*U& е*|Uе! е!~UеН%"Йэбб}26Qэе*6Q& еН9*6Q& еН/ЙГ@НњН»Beliebige Taste bet{tigen Н !є НЄ!QНEН Нњ! Н#НN ! Н«Н ЙНњН»$
MS-DOS-Emulator V1.2 vom 26.8.87
Н»)Befehle: Change, Dir, Erase, Help, New,
Н»$         Protocol, Quit, Read, WriteНОН НњН»E
Befehle bestehen generell aus einem Buchstaben. Hinter dem Befehls-Н»F
buchstaben kann sofort ein Dateiname folgen, welcher aber auch durchН»H
ein oder mehrere Leerzeichen vom Befehl getrennt sein oder ganz fehlenН»*
darf. Es existieren folgende Befehle :
Н»F
C : CHANGENAME, besser bekannt als RENAME. Es werden zwei DateinamenН»G
    eingegeben, wovon der erste der Alte und der zweite der Neue ist.Н»F
    Fehlende Dateinamen werden explizit abgefragt. Wildcards sind inН»(
    keinem der beiden Namen erlaubt.
Н»F
D : DIRECTORY, gibt die Directory der MS-DOS-Diskette aus. WildcardsН»E
    sind erlaubt, au~erdem kann durch Eingabe eines 'F' unmittelbarН»G
    nach dem Befehl die Option 'FULL' gesetzt werden, welche f}r alleН»E
    Files die Dateil{nge sowie Datum- und Zeiteintrag ausgibt. WirdН»A
    kein Dateiname angegeben, so werden alle Files angezeigt.
Н»C
E : ERASE, l|scht das angegebene File. Wildcards sind erlaubt.

Н НД?НњН»1H : HELP, augenblicklich aktiver Programmteil.
Н»H
N : NEW, loggt neue (andere) MS-DOS-Diskette ein (FAT wird gelesen undН»+
    logische Parameter werden gesetzt).
Н»4
P : PROTOCOL, schaltet Printer-Echo an bzw. aus.
Н».
Q : QUIT, Ausgang zum Betriebssystem CP/M.
Н»I
R : READ, Datei(en) von MS-DOS lesen und nach CP/M schreiben. Wird keinН»G
    Dateiname angegeben, werden Quell- und Zielname explizit erfragt,Н»H
    wobei diese verschieden sein d}rfen. Ansonsten wird die angegebeneН»F
    Datei unter gleichem Namen kopiert. Werden Wildcards benutzt, soН»?
    wird der Dateiname grunds{tzlich von MS-DOS }bernommen.
Н»H
W : WRITE, Datei(en) von CP/M lesen und nach MS-DOS schreiben. DateienН»G
    werden genau wie bei READ angegeben, bei Wildcards wird immer derН»
    CP/M-Name }bernommen.
Н»H
Bei den Kopierbefehlen ist zu beachten, da~ unter CP/M die Dateil{ngenН»F
nur Vielfache von 128 sein k|nnen, deshalb werden die Dateien in derН»J
Regel etwas l{nger beim Kopieren, au~erdem m}ssen u.U. Dateiende-ZeichenН»
angef}gt werden.

Н Й!  }2мSНњН»$
MS-DOS-Emulator V1.2 vom 26.8.87
Н»)Befehle: Change, Dir, Erase, Help, New,
Н»$         Protocol, Quit, Read, WriteНОН НњН»#
Laufwerk mit MS-DOS-Diskette : P НОН ! }2UНњН»Laufwerk mit CP/M - Diskette : Н !яSНМяНЏН !яSе! Сn& Нее!A Сл·нR}2U*U& еН‚!  е! НњНPе*U& е*U& СН“С}ЈoЛEКsIНњН»=Hinweis: phys. Disk-Parameter m}ssen korrekt gesetzt sein !
НОН ! еБН o& }2 UН$НњН»MSDOS>Н !яSНМяНЏН !яSН;Н¤е!  СННЛEКQJ! е!яSН;Н¤СНgzіКЛJХ}2яT!яSе*яT& Се!яSе*яT& Сn& Нелбs*яT& #СГ–J!яSе! Сn& }2юS*юS& е!Q СНЂ}2нS!яSе! е! Нф!яSН;Н¤е!  СННе!яSе! Сn& е!  СНЂС}ЈoЛEК:K!яSе! е! НфГъJ*юS& C ·нRВNKН¦=ГLD ·нRВ^KН|/ГLE ·нRВnKН(<ГLH ·нRВ~KНБ?ГLN ·нRВЋKН$ГLP ·нRВБK*мS& }оo}2мS*мS& ЛEКёK!Ґ?"§ ГѕK!9"§ ГLQ ·нRВОKГLR ·нRВЮKН4ГLW ·нRВоKНђ:ГLНњ! Н#*юS& Н#!? Н#НОН *нS& ЛEКQJ* U& еНИ&ГХ }2мS*мS& ЛEКv!Ґ?"§ Г­K!9"§ Г–KQ ·нRВQ ГЙKR ·нRВR Н4ГЦKW ·нRВW Нђ:ГжKНњ! Н#*юS& Н#! Dateiende-ZeichenН»
angef}gt werden.

Н Й!  }2мSНњН»$
MS-DOS-Emulator V1.2 vom 26.8.87
Н»)Befehle: Change, Dir, Eraseееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее(***********************************************************
**   MSDOS.IN0 :  U T I L I T I E S                       **
***********************************************************)

(* Direkter BIOS-Aufruf ueber BDOS-Funktion 50 *)

function UBIOS(fn,pa,pbc,pde,phl:integer):integer;
var biospb : record
               func,a   : byte;
               bc,de,hl : integer;
               end;
    result : integer;
begin
  with biospb do begin
    func:=fn; a:=pa;
    bc:=pbc; de:=pde; hl:=phl;
    end;
  result:=0;
  case fn of
    2,3,7,13..15,17..19,24 : result:=BDOS(50,addr(biospb));
    9,16,20,22,25          : result:=BDOSHL(50,addr(biospb));
    else                     BDOS(50,addr(biospb));
    end;
  ubios:=result;
  end;

(* RWSECTOR liest/schreibt phys. Sektor auf ang. Drive *)
(* Absolute Sektorangabe, Sektoren ab 1 gezaehlt !!    *)

procedure rwsector(dr,abssec:integer; wflag:boolean;
                                               buf:integer);
var trk,sec,k : integer;
    dph       : ^integer absolute k;
begin
  if abssec>sektoren then
    writeln('Fehler ! Sektor : ',abssec)
  else begin
    abssec:=pred(abssec);                 (* zaehlt ab 0 *)
    trk:=abssec div secptrk;
    sec:=abssec mod secptrk;
    k:=ubios(9,0,dr,1,0);                 (* SELDSK *)
    sec:=ubios(16,0,sec,dph^,0);          (* SECTRN *)
    k:=ubios(23,0,1,0,0);                 (* MULTIO *)
    k:=ubios(10,0,trk,0,0);               (* SETTRK *)
    k:=ubios(11,0,sec,0,0);               (* SETSEC *)
    k:=ubios(12,0,buf,0,0);               (* SETDMA *)
    k:=ubios(28,1,0,0,0);                 (* SETBNK *)
    if wflag then k:=ubios(14,0,0,0,0)    (* WRITE  *)
      else k:=ubios(13,0,0,0,0);          (* READ   *)
    end;
  end;

(* RWCLUSTER liest/schreibt 1 Cluster der MS-DOS-Diskette *)

procedure rwcluster(cl:integer; wflag:boolean; buf:integer);
var k : integer;
begin;
  cl:=(cl-2)*secpcl+datstart;
  for k:=0 to pred(secpcl) do
    rwsector(msdrive,cl+k,wflag,buf+k*psize);
  end;

(* MSLOGIN schaltet BDOS und BIOS 'kalt' auf angegebenes *)
(* MS-Drive um. Zum Einloggen der MS-DOS-Diskette werden *)
(* Boot-Record gelesen und die entsprechenden Parameter  *)
(* gesetzt. Die gesamte FAT wird nach FATBUF gelesen.    *)
(* Groesse der FAT max. 2048 Byte.                       *)

procedure mslogin;
type dpb = record
             spt         : integer;
             bsh,blm,exm : byte;
             dsm,drm     : integer;
             al0,al1     : byte;
             cks,off     : integer;
             psh,phm     : byte;
             end;
var  k,secsize : integer;
     ptr       : ^dpb absolute k;
begin
  k:=ubios(9,0,msdrive,0,0);               (* SELDSK kalt *)
  bdos(14,msdrive);                       (* Select Drive *)
  k:=bdoshl(31);                               (* Get DPB *)
  psize:=128 shl ptr^.psh;                 (* Byte/Sektor *)
  sektoren:=1; secptrk:=2;    (* vorbelegen fuer RWSECTOR *)
  rwsector(msdrive,1,false,addr(dirbuf));  (* Boot-Record *)
  secsize:=dirbuf[$0B]+dirbuf[$0C] shl 8;  (* Byte/Sektor *)
  if psize<>secsize then
    writeln(^G^M^J'Boot-Record defekt !')
  else begin
    secpcl:=dirbuf[$0D];
    reservsec:=dirbuf[$0E]+dirbuf[$0F] shl 8;
    fatzahl:=dirbuf[$10];
    eintraege:=dirbuf[$11]+dirbuf[$12] shl 8;
    sektoren:=dirbuf[$13]+dirbuf[$14] shl 8;
    medium:=dirbuf[$15];
    fatsecs:=dirbuf[$16];
    heads:=dirbuf[$1A];
    secptrk:=dirbuf[$18]*heads;
    dirstart:=reservsec+fatsecs*fatzahl+1;
    datstart:=dirstart+(32*eintraege div psize);
    maxclnum:=(sektoren-pred(datstart)) div secpcl +1;
    clsize:=secpcl*psize;
    bufcl:=trunc((1.0+bufgr)/clsize);
    if psize*fatsecs>succ(fatgr) then
      writeln(^G^M^J'FAT zu gro~ !')
    else for k:=1 to fatsecs do
      rwsector(msdrive,reservsec+k,false,
               addr(fatbuf[psize*pred(k)]));
    end;
  end;

(* RELOG schaltet 'warm' auf angegebenes Drive um. *)

procedure relog(drive:byte);
var k : integer;
begin
  k:=ubios(9,0,drive,1,0);              (* SELDSK *)
  bdos(14,drive);                       (* Select Drive *)
  end;

(* FAT-Eintrag lesen *)

function fat_eintrag(agr:integer):integer;
var offset : integer;
begin
  offset:=trunc(agr*1.5);
  offset:=fatbuf[offset]+fatbuf[succ(offset)] shl 8;
  if odd(agr) then fat_eintrag:=offset shr 4
  else fat_eintrag:=offset and $0FFF;
  end;

(* Wert in FAT einsetzen *)

procedure fat_setzen(gruppe,wert:integer);
var offset,hilf : integer;
begin
  offset:=trunc(gruppe*1.5);
  hilf:=fatbuf[offset]+fatbuf[succ(offset)] shl 8;
  if odd(gruppe) then begin
    hilf:=hilf and $000F;
    wert:=wert shl 4;
    end
  else
    hilf:=hilf and $F000;
  hilf:=hilf or wert;
  fatbuf[offset]:=lo(hilf);
  fatbuf[succ(offset)]:=hi(hilf);
  end;

(* Ersten leeren Block in FAT suchen. Suche beginnt ab *)
(* Cluster hinter START. Keine Endepruefung.           *)

function firstfreecluster(start:integer):integer;
begin
  repeat
    start:=succ(start)
  until fat_eintrag(start)=0;
  firstfreecluster:=start;
  end;

(* FAT auf Diskette schreiben *)

procedure writefat;
var i,j,sec : integer;
begin
  for i:=1 to fatzahl do begin
    sec:=reservsec+pred(i)*fatsecs;
    for j:=1 to fatsecs do
      rwsector(msdrive,sec+j,true,
               addr(fatbuf[psize*pred(j)]));
    end;
  end;

(* Freien Speicherplatz der MS-DOS-Diskette berechnen *)
(* (aus FAT). Angegeben wird Speicherplatz in Bytes.  *)

function msspace:real;
var i : integer;
    s : real;
begin
  s:=0.0;
  for i:=2 to maxclnum do
    if fat_eintrag(i)=0 then s:=s+clsize;
  msspace:=s;
  end;

(* Freier Speicherplatz der CP/M-Diskette (in Bytes) *)

function cpmspace:real;
var buf : array[0..2] of byte;
begin
  BDOS(26,addr(buf));      (* Set DMA *)
  BDOS(46,cpmdrive);       (* Get Disk Free Space *)
  relog(msdrive);          (* zur Sicherheit *)
  cpmspace:=128.0*(65536.0*buf[2]+256.0*buf[1]+buf[0]);
  end;

(* Dateinamen SUCHNAME aus BEFEHL extrahieren *)

procedure generate_suchname;
begin
  suchname:=copy(befehl,1,14);
  i:=pos(' ',suchname);
  if i>0 then delete(suchname,i,14);
  end;

(* String auf Wildcards pruefen *)

function wildcard(name:string14):boolean;
begin
  wildcard:=(pos('?',name)>0) or (pos('*',name)>0);
  end;

(* Datei-Namens-String in Character-Array (11 Buchstaben) *)
(* umsetzen. Wildcards: '?' unveraendert, '*' expandiert. *)

function expand(name:string14):string14;
var i,j  : byte;
    hilf : string14;
begin
  hilf:='           '; j:=1;
  for i:=1 to length(name) do
    case name[i] of
      '.' : j:=9;
      '*' : repeat
              hilf[j]:='?';
              j:=succ(j);
            until j in [9,12];
       else begin
              hilf[j]:=upcase(name[i]);
              j:=succ(j);
              end;
      end;
  expand:=hilf;
  end;

(* Datei-Namen aus Array-Form in String-Form wandeln *)

function compress(name:string14):string14;
var i : integer;
begin
  for i:=11 downto 9 do
    if name[i]=' ' then delete(name,i,1);
  if length(name)>8 then insert('.',name,9);
  for i:=8 downto 2 do
    if name[i]=' ' then delete(name,i,1);
  compress:=name;
  end;

(* Namen, evtl. mit Wildcards, vergleichen; beide in *)
(* Array-Form! NAM1 kann Wildcards enthalten, NAM2   *)
(* kommt von Diskette(MSDOS).                        *)

function gleichheit(nam1,nam2:string14):boolean;
var i    : byte;
    flag : boolean;
begin
  flag:=true;
  for i:=1 to 11 do
    if (nam1[i]<>'?') and (nam1[i]<>nam2[i]) then
      flag:=false;
  if ord(nam2[1]) in [$E5,0] then flag:=false;
  gleichheit:=flag;
  end;

 hilf[j]:='?';
              j:=succ(j);
            until j in [9,12];
       else begin
              hilf[j]:=upcase(name[i]);
              j:=succ(j);
              end;
      end;
  expand:=hilf;
  end;

(* Datei-Namen aus Array-Form in String-Form wandeln *)

function compress(name:string14):string14;
var i : integer;
begin
  for i:=11 downto 9 do
    if nam(***********************************************************
**   MSDOS.IN1 :  Lesen der MS-DOS-Diskette               **
***********************************************************)

(* SCAN_MSDIR sucht in MS-DOS-Directory nach File mit     *)
(* Namen SUCHNAME. Variable GEFUNDEN gibt Erfolg der      *)
(* Suche an. Wenn TRUE, werden die File-Parameter-        *)
(* Variablen auf die entspr. Werte gesetzt. Suche nach    *)
(* FIRST/NEXT bei Wildcards, Variable MSNAME wird auf     *)
(* tatsaechlich gefundenen Namen gesetzt.                 *)

procedure scan_msdir(first:boolean);
var i       : integer;
    ende    : boolean;
    vglname : string14;
begin
  gefunden:=false;
  if first then begin
    ende:=false;
    i:=0;
    dirsec:=pred(dirstart);
    diroff:=-32;
    end;
  while not ende and not gefunden do begin
    diroff:=(diroff+32) mod psize;
    if diroff=0 then begin
      dirsec:=succ(dirsec);
      rwsector(msdrive,dirsec,false,addr(dirbuf));
      end;
    i:=succ(i);
    vglname:='           ';
    move(dirbuf[diroff],vglname[1],11);
    gefunden:=gleichheit(suchname,vglname)
              and (dirbuf[diroff+11]<>$28);
    ende:=(dirbuf[diroff]=0) or (i=eintraege);
    end;
  if gefunden then begin
    msname:=vglname;
    zeit:=dirbuf[diroff+22]+dirbuf[diroff+23] shl 8;
    datum:=dirbuf[diroff+24]+dirbuf[diroff+25] shl 8;
    startgruppe:=dirbuf[diroff+26]+dirbuf[diroff+27] shl 8;
    datlength:=65536.0*dirbuf[diroff+30]
               +256.0*dirbuf[diroff+29]+dirbuf[diroff+28];
    end;
  end;

(* Directory der MS-DOS-Diskette ausgeben *)

procedure directory;
var spalte,i,anzahl : integer;
    options         : boolean;
begin
  spalte:=0;
  anzahl:=0;
  options:=false;
  if (length(befehl)>0) and (befehl[1]='F') then begin
    delete(befehl,1,1);
    options:=true;
    end;
  while (length(befehl)>0) and (befehl[1]=' ') do
    delete(befehl,1,1);
  generate_suchname;
  if length(suchname)=0 then suchname:='*.*';
  suchname:=expand(suchname);
  scan_msdir(true);                   (* Search for First *)
  while gefunden do begin
    anzahl:=succ(anzahl);
    if not options then begin
      if spalte mod 5=0 then write(chr(msdrive+$41));
      write(' : ');
      end;
    write(copy(msname,1,8),' ',copy(msname,9,3));
    if options then begin
      write(datlength:9:0);
      if datum=0 then write('':10)
      else write(datum and 31:4,'.',
                 datum shr 5 and 15:2,'.',
                 (80+datum shr 9) mod 100:2);
      if zeit<>0 then write(zeit shr 11:4,':',
                            zeit shr 5 and 63:2,':',
                            zeit shl 1 and 63:2);
      end
    else spalte:=succ(spalte);
    if spalte mod 5=0 then writeln;
    scan_msdir(false);                (* Search for Next *)
    end;
  if spalte mod 5>0 then writeln;
  writeln(anzahl:9,' Datei(en)',trunc(msspace/1024.0):10,
                                                  'k frei');
  end;

(* Einzelne Datei von MS-DOS nach CP/M kopieren *)

procedure lies;
var gruppe,laenge,n,m : integer;
begin
  if datlength>cpmspace then writeln(diskfull) else begin
    laenge:=succ(trunc((datlength-1.0)/128.0));
    assign(datei,chr(cpmdrive+$41)+':'+cpmname);
    rewrite(datei);
    gruppe:=startgruppe;
    while laenge>0 do begin
      m:=0;
      while (m<bufcl) and (gruppe<$FF8) do begin
        rwcluster(gruppe,false,addr(datbuf[m*clsize]));
        gruppe:=fat_eintrag(gruppe);
        m:=succ(m);
        end;
      n:=m*clsize shr 7;
      if n>laenge then n:=laenge;
      relog(cpmdrive);
      blockwrite(datei,datbuf,n);
      relog(msdrive);
      laenge:=laenge-n;
      end; {while}
    close(datei);
    relog(msdrive);       (* CLOSE schaltete auf CPMDRIVE *)
    end;
  end;

procedure readfile;
begin
  generate_suchname;
  cpmname:=suchname;
  if length(suchname)=0 then begin
    repeat
      write('MS-DOS-Dateiname : ');
      readln(suchname);
    until length(suchname)>0;
    write('CP/M - Dateiname : ');
    readln(cpmname);
    if length(cpmname)=0 then cpmname:=suchname;
    end;
  suchname:=expand(suchname);
  scan_msdir(true);
  if not gefunden then writeln(nofile)
  else if wildcard(suchname) then begin
    writeln(copying);
    while gefunden do begin
      cpmname:=compress(msname);
      writeln(cpmname);
      lies;
      scan_msdir(false);
      end;
    end
  else lies;
  end;

ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;******************************************************************************
;*  D I S K I O  *  C P M S Y S 4 f  *  T h o m a s   H o l t e * 8 5 0 9 2 5 *
;******************************************************************************
;*									      *
;*  			    D I S K   H A N D L E R	      		      *
;*                          =======================                           *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	TITLE 'CP/M 3 DISKETTE HANDLER'

	DSEG

;Disk drive dispatching tables for linked BIOS
	GLOBAL DS0,MF0,MF1,FD0,IBMPC,KDS,RAM,RAIR,ALPHAP3,DRIVEP

;Variables containing parameters passed by BDOS
	EXTERNAL @DTBL,@ADRV,@RDRV,@DMA,@TRK,@SECT,@DBNK,@CBNK

;System control block variables
	EXTERNAL @ERDME		;BDOS error mode

	EXTERNAL ?PMSG		;print message ^HL up to 0, saves reg. BC & DE
	EXTERNAL ?PDERR		;print BIOS disk error header
	EXTERNAL ?CONIN,?CONO	;con in and out
	EXTERNAL ?CONST		;get console status

	EXTERNAL ?BANK,?USERF

;ASCII control codes:
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape


;Extended Disk Parameter Headers (XDPHs)

	DEFW DS$WRITE
	DEFW DS$READ
	DEFW FD$LOGIN
	DEFW DS$INIT
	DEFB 0  	        ;relative drive zero
	DEFB 2			;drive type
				;  0 = floppy disk
				;  1 = floppy disk (special format)
				;  2 = Winchester
				;  3 = Winchester (cartridge)
				;  4 = RAM disk
DS0:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB0   		;disk parameter block
	DEFW 0            	;no CSV
	DEFW 0FFFEH,0FFFEH	;ALV, DIRBCB, DTABCB, HASH
	DEFW 0FFFEH,0FFFEH	;alloc'd by GENCPM
	DEFB 0			;hash bank

	DEFW FD$WRITE
	DEFW FD$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 0,0	        ;relative drive zero
MF0:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB12  		;disk parameter block
	DEFW 0FFFEH,0FFFEH	;CSV, ALV, DIRBCB, DTABCB, HASH
	DEFW 0FFFEH,0FFFEH	;alloc'd by GENCPM
	DEFW 0FFFEH
	DEFB 0			;hash bank

	DEFW FD$WRITE
	DEFW FD$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 1,0	        ;relative drive one
MF1:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB12  		;disk parameter block
	DEFW CSV3,ALV3
	DEFW 0FFFEH,0FFFEH	;DIRBCB, DTABCB, HASH alloc'd by GENCPM
	DEFW 0FFFEH
	DEFB 0			;hash bank

	DEFW FD$WRITE
	DEFW FD$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 4,0	        ;relative drive four
FD0:  	DEFW XLT3		;translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB3   		;disk parameter block
	DEFW 0FFFEH,0FFFEH	;CSV, ALV, DIRBCB, HASH
	DEFW 0FFFEH,0FFFFH	;alloc'd by GENCPM
	DEFW 0FFFEH		;no data buffer
	DEFB 0			;hash bank

*EJECT
;IBM PC format:
	DEFW I$WRITE
	DEFW I$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 1,1	        ;relative drive one
IBMPC:  DEFW 0   		;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB8 		;disk parameter block
	DEFW CSV3,ALV3       	;checksumm vector, allocation vector
	DEFW DIBCBH,DTBCBH	;BCB list header
	DEFW 0FFFFH		;no HASH
	DEFB 0			;hash bank
IDCT:	DEFB 01111100B
	DEFB 10000000B
	DEFB 1,16,40

*EJECT
;Kontron KDS format:
	DEFW K$WRITE
	DEFW K$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 1,1	        ;relative drive one
KDS:    DEFW XLTA		;translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPBA 		;disk parameter block
	DEFW CSV3,ALV3       	;checksumm vector, allocation vector
	DEFW DIBCBH,DTBCBH	;BCB list header
	DEFW 0FFFFH		;no HASH
	DEFB 0			;hash bank
KDCT:	DEFB 01111000B
	DEFB 01000000B
	DEFB 1,32,77

*EJECT
;RAM disk:
	DEFW M$WRITE
	DEFW M$READ
	DEFW FD$LOGIN
	DEFW M$INIT0
	DEFB 0,4
RAM:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPBC   		;disk parameter block
	DEFW 0			;no CSV
	DEFW 0FFFEH,0FFFEH	;ALV, DIRBCB alloc'd by GENCPM
	DEFW 0FFFFH       	;no data buffer
	DEFW 0FFFEH		;HASH alloc'd by GENCPM
	DEFB 0			;hash bank

*EJECT
;RAIR format:
	DEFW R$WRITE
	DEFW R$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 1,1	        ;relative drive one
RAIR:   DEFW 0   		;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPBD 		;disk parameter block
	DEFW CSV3,ALV3       	;checksumm vector, allocation vector
	DEFW DIBCBH,DTBCBH	;BCB list header
	DEFW 0FFFFH		;no HASH
	DEFB 0			;hash bank
RDCT:	DEFB 01111000B
	DEFB 10000000B
	DEFB 2,20,80

*EJECT
;alphaTronic P3/P4 format:
	DEFW A$WRITE
	DEFW A$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 1,1	        ;relative drive one
ALPHAP3:DEFW 0   		;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPBE 		;disk parameter block
	DEFW CSV3,ALV3       	;checksumm vector, allocation vector
	DEFW DIBCBH,DTBCBH	;BCB list header
	DEFW 0FFFFH		;no HASH
	DEFB 0			;hash bank
ADCT:	DEFB 01111000B
	DEFB 11000000B
	DEFB 1,10,80

*EJECT
;virtual disk drive P:
	DEFW P$WRITE
	DEFW P$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 1,1	        ;relative drive one
DRIVEP:	DEFW XLTF		;translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPBF 		;disk parameter block
	DEFW CSVF,ALVF      	;checksumm vector, allocation vector
	DEFW DIBCBH,DTBCBH	;BCB list header
	DEFW 0FFFFH		;no HASH
	DEFB 0			;hash bank
PDCT:	DEFB 01110000B
	DEFB 10000000B
	DEFB 2,20,80

;sector translation tables:
XLT3:	DEFB 0,6,12,18,24,4,10,16,22,2,8,14,20
	DEFB 1,7,13,19,25,5,11,17,23,3,9,15,21

XLTA:	DEFB 0,3,6,9,12,15,2,5,8,11,14,1,4,7,10,13

XLTF:	DEFB 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
	DEFB 17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33
	DEFB 34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51

;checksumm vector:
CSV3:	DEFS 64
CSVF:	DEFS 64

;allocation vectors:
ALV3:	DEFS 99
ALVF:	DEFS 100

;BCB list header:
DIBCBH:	DEFW DIRBCB
DTBCBH:	DEFW DTABCB

;directory control block:
DIRBCB:	DEFB 0FFH
	DEFS 9
	DEFW DIRBUF
	DEFB 0
	DEFW 0

;data control block:
DTABCB:	DEFB 0FFH
	DEFS 9
	DEFW DTABUF
	DEFB 0
	DEFW 0

;directory buffer:
DIRBUF:	DEFS 1024

;data buffer:
DTABUF:	DEFS 1024


*EJECT
	CSEG			;DPB must be resident

;Disk Parameter Blocks (DPB)
DPB0: 	DEFW 72			;128 byte records per track
	DEFB 6,63		;block shift and mask
	DEFB 3			;extent mask
	DEFW 1617		;maximum block number
	DEFW 1023		;maximum directory entry number
	DEFB 0F0H,0		;alloc vector for directory
	DEFW 8000H		;checksumm size
	DEFW 1			;offset for system tracks
	DEFB 3,7		;physical sector size shift and mask

DPB12:	DEFW 80			;128 byte records per track
	DEFB 4,15		;block shift and mask
	DEFB 0			;extent mask
	DEFW 389		;maximum block number
	DEFW 191		;maximum directory entry number
	DEFB 0E0H,0		;alloc vector for directory
	DEFW 48			;checksumm size
	DEFW 2			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask

DPB3: 	DEFW 26			;128 byte records per track
	DEFB 3,7 		;block shift and mask
	DEFB 0			;extent mask
	DEFW 242		;maximum block number
	DEFW 63 		;maximum directory entry number
	DEFB 0C0H,0		;alloc vector for directory
	DEFW 16			;checksum size
	DEFW 2			;offset for system tracks
	DEFB 0,0		;physical sector size shift and mask

DPB8: 	DEFW 32 		;128 byte records per track
	DEFB 4,15		;block shift and mask
	DEFB 1			;extent mask
	DEFW 157		;maximum block number
	DEFW 63 		;maximum directory entry number
	DEFB 80H,0		;alloc vector for directory
	DEFW 16			;checksum size
	DEFW 1			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask

DPBA: 	DEFW 32 		;128 byte records per track
	DEFB 4,15		;block shift and mask
	DEFB 0			;extent mask
	DEFW 299		;maximum block number
	DEFW 255		;maximum directory entry number
	DEFB 0F0H,0		;alloc vector for directory
	DEFW 64			;checksum size
	DEFW 4			;offset for system tracks
	DEFB 1,1		;physical sector size shift and mask

DPBC:	DEFW 447		;128 byte records per track
	DEFB 3,7 		;block shift and mask
	DEFB 0			;extent mask
	DEFW 110		;maximum block number
	DEFW 31 		;maximum directory entry number
	DEFB 80H,0		;alloc vector for directory
	DEFW 8000H		;checksum size
	DEFW 0			;offset for system tracks
	DEFB 0,0		;physical sector size shift and mask

DPBD: 	DEFW 4  		;128 byte records per track
	DEFB 4,15		;block shift and mask
	DEFB 0			;extent mask
	DEFW 390		;maximum block number
	DEFW 127		;maximum directory entry number
	DEFB 0C0H,0		;alloc vector for directory
	DEFW 32			;checksum size
	DEFW 36			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask

DPBE: 	DEFW 80			;128 byte records per track
	DEFB 4,15		;block shift and mask
	DEFB 0			;extent mask
	DEFW 394		;maximum block number
	DEFW 127		;maximum directory entry number
	DEFB 0C0H,0		;alloc vector for directory
	DEFW 32			;checksum size
	DEFW 1			;offset for system tracks
	DEFB 3,7		;physical sector size shift and mask

DPBF: 	DEFW 80			;128 byte records per track
	DEFB 4,15		;block shift and mask
	DEFB 0			;extent mask
	DEFW 394		;maximum block number
	DEFW 191		;maximum directory entry number
	DEFB 0E0H,0		;alloc vector for directory
	DEFW 48			;checksumm size
	DEFW 1			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask


*EJECT
	DSEG			;rest in banked memory

;hard disk init routine:
DS$INIT:XOR  A			;bank 0, drive 0
	LD   D,A		;track 0
	LD   E,A
	LD   B,A		;sector 0
	LD   HL,SPARE$DIRECTORY	;^buffer
	LD   C,16		;function #
	CALL ?USERF		;read in spare directory
	OR   A			;any errors ?
	RET  Z			;return if not
	LD   HL,DS$ERRMSG	;^error message --> reg. HL
	CALL ?PMSG		;print it
	JR   $			;...and hang up!
DS$ERRMSG:
	DEFB SUB
	DEFM 'HARD DISK FAULT'
	DEFB 0


*EJECT
;RAM disk init routine:
POWUP	EQU  111DH		;power up/reset marker	

M$INIT0:LD   A,(POWUP)		;power up ?
	OR   A
	RET  Z			;return if not

;clear RAM disk:
	LD   C,32		;entry count	        --> reg. C
	LD   DE,128		;^first directory entry --> reg. DE
CLRNXT:	PUSH BC			;save remaining entry count
	PUSH DE			;save ^directory entry
	LD   HL,CLRBYT		;^E5 		  --> reg. HL
	LD   BC,1 SHL 8+15      ;byte count 	  --> reg. B
				;function #	  --> reg. C
	LD   A,2		;source      bank # = 0
				;destination bank # = 2
	CALL ?USERF		;clear current entry
	POP  HL			;^current directory entry --> reg. HL
	LD   DE,32		;offset to next entry     --> reg. DE
	ADD  HL,DE		;add offset
	EX   DE,HL		;^next directory entry    --> reg. DE
	POP  BC			;restore entry count
	DEC  C			;decrement it
	JR   NZ,CLRNXT		;clear next entry
	RET
CLRBYT:	DEFB 0E5H


*EJECT
;hard disk read routine:
DS$READ:LD   A,16  		;function number --> accu
	JR   DS$TASK

;hard disk write routine:
DS$WRITE:
	LD   A,17		;function number --> accu
DS$TASK:LD   (DS$MODE),A	;save function number

;*****************************************************
;* Bad block administration (sector skipping method) *
;* originally written by Andy Johnson-Laird	     *
;* modified by Thomas Holte (c) 1985		     *
;* (you've fooled me with many errors, Andy !!!)     *	
;*****************************************************
SECTORS$PER$TRACK EQU 9 
SPARE$LENGTH	  EQU 1024	;341 entries, 3 bytes each

	LD   HL,SPARE$DIRECTORY-3
				;HL -> spare directory - 1 entry

	LD   DE,(@TRK)		;get requested track
	LD   A,(@SECT)		;get sector number

CHECK$ENTRY:
	LD   C,A		;save sector number for later
	LD   B,0   		;set counter

CHECK$ENTRY1:
	INC  HL			;update to next (or first entry)
	INC  HL
	INC  HL

	INC  B			;update count

	CALL CMPM		;compare req. track to table entry

	JR   Z,TRACKS$MATCH	;possible match of track and sector
	JR   NC,COMPUTE$INCREMENT
				;requested track < table entry
	JR   CHECK$ENTRY1	;requested track > table entry

TRACKS$MATCH:
	INC  HL			;HL -> MS byte of track
	INC  HL			;HL -> sector
	LD   A,(HL)		;get sector from table
	DEC  HL
	DEC  HL

	CP   C			;compare with requested sector
	JR   Z,SECTORS$MATCH	;track/sector matches
	JR   NC,COMPUTE$INCREMENT
				;req. trk/sec < spare trk/sec
	JR   CHECK$ENTRY1	;move to next table entry

SECTORS$MATCH:
	INC  B			;if track and sectors match with
				;a table entry, then an additional 
				;sector must be skipped

COMPUTE$INCREMENT:		;B contains number of cumulative
				;number of sectors to skip
	DEC  B			;0 sectors to skip ?
	JP   Z,DS$IO		;if yes, go to physical sector read/write 
	LD   A,C		;get requested sector
	ADD  A,B		;skip required number
	LD   B,SECTORS$PER$TRACK;determine final sector number
				;and track increment
	CALL DIV$A$BY$B		;returns C = quotient, A = remainder
	LD   (@SECT),A          ;A = new sector number

	LD   B,0		;make track increment a word
	EX   DE,HL    		;get requested track
	ADD  HL,BC		;add on increment
	LD   (@TRK),HL		;save updated track
	EX   DE,HL		;get table pointer
	JP   CHECK$ENTRY	;go to physical disk read/write

; DIV$A$BY$B
; Divide A by B
;
; This routine divides A by B, returning the quotient in C
; and the remainder in A.
;
; Entry parameters
;
;	A = dividend
;	B = divisor
;
; Exit parameters
;
;	A = remainder
;	C = quotient
;
DIV$A$BY$B:
	LD   C,0		;initialize quotient
DIV$A$BY$B$LOOP:
	INC  C			;increment quotient
	SUB  B			;subtract divisor
	JP   P,DIV$A$BY$B$LOOP	;repeat if result still +ve
	DEC  C			;correct quotient
	ADD  A,B		;correct remainder
	RET

; CMPM
; Compare memory
;
; This subroutine compares the contents of DE to (HL) and (HL+1)
; returning with the flags as though the subtraction (HL) - DE
; were performed.
;
; Entry parameters
;
;	HL -> word in memory
;	DE =  value to be compared
;
; Exit parameters
;
;	Flags set for (HL) - DE
;
CMPM:	INC  HL
	LD   A,(HL)		;get MS byte
	CP   D
	DEC  HL			;return with HL unchanged
	RET  NZ			;return now if MS bytes unequal
	LD   A,(HL)		;get LS byte
	CP   E
	RET

SPARE$DIRECTORY:
	DEFS SPARE$LENGTH	;spare directory itself
	DEFW -1			;end marker

;*****************************************************

DS$IO:	LD   A,(DS$MODE)	;function #    --> reg. C		
	LD   C,A
	LD   A,(@SECT)		;sector number --> reg. B
	LD   B,A
	LD   A,(@DBNK)		;DMA bank      --> accu (upper nibble)
	SLA  A
	SLA  A
	SLA  A
	SLA  A
	LD   HL,@RDRV		;relative drive number --> accu (lower nibble)
	ADD  A,(HL)
	LD   DE,(@TRK)		;track number	       --> reg. DE
	LD   HL,(@DMA)		;DMA address	       --> reg. HL
	CALL ?USERF		;transfer hard disk sector
	OR   A			;any errors ?
	RET  Z			;return if not
	LD   A,1		;return common error code
	RET
DS$MODE:DEFS 1			;access mode
		

*EJECT
;disk read routine:
FD$READ:LD   A,(@SECT)		;sector number	       --> reg. B
	LD   B,A
	LD   A,(@TRK)		;track number	       --> reg. E
	LD   E,A 
FD$REA1:LD   A,(@RDRV)		;relative drive number --> reg. C
	LD   C,A
	LD   A,(@DBNK)		;DMA bank --> accu (upper nibble)
	SLA  A
	SLA  A
	SLA  A
	SLA  A
	OR   C			;set drive number
	LD   HL,(@DMA)		;user buffer address   --> reg. HL
	LD   C,11		;function number       --> reg. C
	CALL ?USERF		;read physical disk sector
	LD   (DISK$STATUS),A	;save status for error messages
	OR   A			;any errors ?
	JP   NZ,RDERR	
	RET

;suppress error message if BDOS is returning errors to application ...
RDERR:	LD   A,(@ERDME)
	INC  A
	JR   Z,R$HARD$ERROR

;had permanent error, print message like:
;	BIOS Error on d: T-nn, S-nn, <type>, Retry ?
	CALL ?PDERR		;print message header
	LD   HL,(DISK$STATUS)	;get status byte from last error
	LD   H,0
	DEC  L
	ADD  HL,HL		;make byte offset
	LD   BC,R$ERROR$TABLE	;point at table of message addresses
	ADD  HL,BC
	LD   A,(HL)		;get specific message address
	INC  HL
	LD   H,(HL)
	LD   L,A
	CALL ?PMSG		;print message
	LD   HL,ERROR$MSG	;print "<BEL>, Retry (Y/N) ? "
	CALL ?PMSG
	CALL U$CONIN$ECHO	;get operator response
	LD   C,A		;save response
	LD   HL,MSG$END		;disable status line
	CALL ?PMSG	
	LD   A,C		;restore response
	CP   'Y'		;yes, then retry 10 more times
	JP   Z,FD$READ
R$HARD$ERROR:			;otherwise,
	LD   A,1		;return hard error to BDOS
	RET


*EJECT
;disk write routine:
FD$WRITE:
        LD   A,(@SECT)		;sector number	       --> reg. B
	LD   B,A
	LD   A,(@TRK)		;track number	       --> reg. E
	LD   E,A 
FD$WRI1:LD   A,(@RDRV)		;relative drive number --> reg. C
	LD   C,A
	LD   A,(@DBNK)		;DMA bank --> accu (upper nibble)
	SLA  A
	SLA  A
	SLA  A
	SLA  A
	OR   C			;set drive number
	LD   HL,(@DMA)		;user buffer address   --> reg. HL
	LD   C,12		;function number       --> reg. C
	CALL ?USERF		;write physical disk sector
	LD   (DISK$STATUS),A	;save status for error messages
	OR   A			;any errors ?
	JP   NZ,WRERR
	RET

;suppress error message if BDOS is returning errors to application ...
WRERR:	LD   A,(@ERDME)
	INC  A
	JR   Z,W$HARD$ERROR

;had permanent error, print message like:
;	BIOS Error on d: T-nn, S-nn, <type>, Retry ?
	CALL ?PDERR		;print message header
	LD   HL,(DISK$STATUS)	;get status byte from last error
	LD   H,0
	DEC  L
	ADD  HL,HL		;make byte offset
	LD   BC,W$ERROR$TABLE	;point at table of message addresses
	ADD  HL,BC
	LD   A,(HL)		;get specific message address
	INC  HL
	LD   H,(HL)
	LD   L,A
	CALL ?PMSG		;print message
	LD   HL,ERROR$MSG	;print "<BEL>, Retry (Y/N) ? "
	CALL ?PMSG
	CALL U$CONIN$ECHO	;get operator response
	LD   C,A		;save response
	LD   HL,MSG$END		;disable status line
	CALL ?PMSG	
	LD   A,C		;restore response
	CP   'Y'		;yes, then retry 10 more times
	JP   Z,FD$WRITE
W$HARD$ERROR:			;otherwise,
	LD   A,(DISK$STATUS)	;return hard error to BDOS
	CP   5			;diskette write protected ?
	LD   A,1		;common error code
	RET  NZ
	INC  A

;no login and init procedures:
FD$LOGIN:
FD$INIT:
	RET

U$CONIN$ECHO:			;get console input, echo it, and shift to
				;upper case
	CALL ?CONST		;see if any character already struck
	OR   A
	JR   Z,U$C1
	CALL ?CONIN		;yes, eat and try again
	JR   U$CONIN$ECHO
U$C1:	CALL ?CONIN
	PUSH AF
	LD   C,A
	CALL ?CONO
	POP  AF
	CP   'A'
	RET  C
	AND  0DFH   		;make upper case
	RET

DISK$STATUS:
	DEFS 1			;last error status code for messages


*EJECT
;IBM PC format:
I$READ:	LD   A,0FFH    		;mark READ
	JR   I$TASK
I$WRITE:XOR  A			;mark WRITE
I$TASK:	LD   (A$MODE),A
	LD   A,(IBMPC-2)	;relative drive number	  --> accu
	ADD  A,A		;*2
	LD   C,A		;save it
	ADD  A,A		;*4
	ADD  A,C		;*6
	LD   B,0		;relative drive # * 6	  --> reg. BC
	LD   C,A		
	LD   HL,DCT		;^drive control table     --> reg. HL
	ADD  HL,BC		;calc real pointer 
	PUSH HL			;save DCT pointer
	LD   DE,TDCT		;^temporary storage area  --> reg. DE
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;save disk parameters of drive B:
	LD   HL,IDCT		;^parameters for drive I: --> reg. HL
	POP  DE    		;DCT pointer              --> reg. DE
	PUSH DE			;save DCT pointer again
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;load disk parameters of drive I:
	LD   A,(@TRK)		;track number --> accu
	SUB  40			; >= 40 ?
	JR   NC,I$TASK1		;jump if yes
	ADD  A,40		;restore track number
	LD   E,A		;store it
	LD   A,(@SECT)		;sector number --> accu
	JR   I$TASK2
I$TASK1:LD   E,A		;save it
	LD   A,40		;build new track # (counts backward)
	SUB  E
	DEC  A
	LD   E,A		;store it
	LD   A,(@SECT)		;sector number --> accu
	ADD  A,8		;adjust it
I$TASK2:LD   B,A		;store sector number

	LD   A,(A$MODE)		;read or write ?
	OR   A
	JR   Z,I$TASK3		;jump if write
	CALL FD$REA1		;read sector
	JR   I$TASK4
I$TASK3:CALL FD$WRI1		;write sector

I$TASK4:LD   HL,TDCT		;restore original disk parameters
	POP  DE
	LD   BC,5
	LDIR
	LD   HL,IDCT+1		;get drive status
	SET  0,(HL)		;set init bit
	RET


*EJECT
;Kontron KDS format:
K$READ:	LD   A,0FFH    		;mark READ
	JR   K$TASK
K$WRITE:XOR  A			;mark WRITE
K$TASK:	LD   (A$MODE),A
	LD   A,(KDS-2)		;relative drive number	  --> accu
	ADD  A,A		;*2
	LD   C,A		;save it
	ADD  A,A		;*4
	ADD  A,C		;*6
	LD   B,0		;relative drive # * 6	  --> reg. BC
	LD   C,A		
	LD   HL,DCT		;^drive control table     --> reg. HL
	ADD  HL,BC		;calc real pointer 
	PUSH HL			;save DCT pointer
	LD   DE,TDCT		;^temporary storage area  --> reg. DE
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;save disk parameters of drive B:
	LD   HL,KDCT		;^parameters for drive K: --> reg. HL
	POP  DE    		;DCT pointer              --> reg. DE
	PUSH DE			;save DCT pointer again
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;load disk parameters of drive K:
	LD   A,(@TRK)		;track number --> accu
	SUB  77			; >= 77 ?
	JR   NC,K$TASK1		;jump if yes
	ADD  A,77		;restore track number
        LD   E,A		;store it
	LD   A,(@SECT)		;sector number --> accu
	JR   K$TASK2
K$TASK1:LD   E,A		;save it
	LD   A,(@SECT)		;sector number --> accu
	ADD  A,16		;adjust it
K$TASK2:LD   B,A		;store sector number

	LD   A,(A$MODE)		;read or write ?
	OR   A
	JR   Z,K$TASK3		;jump if write
	CALL FD$REA1		;read sector
	JR   K$TASK4
K$TASK3:CALL FD$WRI1		;write sector

K$TASK4:LD   HL,TDCT		;restore original disk parameters
	POP  DE
	LD   BC,5
	LDIR
	LD   HL,KDCT+1		;get drive status
	SET  0,(HL)		;set init bit
	RET


*EJECT
;RAM disk I/O routines
M$READ:	LD   A,0FFH		;switch on read flag
	JR   TASKM
M$WRITE:XOR  A			;clear read flag
TASKM:	LD   (RDFLAG),A
	LD   A,(@TRK)		;track # --> accu
	ADD  A,2		;calc source bank #
	ADD  A,A
	ADD  A,A
	ADD  A,A
	ADD  A,A
	LD   HL,@DBNK		;get destination bank # 
	ADD  A,(HL)
	PUSH AF			;save bank numbers
	LD   DE,(@DMA)		;DMA address --> reg. DE
	LD   HL,(@SECT)		;sector #    --> reg. HL
	INC  HL			;adjust it
	LD   B,7		;sector # * 128
	ADD  HL,HL
	DJNZ $-1
	LD   BC,128 SHL 8+15	;sector length --> reg. B
				;function #    --> reg. C
	LD   A,(RDFLAG)		;read or write ?
	OR   A
	JR   NZ,TASKM1		;jump if read
	POP  AF			;restore bank numbers
	RLCA			;swap bank numbers
	RLCA
	RLCA
	RLCA
	PUSH AF			;push bank numbers again
	EX   DE,HL
TASKM1:	POP  AF			;restore bank numbers 
	CALL ?USERF		;transfer "sector"
	XOR  A
	RET
RDFLAG:	DEFS 1


*EJECT
;RAIR format:
R$READ:	LD   A,0FFH    		;mark READ
	JR   R$TASK
R$WRITE:XOR  A			;mark WRITE
R$TASK:	LD   (A$MODE),A
	LD   A,(RAIR-2)		;relative drive number	  --> accu
	ADD  A,A		;*2
	LD   C,A		;save it
	ADD  A,A		;*4
	ADD  A,C		;*6
	LD   B,0		;relative drive # * 6	  --> reg. BC
	LD   C,A		
	LD   HL,DCT		;^drive control table     --> reg. HL
	ADD  HL,BC		;calc real pointer 
	PUSH HL			;save DCT pointer
	LD   DE,TDCT		;^temporary storage area  --> reg. DE
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;save disk parameters of drive B:
	LD   HL,RDCT		;^parameters for drive L: --> reg. HL
	POP  DE    		;DCT pointer              --> reg. DE
	PUSH DE			;save DCT pointer again
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;load disk parameters of drive O:
	LD   A,(@TRK)		;track # (LSB) 			    --> reg. C
	LD   C,A
	LD   A,(@TRK+1)		;track # (MSB) 			    --> accu
	LD   DE,20		;number of physical sectors / track --> reg. DE
	LD   HL,0      		;clear accumulator
	LD   B,16		;init counter
R$TASK1:RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
        SBC  HL,DE    		;subtract divisor
	JR   NC,$+3		;subtraction ok
        ADD  HL,DE		;restore accumulator
	CCF			;restore carry flag
	DJNZ R$TASK1		;counter = 0 ?
	RL   C			;get last result bit
	RLA
	LD   E,C		;now reg. E contains track #
	LD   B,L		;now reg. B contains sector #

	LD   A,(A$MODE)		;read or write ?
	OR   A
	JR   Z,R$TASK3		;jump if write
	CALL FD$REA1		;read sector
	JR   R$TASK4
R$TASK3:CALL FD$WRI1		;write sector

R$TASK4:LD   HL,TDCT		;restore original disk parameters
	POP  DE
	LD   BC,5
	LDIR
	LD   HL,RDCT+1		;get drive status
	SET  0,(HL)		;set init bit
	RET


*EJECT
;alphaTronic P3/P4 format:
A$READ:	LD   A,0FFH    		;mark READ
	JR   A$TASK
A$WRITE:XOR  A			;mark WRITE
A$TASK:	LD   (A$MODE),A
	LD   A,(ALPHAP3-2)	;relative drive number	  --> accu
	ADD  A,A		;*2
	LD   C,A		;save it
	ADD  A,A		;*4
	ADD  A,C		;*6
	LD   B,0		;relative drive # * 6	  --> reg. BC
	LD   C,A		
	LD   HL,DCT		;^drive control table     --> reg. HL
	ADD  HL,BC		;calc real pointer 
	PUSH HL			;save DCT pointer
	LD   DE,TDCT		;^temporary storage area  --> reg. DE
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;save disk parameters of drive B:
	LD   HL,ADCT		;^parameters for drive O: --> reg. HL
	POP  DE    		;DCT pointer              --> reg. DE
	PUSH DE			;save DCT pointer again
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;load disk parameters of drive O:
        LD   A,(@SECT)		;sector number --> accu
	LD   B,A		;sector number --> reg. B
	CP   5
	LD   A,(@TRK)		;track number  --> accu
	LD   E,A		;track number  --> reg. E
	JR   C,A$TASK1		;jump if sector # is lower than 5
        OR   A			;track 0 ?
	JR   NZ,A$TASK2		;jump if not track 0
	INC  E        		;convert track # to 1
	LD   A,B		;sector # --> accu
	SUB  5			;convert it
	LD   B,A		;store it
	JR   A$TASK2
A$TASK1:DEC  A			;track 1 ?
	JR   NZ,A$TASK2		;jump if not track 1
	LD   E,A		;convert track # to 0
	LD   A,B		;sector # --> accu
	ADD  A,5		;convert it
	LD   B,A		;store it
A$TASK2:LD   A,(@RDRV)		;relative drive number --> reg. C
	LD   C,A
	LD   A,(@DBNK)		;DMA bank --> accu (upper nibble)
	SLA  A
	SLA  A
	SLA  A
	SLA  A
	OR   C			;set drive number
	LD   HL,(@DMA)		;user buffer address   --> reg. HL
	LD   D,A		;save drive/bank #
	LD   A,(A$MODE)		;read or write ?
	OR   A
	LD   A,D		;restore drive/bank #
	JR   Z,A$TASK3		;jump if write

	LD   C,11		;function number       --> reg. C
	CALL ?USERF		;read physical disk sector
	LD   (DISK$STATUS),A	;save status for error messages
	OR   A			;any errors ?
	CALL NZ,RDERR	
	JR   A$TASK4

A$TASK3:LD   C,12		;function number       --> reg. C
	CALL ?USERF		;write physical disk sector
	LD   (DISK$STATUS),A	;save status for error messages
	OR   A			;any errors ?
	CALL NZ,WRERR

A$TASK4:LD   HL,TDCT		;restore original disk parameters
	POP  DE
	LD   BC,5
	LDIR
	LD   HL,ADCT+1		;get drive status
	SET  0,(HL)		;set init bit
	RET
A$MODE:	DEFS 1			;mark READ/WRITE


*EJECT
;virtual disk drive:
DCT	EQU  10D7H		;drive control table (SYSTAB)

P$READ:	LD   IX,FD$READ		;read  routine vector     --> reg. IX
	JR   P$TASK
P$WRITE:LD   IX,FD$WRITE	;write routine vector     --> reg. IX
P$TASK:	LD   A,(DRIVEP-2)	;relative drive number	  --> accu
	ADD  A,A		;*2
	LD   C,A		;save it
	ADD  A,A		;*4
	ADD  A,C		;*6
	LD   B,0		;relative drive # * 6	  --> reg. BC
	LD   C,A		
	LD   HL,DCT		;^drive control table     --> reg. HL
	ADD  HL,BC		;calc real pointer 
	PUSH HL			;save DCT pointer
	LD   DE,TDCT		;^temporary storage area  --> reg. DE
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;save disk parameters of drive B:
	LD   HL,PDCT		;^parameters for drive P: --> reg. HL
	POP  DE    		;DCT pointer              --> reg. DE
	PUSH DE			;save DCT pointer again
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;load disk parameters of drive P:
	LD   HL,P$RET		;return address		  --> reg. HL
	PUSH HL			;push it
	JP   (IX)		;jump to driver
P$RET:	LD   HL,TDCT		;restore original disk parameters
	POP  DE
	LD   BC,5
	LDIR
	LD   HL,PDCT+1		;get drive status
	SET  0,(HL)		;set init bit
	RET
TDCT:	DEFS 5			;temporary storage area


*EJECT
;tables of pointers to error message strings
R$ERROR$TABLE:
	DEFW R1MSG
	DEFW R2MSG
	DEFW R3MSG
	DEFW R4MSG
	DEFW R5MSG
	DEFW R6MSG
	DEFW R7MSG
	DEFW R8MSG
	DEFW R9MSG
	
W$ERROR$TABLE:
	DEFW W1MSG
	DEFW W2MSG
	DEFW W3MSG
	DEFW W4MSG
	DEFW W5MSG
	DEFW W6MSG
	DEFW W7MSG
	DEFW W8MSG
	DEFW W9MSG
	
R1MSG:	DEFM ' Illegal drive #,'
	DEFB 0
R2MSG:	DEFM ' Track # too high,'
	DEFB 0
R3MSG:	DEFM ' Sector # too high,'
	DEFB 0
R4MSG:	DEFM ' Device not available,'
	DEFB 0
R5MSG:	DEFB 0
R6MSG:	DEFM ' Locked/deleted record,'
	DEFB 0
R7MSG:  DEFM ' Data record not found,'
	DEFB 0
R8MSG:	DEFM ' Parity error during read,'
	DEFB 0
R9MSG:	DEFM ' Lost data during read,'
	DEFB 0

W1MSG:	DEFM ' Illegal drive #,'
	DEFB 0
W2MSG:	DEFM ' Track # too high,'
	DEFB 0
W3MSG:	DEFM ' Sector # too high,'
	DEFB 0
W4MSG:	DEFM ' Device not available,'
	DEFB 0
W5MSG:	DEFM ' Write protected diskette,'
	DEFB 0
W6MSG:	DEFM ' Write fault on disk drive,'
	DEFB 0
W7MSG:  DEFM ' Data record not found,'
	DEFB 0
W8MSG:	DEFM ' Parity error during write,'
	DEFB 0
W9MSG:	DEFM ' Lost data during write,'
	DEFB 0

ERROR$MSG:
	DEFM ' Retry (Y/N) ? '
	DEFB 0

MSG$END:DEFB SUB,ESC,'D',0

	END
SG
	DEFW W8MSG
	DEFW W9MSG
	
R1MSG:	DEFM ' Illegal drive #,'
	DEFB 0
R2MSG:	DEFM ' Track # too high,'
	DEFB 0
R3MSG:	DEFееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;******************************************************************************
;*  D I S K I O  *  C P M S Y S 4 f  *  T h o m a s   H o l t e * 8 5 0 6 2 6 *
;******************************************************************************
;*									      *
;*  			    D I S K   H A N D L E R	      		      *
;*                          =======================                           *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	TITLE 'CP/M 3 DISKETTE HANDLER'

	DSEG

;Disk drive dispatching tables for linked BIOS
	GLOBAL DS0,MF0,RAM,DRIVEP

;Variables containing parameters passed by BDOS
	EXTERNAL @DTBL,@ADRV,@RDRV,@DMA,@TRK,@SECT,@DBNK,@CBNK

;System control block variables
	EXTERNAL @ERDME		;BDOS error mode

	EXTERNAL ?PMSG		;print message ^HL up to 0, saves reg. BC & DE
	EXTERNAL ?PDERR		;print BIOS disk error header
	EXTERNAL ?CONIN,?CONO	;con in and out
	EXTERNAL ?CONST		;get console status

	EXTERNAL ?BANK,?USERF

;ASCII control codes:
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape


;Extended Disk Parameter Headers (XDPHs)

	DEFW DS$WRITE
	DEFW DS$READ
	DEFW FD$LOGIN
	DEFW DS$INIT
	DEFB 0  	        ;relative drive zero
	DEFB 2			;drive type
				;  0 = floppy disk
				;  1 = floppy disk (special format)
				;  2 = Winchester
				;  3 = Winchester (cartridge)
				;  4 = RAM disk
DS0:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB0   		;disk parameter block
	DEFW 0            	;no CSV
	DEFW 0FFFEH,0FFFEH	;ALV, DIRBCB, DTABCB, HASH
	DEFW 0FFFEH,0FFFEH	;alloc'd by GENCPM
	DEFB 0			;hash bank

	DEFW FD$WRITE
	DEFW FD$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 0,0	        ;relative drive zero
MF0:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB1   		;disk parameter block
	DEFW 0FFFEH,0FFFEH	;CSV, ALV, DIRBCB, DTABCB, HASH
	DEFW 0FFFEH,0FFFEH	;alloc'd by GENCPM
	DEFW 0FFFEH
	DEFB 0			;hash bank

*EJECT
;RAM disk:
	DEFW M$WRITE
	DEFW M$READ
	DEFW FD$LOGIN
	DEFW M$INIT0
	DEFB 0,4
RAM:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPBC   		;disk parameter block
	DEFW 0			;no CSV
	DEFW 0FFFEH,0FFFEH	;ALV, DIRBCB alloc'd by GENCPM
	DEFW 0FFFFH       	;no data buffer
	DEFW 0FFFEH		;HASH alloc'd by GENCPM
	DEFB 0			;hash bank

*EJECT
;virtual disk drive P:
	DEFW P$WRITE
	DEFW P$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 1,1	        ;relative drive one
DRIVEP:	DEFW XLT  		;translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPBF 		;disk parameter block
	DEFW CSV,ALV       	;checksumm vector, allocation vector
	DEFW DIBCBH,DTBCBH	;BCB list header
	DEFW 0FFFFH		;no HASH
	DEFB 0			;hash bank
PDCT:	DEFB 01110000B
	DEFB 10000000B
	DEFB 2,20,80

;translation tables:
XLT:	DEFB 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
	DEFB 17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33
	DEFB 34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51

;checksumm vector:
CSV:	DEFS 64

;allocation vectors:
ALV:	DEFS 100

;BCB list header:
DIBCBH:	DEFW DIRBCB
DTBCBH:	DEFW DTABCB

;directory control block:
DIRBCB:	DEFB 0FFH
	DEFS 9
	DEFW DIRBUF
	DEFB 0
	DEFW 0

;data control block:
DTABCB:	DEFB 0FFH
	DEFS 9
	DEFW DTABUF
	DEFB 0
	DEFW 0

;directory buffer:
DIRBUF:	DEFS 1024

;data buffer:
DTABUF:	DEFS 1024


*EJECT
	CSEG			;DPB must be resident

;Disk Parameter Blocks (DPB)
DPB0: 	DEFW 68			;128 byte records per track
	DEFB 6,63		;block shift and mask
	DEFB 3			;extent mask
	DEFW 1298		;maximum block number
	DEFW 1023		;maximum directory entry number
	DEFB 0F0H,0		;alloc vector for directory
	DEFW 8000H		;checksumm size
	DEFW 1			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask

DPB1:	DEFW 80			;128 byte records per track
	DEFB 4,15		;block shift and mask
	DEFB 0			;extent mask
	DEFW 389		;maximum block number
	DEFW 191		;maximum directory entry number
	DEFB 0E0H,0		;alloc vector for directory
	DEFW 48			;checksumm size
	DEFW 2			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask

DPBC:	DEFW 447		;128 byte records per track
	DEFB 3,7 		;block shift and mask
	DEFB 0			;extent mask
	DEFW 110		;maximum block number
	DEFW 31 		;maximum directory entry number
	DEFB 80H,0		;alloc vector for directory
	DEFW 8000H		;checksum size
	DEFW 0			;offset for system tracks
	DEFB 0,0		;physical sector size shift and mask

DPBF: 	DEFW 80			;128 byte records per track
	DEFB 4,15		;block shift and mask
	DEFB 0			;extent mask
	DEFW 394		;maximum block number
	DEFW 191		;maximum directory entry number
	DEFB 0E0H,0		;alloc vector for directory
	DEFW 48			;checksumm size
	DEFW 1			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask


*EJECT
	DSEG			;rest in banked memory

;hard disk init routine:
DS$INIT:XOR  A			;bank 0, drive 0
	LD   D,A		;track 0
	LD   E,A
	LD   B,A		;sector 0
	LD   HL,SPARE$DIRECTORY	;^buffer
	LD   C,16		;function #
	CALL ?USERF		;read in spare directory
	OR   A			;any errors ?
	RET  Z			;return if not
	LD   HL,DS$ERRMSG	;^error message --> reg. HL
	CALL ?PMSG		;print it
	JR   $			;...and hang up!
DS$ERRMSG:
	DEFB SUB
	DEFM 'HARD DISK FAULT'
	DEFB 0


*EJECT
;RAM disk init routine:
POWUP	EQU  111DH		;power up/reset marker	

M$INIT0:LD   A,(POWUP)		;power up ?
	OR   A
	RET  Z			;return if not

;clear RAM disk:
	LD   C,32		;entry count	        --> reg. C
	LD   DE,128		;^first directory entry --> reg. DE
CLRNXT:	PUSH BC			;save remaining entry count
	PUSH DE			;save ^directory entry
	LD   HL,CLRBYT		;^E5 		  --> reg. HL
	LD   BC,1 SHL 8+15      ;byte count 	  --> reg. B
				;function #	  --> reg. C
	LD   A,2		;source      bank # = 0
				;destination bank # = 2
	CALL ?USERF		;clear current entry
	POP  HL			;^current directory entry --> reg. HL
	LD   DE,32		;offset to next entry     --> reg. DE
	ADD  HL,DE		;add offset
	EX   DE,HL		;^next directory entry    --> reg. DE
	POP  BC			;restore entry count
	DEC  C			;decrement it
	JR   NZ,CLRNXT		;clear next entry
	RET
CLRBYT:	DEFB 0E5H


*EJECT
;hard disk read routine:
DS$READ:LD   A,16  		;function number --> accu
	JR   DS$TASK

;hard disk write routine:
DS$WRITE:
	LD   A,17		;function number --> accu
DS$TASK:LD   (DS$MODE),A	;save function number

;*****************************************************
;* Bad block administration (sector skipping method) *
;* originally written by Andy Johnson-Laird	     *
;* modified by Thomas Holte (c) 1985		     *
;* (you've fooled me with many errors, Andy !!!)     *	
;*****************************************************
SECTORS$PER$TRACK EQU 17
SPARE$LENGTH	  EQU 512 	;170 entries, 3 bytes each

	LD   HL,SPARE$DIRECTORY-3
				;HL -> spare directory

	LD   DE,(@TRK)		;get requested track
	LD   A,(@SECT)		;get sector number

CHECK$ENTRY:
	LD   C,A		;save sector number for later
	LD   B,0   		;set counter

CHECK$ENTRY1:
	INC  HL			;update to next (or first entry)
	INC  HL
	INC  HL

	INC  B			;update count

	CALL CMPM		;compare req. track to table entry

	JR   Z,TRACKS$MATCH	;possible match of track and sector
	JR   NC,COMPUTE$INCREMENT
				;requested track < table entry
	JR   CHECK$ENTRY1	;requested track > table entry

TRACKS$MATCH:
	INC  HL			;HL -> MS byte of track
	INC  HL			;HL -> sector
	LD   A,(HL)		;get sector from table
	DEC  HL
	DEC  HL

	CP   C			;compare with requested sector
	JR   Z,SECTORS$MATCH	;track/sector matches
	JR   NC,COMPUTE$INCREMENT
				;req. trk/sec < spare trk/sec
	JR   CHECK$ENTRY1	;move to next table entry

SECTORS$MATCH:
	INC  B			;if track and sectors match with
				;a table entry, then an additional 
				;sector must be skipped

COMPUTE$INCREMENT:		;B contains number of cumulative
				;number of sectors to skip
	DEC  B			;0 sectors to skip ?
	JP   Z,DS$IO		;if yes, go to physical sector read/write 
	LD   A,C		;get requested sector
	ADD  A,B		;skip required number
	LD   B,SECTORS$PER$TRACK;determine final sector number
				;and track increment
	CALL DIV$A$BY$B		;returns C = quotient, A = remainder
	LD   (@SECT),A          ;A = new sector number

	LD   B,0		;make track increment a word
	EX   DE,HL    		;get requested track
	ADD  HL,BC		;add on increment
	LD   (@TRK),HL		;save updated track
	EX   DE,HL		;get table pointer
	JP   CHECK$ENTRY	;go to physical disk read/write

; DIV$A$BY$B
; Divide A by B
;
; This routine divides A by B, returning the quotient in C
; and the remainder in A.
;
; Entry parameters
;
;	A = dividend
;	B = divisor
;
; Exit parameters
;
;	A = remainder
;	C = quotient
;
DIV$A$BY$B:
	LD   C,0		;initialize quotient
DIV$A$BY$B$LOOP:
	INC  C			;increment quotient
	SUB  B			;subtract divisor
	JP   P,DIV$A$BY$B$LOOP	;repeat if result still +ve
	DEC  C			;correct quotient
	ADD  A,B		;correct remainder
	RET

; CMPM
; Compare memory
;
; This subroutine compares the contents of DE to (HL) and (HL+1)
; returning with the flags as though the subtraction (HL) - DE
; were performed.
;
; Entry parameters
;
;	HL -> word in memory
;	DE =  value to be compared
;
; Exit parameters
;
;	Flags set for (HL) - DE
;
CMPM:	INC  HL
	LD   A,(HL)		;get MS byte
	CP   D
	DEC  HL			;return with HL unchanged
	RET  NZ			;return now if MS bytes unequal
	LD   A,(HL)		;get LS byte
	CP   E
	RET

SPARE$DIRECTORY:
	DEFS SPARE$LENGTH	;spare directory itself
	DEFW -1			;end marker

;*****************************************************

DS$IO:	LD   A,(DS$MODE)	;function #    --> reg. C		
	LD   C,A
	LD   A,(@SECT)		;sector number --> reg. B
	LD   B,A
	LD   A,(@DBNK)		;DMA bank      --> accu (upper nibble)
	SLA  A
	SLA  A
	SLA  A
	SLA  A
	LD   HL,@RDRV		;relative drive number --> accu (lower nibble)
	ADD  A,(HL)
	LD   DE,(@TRK)		;track number	       --> reg. DE
	LD   HL,(@DMA)		;DMA address	       --> reg. HL
	CALL ?USERF		;transfer hard disk sector
	OR   A			;any errors ?
	RET  Z			;return if not
	LD   A,1		;return common error code
	RET
DS$MODE:DEFS 1			;access mode
		

*EJECT
;disk read routine:
FD$READ:LD   A,(@SECT)		;sector number	       --> reg. B
	LD   B,A
	LD   A,(@TRK)		;track number	       --> reg. E
	LD   E,A 
FD$REA1:LD   A,(@RDRV)		;relative drive number --> reg. C
	LD   C,A
	LD   A,(@DBNK)		;DMA bank --> accu (upper nibble)
	SLA  A
	SLA  A
	SLA  A
	SLA  A
	OR   C			;set drive number
	LD   HL,(@DMA)		;user buffer address   --> reg. HL
	LD   C,11		;function number       --> reg. C
	CALL ?USERF		;read physical disk sector
	LD   (DISK$STATUS),A	;save status for error messages
	OR   A			;any errors ?
	JP   NZ,RDERR	
	RET

;suppress error message if BDOS is returning errors to application ...
RDERR:	LD   A,(@ERDME)
	INC  A
	JR   Z,R$HARD$ERROR

;had permanent error, print message like:
;	BIOS Error on d: T-nn, S-nn, <type>, Retry ?
	CALL ?PDERR		;print message header
	LD   HL,(DISK$STATUS)	;get status byte from last error
	LD   H,0
	DEC  L
	ADD  HL,HL		;make byte offset
	LD   BC,R$ERROR$TABLE	;point at table of message addresses
	ADD  HL,BC
	LD   A,(HL)		;get specific message address
	INC  HL
	LD   H,(HL)
	LD   L,A
	CALL ?PMSG		;print message
	LD   HL,ERROR$MSG	;print "<BEL>, Retry (Y/N) ? "
	CALL ?PMSG
	CALL U$CONIN$ECHO	;get operator response
	LD   C,A		;save response
	LD   HL,MSG$END		;disable status line
	CALL ?PMSG	
	LD   A,C		;restore response
	CP   'Y'		;yes, then retry 10 more times
	JP   Z,FD$READ
R$HARD$ERROR:			;otherwise,
	LD   A,1		;return hard error to BDOS
	RET


*EJECT
;disk write routine:
FD$WRITE:
        LD   A,(@SECT)		;sector number	       --> reg. B
	LD   B,A
	LD   A,(@TRK)		;track number	       --> reg. E
	LD   E,A 
FD$WRI1:LD   A,(@RDRV)		;relative drive number --> reg. C
	LD   C,A
	LD   A,(@DBNK)		;DMA bank --> accu (upper nibble)
	SLA  A
	SLA  A
	SLA  A
	SLA  A
	OR   C			;set drive number
	LD   HL,(@DMA)		;user buffer address   --> reg. HL
	LD   C,12		;function number       --> reg. C
	CALL ?USERF		;write physical disk sector
	LD   (DISK$STATUS),A	;save status for error messages
	OR   A			;any errors ?
	JP   NZ,WRERR
	RET

;suppress error message if BDOS is returning errors to application ...
WRERR:	LD   A,(@ERDME)
	INC  A
	JR   Z,W$HARD$ERROR

;had permanent error, print message like:
;	BIOS Error on d: T-nn, S-nn, <type>, Retry ?
	CALL ?PDERR		;print message header
	LD   HL,(DISK$STATUS)	;get status byte from last error
	LD   H,0
	DEC  L
	ADD  HL,HL		;make byte offset
	LD   BC,W$ERROR$TABLE	;point at table of message addresses
	ADD  HL,BC
	LD   A,(HL)		;get specific message address
	INC  HL
	LD   H,(HL)
	LD   L,A
	CALL ?PMSG		;print message
	LD   HL,ERROR$MSG	;print "<BEL>, Retry (Y/N) ? "
	CALL ?PMSG
	CALL U$CONIN$ECHO	;get operator response
	LD   C,A		;save response
	LD   HL,MSG$END		;disable status line
	CALL ?PMSG	
	LD   A,C		;restore response
	CP   'Y'		;yes, then retry 10 more times
	JP   Z,FD$WRITE
W$HARD$ERROR:			;otherwise,
	LD   A,(DISK$STATUS)	;return hard error to BDOS
	CP   5			;diskette write protected ?
	LD   A,1		;common error code
	RET  NZ
	INC  A

;no login and init procedures:
FD$LOGIN:
FD$INIT:
	RET

U$CONIN$ECHO:			;get console input, echo it, and shift to
				;upper case
	CALL ?CONST		;see if any character already struck
	OR   A
	JR   Z,U$C1
	CALL ?CONIN		;yes, eat and try again
	JR   U$CONIN$ECHO
U$C1:	CALL ?CONIN
	PUSH AF
	LD   C,A
	CALL ?CONO
	POP  AF
	CP   'A'
	RET  C
	AND  0DFH   		;make upper case
	RET

DISK$STATUS:
	DEFS 1			;last error status code for messages


*EJECT
;RAM disk I/O routines
M$READ:	LD   A,0FFH		;switch on read flag
	JR   TASKM
M$WRITE:XOR  A			;clear read flag
TASKM:	LD   (RDFLAG),A
	LD   A,(@TRK)		;track # --> accu
	ADD  A,2		;calc source bank #
	ADD  A,A
	ADD  A,A
	ADD  A,A
	ADD  A,A
	LD   HL,@DBNK		;get destination bank # 
	ADD  A,(HL)
	PUSH AF			;save bank numbers
	LD   DE,(@DMA)		;DMA address --> reg. DE
	LD   HL,(@SECT)		;sector #    --> reg. HL
	INC  HL			;adjust it
	LD   B,7		;sector # * 128
	ADD  HL,HL
	DJNZ $-1
	LD   BC,128 SHL 8+15	;sector length --> reg. B
				;function #    --> reg. C
	LD   A,(RDFLAG)		;read or write ?
	OR   A
	JR   NZ,TASKM1		;jump if read
	POP  AF			;restore bank numbers
	RLCA			;swap bank numbers
	RLCA
	RLCA
	RLCA
	PUSH AF			;push bank numbers again
	EX   DE,HL
TASKM1:	POP  AF			;restore bank numbers 
	CALL ?USERF		;transfer "sector"
	XOR  A
	RET
RDFLAG:	DEFS 1


*EJECT
;virtual disk drive:
DCT	EQU  10D7H		;drive control table (SYSTAB)

P$READ:	LD   IX,FD$READ		;read  routine vector     --> reg. IX
	JR   P$TASK
P$WRITE:LD   IX,FD$WRITE	;write routine vector     --> reg. IX
P$TASK:	LD   A,(DRIVEP-2)	;relative drive number	  --> accu
	ADD  A,A		;*2
	LD   C,A		;save it
	ADD  A,A		;*4
	ADD  A,C		;*6
	LD   B,0		;relative drive # * 6	  --> reg. BC
	LD   C,A		
	LD   HL,DCT		;^drive control table     --> reg. HL
	ADD  HL,BC		;calc real pointer 
	PUSH HL			;save DCT pointer
	LD   DE,TDCT		;^temporary storage area  --> reg. DE
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;save disk parameters of drive B:
	LD   HL,PDCT		;^parameters for drive P: --> reg. HL
	POP  DE    		;DCT pointer              --> reg. DE
	PUSH DE			;save DCT pointer again
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;load disk parameters of drive P:
	LD   HL,P$RET		;return address		  --> reg. HL
	PUSH HL			;push it
	JP   (IX)		;jump to driver
P$RET:	LD   HL,TDCT		;restore original disk parameters
	POP  DE
	LD   BC,5
	LDIR
	LD   HL,PDCT+1		;get drive status
	SET  0,(HL)		;set init bit
	RET
TDCT:	DEFS 5			;temporary storage area


*EJECT
;tables of pointers to error message strings
R$ERROR$TABLE:
	DEFW R1MSG
	DEFW R2MSG
	DEFW R3MSG
	DEFW R4MSG
	DEFW R5MSG
	DEFW R6MSG
	DEFW R7MSG
	DEFW R8MSG
	DEFW R9MSG
	
W$ERROR$TABLE:
	DEFW W1MSG
	DEFW W2MSG
	DEFW W3MSG
	DEFW W4MSG
	DEFW W5MSG
	DEFW W6MSG
	DEFW W7MSG
	DEFW W8MSG
	DEFW W9MSG
	
R1MSG:	DEFM ' Illegal drive #,'
	DEFB 0
R2MSG:	DEFM ' Track # too high,'
	DEFB 0
R3MSG:	DEFM ' Sector # too high,'
	DEFB 0
R4MSG:	DEFM ' Device not available,'
	DEFB 0
R5MSG:	DEFB 0
R6MSG:	DEFM ' Locked/deleted record,'
	DEFB 0
R7MSG:  DEFM ' Data record not found,'
	DEFB 0
R8MSG:	DEFM ' Parity error during read,'
	DEFB 0
R9MSG:	DEFM ' Lost data during read,'
	DEFB 0

W1MSG:	DEFM ' Illegal drive #,'
	DEFB 0
W2MSG:	DEFM ' Track # too high,'
	DEFB 0
W3MSG:	DEFM ' Sector # too high,'
	DEFB 0
W4MSG:	DEFM ' Device not available,'
	DEFB 0
W5MSG:	DEFM ' Write protected diskette,'
	DEFB 0
W6MSG:	DEFM ' Write fault on disk drive,'
	DEFB 0
W7MSG:  DEFM ' Data record not found,'
	DEFB 0
W8MSG:	DEFM ' Parity error during write,'
	DEFB 0
W9MSG:	DEFM ' Lost data during write,'
	DEFB 0

ERROR$MSG:
	DEFM ' Retry (Y/N) ? '
	DEFB 0

MSG$END:DEFB SUB,ESC,'D',0

	END
es  1 =  256 bytes
                                ;          2 = 512 bytes  3 = 1024 bytes
                                ;bit 5   : 0 = new sector numbering on backside
                                ;          1 = sector numbering continued on
                                ;              backside
                                ;bit 0   : drive status (used by disk driver --
                                ;                        do not alter)
        DEFB 2                  ;interleaving factor
        DEFB 20                 ;sector count per track
        DEFB 80                 ;number of usable tracks
        DEFB 0                  ;current track

;drive 1:
        DEFB 01110000B
        DEFB 10000000B
        DEFB 2
        DEFB 20
        DEFB 80
        DEFB 0

;drive 2:
        DEFB 01110000B,10000000B,2,20,80,0

;drive 3:
        DEFB 01110000B,10000000B,2,20,80,0


;drive control tables (8 inch)

;drive 0:
        DEFB 00001010B
        DEFB 00000000B
      ;******************************************************************************
;*  D R V T B L  *  C P M S Y S 4 e  *  T h o m a s   H o l t e * 8 5 0 9 2 6 *
;******************************************************************************
;*									      *
;*  			     D R I V E   T A B L E			      *
;*                           =====================                            *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	GLOBAL @DTBL
	EXTERNAL DS0,MF0,RAM,DRIVEP


@DTBL:	DEFW DS0,MF0,0,0,0,0,0,0
	DEFW 0,0,0,0,RAM,0,0,DRIVEP
	DEFW RAM

	END
W9MSG:	DEFM ' Lost data during write,'
	DEFB 0

ERROR$MSG:
	DEFM ' Retry (Y/N) ? '
	DEFB 0

MSG$END:DEFB SUB,ESC,'D',0

	END
sec
                                ;1 = 0.5 msec    7 = 3.5 msec   12 = 6.0 msec
				;2 = 1.0 msec    8 = 4.0 msec   13 = 6.5 msec
				;3 = 1.5 msec    9 = 4.5 msec   14 = 7.0 msec
				;4 = 2.0 msec   10 = 5.0 msec   15 = 7.5 msec
				;5 = 2.5 msec
        DEFB 10000000B          ;bits 7,6: sector length
                                ;          0 =  256 bytes  1 = 512 bytes
                                ;          2 = 1024 bytes  3 = 128 bytes
                                ;bit 0   : drive status (used by disk driver --
                                ;                        do not alter)
	DEFB 32   		;starting track for write precomp / 4
        DEFB 1                  ;interleaving factor
        DEFB 9                  ;sector count per track
        DEFW 1440               ;number of usable tracks

;drive 1:
        DEFB 00100000B
        DEFB 10000000B
        DEFB 0FFH
        DEFB 1 
        DEFB 9
        DEFW 612

;drive 2:
        DEFB 00100000B,01000000B,0,1,16
   BACK,UP         BACKUP               
;;
INPUTERA	$"^j^mEnter files to erase as a filelist:  "IF ~NU $'L1;ERASE $'L1;SP;ELSE;ECHO ^M^J N%>OTHING ENTERED!;FI
INPUT		$Z$"^m^jEnter penultimate command ^[) ('EXIT' to exit ZEX completely):  ^[("$ZIF EQ $'E1 EXIT;ECHO ^M^JR%>ETURNING TO %<ZCPR3...;RS %CURDU;POKE $+M0008 0;ELSE;$'L1;FI
INPUTRET	$Z$"^m^jEnter final command ^[)('EXIT' to exit ZEX completely):  ^[("$ZFI;IF EQ $'E1 EXIT;ECHO ^M^JA%>BORTING %<ZEX %>SCRIPT...;RS %CURDU;POKE $+M0008 0;ELSE;$'L1;RS E R%>ETURNING TO %<ZEX %>SCRIPT AT LETTER%< %$RF05...;HOLD 2;FI

D,IR		SDZ $*

THIS ALIAS PROVIDES A DIRECTORY-DISPLAY COMMAND IN WHICH THE FILE
 ; SPECIFICATION IS AUTOMATICALLY WILDCARDED.  IT SAVES THE TROUBLE OF
 ; HAVING TO TYPE ASTERISKS MANUALLY.

D!=SD/	        SDZ $TD1$TU1:$TN1*.$TT1* $-1

 ; THIS ALIAS IS USED WITH THE SYNTAX NAME DU:DIR PW OR NAME DIR PW TO ASSIGN
 ; THE NAMED DIRECTORY DIR TO THE DESIGNATED (OR CURRENT) DRIVE/USER.  THE
 ; SECOND TOKEN IS OPTIONAL; IF PRESENT, IT WILL ASSIGN A PASSWORD AS WELL.

FOR             format $1;initdir $1;set $1[update=on,access=on] 



NAME=SETNAME	EDITNDR $TD1$TU1:$TN1 $2 \X



 ; this will format a disc on a Computer with CP/M PLUS and prepare DS

CREATE=MAKEDISK	format $1;zex initime $1;set $1[name=$"DISKNAME> "$'L1,create,update]


make=initdir $1;set $1[name=$"DISKNAME> "$'L1,create,update]

 ; THIS ALIAS CAN HELP TO TEMPORARILY CHANGE A DU: NAME

RENDIR		NAME10 $1


 ; THIS ALIAS WILL SAVE THE CURRENTLY DEFINED NAMED DIRECTORIES IN THE FILE
 ; A0:Z3PLUS.NDR.  IF A COMMAND TAIL BEGINNING WITH 'L' (FOR LIBRARY) IS
 ; INCLUDED, THE FILE WILL BE PUT INTO Z3PLUS.LBR SO THAT IT WILL AUTOMATICALLY
 ; BE LOADED AT Z-SYSTEM COLD BOOT AND THE INDIVIDUAL NDR FILE WILL BE ERASED.

PUTNDR		SAVENDR C0:DEFAULT;IF EQ $1 L*;LPUT C0:DEFAULT C0:DEFAULT.NDR;ERA C0:DEFAULT.NDR;FI

 ; THIS ALIAS WILL ALLOW YOU TO EXAMINE A FILE.  IT LOADS THE FILE INTO THE
 ; TPA AND THEN USES THE RCP PEEK COMMAND TO EXAMINE IT.  IT WILL LOAD A FILE
 ; FROM THE CURRENT DIRECTORY EVEN IF THAT DIRECTORY IS NOT ON THE PATH.

LOOK		GET 100 $TD1$TU1:$TF1;P 100


 ; THIS IS TO QUIT Z3PLUS

CPM=OFF=EXIT		Z3PLUS OFF

 ; THIS ALIAS PROVIDES A SHORTHAND FOR THE CRUNCH COMMAND.

CR,UNCH		crunch $*
UNCR,UNCH       uncrunch $*
ZF,ILER         zfiler $* 
ZP,ATCH         zpatch $* 
QLIST           ql $*


 ; F}r das Programm MSDOS um IBM Disketten lesen zu k|nnen, muss das
 ; Z3PLUS SMALL Modell eingeschaltet werden, sonst zuwenig Speicher.
 
MSDOS		fremd ibm-pc;z3plus small;c0:mstocpm;z3plus

 

 ; THE FOLLOWING PAIR OF ALIASES AUTOMATES A RECURSIVE INVOCATION OF SOME
 ; OTHER COMMAND LINE.  IT IS INVOKED AS RECURSE COMMANDLINE.

REC,URSE	IF NU $1;ECHO;ECHO %<  S%>YNTAX: %<$0 CMDNAME [PARAMETERS];ECHO;ELSE; RECURSE2 $*;FI
RECURSE2	FI;$*;IF IN R%>UN %<"$1" %>AGAIN? ; $0 $*


 ; THE FOLLOWING PAIR OF ALIASES AUTOMATES THE REPEATED INVOCATION OF A
 ; COMMAND THAT TAKES A SINGLE ARGUMENT.  IT IS INVOKED AS
 ; REPEAT COMMAND ARG1 ARG2 ... ARGN.  THE COMMAND COMMAND IS EXECUTED
 ; IN SEQUENCE, FIRST WITH ARG1, THEN WITH ARG2, AND SO ON.

REP,EAT		IF NU $2;ECHO;ECHO %<  S%>YNTAX: %<$0 CMDNAME ARG1 ARG2 ...;ECHO;ELSE; REPEAT2 $*;FI
REPEAT2		FI;$1 $2;IF ~NU $3; REPEAT2 $1 $-2
 
 ; Der ALIAS RAMINIT soll einige Programme auf die RAMDisk kopieren, 
 ; weil ich die wichtig finde.
 
INI,TRAM        pip m:=pip.com;pip m:=fremd.com;pip m:=zfiler.com;pip m:=xd.com;pip m:=lsh.com;pip m:=zde.com;pip m:=ql.com;pip m:=zpatch.com;pip m:=dir.com

 ; Die folgenden ALIASes geben einige Contolcodes aus. Der Zugriff wird
 ; entschieden vereinfacht.
 ; STATOFF = Statuszeile aus
 ; WRAPON  = Wrap around modus on
 ; WRAPOFF = Wrap around modus off
 ; WSKBD   = Word Star Keyboard
 ; NKBD    = Normal Keyboard

STATOFF         echo ^[D
WRAPON          echo ^[X
WRAPOFF         echo ^[Y
WSKBD           echo ^[O
NKBD            echo ^[N

 ; Der ALIAS EH initialisiert den Errorhandler bzw. die Eingabeshell
 
EH                era m:lsh.cmd;m:lsh m:lsh.cmd

 ; Mit HOLERAUS werden Files aus einer .LBR-Datei herausgeholt, entcruncht
 ; und die gecrunchten Files werden geloescht.
 
HOLERAUS       lget $1 *.*;uncrunch *.*;era *.?z?

   
 ; Diese ALIASe erleichtern den Zugang zu den Named Directorys
 
COM,:=COMM,:=COM,MANDS:=A0,:              a0:
WOR,:=WORK,:=B0,:                         b0: 
K[M,:=K[MP,:=K[M,PFF:=P0,:                p0:
BASE,:=ROOT,:                             c0:
ASM,:=SLR,:                               c2:
TURBO:=PASCAL:                            c3:
ZMP:=MEX:=MOD:=MODE:=MODE,M:              c4:
UTI,ILITY:                                c1:
SOUR,CES:				  c5:
CAT,ALOG:                                c14: 
NEU,ES:                                  c13:   
MIX,ED:                                  c10:
PROF,:                                    o0:


      ; Dieser Alias ruft VLU auf, wenn ein LBR-Filename eingegeben wird
 
>LBR      vlu $tn0 

 ; Memory Display Aliases
 
PBIOS=BIOS                  p $ab
PCCP=CCP=CPR                p $ac
PDOS=DOS                    p $ad
PENV=ENV                    p $ae
PFCP=FCP                    p $af
PIOP=IOP                    p $ai
PMCL=MCL                    p $al
PMSG=MSG                    p $am
PNDR=NDR                    p $an
PPATH                       p $ap
PRCP=RCP                    p $ar
PSHL=PSHELL=SHELL           p $as
PXFCB=PFCB=FCB              p $ax
PTCAP                       p f000

; Die folgenden Files befinden sich auf C6:Z3COM> und muessen so nicht
; im Suchpfad mit angegeben werden.


@10=COMP=IMP2Z44=ABORT=CPSET=IMP2Z45=ACOPY=CRUNCH=IOBUG=ACREATE           c6:$!
DCREATE=LAP=ADIR=DIFF=LINKPRL=ARK11=EXAMREL=MAKE27=ARK11ZS                c6:$!
EXL=MCOPY=BALIAS=BCINS=EXTEND=MEX+2ZE=BCOMP=FINDERR=MEX+2ZS               c6:$!
BEEP=FOR=MEX2ZE=GETVAR=MEX2ZS=CD39=GOTO=MKDIR32=CLRCST=HELPC              c6:$!
MKLINE=CLRRSX=HELPPR10=MU3=CMD=HOLDZ=NAME=HP11=NEXT11=COMMEN20            c6:$!
HPRSX=PAGE=PAUSE=SHSET22=TRIM=PIPE18=SHVAR=TY3MTEST=PPIP=SLOWDOWN         c6:$!
TY4MTEST=PROTECT=SNAP=TYPELZ22=PUSH12=SNAPRCP=TYPEQZ17=QLUX=SPEEDUP       c6:$!
QLUXBBS=SUB34=RCP-COM=T4GEN01=UNSQ=REG=T4N41=UNZIP099=RENAMEZ=TALIAS      c6:$!
VCED18=RESOLVE=TCCHECK=VCINST20=RLIB12=TCMAKE=VCOMP=SETFILE=VFILER        c6:$!
SHDEFINE=TESTERR=VID=SHELLINI=TEX13=VREN=SHFILE11=TEXT2DB=WHEEL=SHOW14    c6:$!
TEXT2DB=XECHO=SHOWSHST=TPA=Z-GOLF=Z33FILLD=ZLUXKMD=ZPATCH13=Z33VEH11      c6:$!
ZCNFG14=ZPUZZLE=Z33VER10=ZCNFG14=ZRDPUB=ZCOPY=ZXLATE14=Z3LOCATE           c6:$!
ZDDTZ=ZZAP21=ZGREP                                                        c6:$!

;Insert this into your ALIAS.CMD (or LSH.CMD for that matter!) - Rick Charnes
GST  cls;box 0 3 10 19 60;go 0 5 15 15 50;go 0 7 20 11 40;gxymsg 10 30 gst does exactly;go 12 32 what i want!


_:=__:=___:=____:=_____:=______:=_______:=________: if whl;echo d%>irectory %<$0%> is not an allowed directory. ^m^j%<t%>he valid directories are:^m^j;pwd;fi;echo

TRL-UP-ARROW
	DEFB LF,ETX,SUB 	;DOWN-ARROW, SHIFT-DOWN-ARROW, CTRL-DOWN-ARROW
	DEFB SOH,CAN,BS  	;LEFT-ARROW, SHIFT-LEFT-ARROW, CTRL-LEFT-ARROW
	DEFB ACK,HT,BEL  	;RGHT-ARROW, SHIFT-RGHT-ARROW, CTRL-RGHT-ARROW
	DEFB ' ',' ',0 		;SPACE     , SHIFT-SPACE     , CTRL-SPACE

;address 38A0H (function keys):	
	DEFB 80H,80H,0  	;F1, SHIFT-F1, CTRL-F1
	DEFB 81H,81H,0  	;F2, SHIFT-F2, CTRL-F2
	DEFB 82H,82H,0  	;F3, SHIFT-F3, CTRL-F3
	DEFB 83H,83H,0  	;F4, SHIFT-F4, CTRL-F4
	DEFB 84H,84H,0  	;F5, SHIFT-F5, CTRL-F5
	DEFB 85H,85H,0  	;F6, SHIFT-F6, CTRL-F6
	DEFB 86H,86H,0  	;F7, SHIFT-F7, CTRL-F7
	DEFB 87H,87H,0 		;F8, SHIFT-F8, CTRL-F8

;address 38C0H (number keys [numeric keypad]):	
	DEFB '0','0',0  	;1, SHIFT-1, CTRL-1
	DEFB '1','1',0  	;2, SHIFT-2, CTRL-2
	DEFB '2','3',0  	;3, SHIFT-3, CTRL-3
	DEFB '3','3',0  	;4, SHIFT-4, CTPL-4
	DEFB '4','4',0  	;5, SHIFT-5, CTRL-5
	DEFB '5','5',0  	;6, SHIFT-6, CTRL-6
	DEFB '6','6',0  	;7, SHIFT-7, CTRL-7
	DEFB '7','7',0 		;8, SHIFT-8, CTRL-8

;address 388
; DEFAULT.Z3P file -- Z3PLUS default system descriptor values

; (11/05/89)
; Changed for Volker Dose - Genie IIIs Holte CP/M 3a 03.10.90
; jetzt auch mit 10 MB Festplatte C:
; The syntax here is:
;
; VARIABLENAME = VALUE ; any comment
;
; values are DECIMAL by default
;
;	 nn. is also DECIMAL
;	 nnH is HEX
;      nnnnB is BINARY
;
; The '=' sign isn't required.  You can also use 'equ',
; or just a space or tab separator.

;-------------------------

; THE FOLLOWING VALUES SHOULD ALWAYS BE ADJUSTED TO DESCRIBE YOUR SYSTEM.

EXPATHS = 5



; vector of valid drives, bit 0 is A:...bit 15 is P:
; set a 0 digit for each unavailable drive (binary number ends with 'B')

DRVVEC  = 1101000000000111B	;  <-- set bits for valid drives
;         PONMLKJIHGFEDCBA

; The highest drive and user number that may be accessed
; by the command processor when loading a file or parsing
; a command line.

MAXDRV	= 16	; note --> A: = 1, ... P: = 16
MAXUSR	= 15	; 15 is the limit for CP/M 3 bdos

; Clock speed of your computer

SPEED	=  7	; cpu in mhz

; CRT definitions

COLS	= 80	; CRT terminal width
ROWS	= 24	; total rows (lines)
LINS	= 22	; rows of text

; Printer definitions

PCOL	= 80	; PRT width
PROW	= 72	; total rows (lines)
PLIN	= 64	; total lines of text
FORM	=  1	; 1 if printer can form-feed using form-feed character

;-------------------------

; THE FEATURES AND MEMORY REQUIREMENTS OF YOUR Z3PLUS SYSTEM ARE
DETERMINED
; BY THE FOLLOWING VALUES.  Values marked with '*' should not
normally be
; changed.

; Z-System segment sizes (in 128-byte records)

Z3ENVS	=   2	; * environment size (1 + 1 for termcap)
CCPS	=  20	; * command processor size
RCPS 	=  18	;   resident command package size
FCPS	=   5	;   flow command package size

; Z-System segment sizes (in other units)

Z3NDIRS	=  25	;   names in named directory register
Z3CLS	= 200   ;   MULTIPLE COMMAND LINE (max value =250)

;-------------------------

; OTHER ITEMS THAT YOU ARE LESS LIKELY TO WANT TO CHANGE.

; The name of the startup command that is executed when Z3PLUS
; is loaded for the first time.  That command may be an alias,
; to load terminal definition, error handler, shell, or whatever.

STARTUP = STARTZ3P	; ascii string, no spaces

; The command search path for a file.  Use one to five pairs
; of drive-usernumber combinations. "$" means the current drive
; or user number.  The final pair is the "root" directory, and


PATH = m0$$c1c0

; Other environment parameters

QUIET	=  0	; 1 if commands are to be silent
WHEEL	= FFh	; 0 to disable protected commands

DUOK	=  1	; 1 if ok to change directory using drive-user: form

;-------------------------

; DO NOT CHANGE ANY OF THE FOLLOWING VALUES

;CRT	= 0
;PRT	= 0

; These environment variables are reserved for future
; development.

SPAR1	0	; spare byte at z3env+36h

SPAR2	0	; spare bytes at z3env+3Bh
SPAR3	0	; +3Ch
SPAR4	0	; +3Dh
SPAR5	0	; +3Eh

; The environment type should be left set to 80h.
; Future developments may use higher values.

ENVTYP	= 80h	; environment type

; end of DEFAULT.Z3P
 be an alias,
; to load terminal definition, error handler, shell, or whatever.

STARTUP = STARTZ3P	; ascii string, no spaces

; The command search path for a file.  Use one to five pairs
; of drive-usernumber combinations. "$" means the current drive
; or user number.  The final pair is the "root" directory, and


PATH = m0$$c1c0

; Other environment parameters

QUIEeen
	DEFB DC3,93H,SOH 	;LEFT-ARROW, SHIFT-LEFT-ARROW, CTRL-LEFT-ARROW
				;      LEFT-ARROW = cursor left
				;SHIFT-LEFT-ARROW = start of line
				;CTRL -LEFT-ARROW = word left
	DEFB EOT,94H,ACK  	;RGHT-ARROW, SHIFT-RGHT-ARROW, CTRL-RGHT-ARROW
				;      RIGHT-ARROW = cursor right
				;SHIFT-RIGHT-ARROW = end of line
				;CTRL -RIGHT-ARROW = word right
	DEFB ' ',' ',95H	;SPACE     , SHIFT-SPACE     , CTRL-SPACE
				;CTRL-SPACE = hard space

;address 38A0H (function keys):	
	DEFB SYN,SYN,0  	;FHOLTE-CP/M + 8 
    =%+ %+   R S   W V       Ћ Ќ Њ ‹ Ѓ Ђ   — † … ‚ ѓ „                                          y using drive-user: form

;-------------------------

; DO NOT CHANGE ANY OF THE FOLLOWING VALUES

;CRT	= 0
;PRT	= 0

; These environment variables are reserved for future
; development.

SPAR1	0	; spare byte at z3env+36h

SPAR2	0	; spare bytes at z3env+3Bh
SPAR3	0	; +3Ch
SPAR4	0	; +3Dh
SPAR5	0	; +3Eh

; The environment type should be left set to 80h.
; Future d toggle right justifying

;address 38C0H (number keys [numeric keypad]):	
	DEFB '0','0',0  	;1, SHIFT-1, CTRL-1
	DEFB '1','1',0  	;2, SHIFT-2, CTRL-2
	DEFB '2','3',0  	;3, SHIFT-3, CTRL-3
	DEFB '3','3',0  	;4, SHIFT-4, CTRL-4
	DEFB '4','4',0  	;5, SHIFT-5, CTRL-5
	DEFB '5','5',0  	;6, SHIFT-6, CTRL-6
	DEFB '6','6',0  	;7, SHIFT-7, CTRL-7
	DEFB '7','7',0 		;8, SHIFT-8, CTRL-8

;address 3880H (function keys & escape key):
	DEFB 0,0,0      	;SHIFT
	DEFB 0,0,0      	;CTRL
	DEFB ESC,ESC,0  	;ESC
	DEFB ETX,ETX,0 		;P5, SHIFT-P5, CTRL-P5
				;P5 = page down
	DEFB DC2,DC2,0  	;P4, SHIFT-P4, CTRL-P4
				;P4 = page up	
	DEFB SUB,SUB,0  	;P3, SHIFT-P3, CTRL-P3
				;P3 = line down
	DEFB ETB,ETB,0  	;P2, SHIFT-P2, CTRL-P2
				;P2 = line up
	DEFB HT,HT,0    	;P1, SHIFT-P1, CTRL-P1
				;P1 = TAB

;address 38E0H (number & special keys [numeric keypad]):	
	DEFB '8','8',0  	;8 , SHIFT-8 , CTRL-8
	DEFB '9','9',0  	;9 , SHIFT-9 , CTRL-9
	DEFB 0FEH,0FEH,0	;00, SHIFT-00, CTRL-00
	DEFB 0,0,0      	;LOCK
	DEFB ',',',',0  	;, , SHIFT-, , CTRL-,
	DEFB '-','-',0  	;- , SHIFT-- , CTRL--
	DEFB '.','.',0  	;. , SHIFT-. , CTRL-.
	DEFB 0,0FBH,0		;SHIFT-PRINT


*EJECT
VECTOR:	DEFW FKEYS 		;function key vector

OFFSET  DEFL 0			;initialize offset

FKEYS:	REPT 13			;function key pointer
	DEFW F0+OFFSET
OFFSET	DEFL OFFSET+81
	ENDM
	DEFW ERAEND,ERABEG,SOTXT,SOCRT,EOTXT,EOCRT
	DEFW SOLIN,EOLIN,HSPACE,HYPHEN,JSTIFY

F0:
;	.XLIST
   	REPT 13			;function key buffer
	DEFB 1
	REPT 80
	DEFB 0
	ENDM0 ! $"Enter ZFILER macro script: "
A ! $d$u:;zex pkxarc $f
B ! IF ~eq $t com and ~eq $t ar?;$d$u:;BISHOW $f;else;echo ^A f%>ile %<$f%> is not viewable! ^B;fi
C ! qlist $d$u:$f
D ! if eq $t lbr;$d$u:;ldir $f;else;$d$u:;SDZ $f $l;fi
E ! $d$u:;ZDE $f
G ! ZPATCH $d$u:$f
H ! HELP $P
K ! $d$u:;$!crunch $f $"Destination directory: "$"Comment in []? ";$h:
L ! $d$u:;F0:LOADND $"Login and update which Drive/User? "
M ! d0:;MENU;$HB
N ! $d$u:;Nulu $P:
P ! GET 100 $d$u:$f;p 100;p 180
Q ! $d$u:;f0:SQ $f;$h:
R ! $D$U:;F0:EXL $P
T ! $!f5:v $p
S ! if eq $t ?z? ;echo  PLEASE - N%>o %<crunched%>- files;else;$d$u:;SFCPC $f;fi
U ! if eq $t ?z?;$d$u:;uncunch $f;$h:;else;If eq $t ?y?;$d$u:;UCRLZH $f;FI
X ! if ~eq $t com;echo n%>ot a %<com%> file;else;$d$u:;:$n $" Command Tail: ";$h:;fi
V ! $d$u:;vlu;$h:
Z ! $d$u:;$" Command to perform on file: " $f $" Tail: ";$h:
#
	SAMPLE ZFILER COMMAND MACROS FOR USE WITH NZCOM AND Z3PLUS

macros:
        A.  ARC-viewing/extracting         N.  NSWEEP Multi-User op.
        B.  Bidirect. textview even LBR    O. 
        C.  QLIST even Crunched            P.  Look File
        D.  Display  LBR/ARC/ARK           Q.  Squeeze file
        E.  Edit file pointed to           R.  Read with cntrl chars
        F.                                 S.  Show large ASCII File
        G.  ZPATCH fname                   T.  Type it by V (.?Y? too)
        H.  HELP-DATABASE for ZCPR         U.  Uncrunch standard+.?Y?
        I.                                 V.  VLU Library utility
        J.                                 W. 
        K.  "K"runch the file              X.  eXecute the file
        L.  Log in and update D/U          Y. 
        M.  ===> Menu-System <====         Z.  perform command on file
       
                  =======  0.  on-line macro =======

               ZFILER parameters for use with macro '0' 
$!     ZEX 'GO'		$P  DU:FN.FT	$D  DRIVE $'..'  PROMPT  	$N  FN
$".."  PROMPT  		$F  FN.FT	$U  USER    $H  HOME DU		$T  FT
  Display  LBR/ARC/ARK           Q.  Squeeze file
        E.  Edit file pointed to           R.  Read with cntrl chars
        F.                                 S.  Show large ASCII File
        G.  ZPATCH fname                   T.  Type it by V (.?Y? too)
        H.  HELP-DATABASE for ZCPR         U.  Uncrunch standard+.?Y?
        I.                         ;          sec. on track  1 = one
                                ;bit 2   : steps per      0 = one step
                                ;          trk to trk     1 = two steps
                                ;bits 1,0: track stepping rate
                                ;          0 =  3 msec    1 =  6 msec
                                ;          2 = 10 msec    3 = 15 msec
        DEFB 10000000B          ;bits 7,6: sector length
                                ;          0 = 128 bytes  1 =  256 bytes
                                ;          2 = 512 bytes  3 = 1024 bytes
                                ;bit 5   : 0 = new sector numbering on backside
                                ;          1 = sector numbering continued on
                                ;              backside
                                ;bit 0   : drive status (used by disk driver --
                                ;                        do not alter)
        DEFB 2                  ;interleaving factor
        DEFB 20                 ;sector count per track
        DEFB 80                 ;number of usable tracks
        DEFB 0                  ;current track

;drive 1:
        DEFB 01110000B
        DEFB 10000000B
        DEFB 2
        DEFB 20
        DEFB 80
        DEFB 0

;drive 2:
        DEFB 01110000B,10000000B,2,20,80,0

;drive 3:
        DEFB 01110000B,10000000B,2,20,80,0


;drive control tables (8 inch)

;drive 0:
        DEFB 00001010B
        DEFB 00000000B
        DEFB 1
        DEFB 26
        DEFB 77
        DEFB 0

;drive 1:
        DEFB 00001010B,00000000B,1,26,77,0

;drive 2:
        DEFB 00001010B,00000000B,1,26,77,0

;drive 3:
        DEFB 00001010B,00000000B,1,26,77,0


TRYS:   DEFB 10                 ;# of times to try I/O until routine gives up


*EJECT
;Winchester disk control tables:

;drive 0:
DCTW:   DEFB 01100000B          ;bits 7-5: no. of surfaces
                                ;          0 = one   head    4 = five  heads
                                ;          1 = two   heads   5 = six   heads
                                ;          2 = three heads   6 = seven heads
                                ;          3 = four  heads   7 = eight heads
                                ;bit 4   : no. of first      0 = zero
                                ;          sector on track   1 = one
                                ;bits 3-0: track stepping rate
                                ;0 = 35  usec    6 = 3.0 msec   11 = 5.5 msec
                                ;1 = 0.5 msec    7 = 3.5 msec   12 = 6.0 msec
				;2 = 1.0 msec    8 = 4.0 msec   13 = 6.5 msec
				;3 = 1.5 msec    9 = 4.5 msec   14 = 7.0 msec
				;4 = 2.0 msec   10 = 5.0 msec   15 = 7.5 msec
				;5 = 2.5 msec
        DEFB 01000000B          ;bits 7,6: sector length
                                ;          0 =  256 bytes  1 = 512 bytes
                                ;          2 = 1024 bytes  3 = 128 bytes
                                ;bit 0   : drive status (used by disk driver --
                                ;                        do not alter)
	DEFB 32   		;starting track for write precomp / 4
        DEFB 1                  ;interleaving factor
        DEFB 17                 ;sector count per track
        DEFW 1224               ;number of usable tracks

;drive 1:
        DEFB 00100000B
        DEFB 10000000B
        DEFB 0FFH
        DEFB 1 
        DEFB 9
        DEFW 612

;drive 2:
        DEFB 00100000B,01000000B,0,1,16
        DEFW 1224


*EJECT
;powerup/reset parameters:

;powerup/reset marker:
POWUP:	DEFS 1

;table of video parameters:
VIDPAR: DEFB 110		;horizontal total
	DEFB 80			;horizontal displayed
	DEFB 86			;h sync position
	DEFB 10			;h sync width
	DEFB 28			;vertical total
	DEFB 4			;v total adjust
	DEFB 25  		;vertical displayed
	DEFB 25			;v sync position
	DEFB 0			;interlace mode (non interlace)
	DEFB 10			;max scan line address
	DEFB 6AH		;cursor start
	DEFB 10			;cursor end
	DEFB 0  		;start address (H)
	DEFB 0			;start address (L)
	DEFB 0			;cursor (H)
   	DEFB 0			;cursor (L)

;character set:
CHRSET:	DEFB 'A'		;'A' = ASCII  character set
				;'G' = German character set

;RS-232-C parameters:
SER0:	DEFB 11000100B
	DEFB 8

SER1:	DEFB 11000100B
	DEFB 8

;clock ?
CLOCK:	DEFB 0			;0 = software clock
				;1 = hardware clock 


*EJECT
;*******************
;*  $ V D I N I T  *
;*******************

;entry: HL = address of video parameter table

;  struct {
;	    char R0, R1, R2 , R3 , R4 , R5 , R6 , R7 ,
;		 R8, R9, R10, R11, R12, R13, R14, R15;
;	  } *HL;

;  R0  = This 8 bit write-only register determines the horizontal frequency of
;	 HS. It is the total of displayed plus non-displayed character time
;	 units minus one.
;  R1  = This 8 bit write-only register determines the number of displayed 
;	 characters per horizontal line.
;  R2  = This 8 bit write-only register determines the horizontal sync position
;	 on the horizontal line.
;  R3  = This 4 bit write-only register determines the width of the HS pulse.
;	 It may not be apparent why this width needs to be programmed. However,
;	 consider that all timing widths must be programmed as multiples of the
;	 character clock period which varies. If HS width were fixed as an
;	 integral number of character times, it would vary with character rate
;	 and be out of tolerance for certain monitors. The rate programmable
;	 feature allows compensating HS width.
;  R4
;  R5  = The vertical frequency of VS is determined by both R4 and R5. The
;	 calculated number of character line times is usually an integer plus a
;	 fraction to get exactly a 50 or 60 Hz vertical refresh rate. The
;	 integer number of character line times minus one is programmed in the
;	 7 bit write-only Vertical Total Register (R4); the fraction is
;	 programmed in the 5 bit write-only Vertical Scan Adjust Register (R5)
;	 as a number of scan line times.
;  R6  = This 7 bit write-only register determines the number of displayed
;	 character rows on the CRT screen, and is programmed in character row
;	 times.
;  R7  = This 7 bit write-only register determines the vertical sync position
;	 with respect to the reference. It is programmed in character row
;	 times.
;  R8  = This 2 bit write-only register controls the raster scan mode. When bit
;	 0 and bit 1 are reset, or bit 0 is reset and bit 1 set, the non-
;	 interlace raster scan mode is selected. Two interlace modes are
;	 available. Both are interlaced 2 fields per frame. When bit 0 is set
;	 and bit 1 is reset, the interlace sync raster scan mode is selected.
;	 Also when bit 0 and bit 1 are set, the interlace sync and video raster
;	 scan mode is selected.
;  R9  = This 5 bit write-only register determines the number of scan lines per
;	 character row including spacing. The programmed value is a max address
;	 and is one less than the number of scan lines.
;  R10 = This 7 bit write-only register controls the cursor format. Bit 5 is
;	 the blink timing control. When bit 5 is low, the blink frequency is
;	 1/16 of the vertical field rate, and when bit 5 is high, the blink
;	 frequency is 1/32 of the vertical field rate. Bit 6 is used to enable
;	 a blink. The cursor start scan line is set by the lower 5 bits.
;  R11 = This 5 bit write-only register sets the cursor end scan line.
;  R12
;  R13 = Start Address Register is a 14 bit write-only register which
;	 determines the first address put out as a refresh address after
;	 vertical blanking. It consists of an 8 bit lower register (R13), and a
;	 6 bit higher register (R12).
;  R14
;  R15 = This 14 read/write register stores the cursor location. This register
; 	 consists of an 8 bit lower (R15) and 6 bit higher (R14) register.
 
$CRTREG EQU  0F6H		;CRT controller address register
$CRTCMD EQU  0F7H		;CRTC command register

;initialize the video controller chip M6845:
$VDINIT:LD   A,10H		;source      bank = 1
				;destination bank = 0
VDINIT1:LD   DE,$VIDPAR		;^temp buffer 		   --> reg. DE
	LD   B,16		;length of parameter table --> reg. B
	CALL $XMOVE		;get video parameter table
        LD   BC,1000H		;CRTC register count       --> reg.  B
				;CRTC start register       --> reg.  C
	LD   HL,$VIDPAR		;^video parameter table    --> reg. HL
OUTCMD:	LD   A,C		;CRTC register no.         --> accu
       	OUT  ($CRTREG),A	;select CRTC register
	LD   A,(HL)		;video parameter --> accu
	OUT  ($CRTCMD),A	;output CRTC command
	INC  HL			;bump ^video parameter
	INC  C			;increment CRTC register no.
	DJNZ OUTCMD		;output 16 parameters
	LD   A,($VIDPAR+10)	;get control byte for cursor start
	LD   (CURBEG),A		;store it for subsequent use
	RET  			;return to caller

CURBEG:	DEFS 1			;temporary storage for cursor start byte
$VIDPAR:DEFS 16     		;temporary buffer for video parameter table


*EJECT
;*******************
;*  $ R S I N I T  *
;*******************

;entry: B = number  of RS232C interface (0, 1)
;	A = data format
;	E = baud rate

;  A
;  Bit    0: 0 = no   parity
;	     1 =      parity
;  Bit    1: 0 = odd  parity
;	     1 = even parity
;  Bits 3-2: 1 = 1   stop bit
;	     2 = 1.5 stop bits
;            3 = 2   stop bits
;  Bits 7-6: 0 = 5 bits word length
;	     1 = 7 bits word length
;	     2 = 6 bits word length
;	     3 = 8 bits word length

;  	    Desired Baud Rate  | reg. E
;	  =====================|=======
;          	 50	       |   2
;          	 75	       |   3
;	      	110	       |  15
;	  	134.5	       |   4
;	  	150	       |  14
;		200	       |   5
;	  	300	       |  13
;	  	600	       |   6
;	       1200	       |  11
;	       1800	       |  10
;	       2400	       |   7
;	       4800	       |   9
;	       9600	       |   8
;	      19200	       |   0


RATE	EQU  0F1H		;baud rate register
BTx  	EQU  0F2H		;dual baud rate register

;calc initialization routine entry:
$RSINIT:LD   HL,RSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine
	 
;RS232C initialization driver entry routine:
RSTAB:	DEFW RSINIA,RSINIB	

;control register of SIO A:
WR0A	EQU  0D2H

RSINIA: LD   C,A		;save data format
        AND  0C0H		;mask word length bits
	SET  0,A     		;receiver enable
	LD   (WR3A),A		;load write register 3
        LD   A,C   		;restore data format
	AND  0FH		;mask stop bits and parity
        SET  6,A		;x 16 clock mode
	LD   (WR4A),A		;load write register 4
	LD   A,C		;restore data format
	RRA
	AND  60H		;mask word length bits
	OR   88H   		;set DTR, transmitter enable
	LD   (WR5A),A		;load write register 5
	LD   A,B		;relative port number --> accu
	OR   A
	IN   A,(RATE)		;read baud rates
	AND  0F0H		;mask baud rate of channel A
	LD   HL,INITBLA
	JR   RSINIB1

INITBLA:DEFB 1
	DEFB BTx
	DEFB 0
	DEFB 9
        DEFB WR0A
	DEFB 18H		;channel reset
	DEFB 1
	DEFB 0			;disable interrupts
	DEFB 4
WR4A:	DEFS 1
	DEFB 5
WR5A:	DEFS 1
	DEFB 3
WR3A:	DEFS 1
	DEFB 0


*EJECT
;control register of SIO B:
WR0B	EQU  0D3H

RSINIB: LD   C,A		;save data format
        AND  0C0H		;mask word length bits
	SET  0,A     		;receiver enable
	LD   (WR3B),A		;load write register 3
        LD   A,C   		;restore data format
	AND  0FH		;mask stop bits and parity
        SET  6,A		;x 16 clock mode
	LD   (WR4B),A		;load write register 4
	LD   A,C		;restore data format
	RRA
	AND  60H		;mask word length bits
	OR   88H   		;set DTR, transmitter enable
	LD   (WR5B),A		;load write register 5
	LD   A,B		;relative port number --> accu
	OR   A
	IN   A,(RATE)		;read baud rates
	AND  0FH		;mask baud rate of channel B
	SLA  E			;shift baud rate code into upper nibble
	SLA  E
	SLA  E
	SLA  E
	LD   HL,INITBLB
RSINIB1:OR   E			;set baud rate
	OUT  (RATE),A		;output baud rate
RSINIB2:LD   A,(HL)
	OR   A			;end of table ?
	RET  Z			;return if yes
	LD   B,A		;byte count  --> reg. B
	INC  HL			;bump table pointer
	LD   C,(HL)		;port number --> reg. C
	INC  HL			;bump table pointer
	OTIR			;output bytes
	JR   RSINIB2		;output next byte stream

INITBLB:DEFB 1
	DEFB BTx
	DEFB 0
	DEFB 9
        DEFB WR0B
	DEFB 18H		;channel reset
	DEFB 1
	DEFB 0			;disable interrupts
	DEFB 4
WR4B:	DEFS 1
	DEFB 5
WR5B:	DEFS 1
	DEFB 3
WR3B:	DEFS 1
	DEFB 0

								
*EJECT
;*******************
;*  $ K B C H A R  *  
;*******************

;exit: A = char (0 = no char available)

$SYS0	EQU  0F9H		;bank select port 0
$SYS1	EQU  0FAH		;bank select port 1

;get a keyboard character if available:
$KBCHAR:LD   A,(RDYKEY)		;active key ?
	OR   A
	RET  NZ        		;return if yes
	DI			;disable the interrupts
	LD   A,(KLEN)		;A = buffer length
	OR   A			;jump if
	JR   Z,KBCHAR2		;buffer empty
	DEC  A			;dec the length
	LD   (KLEN),A		;save it
	LD   HL,(CPTR)		;HL = character pointer
	LD   A,(HL)		;A = key value
	LD   (RDYKEY),A		;store it
	INC  HL			;bump pointer
	LD   DE,KBUF+80		;DE = end of bufferr pointer
	EX   DE,HL		;swap the pointers
	SBC  HL,DE		;wrap around the buffer ?
	EX   DE,HL		;swap the pointers
	JR   NZ,KBCHAR1		;jump if no wrap around
	LD   HL,KBUF		;HL = new pointer
KBCHAR1:LD   (CPTR),HL		;save the pointer
KBCHAR2:EI			;reenable interrupts
	RET			;return

KLEN:	DEFB 0			;number of active keys
EPTR:	DEFW KBUF		;pointer to next free location
CPTR:	DEFW KBUF		;pointer to first active key
KBUF:	DEFS 80			;type ahead buffer

*EJECT
;this area makes the preliminary check of keyboard rows:
$SCAN:  IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11000110B		;enable memory mapped I/O
				;disable graphic page
				;enable keyboard
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	CALL SCAN		;scan keyboard
	LD   C,A		;code of scanned key --> reg. C
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A		;write it
	RET			;return to interrupt service routine
	
SCAN:	LD   HL,KEYHLD		;HL = keyboard work area ptr
	LD   IX,KEYBRD		;IX = row address table ptr
	LD   BC,38E0H		;BC = row A10 ptr
	LD   D,10 		; E = column index
	LD   A,(BC)		;load row 10
	AND  0F7H		;mask out LOCK key
	LD   E,A		;8 column bits
	XOR  (HL)               ;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E        		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row 10
	DEC  D			;decrement row index
       	INC  HL			;eleven byte buffer indexed by row
        LD   C,(IX)		;row address (LSB) --> reg. C
	LD   A,(BC)		;load row 9
	AND  0FCH		;mask out SHIFT + CTRL keys
	LD   E,A		;8 column bits
	XOR  (HL)               ;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E        		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row 9
     	INC  IX			;increment ^row address table
	DEC  D			;decrement row index
CHKKEY:	INC  HL			;ten byte buffer indexed by row
        LD   C,(IX)		;row address (LSB) --> reg. C
	LD   A,(BC)		;load row N
	LD   E,A		;8 column bits
	XOR  (HL)		;XOR with previous
	LD   (HL),E   		;store column bits in buffer
	AND  E     		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row N
     	INC  IX			;increment ^row address table
	DEC  D			;decrement row index
	JP   P,CHKKEY		;try next row

;check for previous key:
	PUSH AF			;save column bits
       	LD   HL,(OLDROW)	;^previous row   --> reg. HL
        LD   A,(OLCLMN)		;old column bits --> accu
        AND  (HL)               ;previous key active ?
	JR   NZ,PREV    	;jump to wait/repeat procedure if yes
	XOR  A			;clear repeat mode
	LD   (REPEAT),A
	LD   H,A
	LD   L,A
        LD   (COUNT1),HL        ;reset first counter
	LD   HL,(DELAY3)        ;preset second counter
	LD   (COUNT2),HL
	POP  AF      		;restore column bits
	RET   			;no key depression - return

;delay routine until key autorepeats:
PREV:	PUSH AF                 ;save previous column bits
	PUSH HL                 ;save previous row
	LD   HL,(COUNT1)        ;increment first counter
	INC  HL
   	LD   (COUNT1),HL
	LD   DE,(COUNT2)        ;and compare it with second counter
	LD   A,H
        CP   D
	JR   NZ,REST  
	LD   A,L
	CP   E
REST:  	POP  HL			;restore previous row
	JR   NZ,RTN		;return if first counter <> second counter
	POP  AF			;restore previous column bits
	CPL			;clear previous row
	AND  (HL)
	LD   (HL),A
	LD   A,1		;set repeat mode
	LD   (REPEAT),A		
	LD   HL,0		;clear first counter
	LD   (COUNT1),HL
	LD   HL,(DELAY4)	;initialize second counter
	LD   (COUNT2),HL	
	POP  AF			;adjust stack pointer
	JR   SCAN		;scan keyboard again
RTN:	POP  AF			;restore column bits
	POP  AF
	RET			;no key active - return
	
;fist debounce routine:
ACTIVE:	LD   E,A		;save column bits
	PUSH BC			;save active row address
	LD   BC,(DELAY1)	;delay count value
	CALL DELAY		;delay for 7.33 milliseconds (may be varied)
	POP  BC			;restore row address
	LD   A,(BC)		;and reload original flags from active row
	AND  E			;then combine current flag bits with original
				;flag bits
	RET  Z			;rtn to caller if zero because row was not
				;active on 2nd test
	LD   (OLDROW),HL	;save row

;calculate ordinal number of pressed key:
	LD   A,D		;otherwise we have a legimately active row
	RLCA			;row index * 2
	RLCA			;row index * 4
	RLCA			;row index * 8
	LD   D,A		;save in D
	LD   C,1		;start with bit 0
AGAIN:	LD   A,C		;mask
	AND  E			;test for non-zero column
	JR   NZ,FOUND		;go if found
	INC  D			;bump column number
	RLC  C			;align mask
	JR   AGAIN		;try again
FOUND:	LD   A,C      		;column bits --> accu
	LD   (OLCLMN),A		;store them
	LD   E,D		; row * 8 + column (0 - 7)  --> reg. DE
	LD   D,0
	LD   H,D		; row * 8 + column (0 - 7)  --> reg. HL
	LD   L,E
	ADD  HL,HL		;(row * 8 + column (0 - 7)) * 2
 	ADD  HL,DE		;(row * 8 + column (0 - 7)) * 3
		
;get ASCII code of pressed key:
	LD   BC,(KEYTAB)	;^table of ASCII codes --> reg. BC
	ADD  HL,BC              ;calculate ^ASCII code of pressed key
	LD   A,(3880H)          ;load SHIFT bit
	BIT  0,A		;SHIFT ?
	JR   Z,CTRL             ;jump if not
	INC  HL 		;adjust table pointer
	JR   LOCK
CTRL:	BIT  1,A		;CTRL ?
	JR   Z,LOCK		;jump if not
	INC  HL			;adjust table pointer
	INC  HL
	LD   A,(HL)		;get ASCII code
	JR   DBOUNCE

;check if caps lock:
LOCK:   LD   A,(38E0H)          ;load LOCK bit
	BIT  3,A		;LOCK ?
	JR   Z,UMLAUT           ;jump if not
	LD   A,(HL)    		;restore char
	CP   'a'		;is it a letter ?
	JR   C,DBOUNCE          ;jump if not
	LD   A,(GERMAN)		;German character set ?
	OR   A
	LD   A,(HL)		;restore char
	JR   Z,UCAPS		;jump if US-ASCII
	CP   DEL
	JR   NC,DBOUNCE		;adjust to lower case
	JR   UCASE
UCAPS:  CP   '{'  		;adjust to lower case
	JR   NC,DBOUNCE
UCASE:	AND  5FH                ;force upper case
	JR   DBOUNCE

;check if German character set:
UMLAUT:	LD   A,(GERMAN)		;German character set ?
	OR   A
	LD   A,(HL)		;restore char
	JR   Z,DBOUNCE		;jump if US-ASCII
        LD   A,(3880H) 		;load SHIFT bit
	BIT  0,A      		;SHIFT ?
        LD   A,(HL)   		;restore char
	JR   NZ,SHIFT     	;jump if SHIFT
	CP   '['    		;"Umlaut" ?
      	JR   C,DBOUNCE		;jump if not
	CP   '_'
	JR   NC,DBOUNCE
        JR   FILTER
SHIFT:  CP   '{'   		;"Umlaut" ?
	JR   C,DBOUNCE          ;jump if not
	CP   DEL
	JR   NC,DBOUNCE
FILTER: XOR  20H		;change to upper/lower case

;second debounce routine:
DBOUNCE:LD   D,A      		;save character
	LD   A,(REPEAT)		;auto repeat ?
	OR   A
	JR   NZ,NBOUNCE		;no debounce if repeat mode
	LD   BC,(DELAY2)        ;load delay count
	CALL DELAY 		;delay
NBOUNCE:LD   A,D       		;A = ASCII - like character
	RET			;return

KEYBRD:	DEFB 80H,0C0H,0A0H,40H,20H,10H,08H,04H,02H,01H
GERMAN: DEFB 0    		;switch bit to alter character set
				;(0 = US-ASCII, FF = German)
KEYHLD:	DEFB 0,0,0,0,0,0        ;keyboard work area
	DEFB 0,0,0,0,0
COUNT1: DEFW 0     		;delay counters for auto repeat function
COUNT2: DEFW 0     
OLDROW: DEFW 0     		;temporary memory for keyboard driver
OLCLMN: DEFB 0     
RDYKEY:	DEFB 0			;key code memory
REPEAT:	DEFB 0			;repeat mode


*EJECT
;*******************
;*  $ K B W A I T  *
;*******************

;exit: A = char

;wait for a keyboard character:

;scan for special function key:
$KBWAIT:LD   A,(COUNT3)		;letter counter --> accu
	OR   A			;test it
	JR   Z,DZERO		;jump if counter empty
	DEC  A			;decrement counter
	LD   (COUNT3),A		;store it
	LD   HL,(FPTR)		;load letter pointer
	LD   A,(HL)  		;load next letter
	INC  HL			;bump letter pointer
	LD   (FPTR),HL		;store it
	LD   C,A		;save active key
	LD   A,(HL)		;get next key
	LD   (RDYKEY),A		;store that sucker
	LD   A,C		;restore active key
	JP   TSTKEY+2

;scan for special key "00":
DZERO:  LD   HL,RDYKEY		;^scanned key --> reg. HL
	LD   A,(HL)		; scanned key --> accu
	CP   0FBH		;is it PRINT ?
	JR   Z,PRINT		;jump if yes
	CP   0FCH		;is it SHIFT - CLEAR ?
	JR   Z,ERASE		;jump if yes
	CP   0FDH		;is it SHIFT - BREAK ?
	JR   Z,GERSET		;jump if yes
	CP   0FEH		;is it "00" ?
	JR   C,FKEY  		;jump if not
	INC  A			;bump "00"-counter
	LD   (HL),A		;store "00"-counter
	LD   A,'0'		;return one zero
	RET			;return to caller
PRINT:	PUSH HL			;save reg. HL
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
      	LD   HL,$SCREEN		;address of first screen location --> reg. HL
	LD   IX,(VDTABP)	;^current parameter table	  --> reg. IX
	LD   A,(IX)		;line count of screen		  --> reg. D
	LD   D,A
PRINT1:	LD   A,(IX+1)		;column count of screen		  --> reg. B
	LD   B,A
PRINT2:	LD   A,(HL)		;screen character 		  --> accu
	AND  7FH		;mask it
	INC  HL			;bump screen pointer
 	CALL PRCHR0		;output character to printer 0
	DJNZ PRINT2		;repeat "column count" times
	LD   A,CR		;output a carriage return
	CALL PRCHR0
	LD   A,LF		;output a line feed
	CALL PRCHR0
	DEC  D			;decrement line counter
	JR   NZ,PRINT1		;print next line	
	POP  HL			;restore reg. HL
	JR   GERSE3		;go on
ERASE:	LD   A,SUB
	PUSH HL
	CALL $VDCHAR		;clear screen
	POP  HL
	JR   GERSE3		;go on
GERSET:	PUSH HL
	LD   A,ESC
	CALL $VDCHAR
       	LD   A,(GERMAN)		;load switch bit for changing char set
	CPL			;invert it
	LD   (GERMAN),A		;store it
	OR   A
	JR   Z,GERSE1
	LD   A,'G'		;load German character set
	JR   GERSE2
GERSE1:	LD   A,'A'		;load ASCII character set
GERSE2:	CALL $VDCHAR
	POP  HL
GERSE3:	XOR  A			;clear key code	
	JR   TSTKEY

;test if function key:
FKEY:	BIT  7,A		;check if code >= 80H
	JR   Z,TSTKEY		;jump if not 	 
	PUSH HL			;save ^key memory
	LD   C,A		;save key code
	LD   E,A
	LD   HL,VECTOR		;^function key vector --> reg. HL
	LD   A,(HL)		;function key vector = 0 ?
	LD   D,A		;save LSB of key vector
	INC  HL
	OR   (HL)
	JR   Z,FKEYEND		;jump if no special function
	LD   H,(HL)		;function key vector --> reg. HL
	LD   L,D
	LD   D,0
	SLA  E			;most significant 7 bits of code * 2
	ADD  HL,DE		;calculate vector address
	LD   A,(HL)		;no special function ?
	LD   E,A
	INC  HL
	LD   D,(HL)
	OR   D
	JR   Z,FKEYEND
	LD   A,(DE)		;vector --> accu
	LD   (COUNT3),A		;load counter
	INC  DE
	LD   (FPTR),DE		;load address of first function key character
	POP  HL			;adjust stack pointer
	JP   $KBWAIT
FKEYEND:LD   A,C		;restore original key code	
	POP  HL			;restore ^key memory

;test key memory if legal code:
TSTKEY: LD   (HL),0		;clear key memory
	OR   A			;legal key code ?
	RET  NZ       		;return to caller

;scan keyboard:
        CALL $KBCHAR		;scan keyboard
	JP   $KBWAIT		;test if active key

COUNT3:	DEFB 0     		;letter counter for function keys
FPTR:	DEFW 0     		;letter pointer for function keys


*EJECT
;*******************
;*  $ V D C H A R  *
;*******************

;entry: A = char

$BUZZ	EQU  3860H		;buzzer address
$SCREEN EQU  3800H		;address of first screen location

;character output routine:
$VDCHAR:LD   C,A		;save character
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	LD   A,C		;restore character

        LD   IX,(VDTABP)	;^^screen constants --> reg. IX
	LD   HL,ESCAPE 		;test if escape sequence
	BIT  2,(HL)		
	JR   NZ,ESCSQ2		;cursor addressing routine
	BIT  1,(HL)
	JR   NZ,ESCSQ1		;handle second byte of escape sequence
	BIT  0,(HL)
	JR   NZ,ESCSEQ		;handle first byte of escape sequence
	CP   ESC		;char = ESC ?
	JR   NZ,NORMAL 		;jump if normal ASCII char
	SET  0,(HL)		;remark escape sequence
	RET

;handling of single byte ASCII's:
NORMAL: CP   20H		;control char ?
	JR   C,CNTRL 
	LD   L,A		;save char
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	LD   A,L		;restore char	
        OR   A			;ASCII code > 80H ?
	JP   P,NORMAL1		;jump if not
	CP   0A0H		;ASCII code > 0A0H ?
	JR   NC,NORMAL1		;jump if yes
	SUB  80H		;convert code if special char
NORMAL1:OR   (IX+11)		;put invert mask over character
	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   (HL),A		;output char
	JP   CURRGT		;output cursor

;handling of control codes: 
CNTRL:	OR   A			;control code = 0 ?
	RET  Z
      	LD   HL,TAB1E+1		;^end of control code table --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length               --> reg. BC
CAGAIN:	CPDR			;search char
	RET  NZ			;return to caller if not found
	INC  (HL)		;escape sequence ?
	DEC  (HL)
	JR   NZ,CAGAIN		;search next char
	JR   ESCEND

;first entry into escape sequence:
ESCSEQ:	RES  0,(HL)		;reset escape bit
	LD   HL,TAB1E+1		;^end of ESC-sequence-table-1 --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length                 --> reg. BC
EAGAIN:	CPDR          		;search char
	RET  NZ			;return to caller if not found
	INC  (HL)		;escape sequence ?
	DEC  (HL)
	JR   Z,EAGAIN		;search next char
ESCEND:	LD   HL,CTRLJP		;jump vector --> reg. HL
        DEC  BC			;calc jump address
	ADD  HL,BC
	LD   C,(HL)		;jump address --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute function

;second entry into escape sequence:
ESCSQ1: RES  1,(HL)		;reset second escape bit
	SUB  20H		;adjust line/column no.
	LD   D,A		;save it
	LD   A,(ESCCHR)		;load first byte of escape sequence
	LD   HL,TAB2E+1		;^end of ESC-sequence-table-2 --> reg. HL
	LD   BC,TAB2E-TAB2S+2	;table length                 --> reg. BC
	CPDR			;search char
	LD   HL,ESCJP 		;^jump vector
	LD   A,D		;restore line/column no.
	JR   ESCEND+3

;third entry into escape sequence:
ESCSQ2: RES  2,(HL)		;reset third escape bit
	SUB  20H		;adjust column no.
	CP   (IX+7)		;legal column no. ?
	RET  NC			;return if not
	ADD  A,(IX+3)		;add left column
	LD   (IX+9),A		;store new column no.
	LD   A,(LINE)  		;fetch new line no.
	ADD  A,(IX+2)		;add top line
	LD   (IX+8),A		;store it
	CALL OUTCUR		;output cursor
	JP   CURON+4		;turn on cursor

;handle first byte of two or three byte escape sequence:
ESC1ST: LD   (ESCCHR),A		;store first byte of escape sequence
	LD   HL,ESCAPE
	SET  1,(HL)		;remark it
	RET

;handle second byte of three byte escape sequence:
ESC2ND: CP   (IX+6)		;legal line no. ?
	RET  NC			;return if not
	LD   (LINE),A  		;save new line
	LD   HL,ESCAPE
	SET  2,(HL)		;remark cursor addressing sequence
	RET

;beep:
BEEP:   IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11000110B		;enable memory mapped I/O
				;disable graphic page
				;enable buzzer
	OUT  ($SYS1),A		;write system byte 1

     	LD   BC,0     		;repeat counter --> reg. B
				;  wait counter --> reg. C
	DI			;force clean tone
BEEP1:	LD   A,($BUZZ)		;turn on buzzer
	PUSH BC			;save base value of wait counter
BUZZON: NOP			;little delay for lower frequency
	NOP
	NOP
	DEC  C			;decrement wait counter
	JR   NZ,BUZZON		;wait `til end of buzz
	POP  BC			;restore wait counter
	DJNZ BEEP1 		;turn on buzzer eleven times
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A		;write it
	RET

;cursor left:
CURLFT: LD   A,(IX+3)		;left column --> accu
	CP   (IX+9)		; > current column ?
	JP   M,CURLFT1		;jump if not
	LD   A,(WRAP)		;wrap around mode ?
	OR   A
	RET  Z			;return if not	
       	LD   A,(IX+5)		;right column --> current column
	LD   (IX+9),A
	JR   CURUP
CURLFT1:DEC  (IX+9) 		;decrement column no.
	JP   INSLI3

;cursor down:
CURDWN: LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; >= bottom line ?
	JP   P,CURDW1		;scroll up if yes
	INC  (IX+8) 		;increment line no.
	JP   OUTCUR
CURDW1: LD   A,(IX+2)		;top line --> current line
	LD   (IX+8),A
	JP   SCRLU		;scroll window up one line

;cursor up:
CURUP:  LD   A,(IX+2)		;top line --> accu
	CP   (IX+8)		; >= current line ?
	RET  P			;return if yes
	DEC  (IX+8) 		;decrement line
	JP   OUTCUR

;cursor right:
CURRGT:	LD   A,(IX+5)		;right column --> accu
	CP   (IX+9)		;right column >= current column ?
	RET  M			;return if cursor beyond right column
	PUSH AF			;save status reg.
	INC  (IX+9) 		;increment column no.
	POP  AF			;restore status reg.
	JP   NZ,OUTCUR		;output cursor 
	LD   A,(WRAP)		;wrap around mode ?
	OR   A
	JP   Z,CUROFF+4		;turn cursor off
       	LD   A,(IX+3)		;left column  --> current column
	LD   (IX+9),A
	CALL OUTCUR		;output cursor
	JR   CURDWN		;perform line feed

;carriage return:
NEWLIN:	LD   A,(IX+3)		;left column  --> current column
	LD   (IX+9),A
	JP   INSLI3		;output cursor
	
;home cursor:
HOME:	LD   A,(IX+2)		;top line    --> current line
	LD   (IX+8),A
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	JP   OUTCUR		;output cursor

;select window:
WINDOW:	LD   C,A		;save window # 
	LD   A,(STONOFF)	;status line enabled ?
	RET  NZ			;return if yes 
	LD   A,C		;restore window #
	OR   A			;window # < 0 ?
	RET  M			;return if yes
	CP   8			;window # > 7 ?
	RET  NC			;return if yes
	ADD  A,A		;multiply window number by 13
	ADD  A,C
	ADD  A,A
	ADD  A,A
	ADD  A,C
	LD   B,0		;window number * 13 --> reg. BC 
	LD   C,A
	LD   HL,VDTAB		;^screen constants  --> reg. HL
	ADD  HL,BC		;calc current table entry
	LD   (VDTABP),HL	;store it
	PUSH HL         	;^screen constants  --> reg. IX
	POP  IX
	LD   A,(IX+12)		;cursor off ?
	OR   A
	JR   Z,WINDOW2 		;jump if not
WINDOW1:CALL CUROFF+4		;turn off cursor
	JP   OUTCUR             ;output cursor & return to caller
WINDOW2:LD   A,(IX+5)		;right column --> accu
	CP   (IX+9)		;right column >= current column ?
	JR   C,WINDOW1 		;turn off cursor beyond right column
	CALL OUTCUR		;position cursor
	JR   CURON+4		;turn on cursor & return to caller

;set top line:
SETTOP:	CP   (IX)		;legal  line/column no. ?
	RET  NC			;return if not
	LD   B,A		;save line/column
	SUB  (IX+4)		;top    line   - bottom line
				;left   column - right  column
	NEG			;bottom line   - top    line
				;right  column - left   column
	JP   M,SETTO1		;jump if illegal top line/left column
	INC  A			;adjust line/column count
	LD   (IX+6),A		;store new line/column count
SETTO1:	LD   A,B		;restore line column
	RET  M
	LD   (IX+2),A		;store new top line/left column
	CP   (IX+8)		;current line   > top  line ?
				;current column > left column ?
	RET  C			;return to caller if yes
SETTO2: LD   (IX+8),A		;store new current line/column
       	LD   IX,(VDTABP)	;adjust ^screen constants
	JP   OUTCUR		;output cursor

;set bottom line:
SETBOT:	CP   (IX)		;legal  line/column no. ?
	RET  NC			;return if not
	LD   B,A		;save line/column
	SUB  (IX+2)		;bottom line   - top  line
				;right  column - left column
	JP   M,SETTO1		;jump if illegal bottom line/left column
	INC  A			;adjust line/column count
	LD   (IX+6),A		;store new line/column count
       	LD   A,B		;restore line column
	LD   (IX+4),A		;store new bottom line/left column
	CP   (IX+8)		;current line   > bottom line ?
				;current column > right  column ?
	RET  P			;return to caller if not
	JR   SETTO2

;set left column:
SETLFT: INC  IX			;adjust ^screen constants
	JR   SETTOP		;set left column

;set right column:
SETRGT: INC  IX			;adjust ^screen constants
	JR   SETBOT		;set right column

;set erase character:
SETERA:	ADD  A,20H		;restore ASCII code of erase character
	CP   80H		;ASCII between 80H and 9FH ?
	JR   C,SETERA1
	CP   0A0H
	JR   NC,SETERA1
	RES  7,A		;make code between 00H and 1Fh
SETERA1:LD   (IX+10),A		;store new erase character
	RET			;return to caller

;turn off cursor:
CUROFF:	LD   (IX+12),0FFH	;store remark byte
        LD   A,10		;CRTC register no. --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,20H
	OUT  ($CRTCMD),A	;turn off cursor
	RET

;turn on cursor:
CURON:	LD   (IX+12),0 		;clear remark byte
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	LD   A,(IX+12)		;load remark byte
	OR   A			;test remark byte
	RET  NZ			;no action if cursor is invisible
       	LD   A,10		;CRTC register no. --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,(CURBEG)		;cursor image      --> accu
	OUT  ($CRTCMD),A	;turn on cursor
	RET

;set ASCII character set:
SETASC:	XOR  A			;clear accu
SETAS1:	LD   (GERMAN),A		;set ASCII char set
	JP   SELCHR  		;select ASCII character set and ret to caller

;disable status line:
STATOFF:LD   A,(STONOFF)	;status line enabled ?
	OR   A
	RET  Z			;return if not
	XOR  A 			;clear marker
        LD   HL,VDTEMP		;restore screen parameter table
	JR   STATO1

;enable status line:
STATON:	LD   A,(STONOFF)	;status line already enabled ?
	OR   A
	RET  NZ			;return if yes
	CPL			;set marker
       	LD   HL,(VDTABP)	;save screen parameter table
	LD   DE,VDTEMP
	LD   BC,13
	LDIR
	LD   HL,VDSTAT		;setup status line parameters
STATO1:	LD   DE,(VDTABP)
	LD   BC,13
	LDIR
	LD   (STONOFF),A	;store marker
	JP   OUTCUR		;output cursor

;set German character set:
SETGER:	LD   A,0FFH		;set accu to ones
	JR   SETAS1		;set German char set

;switch on normal keyboard:
SETNKB:	LD   HL,NBOARD		;^normal key table  --> reg. HL
SETNK1:	LD   (KEYTAB),HL	;store it
	RET			;return to caller

;switch on WordStar keyboard:
SETWKB:	LD   HL,WBOARD		;^WordStar key table --> reg. HL
	JR   SETNK1		 

;turn on inverse display mode:
INVON:	LD   (IX+11),80H	;store invert mask
	RET

;turn off inverse display mode:
INVOFF: LD   (IX+11),0  	;clear invert mask
	RET

;turn on wrap around mode:
WRAPON:	LD   A,0FFH
	LD   (WRAP),A   	;remember wrap around mode
	RET

;turn off wrap around mode:
WRAPOFF:XOR  A
	LD   (WRAP),A
	RET

;insert character:
INSCHR:	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   A,(IX+5)		;right column            --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	JR   Z,INSCH1		;no columns to shift
	LD   B,0		;no of columns to shift --> reg. BC
	LD   C,A
	ADD  HL,BC		;now HL contains address of last column
	LD   D,H
	LD   E,L		;now DE contains address of last column
	DEC  HL			;now HL contains address of last column - 1
	LDDR			;shift rest of line right one char
	INC  HL			;now HL contains current cursor address
INSCH1:	LD   A,(IX+10)		;get erase char
        LD   (HL),A  		;insert one space at current cursor location
	RET

;insert line:
INSLIN:	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	LД   A,(IX+4©		;bottoн linе --ѕ accu
	SUB  (IX+8)		;calc. no. of lines to scroll
	LD   B,(IX+4)		;bottom line --> current line
	LD   (IX+8),B
INSLI1: JR   Z,INSLI2		;return if line count = 0
       	CALL CALC		;calculate start position
	PUSH HL			;save it
	LD   D,0 		;maximum column count --> reg. DE
	LD   E,(IX+1)
	SBC  HL,DE		;now HL contains ^(last line - 1)
	POP  DE			;restore ^last line
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll down one line
	DEC  (IX+8)		;decrement current line
	DEC  A			;decrement counter
	JR   INSLI1		;scroll down all lines
INSLI2:	CALL ERAEOLN		;erase current line
INSLI3:	CALL OUTCUR		;output cursor
	JP   CURON+4		;turn on cursor

;delete character:
DELCHR:	LD   HL,(CURADR)	;absolute screen address  --> reg. HL
       	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	JR   Z,INSCH1		;no columns to shift
	LD   B,0		;no. of columns to shift --> reg. BC
	LD   C,A
	LD   D,H
	LD   E,L		;now DE contains absolute screen address
	INC  HL			;now HL contains absolute screen address + 1
	LDIR			;shift rest of line left one char
	DEC  HL			;now HL contains address of last column
	JR   INSCH1		;insert one space at last column

;erase to end of line:
ERAEOLN:CALL CALC		;calculate absolute screen address
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;now accu contains number of columns to erase
	RET  M			;return if cursor beyond right column
       	LD   C,(IX+10)		;get erase char
ERAEO1:	LD   (HL),C  		;clear column
	INC  HL			;bump column ptr
	DEC  A			;decrement column counter
	JP   P,ERAEO1		;erase all columns right to the cursor
	RET

;delete line:
DELLIN: LD   A,(IX+3)		;left  column --> current column
	LD   (IX+9),A
       	LD   A,(IX+8)		;current line no. --> accu
	PUSH AF			;save it
	CALL SCRLU		;scroll rest of window up one line
	POP  AF
	LD   (IX+8),A		;restore current line
	JR   INSLI3		;output cursor
 
;erase to end of screen:
ERAEOS: CALL ERAEOLN		;erase to end of first line
	LD   B,(IX+8)		;save current line
	LD   C,(IX+9)		;save current column
	PUSH BC
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	LD   A,(IX+4)		;bottom line --> accu
	SUB  B			;now accu contains number of lines to erase
	LD   B,A		;counter --> reg. B
        JR   Z,ERAES2		;no further lines to erase
ERAES1: INC  (IX+8)		;increment current line
	PUSH BC			;save counter
	CALL ERAEOLN		;erase current line
	POP  BC			;restore counter
	DJNZ ERAES1		;erase to end of whole window
ERAES2: POP  BC
        LD   (IX+8),B		;restore original line   no.
	LD   (IX+9),C		;restore original column no.
	RET

;clear screen:
ERAALL: CALL HOME		;home cursor
	JR   ERAEOS		;clear to end of screen

;output cursor:
OUTCUR:	CALL CALC               ;calculate absolute screen address
	LD   (CURADR),HL	;store it
	LD   DE,$SCREEN		;base address of video RAM --> reg. DE
	OR   A			;clear carry flag
	SBC  HL,DE		;subtract base address from current cursor
				;address
	LD   C,$CRTREG		;CRTC address register --> reg. C
	LD   A,14		;CRTC register number  --> accu
	OUT  (C),A		;select CRTC register
	INC  C			;CRTC command register --> reg. C
	OUT  (C),H		;output cursor address (MSB)
	INC  A			;increment CRTC register no.
	DEC  C			;decrement port number
	OUT  (C),A		;select CRTC register
	INC  C			;CRTC command register --> reg. C
	OUT  (C),L		;output cursor address (LSB)
	RET

;scroll up routine:
SCRLU:	LD   A,(IX+9)		;current column --> accu
	PUSH AF			;save it
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
      	LD   A,(IX+4)		;bottom line  --> accu
	SUB  (IX+8)		;calc. no. of lines to scroll
SCRLU1: JR   Z,SCRLU2		;clear last line if count = 0
        CALL CALC		;calculate start position
	PUSH HL			;save it
	LD   D,0 		;maximum column count --> reg. DE
	LD   E,(IX+1)
	ADD  HL,DE		;now HL contains address of line to scroll
	POP  DE			;restore ^line before
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll up one line
	INC  (IX+8)		;increment current line
	DEC  A			;decrement counter
	JR   SCRLU1             ;scroll up all lines
SCRLU2:	CALL ERAEOLN		;clear last line
	POP  AF			;restore column no.
	LD   (IX+9),A		;store it
	RET

;calculate absolute cursor address:
CALC:	LD   HL,$SCREEN		;address of first screen loc --> reg. HL
	LD   D,0		;maximum column count        --> reg. DE
	LD   E,(IX+1)
	LD   B,(IX+8)		;current line                --> reg. B
	DEC  B
	INC  B
        JR   Z,CALC2		;jump if line no. = 0
CALC1:	ADD  HL,DE
	DJNZ CALC1		;handle all lines
CALC2:	LD   E,(IX+9)		;current column --> reg. DE
	ADD  HL,DE		;now HL contains absolute screen address
	RET

;jump vectors:
CTRLJP:	DEFW BEEP,CURLFT,CURDWN,CURUP,CURRGT,NEWLIN,HOME,ESC1ST,ESC1ST,ESC1ST
	DEFW ESC1ST,ESC1ST,ESC1ST,ESC1ST,CUROFF,CURON,SETASC,STATOFF,STATON
	DEFW SETGER,SETNKB,SETWKB,INVON,INVOFF,WRAPON,WRAPOFF,INSCHR,INSLIN
	DEFW DELCHR,ERAEOLN,DELLIN,ERAEOS,ERAALL
ESCJP:	DEFW ESC2ND,WINDOW,SETTOP,SETBOT,SETLFT,SETRGT,SETERA

;table of screen constants:
VDTABP:	DEFW VDTAB
VDTAB:	REPT 8
	DEFB 24			;maximum line   count
	DEFB 80			;maximum column count
	DEFB 0			;top     line
	DEFB 0			;left    column
	DEFB 23			;bottom  line
	DEFB 79			;right   column
	DEFB 24			;line    count
	DEFB 80			;column  count
	DEFB 0			;current line
	DEFB 0			;current column
	DEFB ' '		;erase   character 
        DEFB 0     		;0 = normal mode,  80H = inverse mode
       	DEFB 0     		;0 = cursor on  , 0FFH = cursor off
	ENDM

;status line constants:
VDSTAT:	DEFB 25			;maximum line   count
	DEFB 80			;maximum column count
	DEFB 24			;top     line
	DEFB 0			;left    column
	DEFB 24			;bottom  line
	DEFB 79			;right   column
	DEFB 1 			;line    count
	DEFB 80			;column  count
	DEFB 24			;current line
	DEFB 0			;current column
	DEFB ' '		;erase   character 
        DEFB 0     		;0 = normal mode,  80H = inverse mode
       	DEFB 0     		;0 = cursor on  , 0FFH = cursor off

ESCAPE:	DEFB 0     		;contains escape remarks
ESCCHR: DEFB 0     		;memory for escape char
LINE:  	DEFB 0     		;memory for line number
CURADR: DEFW 3800H		;memory for absolute cursor address
WRAP:   DEFB 0			;0 = normal mode, 0FFH = wrap around mode
STONOFF:DEFB 0			;0 = status line off, 0FFH = status line on
VDTEMP:	DEFS 13			;temporary storage area for screen constants


*EJECT
;*******************
;*  $ P R S T A T  *
;*******************

;entry: B = number of Centronics interface (0, 1)

;exit : A = printer status
;       0 = printer ready 
;    <> 0 = printer not ready

;calc entry of printer status routine:
$PRSTAT:LD   HL,PSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
 	LD   L,C
	JP   (HL)		;execute printer status routine

;printer status routine entry table:
PSTAB:	DEFW PRSTA0,PRSTA1

;test status of printer 0:
$PTR0	EQU  0FDH		;printer port 0

PRSTA0:	IN   A,($PTR0)		;read printer status
	AND  0F0H		;mask it
	XOR  30H
	RET			;return to caller

;test status of printer 1:
$PTR1	EQU  0D5H		;printer port 1

PRSTA1:	IN   A,($PTR1)		;read printer status
	AND  0F0H		;mask it
	XOR  30H
	RET			;return to caller


*EJECT
;*******************
;*  $ P R C H A R  *
;*******************

;entry: A = char
;       B = number of Centronics interface (0, 1)

;calc entry of printer output routine:
$PRCHAR:LD   HL,POTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
 	LD   L,C
	JP   (HL)		;execute printer output routine

;printer output routine entry table:
POTAB:	DEFW PRCHR0,PRCHR1

;output a character to printer 0:
PRCHR0:	LD   C,A		;save char
	CALL PRSTA0		;test status of printer 0
	JR   NZ,PRCHR0+1	;wait for printer ready
	LD   A,C		;restore char
	OUT  ($PTR0),A		;print it
	RET			;return to caller
			  
;output a character to printer 1:
$PTR1D	EQU  0D4H		;data port of PIO

PRCHR1:	LD   C,A		;save char
	CALL PRSTA1		;test status of printer 0
	JR   NZ,PRCHR1+1	;wait for printer ready
	LD   A,C		;restore char
	OUT  ($PTR1D),A		;output it
	XOR  A
	OUT  ($PTR1),A		;set STROBE
	INC  A
	OUT  ($PTR1),A		;clear STROBE

	RET			;return to caller
			  

*EJECT
;*******************
;*  $ R S R C S T  *
;*******************

;entry: B = number of RS232C interface (0, 1)

;exit : A = input status
;	0 = no char available
;    <> 0 = char available	

;calc entry of RS232C input status routine:
$RSRCST:LD   HL,RSSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine
	 
;RS232C input status routine entry table:
RSSTAB:	DEFW RSRCSA,RSRCSB	

;get input status of SIO A:
RSRCSA: IN   A,(WR0A)    	;read status
	AND  1   		;character available ?
	RET  NZ 		;return to caller if yes
	LD   B,A		;load counter
	LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0A),A		;request to send
RSRCSA1:IN   A,(WR0A)		;read status	
	BIT  0,A		;character available ?
	JR   NZ,RSRCSA2		;jump if character ready
	DJNZ RSRCSA1		;scan 256 times
	LD   C,0		;no character available
	JR   RSRCSA3
RSRCSA2:LD   C,1		;character available
RSRCSA3:LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	OUT  (WR0A),A		;data terminal ready
        LD   A,C		;get input status
	RET

;get input status of SIO B:
RSRCSB: IN   A,(WR0B)    	;read status
	AND  1   		;character available ?
	RET  NZ 		;return to caller if yes
	LD   B,A		;load counter
	LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0B),A		;request to send
RSRCSB1:IN   A,(WR0B)		;read status	
	BIT  0,A		;character available ?
	JR   NZ,RSRCSB2		;jump if character ready
	DJNZ RSRCSB1		;scan 256 times
	LD   C,0		;no character available
	JR   RSRCSB3
RSRCSB2:LD   C,1		;character available
RSRCSB3:LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	OUT  (WR0B),A		;data terminal ready
        LD   A,C		;get input status
	RET

 
*EJECT
;*****************
;*  $ R S R C V  *
;*****************

;entry: B = number of RS232C interface (0, 1)

;exit : A = char	

;calc entry of RS232C input routine:
$RSRCV: LD   HL,RSRTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine
	 
;RS232C input routine entry table:
RSRTAB:	DEFW RSRCVA,RSRCVB	

;read character from SIO A:
DRA	EQU  0D0H		;data register of SIO A

RSRCVA:	IN   A,(WR0A) 		;read status
	BIT  0,A     		;character available ?
	JR   NZ,RSRCVA2		;jump if yes
	LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0A),A		;request to send
RSRCVA1:IN   A,(WR0A)		;read status	
	BIT  0,A		;character available ?
	JR   Z,RSRCVA1		;loop `til character ready
        LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	OUT  (WR0A),A		;data terminal ready
RSRCVA2:IN   A,(DRA)		;read character
	RET
	
;read character from SIO B:
DRB	EQU  0D1H		;data register of SIO A

RSRCVB:	IN   A,(WR0B) 		;read status
	BIT  0,A     		;character available ?
	JR   NZ,RSRCVB2		;jump if yes
	LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0B),A		;request to send
RSRCVB1:IN   A,(WR0B)		;read status	
	BIT  0,A		;character available ?
	JR   Z,RSRCVB1		;loop `til character ready
        LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	OUT  (WR0B),A		;data terminal ready
RSRCVB2:IN   A,(DRB)		;read character
	RET
	

*EJECT
;*******************
;*  $ R S T X S T  *
;******************* 
	
;entry: B = number of RS232C interface (0, 1)

;exit : A = terminal status
;       0 = data terminal ready
;    <> 0 = data terminal not ready

;get output status of SIO:
$RSTXST:LD   A,WR0A    		;control register of SIO A --> accu
	ADD  A,B		;add relative port number
	LD   C,A		;absolute port address --> reg. C
	LD   A,10H		
	OUT  (C),A		;reset ext/status interrupts
	IN   A,(C)		;read status
	AND  2CH		;buffer empty, data set ready, clear to send ?
        SUB  2CH
	RET
	

*EJECT
;***************
;*  $ R S T X  *
;***************

;entry: A = char
;       B = number of RS232C interface (0, 1)

;write character to SIO:
$RSTX:	LD   E,A		;save character
        CALL $RSTXST  		;test output status
	JR   NZ,$RSTX+1		;wait for CTS
	DEC  C
	DEC  C			;now reg. C points to data port
	OUT  (C),E		;output character
	RET


*EJECT
;disk driver:

;FDC registers:
$FDSEL  EQU  0E0H               ;FDC select  register
$FDCMD  EQU  0ECH               ;FDC command register
$FDSTAT EQU  0ECH               ;FDC status  register
$FDTRK  EQU  0EDH               ;FDC track   register
$FDSIZ  EQU  0EEH               ;FDC size    register
$FDSEC  EQU  0EEH               ;FDC sector  register
$FDDATA EQU  0EFH               ;FDC data    register

;FDC commands:
$SEEK   EQU  10H                ;seek
$RDSEC  EQU  88H                ;read sector
$WRSEC  EQU  0A8H               ;write sector
$SET8   EQU  0C0H               ;set disk size to 5 inch
$FCINT  EQU  0D0H               ;force interrupt
$DDDEN  EQU  0FFH               ;set double density


;***************
;*  $ R E A D  *
;***************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       E  = track  number
;       HL = buffer pointer

;exit : A = error code
;       0 = NO ERROR
;       1 = ILLEGAL DRIVE #
;       2 = TRACK # TOO HIGH
;       3 = SECTOR # TOO HIGH
;       4 = DEVICE NOT AVAILABLE
;       6 = TRIED TO READ LOCKED/DELETED RECORD
;       7 = DATA RECORD NOT FOUND DURING READ
;       8 = PARITY ERROR DURING READ
;       9 = LOST DATA DURING READ

;read a sector:
$READ:  LD   C,A                ;save drive #/bank #
        LD   A,0FFH             ;set READ-flag
        JR   TASK


*EJECT
;*****************
;*  $ W R I T E  *
;*****************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       E  = track  number
;       HL = buffer pointer

;exit : A = error code
;       0 = NO ERROR
;       1 = ILLEGAL DRIVE #
;       2 = TRACK # TOO HIGH
;       3 = SECTOR # TOO HIGH
;       4 = DEVICE NOT AVAILABLE
;       5 = WRITE PROTECTED DISKETTE
;       6 = WRITE FAULT ON DISK DRIVE
;       7 = DATA RECORD NOT FOUND DURING WRITE
;       8 = PARITY ERROR DURING WRITE
;       9 = LOST DATA DURING WRITE

;write a sector:
$WRITE: LD   C,A                ;save drive #/bank #
        XOR  A                  ;clear READ-flag

;dominant controller:
TASK:   LD   (RDFLAG),A         ;set/reset READ-flag
	LD   A,C		;restore drive/bank #
      	RRA   			;get bank number of transfer buffer
	RRA   
	RRA   
	RRA   
	AND  0FH
	LD   (BANK),A		;store bank #
        LD   A,C      		;restore drive/bank #
	AND  0FH		;mask drive #
        CP   8                  ;legal drive # ?
        JR   C,TRKNO            ;jump if yes
        LD   A,1                ;error code 1 --> accu
        RET
TRKNO:  LD   (DRIVE),A          ;store drive #
        LD   (BUFFER),HL        ;store buffer pointer
        CALL GETDCT             ;get control table ptr
        LD   A,E                ;track # --> accu
        CP   (IX+4)             ;legal track # ?
        JR   C,SECNO            ;jump if yes
        LD   A,2                ;error code 2 --> accu
        RET
SECNO:  LD   (TRACK),A          ;store track #
        LD   A,B                ;sector # --> accu
        CP   (IX+3)             ;legal sector # ?
        JR   C,TRYNO            ;jump if yes
        LD   A,3                ;error code 3 --> accu
        RET
TRYNO:	LD   (SECTOR),A		;store sector #
        LD   A,(TRYS)           ;get # of err tries
        INC  A                  ;adjust it
        LD   (TRIES),A          ;store in counter

;set double density & disk size to 8 inch:
        LD   A,$DDDEN           ;set double density command
        BIT  5,(IX)             ;density ?
        JR   NZ,SETDEN          ;jump if double density
        DEC  A                  ;set single density
SETDEN: OUT  ($FDCMD),A         ;set density
        LD   C,$SET8            ;set 8 inch command
        LD   A,(DRIVE)          ;drive # --> accu
	CP   4			;disk size ?
        JR   NC,SETSIZ          ;jump if 8 inch
        RES  6,C                ;set 5 inch command
SETSIZ:	LD   A,C
        OUT  ($FDSIZ),A         ;set disk size

;actual I/O handler:
INIT:   LD   HL,0               ;clear wait counter
        LD   (WAIT),HL
        LD   A,$FCINT           ;force interrupt
        OUT  ($FDCMD),A         ;reset FDC
        IN   A,($FDSTAT)        ;get FDC status
        LD   (OLDSTAT),A        ;save drive status
        CALL SELECT             ;select drive
        BIT  0,(IX+1)           ;is drive initialized ?
        JR   NZ,TRKSEC          ;yes skip init process

;restore drive head:
        SET  0,(IX+1)           ;set init bit in DCT
        LD   A,255              ;max possible track # --> accu
        LD   (IX+5),A           ;make current track # to 255
        XOR  A                  ;desired track # = 0
        JR   TRKSE8

;set track and sector:
TRKSEC: LD   A,(TRACK)          ;track # --> accu
        BIT  5,(IX)             ;disk density ?
        JR   Z,TRKSE1           ;jump if single density
        BIT  4,(IX)             ;density of first track ?
        JR   NZ,TRKSE1          ;jump if double density
        INC  A                  ;increment track #
TRKSE1: BIT  2,(IX)             ;step count from track to track
        JR   Z,TRKSE2           ;jump if step count = 1
        ADD  A,A                ;track # * 2
TRKSE2: CP   (IX+5)             ;same as current track
        JR   NZ,TRKSE6          ;jump to SEEK cmd if not
	LD   C,A		;save track #
	LD   A,$FCINT		;force interrupt
	OUT  ($FDCMD),A
	LD   A,C		;restore track #
        BIT  2,(IX)             ;step count from track to track
        JR   Z,TRKSE3           ;jump if step count = 1
        SRL  A                  ;track # / 2
TRKSE3: OUT  ($FDTRK),A         ;adjust current track #
        LD   A,(SECTOR)         ;sector # --> accu
        BIT  6,(IX)             ;single or double sided ?
        JR   Z,TRKSE4           ;jump if single sided
        BIT  5,(IX+1)           ;sector numbering continued on backside ?
        JR   NZ,TRKSE4          ;jump if yes
        LD   B,(IX+3)           ; sectors/track --> reg. B
        SRL  B                  ;(sectors/track) / 2
        CP   B                  ;front or back side ?
        JR   C,TRKSE4           ;jump if front side
        SUB  B                  ;adjust sector #
TRKSE4: BIT  3,(IX)             ;test number of first sector
        JR   Z,TRKSE5           ;jump if zero
        INC  A                  ;else adjust sector #
TRKSE5: OUT  ($FDSEC),A         ;store sector # in FDC reg
        JR   WAITEN             ;no SEEK
TRKSE6: LD   C,A                ;save track #
        SUB  (IX+5)             ;subtract current track #
        JR   NC,TRKSE7
        NEG                     ;make result positive
TRKSE7: LD   (WAIT),A           ;store calculated step count
        LD   A,C                ;restore track #
TRKSE8: OUT  ($FDDATA),A        ;store track # in FDC reg
	LD   A,$FCINT
        OUT  ($FDCMD),A         ;reset FDC
        LD   A,(IX+5)           ;current track from DCT
        OUT  ($FDTRK),A         ;FDC track register
        LD   A,(IX)
        AND  3                  ;step rate --> accu
	PUSH AF			;save it
        LD   HL,(WAIT)          ;get step count
        JR   Z,TRKS10           ;jump if step rate = 3 msec
        LD   D,H                ;step count --> reg. DE
        LD   E,L
        LD   B,A                ;step rate --> reg. B
TRKSE9: ADD  HL,DE              ;counter = step count * step rate
        DJNZ TRKSE9
TRKS10: LD   B,H                ;counter --> reg. BC
        LD   C,L
        ADD  HL,HL              ;counter * 2
        ADD  HL,BC              ;counter * 3
	LD   A,(DRIVE)		;drive # --> accu
        CP   4                  ;disk size ?
        JR   NC,TRKS11          ;jump if 8 inch
	ADD  HL,HL		;counter * 6
TRKS11: LD   BC,15              ;adjust value for delay loop --> reg. BC
        ADD  HL,BC              ;adjust wait counter
        LD   (WAIT),HL          ;store wait counter (msecs of passed time)
	POP  AF			;restore step rate
        OR   $SEEK              ;or step rate with "seek" command
        OUT  ($FDCMD),A         ;issue seek command
TRKS12: CALL SELECT             ;select drive
	IN   A,($FDSTAT)	;get disk status
        BIT  7,A                ;drive not ready ?
        JP   NZ,READ2           ;jump to error exit
        BIT  0,A                ;seek done ?
        JR   NZ,TRKS12          ;no, loop
        LD   BC,4000            ;load delay counter
        CALL DELAY              ;15 msec head settle delay
        IN   A,($FDTRK)         ;get current track
        LD   (IX+5),A           ;store in drive's DCT
        JP   TRKSEC             ;check track # again

;motor on / head load time:
WAITEN: LD   A,(DRIVE)          ;get drive #
        LD   HL,OLDDRV          ;^previous drive # --> reg. HL
        CP   (HL)               ;new drive # same as old drive # ?
        LD   (HL),A             ;store new drive #
        LD   A,(OLDSTAT)        ;get old FDC status
        RLCA                    ;drive rotating already
        JR   C,WAITE2           ;jump to motor on delay loop, if not
        JR   Z,WAITE6           ;jump if same drive #
WAITE1: LD   HL,50              ;50 msec head load time
        JR   WAITE3
WAITE2: BIT  7,(IX)             ;8 inch drive
        JR   NZ,WAITE1          ;jump if 8 inch drive
        LD   HL,800             ;500 msec delay after motor on
WAITE3: LD   BC,(WAIT)          ;msecs of passed time --> reg. BC
        OR   A                  ;clear carry bit
        SBC  HL,BC              ;calculate remaining wait time
        JR   C,WAITE6           ;no further time to wait
        JR   Z,WAITE6
WAITE5: LD   BC,253             ;1 msec delay
        CALL DELAY
        DEC  HL
        LD   A,H
        OR   L
        JR   NZ,WAITE5          ;loop HL times
WAITE6: IN   A,($FDSTAT)        ;get FDC status
        RLCA                    ;drive rotating already ?
        JP   C,READ2            ;jump if not

;init READ/WRITE:
TASK1:  CALL SELECT             ;select drive
        LD   HL,(BUFFER)        ;get buffer pointer
        LD   A,(RDFLAG)
        OR   A                  ;READ or WRITE ?
	PUSH AF			;save status
	LD   A,(BANK)		;bank # of transfer buffer --> accu
	JP   IO 		;handle disk I/O in common memory

;test controller status:
STATUS: IN   A,($FDSTAT)        ;get FDC status
        BIT  6,A                ;write protect ?
        JR   Z,STATU1           ;jump if not
        LD   A,5                ;error code 5 --> accu
        RET
STATU1: BIT  5,A                ;hardware fault (WRITE) ?
                                ;sector   prot  (READ ) ?
        JR   Z,STATU2           ;jump if no
        LD   A,6                ;error code 6 --> accu
        RET
STATU2: AND  1CH                ;any errors ?
        RET  Z
        RES  0,(IX+1)           ;clear init bit in DCT
        LD   HL,TRIES           ;get tries counter
        DEC  (HL)               ;dec value
        JP   NZ,INIT            ;try again, reseek
        BIT  4,A                ;data record not found ?
        JR   Z,STATU3
        LD   A,7                ;error code 7 --> accu
        RET
STATU3: BIT  3,A                ;parity error ?
        JR   Z,STATU4
        LD   A,8                ;error code 8 --> accu
        RET
STATU4: LD   A,9                ;error code 9 --> accu
        RET

;put drive control table pointer in "IX":
GETDCT: PUSH DE                 ;save reg. DE
        LD   H,0                ;drive # --> reg. HL
        LD   L,A
        ADD  A,A                ; drive # * 2
        ADD  A,L                ; drive # * 3
        ADD  A,A                ; drive # * 6
        LD   L,A                ;(drive # * 6) --> reg. HL
        LD   DE,DCT             ;get drive table start
        ADD  HL,DE              ;add offset and get ^DCT
        PUSH HL                 ;^DCT --> reg. IX
        POP  IX
        POP  DE                 ;restore reg. DE
        RET                     ;return to caller

;select drive:
SELECT: LD   A,(DRIVE)          ;get drive #
	AND  3			;force # between 0 and 3
        OR   A                  ;drive # zero ?
        LD   B,A                ;drive # --> reg. B
        LD   A,1                ;select code for drive zero
        JR   Z,SELEC1           ;jump if drive # zero
        RLCA                    ;rotate left accu
        DJNZ $-1                ;decrement drive #
SELEC1: BIT  6,(IX)             ;single or double sided ?
        JR   Z,SELEC2           ;jump if single sided
        LD   C,A                ;save select code
        LD   A,(SECTOR)         ;sector #       --> accu
        LD   B,(IX+3)           ; sectors/track --> reg. B
        SRL  B                  ;(sectors/track) / 2
        CP   B                  ;front or back side ?
        LD   A,C                ;restore select code
        JR   C,SELEC2           ;jump if front side
        SET  4,A                ;set side select bit
SELEC2: OUT  ($FDSEL),A         ;select drive and side
        RET                     ;return to caller

DRIVE:  DEFS 1                  ;drive
TRACK:  DEFS 2                  ;track
SECTOR: DEFS 1                  ;sector
BUFFER: DEFS 2                  ;I/O buffer
OLDDRV: DEFB 0FFH               ;contains # of previous selected disk
OLDSTAT:DEFS 1			;contains drive status
TRIES:  DEFS 1                  ;counter for counting # of times to try I/O
                                ;after error occurs
RDFLAG: DEFS 1                  ;flag (0 = WRITE, 0FFH = READ)
WAIT:   DEFS 2                  ;counter for passed time


*EJECT
;*******************
;*  $ G E T T I M  *
;*******************

;entry: HL = address of a 21 bytes long buffer, containing on exit
;	     time & date in the form WWW MM/DD/YY HH:MM:SS

;		  WWW = weekday
;		   MM = month
;		   DD = day
;		   YY = year
;		   HH = hours
;		   MM = minutes
;		   SS = seconds		 

;get time & date in ASCII format:
$GETTIM:DI			;critical phase
	PUSH HL			;save ^user buffer
        CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer --> reg. IX

	LD   A,(IX+6)		;weekday      --> accu
	AND  7			;make binary
	LD   H,0		;weekday      --> reg. HL			
	LD   L,A
	LD   DE,DAYTAB		;base of weekday table --> reg. DE
	ADD  A,A		;calc table entry
	ADD  A,L
	LD   L,A
	ADD  HL,DE
	LD   DE,ATIMBUF		;^ASCII buffer 	       --> reg. DE	
	LD   BC,3		;length of table entry --> reg. BC
	LDIR			;move weekday into ASCII buffer
	INC  DE			;bump buffer ptr over space

	LD   A,(IX+2)		;month (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+3)		;month (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX+4)		;day (tenths) --> accu
	AND  '3'		;mask leapyear bit
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+5)		;day (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX)		;year (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+1)		;year (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over space		

	LD   A,(IX+7)		;hours (tenths) --> accu
	AND  '3'		;mask format bit 
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+8)		;hours (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon	

	LD   A,(IX+9)		;minutes (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+10)		;minutes (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon	

	LD   A,(IX+11)		;seconds (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+12)		;seconds (ones)   --> accu
	LD   (DE),A		;store them

	POP  DE			;restore ^user buffer
	LD   HL,ATIMBUF		;^(time & date buffer) 	      --> reg. HL
	LD   B,21		;length of time & date string --> reg. BC
	LD   A,01H		;source bank      = 0
				;destination bank = 1
	JP   $XMOVE		;transfer time & date string and return

;read time & date from clock chip:
GETTIM:	IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  10111111B		;1.78 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
        LD   HL,TIMBUF		;^temp buffer --> reg. HL
	LD   DE,10C4H		;register address displacement --> reg. D
				;register address & read mode  --> reg. E
	LD   B,13		;byte counter 		       --> reg. B
GETTI1:	LD   A,E		;read date & time
	OUT  (5BH),A
	SUB  D
	LD   E,A
	IN   A,(5AH)	 	
	AND  0FH		;mask undesired bits
	OR   '0'		;make ASCII digit
	LD   (HL),A
	INC  HL			;bump ^(time & date)
	DJNZ GETTI1
	POP  AF       		;restore system byte 1
	OUT  ($SYS1),A		;write system byte 1
	RET			;return to caller

DAYTAB:	DEFM 'SatSunMonTueWedThuFri'
TIMBUF:	DEFS 13
ATIMBUF:DEFM 'WWW MM/DD/YY HH:MM:SS'


*EJECT
;*******************
;*  $ S E T T I M  *
;*******************

;entry:  A = weekday (0 - 6, 0 = Sat)
;	 B = month   (MM)
;        D = hours   (HH)
;	 E = minutes (MM)
;	 H = day     (DD)
;	 L = year    (YY)


;set time and date in binary format:
$SETTIM:DI			;critical phase
	LD   IX,TIMBUF		;^temp buffer --> reg. IX
	LD   (IX+6),A		;weekday      --> buffer
	LD   A,L		;year (ones)  --> accu
	AND  0FH		;mask it
	LD   (IX+1),A		;year (ones)  --> buffer
	LD   A,L		;shift reg. L four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX),A		;year  (tenths) --> buffer
	LD   A,B		;month (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+3),A		;month (ones)   --> buffer
	LD   A,B		;shift reg. B four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+2),A		;month (tenths) --> buffer
	LD   A,H		;day   (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+5),A		;day   (ones)   --> buffer
	LD   A,H		;shift reg. H four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+4),A		;day   (tenths) --> buffer
	LD   A,D		;hours (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+8),D		;hours (ones)	--> buffer
	LD   A,D		;shift reg. D four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+7),A		;hours   (tenths) --> buffer
	LD   A,E		;minutes (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+10),A		;minutes (ones)   --> buffer
	LD   A,E		;shift reg. E four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+9),A		;minutes (tenths) --> buffer
	LD   (IX+11),0		;seconds (tenths) --> buffer
	LD   (IX+12),0		;seconds (ones)   --> buffer
	LD   HL,TIMBUF		;^buffer	  --> reg. HL
	LD   DE,10D2H		;register address displacement --> reg. D
				;register address	       --> reg. E
	LD   B,13		;byte counter 		       --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  10010111B		;disable graphic page
				;1.78 MHz clock frequency
	OR   00000101B		;disable memory mapped I/O
				;disable boot EPROM
	OUT  ($SYS1),A		;write system byte 1
SETTI1:	LD   A,E		;set date & time
	SUB  D
	LD   E,A
	OUT  (05BH),A
	LD   A,(HL)
	OUT  (5AH),A
	INC  HL			;bump ^(time & date)
	DJNZ SETTI1
	IN   A,($SYS1)		;read system byte 1
	OR   01000000B		;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	JP   GETTIM		;adjust clock chip and return to caller


*EJECT
;Winchester disk driver:

	COND SASI		;Xebec part

MAXDRIVE EQU 2			;drive count

;DC registers:
WPORT0	EQU  00H		;SASI write port 0 - write data
WPORT1	EQU  01H		;SASI write port 1 - software reset
WPORT2	EQU  02H		;SASI write port 2 - cntlr select
RPORT0	EQU  00H		;SASI read  port 0 - read data
RPORT1	EQU  01H		;SASI read  port 1 - read status

;DC commands:
$TSTDRV	EQU  00H		;test drive ready
$REST  	EQU  01H		;recalibrate
$STATUS	EQU  03H		;request sense status
$$READ	EQU  08H		;read
$$WRITE	EQU  0AH		;write
$INIDRV EQU  0CH		;initialize drive characteristics

;DC status bits:
REQMASK EQU  01H		;request mask for bit test
BUSYMASK EQU 02H		;busy    mask for bit test
CDMASK	EQU  08H                ;command/data bit position test
IOMASK	EQU  10H		;input/output bit mask
ERROR	EQU  02H		;test for an error

	ELSE			;WD1002 part

MAXDRIVE EQU 3			;drive count

;WDC registers:
$DATA  	EQU  50H  		;data register	
$WPC    EQU  51H  		;write precomp register
$ERROR  EQU  51H  		;error register
$SECNO 	EQU  53H  		;sector number register
$CYLLO  EQU  54H  		;cylinder low register
$CYLHI  EQU  55H  		;cylinder high register
$SDH	EQU  56H		;size/drive/head register
$COMND  EQU  57H		;command register
$STATUS	EQU  57H		;status register

;WDC commands:
$REST   EQU  10H		;restore
$$READ 	EQU  20H		;read sector
$$WRITE	EQU  30H		;write sector
$DSEL	EQU  98H		;deselect drive

	ENDC


*EJECT
;*****************
;*  $ R E A D W  *
;*****************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       DE = track  number
;       HL = buffer pointer

;exit : A  = error status returned from controller
;	 0 = NO ERROR
;	-1 = ILLEGAL DRIVE #
;	-2 = TRACK # TOO HIGH
;	-3 = SECTOR # TOO HIGH
;	else error code returned by controller

;read a sector:
$READW:	LD   C,A		;save drive/bank number
       	LD   A,0FFH
	JR   TASKW		;read sector


*EJECT
;*****************
;*  $ W R I T W  *
;*****************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       DE = track  number
;       HL = buffer pointer

;exit : A  = error code
;	 0 = NO ERROR
;	-1 = ILLEGAL DRIVE #
;	-2 = TRACK # TOO HIGH
;	-3 = SECTOR # TOO HIGH
;	else error code returned by controller

;write a sector:
$WRITW:	LD   C,A		;save drive/bank number
       	XOR  A


;dominant controller:
TASKW:	LD   (RDFLAG),A		;set/cear READ-flag
	LD   A,C		;restore drive/bank #
      	RRA    			;get bank number of transfer buffer
	RRA
	RRA
	RRA
	AND  0FH
	LD   (BANK),A		;store bank #
        LD   A,C      		;restore drive/bank #
	AND  0FH		;mask drive #
     	CP   MAXDRIVE		;legal drive # ?
	JR   C,TRKNOW		;jump if yes
	LD   A,-1		;error code 1 --> accu
	RET
TRKNOW: LD   (DRIVE),A		;store drive #
	LD   (BUFFER),HL	;store buffer pointer
       	CALL GETWCT		;get control table ptr
	LD   A,D        	;track # (MSB) --> accu
      	CP   (IX+6)		;legal track # ?
	JR   C,SECNOW		;jump if yes
	JR   Z,CPLOW		;compare LSB's
TRKERR:	LD   A,-2		;error code 2 --> accu
	RET
CPLOW:	LD   A,E      		;track (LSB) --> accu
	CP   (IX+5)		;legal track # ?
	JR   NC,TRKERR		;jump if not
SECNOW:	LD   (TRACK),DE		;store track #
	LD   A,B       		;sector # --> accu
	CP   (IX+4)		;legal sector # ?
	JR   C,INITW		;jump if yes
	LD   A,-3		;error code 3 --> accu
	RET

;actual I/O handler:		
INITW:	LD   (SECTOR),A		;store sector #


*EJECT
	COND SASI		;Xebec part

	LD   A,(OLDW)		;number of previously accessed drive --> reg. C
	LD   C,A
	OR   A			;no drive previously accessed ?
	JP   P,INITW1		;select controller
	OUT  (WPORT1),A		;reset controller
INITW1:	LD   A,(DRIVE)		;drive # --> accu
	LD   (OLDW),A		;save it
	CP   C			;same as old drive ?
	JR   Z,INITW2 		;no drive selection needed if yes

;select Winchester drive:
       	LD   IY,WPARS		;^Winchster parameters --> reg. IY
	LD   H,(IX+6)		;track count --> reg. HL
	LD   L,(IX+5)
	LD   D,0   		;clear MSB of divisor
    	LD   E,(IX)  		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	LD   (IY+2),E		;load head count
	CALL DIV		;calc cylinder count
	LD   (IY),H		;load cylinder count
	LD   (IY+1),L
	LD   (IY+3),H		;load starting cylinder 
	LD   (IY+4),L		;for reduced write current
	LD   H,0		;calc startimg cylinder for write precomp
	LD   L,(IX+2)
	ADD  HL,HL
	ADD  HL,HL
	LD   (IY+5),H		;load starting cylinder for write precomp
	LD   (IY+6),L
	LD   A,$INIDRV		;initialize drive data
	CALL TASKOUT

	LD   HL,WPARS		;^Winchester parameters --> reg. HL
	LD   BC,8 SHL 8+WPORT0	;number of bytes	--> reg. B
				;SASI port 0 		--> reg. C
        CALL REQWAIT		;wait for data request
SELDRV:	IN   A,(RPORT1)		;read status again
	AND  IOMASK+CDMASK+REQMASK	
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,SELDRV1		;jump if data transfer finished
	CP   REQMASK
	JR   NZ,SELDRV 		;wait for request
	OTIR			;load disk parameters
	JR   SELDRV

SELDRV1:CALL GETSTAT		;get error status
	JR   NZ,ERREXIT		;any errors ?

INITW2:	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,RWINI		;jump if yes

;restore drive heads:
RESTOW:	LD   A,$TSTDRV		;test drive ready
	CALL TASKOUT
	CALL GETSTAT		;get error status
	JR   NZ,RESTOW		;retry if drive not ready
        LD   A,$REST  		;recalibrate drive
	CALL TASKOUT
	CALL GETSTAT		;get error status
	JR   NZ,ERREXIT		;any errors ?
      	SET  0,(IX+1)		;set init bit in WCT


*EJECT
	ELSE			;WD1002 part

	EX   DE,HL		;track #  --> reg. HL
	LD   D,0   		;clear MSB of divisor
    	LD   E,(IX)  		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	CALL DIV		;cylinder # = track # / head count (HL)
				;surface #  = track # % head count (DE)
	LD   A,(DRIVE)		;drive # --> accu
	ADD  A,A		;shift drive # 3 bits left
	ADD  A,A
	ADD  A,A
	ADD  A,E		;add surface #
	LD   E,A		;and save it
	LD   A,(IX+1)		;get sector length bits
	RRA
	AND  60H		;mask sector length bits
	ADD  A,E		;add surface # and drive #
	OR   80H		;set ECC error correction bit
	LD   E,A		;save drive select bits
	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,TRKSEW 		;yes, skip init process

;restore drive heads:
RESTOW:	IN   A,($STATUS)	;read WDC status
	AND  0C0H		;mask it
	CP   40H		;busy ?
	JR   NZ,RESTOW		;wait `til WDC is ready to accept a command
	OUT  ($SDH),A		;select drive
	LD   A,(IX)		;get step rate bits
	AND  0FH		;mask them
	OR   $REST		;or with "restore" command
	OUT  ($COMND),A		;restore drive heads
RESTO1: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;restore done ?
	JR   NZ,RESTO1 		;no, loop
      	SET  0,(IX+1)		;set init bit in WCT

;set track and sector:
TRKSEW: LD   A,(IX+2)		;set starting track for write precomp
	OUT  ($WPC),A
        LD   A,(SECTOR)		;sector # --> accu
	BIT  4,(IX)		;test number of first sector
	JR   Z,TRKSW1		;jump if zero
	INC  A			;else adjust sector #
TRKSW1:	OUT  ($SECNO),A         ;set sector #
	LD   A,L     		;set cylinder # (LSB)
	OUT  ($CYLLO),A
	LD   A,H                ;set cylinder # (MSB)
	OUT  ($CYLHI),A
	LD   A,E		;restore drive select bits
	OUT  ($SDH),A		;select drive

;init READ/WRITE:
	LD   E,(IX+1)		;get sector length bits
	LD   B,6
	SRL  E
	DJNZ $-2
	LD   C,$DATA		;init byte counter and data port number

	ENDC

RWINI:  LD   HL,(BUFFER)	;get buffer pointer	
	LD   A,(RDFLAG)		;READ or WRITE ?
	OR   A
	PUSH AF			;save status
	JR   Z,RWINI1		;jump if write
	LD   A,$$READ		;issue read command
	JR   RWINI2
RWINI1:	LD   A,$$WRITE		;issue write command
	
	COND SASI		;Xebec part

RWINI2:	CALL TASKOUT

	ELSE

RWINI2:	OUT  ($COMND),A		;WD1002 part

	ENDC

	LD   A,(BANK)		;bank # of transfer buffer --> accu
	JP   IOW		;handle Winchester I/O in common memory

;test controller status:

	COND SASI		;Xebec part

WDCSTAT:CALL GETSTAT		;get status
	RET  Z			;return if no errors
ERREXIT:LD   A,$STATUS		;request sense status
	CALL TASKOUT
	
        CALL REQWAIT		;wait for data request
        IN   A,(RPORT0)		;read error code
	LD   D,A		;save it temporarily
	IN   A,(RPORT0)		;skip rest
	IN   A,(RPORT0)
	IN   A,(RPORT0)
	CALL GETSTAT		;get status 
	JR   NZ,ERREXIT

        LD   A,D      		;restore error code
	AND  7FH
	RET

	ELSE			;WD1002 part

WDCSTAT:IN   A,($STATUS)	;get WDC status
	AND  1  		;any errors ?
	LD   C,A		;save error status
	JR   Z,DSEL		;return if no errors
	IN   A,($ERROR)	        ;read WDC error register
	LD   C,A		;save error code

DSEL:	LD   A,$DSEL 		;deselect drive
	OUT  ($SDH),A
	LD   A,C		;error code --> accu
	RET			;return to caller

	ENDC

;put drive control table pointer in "IX":
GETWCT: PUSH DE			;save reg. DE
	LD   H,0		;drive # --> reg. HL	
	LD   L,A		
	ADD  A,A		;drive # * 2
	ADD  A,L		;drive # * 3
	ADD  A,A		;drive # * 6
	ADD  A,L  		;drive # * 7	
	LD   L,A		;drive # * 7 --> reg. H
	LD   DE,DCTW		;get drive table start
  	ADD  HL,DE		;add offset and get ^DCT
	PUSH HL			;^DCT --> reg. IX
	POP  IX
	POP  DE			;restore reg. DE
	RET			;return

BANK:	DEFS 1			;bank number of transfer buffer


*EJECT
	COND SASI		;Xebec part

;output a command to SASI controller:
TASKOUT:PUSH HL			;save regs. HL & IY
	PUSH IY			;save reg. IY
	LD   IY,DCCMD		;^command block --> reg. IY
	LD   (IY),A		;store command
	LD   A,(DRIVE)		;load drive #
	RRCA
	RRCA
	RRCA
	LD   (IY+1),A
	LD   DE,(TRACK)		;track #         	 --> reg. DE
	LD   HL,0		;clear result
	LD   B,(IX+4)		;sectors/track 		 --> reg. B
TASKO1: ADD  HL,DE		;track # * sectors/track --> reg. HL
	DJNZ TASKO1
	LD   D,0		;sector # 		 --> reg. DE
	LD   A,(SECTOR)
	LD   E,A
	ADD  HL,DE		;block # = track # * sectors/track + sector #
	LD   (IY+2),H		;load block #
	LD   (IY+3),L
	LD   A,(IX)		;get step rate ?
	AND  0FH
	LD   A,0
	JR   NZ,TASKO2  	;jump if not
	LD   A,5		;set buffered step mode
TASKO2: LD   (IY+5),A		;load control byte

TASKO3:	IN   A,(RPORT1)		;read status port
	AND  BUSYMASK		;mask busy bit
	JR   NZ,TASKO3		;jump, if busy
	LD   A,1		;cntlr default select code
	OUT  (WPORT0),A		;send it to transparent latch
TASKO4:	OUT  (WPORT2),A		;generate a select strobe
      	IN   A,(RPORT1)		;get cntlr response
	AND  BUSYMASK		;isolate the busy mask
	JR   Z,TASKO4		;wait for cntlr busy

	LD   HL,DCCMD		;^command block --> reg. HL
	LD   BC,6 SHL 8+WPORT0	;byte count	--> reg. B
				;port number	--> reg. C
	CALL REQWAIT   		;wait for controller request
	OTIR			;load command

	POP  IY			;restore regs. HL & IY
	POP  HL
	RET

;get status:
GETSTAT:CALL REQWAIT		;wait for request
	IN   A,(RPORT0)		;read in the status byte
	LD   C,A		;save status temporarily
	CALL REQWAIT		;wait for second byte
	IN   A,(RPORT0)		;get the null byte
	LD   A,C		;restore status to A
	AND  ERROR		;isolate the error bit
	RET

;Winchester drive parameters:
WPARS:	DEFS 2			;cylinder count
	DEFS 1			;head 	  count
	DEFS 2          	;starting cylinder for reduced write current
	DEFS 2			;starting cylinder for write precompensation
	DEFB 11			;length of ECC impulse

;command control block:
DCCMD:	DEFS 1			;opcode
	DEFS 1			;luno
	DEFS 2			;block number
	DEFB 1			;block count
	DEFS 1			;control field

SENSE:	DEFS 4			;sense status bytes
OLDW:	DEFB 0FFH		;previously accessed drive

	ENDC


*EJECT
;*******************
;*  $ G T I M E 3  *
;*******************

;entry: HL = pointer to a 5 byte buffer containing on exit
;	     date and time in the form DDDDHHMMSS

;	      DDDD = number of days since January 1st, 1978 (binary    )
;		HH = hours   				    (BCD format)
;		MM = minutes 				    (BCD format)
;		SS = seconds 				    (BCD format)

;get time & date in CP/M 3 format (software clock):
$GTIME3S:
	EX   DE,HL		;^user buffer --> reg. DE
	DI			;critical phase
	JP   GTIME5		;transfer time & date into caller's buffer

;get time & date in CP/M 3 format (hardware clock):
$GTIME3H:
	DI			;critical code (not reentrant)
	PUSH HL			;save ^user buffer
        CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer   --> reg. IX
	LD   IY,BINARY$DATE 	;^result buffer --> reg. IY	

	LD   A,(IX+7)		;hours (tenths) --> reg. C
	AND  3			;make binary
	RLCA    		;hours (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	--> reg. C
	LD   A,(IX+8)		;hours (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+2),A           ;store BCD hours	

	LD   A,(IX+9)		;minutes (tenths) --> reg. C
	AND  7			;make binary
	RLCA    		;minutes (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+10)		;minutes (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+3),A           ;store BCD minutes

	LD   A,(IX+11)		;seconds (tenths) --> reg. C
	AND  7			;make binary
	RLCA    		;seconds (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+12)		;seconds (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+4),A           ;store BCD seconds

	LD   A,(IX+1)		;year (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;year (ones)   --> reg. C
	LD   A,(IX)		;year (tenths) --> accu
	AND  0FH		;make binary
	CALL BCDBIN		;convert BCD year to binary
	LD   (YEAR),A		;store it

	LD   A,(IX+3)		;month (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;month (ones)   --> reg. C
	LD   A,(IX+2)		;month (tenths) --> accu
	AND  1  		;make binary
	CALL BCDBIN		;convert BCD month to binary
	LD   (MONTH),A		;store it

	LD   A,(IX+5)		;day (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;day (ones)   --> reg. C
	LD   A,(IX+4)		;day (tenths) --> accu
	AND  3  		;make binary
	CALL BCDBIN		;convert BCD day to binary
	LD   (DAY),A		;store it

	LD   A,(YEAR)		;binary year --> accu
	SUB  78                 ;subtract base year
	JR   NC,GTIME1          ;result negative ?
	ADD  A,100              ;correct year	
GTIME1: SRL  A			;year / 4 --> accu
	RR   C        		;year % 4 --> reg. C
	SRL  A
	RR   C
	LD   B,6
GTIME2: SRL  C
	DJNZ GTIME2
	LD   HL,0               ;clear daycount
	OR   A			;year / 4 == 0 ?
	JR   Z,GTIME4		;no multiplication
	LD   B,A                ;year / 4 --> reg. B
	LD   DE,1461		;number of days in 4 years --> reg. DE
GTIME3: ADD  HL,DE              ;daycount = year / 4 * 1461
	DJNZ GTIME3
GTIME4:	EX   DE,HL		;daycount --> reg. DE

;calc table index:
	LD   A,C		;year %  4    --> accu
	ADD  A,A		;accu *  2
 	ADD  A,A		;accu *  4
	LD   C,A     		;accu *  4    --> reg. C
  	ADD  A,A		;accu *  8
	ADD  A,C   		;accu * 12
	LD   C,A		;accu * 12    --> reg. C
	LD   A,(MONTH)          ;binary month --> accu
	DEC  A     		;normalize
	ADD  A,C		;index = year % 4 * 12 + month - 1
	ADD  A,A		;make byte index
	LD   C,A		;table index       --> reg. BC
	LD   HL,MONTAB          ;base of day table --> reg. HL
	ADD  HL,BC		;add index
	LD   A,(HL)		;table[index]      --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,A

	ADD  HL,DE 		;daycount += table[index]
	LD   A,(DAY)		;binary day --> accu
	LD   C,A   		;day        --> reg. BC
	ADD  HL,BC		;now reg. HL contains number of days
	        		;since January 1st, 1978

	LD   (IY),L 		;store daycount
	LD   (IY+1),H           

	POP  DE			;restore ^user buffer
GTIME5:	LD   HL,BINARY$DATE	;^temporary buffer --> reg. HL
	LD   B,5		;buffer length	   --> reg. B
	LD   A,(INT)		;called from interrupt service routine ?
	OR   A
	LD   A,1  		;source bank      = 0
				;destination bank = 1
	JP   Z,$XMOVE		;move time & date into user buffer and return,
				;if not called from interrupt service routine

	LD   BC,5		;buffer length --> reg. BC
	LDIR			;no interbank move, if called from interrupt
	RET			;service routine

;convert BCD to binary:
BCDBIN:	ADD  A,A		;lower nibble *  2
	LD   B,A		;lower nibble *  2 --> reg. B
	ADD  A,A		;lower nibble *  4
	ADD  A,A		;lower nibble *  8
	ADD  A,B		;lower nibble * 10
	ADD  A,C		;add lower nibble
	RET

YEAR:	DEFS 1
MONTH:	DEFS 1
DAY:	DEFS 1


*EJECT
;*******************
;*  $ S T I M E 3  *
;*******************

;entry:  D = hours   (HH)
;	 E = minutes (MM)
;	HL = number of days since January 1st, 1978 (binary)

;set time & date in CP/M 3 format (software clock):
$STIME3S:
	DI			;critical phase
	LD   (BINARY$DATE),HL	;load binary date
	LD   HL,TIME$IN$BCD	;^BCD time --> reg. HL
	LD   (HL),D		;load BCD hours
	INC  HL
	LD   (HL),E		;load BCD minutes
	INC  HL
	LD   (HL),0		;reset BCD seconds
	RET			;return to caller

;set time & date in CP/M 3 format (hardware clock):
$STIME3H:
	PUSH DE			;save hours & minutes
	PUSH HL			;save daycount
	DEC  HL			;normalize

        XOR  A     		;clear quotient
	LD   DE,1461  		;number of days in 4 years --> reg. DE
STIME1: SBC  HL,DE              ;daycount / 1461 	   --> accu
	JR   C,STIME2
	INC  A
	JR   STIME1
STIME2: ADD  HL,DE              ;adjust remainder
	EX   DE,HL		;remainder --> reg. DE
	ADD  A,A		;accu * 2
	ADD  A,A		;accu * 4
	LD   (YEAR),A           ;year = daycount / 1461 * 4

;search table entry:
	LD   A,47               ;last index 	   --> accu
STIME3: LD   H,0                ;index #           --> reg. HL
	LD   L,A
	ADD  HL,HL  		;make byte index
	LD   BC,MONTAB          ;dase of day table --> reg. BC
	ADD  HL,BC		;calc table entry
	LD   B,(HL)             ;table[index]      --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,B
	SBC  HL,DE              ;daycount >= table index ?
	JR   C,STIME4 		;if yes search finished
	JR   Z,STIME4
	DEC  A  		;index = index - 1
	JP   P,STIME3

STIME4: LD   B,0                ;clear quotient
STIME5:	SUB  12                 ;index / 12 --> accu
	JR   C,STIME6
	INC  B			;increment quotient
	JR   STIME5
STIME6:	ADD  A,13		;adjust remainder and calc month
	LD   (MONTH),A          ;store it
	LD   A,(YEAR) 		;year --> accu
	ADD  A,B   		;year += index / 12
	SUB  22			;normalize
	JR   NC,STIME7          ;year negative ?
	ADD  A,100		;correct it
STIME7: LD   (YEAR),A           ;store it
	LD   A,L		;table[index] - daycount --> accu
	NEG     		;daycount - table[index] --> accu
	INC  A     		;day = daycount - table[index] + 1
	LD   (DAY),A            ;store it

	POP  HL			;restore day count
	LD   A,H		;daycount (MSB)	      --> accu
	LD   C,L		;daycount (LSB)	      --> reg. C
	LD   DE,7		;no. of days per week --> reg. DE
	LD   HL,0		;clear accumulator
	LD   B,16		;init counter
STIME8:	RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
	SBC  HL,DE		;subtract divisor
	JR   NC,$+3		;subtraction ok
	ADD  HL,DE		;restore accumulator
	CCF			;complement carry flag
	DJNZ STIME8		;counter = 0 ?
	LD   A,L		;weekday no. --> accu
        PUSH AF 		;save weekday

	LD   A,(MONTH)		;binary month --> accu
	CALL BINBCD		;convert to BCD format
	LD   D,A     		;save month

	LD   A,(DAY)		;binary day --> accu
	CALL BINBCD		;convert to BCD format
	LD   H,A		;BCD day     --> reg. H
	LD   A,(YEAR)		;binary year --> accu
	RRA			;year / 4
	JR   C,STIME9
	RRA
	JR   C,STIME9
       	SET  6,H		;set leapyear flag

STIME9:	LD   A,(YEAR)		;binary year --> accu
	CALL BINBCD		;convert to BCD format
	LD   L,A   		;BCD year    --> reg. L

	LD   B,D		;BCD month   --> reg. B
	POP  AF			;weekday     --> accu
	POP  DE			;BCD hours   --> reg. D
				;BCD minutes --> reg. E
	SET  7,D		;set "24 hour" format
	JP   $SETTIM		;set time & date and return to caller

;convert binary to BCD:
BINBCD:	LD   C,0		;clear result
BINBC1: SUB  10			;accu / 10
	JR   C,BINBC2
	INC  C  		;increment quotient
	JR   BINBC1
BINBC2: ADD  A,10		;adjust remainder
	LD   B,4
BINBC3:	SLA  C			;quotient --> upper nibble
	DJNZ BINBC3
	ADD  A,C		;add remainder
	RET

;day table:
;	     Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec	
MONTAB:	DEFW 0000,0031,0059,0090,0120,0151,0181,0212,0243,0273,0304,0334  ;1978
        DEFW 0365,0396,0424,0455,0485,0516,0546,0577,0608,0638,0669,0699  ;1979
        DEFW 0730,0761,0790,0821,0851,0882,0912,0943,0974,1004,1035,1065  ;1980
        DEFW 1096,1127,1155,1186,1216,1247,1277,1308,1339,1369,1400,1430  ;1981


*EJECT
;*******************
;*  $ L D C H A R  *
;*******************

;entry:  A = ASCII code of character to be loaded (00 - 7F)
;	HL = address of dot matrix (16 bytes)

;load user character:
$LDCHAR:AND  7FH		;make seven bit ASCII code
	PUSH AF			;save ASCII code
	LD   DE,PATTERN		;^dot matrix     --> reg. DE
	LD   B,16		;number of bytes --> reg. B
	LD   A,10H		;source bank 	  = 1
				;destination bank = 0
	CALL $XMOVE		;load matrix
	POP  BC			;ASCII code --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	LD   A,B		;ASCII code --> accu
	LD   (3C00H),A		;load ASCII code
	LD   DE,PATTERN		;^dot matrix 	  	     --> reg. DE
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
LDCHAR1:LD   A,(DE)		;get first scan	line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ LDCHAR1		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	OR   80H		;set MSB
	LD   (3C00H),A		;reload code	
	LD   DE,PATTERN		;^dot matrix 	  	     --> reg. DE
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
LDCHAR2:LD   A,(DE)		;get first scan	line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ LDCHAR2		;load next scan line
	LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A
	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;disable character RAM
	OUT  ($SYS0),A		;write system byte 0
	RET			;return to caller
PATTERN:DEFS 16			;temporary storage area for dot matrix
SAVECH:	DEFS 1


*EJECT
;*******************
;*  $ R S T C H R  *
;*******************

;restore original character set:
$RSTCHR:IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	XOR  A  		;reset code counter
	LD   DE,FONTSET		;^dot matrices --> reg. DE
RSTCHR1:LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
RSTCHR2:LD   A,(DE)		;get first scan	line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ RSTCHR2		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	INC  A			;increment ASCII code
	JP   P,RSTCHR1		;load next character

;load inverted characters
	LD   DE,FONTSET		;^dot matrices --> reg. DE
RSTCHR3:LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
RSTCHR4:LD   A,(DE)		;get first scan	line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ RSTCHR4		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	INC  A			;increment ASCII code
	JR   NZ,RSTCHR3		;load next character
	LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A

;select ASCII or national character set:
SELCHR:	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	LD   IX,NATIONAL	;^national codes --> reg. IX
	LD   A,(GERMAN)		;national char set ?
	OR   A
	JR   Z,SELCHR1		;jump if no 
	LD   DE,FONTSET+136*16	;^dot matrices  --> reg. DE
	JR   SELCHR2
SELCHR1:LD   DE,FONTSET+128*16	;^dot matrices  --> reg. DE
SELCHR2:LD   A,(IX)		;character code --> accu
	OR   A			;end of table ?
	JR   Z,SELCHR4		;jump if yes
	INC  IX			;bump table ptr
        LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
SELCHR3:LD   A,(DE)		;get first scan	line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ SELCHR3		;load next scan line
	JR   SELCHR2  		;load next character

;load inverted characters:
SELCHR4:LD   IX,NATIONAL	;^national codes --> reg. IX
        LD   A,(GERMAN)		;national char set ?
	OR   A
	JR   Z,SELCHR5		;jump if no 
	LD   DE,FONTSET+136*16	;^dot matrices  --> reg. DE
	JR   SELCHR6
SELCHR5:LD   DE,FONTSET+128*16	;^dot matrices  --> reg. DE
SELCHR6:LD   A,(IX)		;character code --> accu
	OR   A			;end of table ?
	JR   Z,SELCHR8		;jump if yes
	OR   80H		;make code of inverted char
	INC  IX			;bump table ptr
        LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
SELCHR7:LD   A,(DE)		;get first scan	line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ SELCHR7		;load next scan line
	JR   SELCHR6  		;load next character

SELCHR8:LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A
	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;disable character RAM
	OUT  ($SYS0),A		;write system byte 0
	EI			;reenable interrupts
	RET			;return to caller


;codes of national character set:
NATIONAL:
	DEFM '@[\]{|}~' 
	DEFB 0


*EJECT
;*******************
;*  $ S C R N I O  *
;*******************

;entry:  A = control code
;	     0  read  window
;	     1  write window
;	HL = address of user buffer
;	 D = 0  contiguous  buffer
;	     1  full screen buffer 	
;	 E = attribute
;	     0  normal   display
;	     1  inverted display	

;direct screen I/O:
$SCRNIO:LD   IX,(VDTABP)	;^screen constants --> reg. IX
	LD   (IOMODE),A		;save I/O mode
	PUSH HL			;save ^user buffer
	PUSH DE			;save buffer mode
	LD   A,(IX+8)		;save current line
	LD   (SLINE),A
	LD   A,(IX+9)		;save current column
	LD   (SCOLUMN),A
	LD   A,(IX+11)		;save current display mode
	LD   (SMODE),A	
	LD   A,(IX+12)		;save cursor state
	LD   (SCUROFF),A
	LD   A,(WRAP)		;save "wrap around" mode
	LD   (SWRAP),A
	DEC  E			;test display mode
	JR   Z,SCRNIO1		;jump if inverse display mode
	CALL INVOFF		;turn on normal display mode 
	JR   SCRNIO2
SCRNIO1:CALL INVON		;turn on inverse display mode
SCRNIO2:CALL CUROFF		;turn off cursor
	CALL WRAPOFF		;turn off "wrap around" mode
	CALL HOME		;home cursor
	
	POP  DE			;get buffer mode
	DEC  D			;calc buffer increment
	JR   Z,SCRNIO3		;jump if full screen buffer
	LD   A,(IX+7)		;buffer increment = column count
	JR   SCRNIO4
SCRNIO3:LD   A,(IX+1)		;buffer increment = maximum column count
	POP  DE			;get base address of screen buffer
	ADD  HL,DE		;add cursor address (returned from "HOME")
	PUSH HL			;save actual buffer address
SCRNIO4:LD   (BINC),A		;store buffer increment

;screen I/O:
	LD   A,(IOMODE)		
	OR   A			;read or write screen ?
	JR   NZ,SCRNIO9		;jump if write screen


*EJECT
;read screen:
SCRNIO5:LD   IY,LINBUF		;^temp buffer --> reg. IY
	LD   B,(IX+7)		;column count --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1

SCRNIO6:PUSH BC			;save remaining column count
	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   A,(HL)		;character under cursor  --> accu
	AND  7FH		;mask it
	CP   (IX+10)		;erase character ?
	JR   NZ,SCRNIO7		;jump if not
	LD   A,' '		;convert it to space
SCRNIO7:CP   ' '		;graphic character ?
	JR   NC,SCRNIO8		;jump if not
	ADD  A,80H		;convert code of graphic character
SCRNIO8:LD   (IY),A		;store character
	INC  IY			;inc buffer pointer
	CALL CURRGT		;move cursor right
	POP  BC			;restore column count
	DJNZ SCRNIO6		;read next character

	IN   A,($SYS1)		;read system byte 1
	OR   01010101B		;disable memory mapped I/O
	OUT  ($SYS1),A		;write system byte 1
	LD   HL,LINBUF		;source      address --> reg. HL
	POP  DE			;destination address --> reg. DE
	PUSH DE
	LD   B,(IX+7)		;byte count	     --> reg. B
	LD   A,1		;source      bank = 0
				;destination bank = 1
	CALL $XMOVE		;transfer screen line into user buffer

        LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; == bottom line ?
	JR   Z,SCRNI12      	;jump if yes

	CALL NEWLIN		;carriage return
	CALL CURDWN		;line feed

	LD   HL,(BINC)		;buffer increment --> reg. HL
	LD   H,0
	POP  DE			;buffer pointer   --> reg. DE
	ADD  HL,DE		;increment buffer pointer
	PUSH HL			;save it
	JR   SCRNIO5		;read next line


*EJECT
;write screen:
SCRNIO9:POP  HL			;source      address --> reg. HL
SCRNI10:PUSH HL			;save it
	LD   DE,LINBUF		;destination address --> reg. HL
	LD   B,(IX+7)		;byte count	     --> reg. B
	LD   A,10H		;source      bank = 1
				;destination bank = 0
	CALL $XMOVE		;transfer screen line into user buffer

        LD   IY,LINBUF		;^temp buffer --> reg. IY
	LD   B,(IX+7)		;column count --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1

SCRNI11:PUSH BC			;save remaining column count
	LD   A,(IY)		;character --> accu
	CALL NORMAL		;display character
	INC  IY			;inc buffer pointer
	POP  BC			;restore column count
	DJNZ SCRNI11		;display next character

	IN   A,($SYS1)		;read system byte 1
	OR   01010101B		;disable memory mapped I/O
	OUT  ($SYS1),A		;write system byte 1

        LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; == bottom line ?
	JR   Z,SCRNI12		;jump if yes

	CALL NEWLIN		;carriage return
	CALL CURDWN		;line feed

	LD   HL,(BINC)		;buffer increment --> reg. HL
	LD   H,0
	POP  DE			;buffer pointer   --> reg. DE
	ADD  HL,DE		;increment buffer pointer
	JR   SCRNI10		;write next line


*EJECT
;restore old screen state:
SCRNI12:POP  HL			;adjust stack pointer
	LD   A,(SLINE)		;restore current line
	LD   (IX+8),A
	LD   A,(SCOLUMN)	;restore current column
	LD   (IX+9),A
	LD   A,(SMODE)		;restore current display mode
	LD   (IX+11),A		
	LD   A,(SCUROFF)	;restore cursor state
	LD   (IX+12),A		
	LD   A,(SWRAP)		;restore "wrap around" mode
	LD   (WRAP),A
	CALL OUTCUR		;position cursor
	JP   CURON+4		;turn on (?) cursor and return to caller

;temporary storage area:
SLINE:	DEFS 1			;current cursor line
SCOLUMN:DEFS 1			;current cursor column
SMODE:	DEFS 1			;current display mode
SCUROFF:DEFS 1			;current cursor state
SWRAP:	DEFS 1			;current "wrap around" mode
IOMODE:	DEFS 1			;read or write screen ?
BINC:	DEFS 1			;buffer pointer increment
LINBUF:	DEFS 80			;line buffer


*EJECT
;***************
;*  $ I N I T  *
;***************

;general initialization routine:
$INIT:	DI			;disable interrupts
	IM   1			;select interrupt mode 1 (RST 38H)
 	IN   A,($SYS0)		;read system byte 0
	AND  00110011B		;enable bank 0
				;RTC interrupt only
	OUT  ($SYS0),A		;write system byte 0

	CALL $RSTCHR		;load character set

	XOR  A			;source bank      = 0
				;destination bank = 0
	LD   HL,VIDPAR		;^video parameters --> reg. HL
	CALL VDINIT1		;initialize video controller chip MC6845

	LD   A,ESC		;select national character set
	CALL $VDCHAR
	LD   A,(CHRSET)
	CALL $VDCHAR

	LD   B,0		;# of RS232C interface --> reg. B
	LD   HL,(SER0)		;data format 	       --> accu
	LD   A,L
	LD   E,H		;baud rate   	       --> reg. E
	CALL $RSINIT		;initialize Z80 SIO A

	LD   B,1		;# of RS232C interface --> reg. B
	LD   HL,(SER1)		;data format 	       --> accu
	LD   A,L
	LD   E,H		;baud rate   	       --> reg. E
	CALL $RSINIT		;initialize Z80 SIO B

	LD   HL,PIO$INIT$TBL	;initialize Z80 PIO 
STREAM$OUT:
	LD   A,(HL)
	OR   A
	JR   Z,$FCINIT
	LD   B,A
	INC  HL
	LD   C,(HL)
	INC  HL
	OTIR
	JR   STREAM$OUT		;now Z80 PIO acts as Centronics interface
PIO$INIT$TBL:
	DEFB 2,0D6H,0FH,07H
	DEFB 3,0D7H,0CFH,0F0H,07H
	DEFB 1,0D5H,01H
	DEFB 0

$FCINIT:LD   A,$FCINT           ;initialize floppy disk controller chip WD2791
        OUT  ($FDCMD),A


*EJECT
;powerup/reset test:
	LD   A,10H		;source      bank    = 1
				;destination bank    = 0
	LD   HL,0038H		;source      address = interrupt entry point
	LD   DE,JUMP		;destination address = test variable
	LD   B,1		;byte count 	     = 1
	CALL $XMOVE		;get byte from interrupt entry point in bank 1

	LD   A,(JUMP)		;JP ?
	CP   0C3H
	JR   NZ,$POWUP		;jump if power up
	XOR  A			;clear power up marker
	JR   $RESET
$POWUP:	LD   HL,1		;reset binary date
	LD   (BINARY$DATE),HL
	LD   HL,TIME$IN$BCD	;^BCD time --> reg. HL
	XOR  A
	LD   (HL),A		;reset BCD hours
	INC  HL
	LD   (HL),A		;reset BCD minutes
	INC  HL
	LD   (HL),A		;reset BCD seconds
	CPL        		;set power up marker
$RESET: LD   (POWUP),A

;set interrupt jump vectors:
	LD   A,3		;initialize bank number
$SETINT:LD   HL,0038H		;interrupt entry point --> reg. HL & DE
	LD   D,H
	LD   E,L
	LD   B,3		;byte count 	       --> reg. B
	PUSH AF			;save bank number
	CALL $XMOVE		;transfer jump vector
	POP  AF			;restore bank number
	DEC  A			;decrement bank number
	JR   NZ,$SETINT		;load next interrupt entry point

;hardware clock ?
	LD   A,(CLOCK)
	OR   A
	JR   Z,$CLSGR		;jump if not
	LD   HL,$GTIME3H	;alter entry vectors to 
	LD   ($GTIME3),HL	;clock maintenance routine
	LD   HL,$STIME3H
	LD   ($STIME3),HL

;clear graphic pages:
$CLSGR:	XOR  A			;colour = black
	LD   B,A		;clear graphic page 0
	CALL $CLS
	XOR  A			;colour = black
	LD   B,1		;clear graphic page 1
	CALL $CLS

;calc number of graphic scan lines:
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   DE,(VIDPAR+6)	;number of text	lines		    --> reg. DE
	LD   D,0
	LD   H,D
	LD   L,D
LOOP:	ADD  HL,DE		;calc total number of scan lines - 1
	DJNZ LOOP
	DEC  HL
	LD   (YMAX),HL		;store them		

;build table of y-addresses:
	LD   BC,(VIDPAR+5)	;number of text lines --> reg. B
	LD   DE,YTAB		;^address table	      --> reg. DE
	LD   HL,8000H   	;^graphic screen      --> reg. HL
OLOOP:	PUSH BC			;save line counter
	LD   (YBASE),HL		;store base address
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
ILOOP:	LD   A,L		;calc y address
	LD   (DE),A
	INC  DE
	LD   A,H
	LD   (DE),A
	INC  DE
	LD   A,8
	ADD  A,H
	LD   H,A
	DJNZ ILOOP		;process next scan line
	LD   HL,(YBASE)		;bump base address
	LD   BC,80
	ADD  HL,BC
	POP  BC			;restore line counter
	DJNZ OLOOP		;process next text line

;build table of normalized y-addresses:
	LD   IX,YNTAB		;^address table --> reg. IX
	LD   DE,0		;initialize scan line counter

NOLOOP:	PUSH DE			;save it

	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   HL,0			
NILOOP:	ADD  HL,DE		;y-coordinate * # of scan lines
	DJNZ NILOOP

	LD   DE,18		;load divisor
	CALL DIV
	LD   A,E		;remainder --> accu
	CP   9			;remainder >= 9 ?
	JR   C,$+3  		;jump if not
	INC  HL			;round normalized y-coordinate

	ADD  HL,HL		;make word index
	LD   DE,YTAB		;^unnormalized address table --> reg. DE
	ADD  HL,DE		;calc entry address
	LD   A,(HL)		;copy table entry
	LD   (IX),A
	INC  IX
	INC  HL
	LD   A,(HL)
	LD   (IX),A
	INC  IX
	
	POP  DE			;restore scan line counter
	INC  DE			;increment it
	LD   HL,450		;total count of scan lines --> reg. HL
	CALL CMP		;reached ?
	JR   NZ,NOLOOP		;process next scan line if not
	RET

YBASE:	DEFS 2       		;base address of graphic screen - 80
JUMP:	DEFS 1			;byte at 0038H in bank 1


*EJECT
;*****************
;*  $ C L O C K  *
;*****************

;entry: A =  0  clock display off
;	  <> 0  clock display on
;	B = line   number (0 - 24)
;	E = column number (0 - 79)

;set clock display on/off:
$CLOCK:	LD   IX,(VDTABP)	;^screen constants 		  --> reg. IX
	LD   HL,$SCREEN		;address of first screen location --> reg. HL
	LD   C,E		;display column			  --> reg. C
	LD   D,0		;maximum column count		  --> reg. DE
	LD   E,(IX+1)
	DEC  B			;calc absolute screen address
	INC  B
	JR   Z,CLOCK2
CLOCK1:	ADD  HL,DE
	DJNZ CLOCK1
CLOCK2:	LD   E,C
	ADD  HL,DE
	LD   (CLOCK$LOC),HL	;save display address
       	LD   (CLOCKON),A	;set/reset display marker
	RET			;return to caller
CLOCKON:DEFB 0
CLOCK$LOC:
	DEFS 2


*EJECT
;***************
;*  $ D I S P  *
;***************

;entry: A =  0  turn off graphic display
;	  <> 0  turn on  graphic display
;	B =  graphic page number (0, 1)

$DISP:	LD  C,A			;save accu
	IN  A,($SYS0)		;read system byte 0
	AND 00100001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	INC B			;test page number
	DEC B
	JR  Z,DISP1		;jump if page 0
  	SET 4,A			;select page 1
DISP1:	OUT ($SYS0),A		;write system byte 0
	
	IN  A,($SYS1)		;read system byte 1
	AND 11010101B		;7.2 MHz clock rate
				;disable graphic page
				;disable boot ROM
				;disable graphic display
				;disable memory mapped I/O
	INC C			;test display mode
	DEC C
	JR  Z,DISP2		;jump if no display
	SET 1,A			;enable graphic display
DISP2:	OUT ($SYS1),A		;write system byte 1
	RET			;return to caller


*EJECT
;*************
;*  $ C L S  *
;*************

;entry: A = 0  black
;	    1  white
;	B = graphic page number (0, 1)

;clear graphic page:
$CLS:	LD  C,A			;save colour
	IN  A,($SYS0)		;read system byte 0
	AND 00010001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	INC B			;test page number
	DEC B
	JR  Z,CLS1		;jump if page 0
	SET 5,A			;select page 1
CLS1:	OUT ($SYS0),A		;write system byte 0


	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	LD  A,C			;restore colour
	LD  HL,8000H		;^graphic memory        --> reg. HL
	LD  DE,8001H		;^graphic memory + 1    --> reg. DE
	LD  BC,7FFFH		;size of graphic memory --> reg. BC
	OR  A			;colour ?
	JR  Z,CLS2		;jump if black
	LD  A,0FFH		;select white
CLS2:	LD  (HL),A
	LDIR			;clear graphic page

	IN  A,($SYS1)		;read system byte 1
	AND 11010111B		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	RET			;return to caller


*EJECT
;***************
;*  $ P L O T  *
;***************

;entry:  A = 0  non-normalized (high nibble) 
;	     1      normalized 
;	     0  black          (low  nibble)
;	     1  white
;        B = graphic page number (0, 1)
;	HL = y-coordinate (0 - YYY)
;	DE = x-coordinate (0 - 639)

$PLOT:	PUSH BC			;save graphic page #
      	PUSH AF			;save colour
	PUSH DE			;save x-coordinate
	AND  0F0H		;normalize y-coordinate ?
	JR   Z,PLOT1		;jump if not
	
;normalize y-coordinate:
      	EX   DE,HL		;y-coordinate 		  --> reg. DE
	OR   A			;clear carry flag
 	LD   HL,449   		;maximum scan line number --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   C,PLOT2		;jump if overflow

      	PUSH DE			;save x-coordinate
	
 	ADD  HL,HL        	;make word index
	LD   DE,YNTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL) 
	JR   PLOT4


*EJECT
PLOT1:	EX   DE,HL		;y-coordinate 		  --> reg. DE
	OR   A			;clear carry flag
 	LD   HL,(YMAX)		;maximum scan line number --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   NC,PLOT3		;jump if no overflow
PLOT2:	POP  HL			;adjust stack
	POP  HL
	RET

PLOT3:	PUSH DE			;save x-coordinate
	
 	ADD  HL,HL        	;make word index
	LD   DE,YTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL) 

PLOT4:	POP  HL			;get x-coordinate
;divide x-coordinate by 8:
	XOR  A			;clear remainder
	SRL  H			;/ 2
	RR   L
	RRA
	SRL  H			;/ 4
	RR   L
	RRA
	SRL  H			;/ 8
	RR   L
	RRA

	LD   C,A		;save accu
	LD   A,H		;test MSB of result
	OR   A
	JR   NZ,PLOT2		;return if overflow
	LD   A,L		;test LSB of result
	CP   80
	JR   NC,PLOT2		;return if overflow
	LD   A,C		;restore accu

	ADD  HL,DE		;final result = y-address + x / 8
	SET  7,H		;select upper 32K page

	RRA			;build SET/RES instruction
	RRA
	OR   0C6H		;SET instruction
	POP  BC			;get colour
	BIT  0,B		;black or white ?
	JR   NZ,$+4		;jump if white
	AND  0BEH		;RES instruction
	LD   (SETRES),A		;load instruction

	IN   A,($SYS0)		;read system byte 0
	AND  00010001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	POP BC			;get  page number
	INC B			;test page number
	DEC B
	JR  Z,PLOT5		;jump if page 0
	SET 5,A			;select page 1
PLOT5:	OUT ($SYS0),A		;write system byte 0

	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	DEFB 0CBH		;SET/RES dot
SETRES:	DEFS 1

	IN  A,($SYS1)		;read system byte 1
	AND 11010111B		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	EI			;reenable interrupts
	RET			;return to caller

YMAX:	DEFS 2			;total number of scan lines
YTAB:	DEFS 800		;addresses of all y-coordinates
YNTAB:	DEFS 900		;address of all normalized y-coordinates


*EJECT
;*****************
;*  $ P O I N T  *
;*****************

;entry:  B = graphic page number (0, 1)
;	HL = y-coordinate (0 - YYY)
;	DE = x-coordinate (0 - 639)
;
;exit :  A = 0  black
;	     1  white

$POINT:	PUSH BC			;save graphic page #
	PUSH DE			;save x-coordinate
	
POINT1:	EX   DE,HL		;y-coordinate 		    --> reg. DE
	OR   A			;clear carry flag
 	LD   HL,(YMAX)		;total number of scan lines --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   NC,POINT3		;jump if no overflow
POINT2:	XOR  A			;clear accu
	POP  HL			;adjust stack
	RET

POINT3:	PUSH DE			;save x-coordinate
	
 	ADD  HL,HL        	;make word index
	LD   DE,YTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL) 

      	POP  HL			;get x-coordinate
;divide x-coordinate by 8:
	XOR  A			;clear remainder
	SRL  H			;/ 2
	RR   L
	RRA
	SRL  H			;/ 4
	RR   L
	RRA
	SRL  H			;/ 8
	RR   L
	RRA

	LD   C,A		;save accu
	LD   A,H		;test MSB of result
	OR   A
	JR   NZ,POINT2		;return if overflow
	LD   A,L		;test LSB of result
	CP   80
	JR   NC,POINT2		;return if overflow
	LD   A,C		;restore accu

	ADD  HL,DE		;final result = y-address + x / 8
	SET  7,H		;select upper 32K page

	RRA			;build BIT instruction
	RRA
	OR   46H
	LD   (BITTST),A		;load instruction

	IN   A,($SYS0)		;read system byte 0
	AND  00010001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	POP BC			;get  page number
	INC B			;test page number
	DEC B
	JR  Z,POINT4		;jump if page 0
	SET 5,A			;select page 1
POINT4:	OUT ($SYS0),A		;write system byte 0

	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	DEFB 0CBH		;BIT test
BITTST:	DEFS 1

	IN  A,($SYS1)		;read system byte 1
	RES 3,A      		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	EI			;reenable interrupts

	LD   A,0		;clear accu
	RET  Z			;accu = 0 if dot = black
	INC  A			;accu = 1 if dot = white
	RET			;return to caller


*EJECT
;***************
;*  $ L I N E  *
;***************

;entry:  A = 0  non-normalized (high nibble) 
;	     1      normalized 
;	     0  black          (low  nibble)
;	     1  white
;        B = graphic page number (0, 1)
;	HL = ^coordinates (x1, y1, x2, y2)

;draw line:
$LINE:	PUSH BC			;save page number
	PUSH AF			;save mode & colour
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X1		;^coordinates --> reg. DE
	LD   B,8		;byte count   --> reg. BC	
	CALL $XMOVE		;get coordinates
	POP  AF			;get mode
	LD   C,A		;save colour
	AND  0F0H		;normalize y-coordinates ?
	LD   A,C		;restore colour
	PUSH AF			;save colour
	JR   Z,LINE4		;jump if not

;normalize y-coordinates:
	POP  AF			;get colour
	AND  0FH		;mask mode
	PUSH AF
	LD   B,2		;y1, y2
	LD   IX,Y1		;^first y-coordinate 		    --> reg. IX
LINE1:	PUSH BC			;save counter
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   D,(IX+1)		;y-coordinate 			    --> reg. DE
	LD   E,(IX)
	LD   HL,0
LINE2:	ADD  HL,DE		;y-coordinate * # of scan lines
	DJNZ LINE2

	LD   DE,18		;load divisor
	CALL DIV
	LD   A,E		;remainder --> accu
	CP   9			;remainder >= 9 ?
	JR   C,LINE3		;jump if not
	INC  HL			;round normalized y-coordinate
LINE3:	LD   (IX+1),H		;store normalized y-coordinate
	LD   (IX),L
	INC  IX			;get ^second y-coordinate
	INC  IX 		
	INC  IX 
	INC  IX
	POP  BC			;restore counter
	DJNZ LINE1		;normalize second y-coordinate
	 	
;calc px and dx:
LINE4:	LD   HL,0		;clear pp
	LD   (PP),HL
      	LD   HL,(X2)		;second x-coordinate --> reg. HL
	LD   DE,(X1)		;first  x-coordinate --> reg. DE
	CALL CMP		;x2 >= x1 ?
	JP   M,LINE5		;jump if x2 < x1
	LD   BC,1		;dx = 1
	JR   LINE6
LINE5:	LD   BC,-1		;dx = -1
	EX   DE,HL		
LINE6:	LD   (DX),BC		;store dx
	OR   A
	SBC  HL,DE		;px = x2 - x1 + 1 (x1 - x2 + 1)
	INC  HL
	LD   (PX),HL
	
;calc py and dy:
      	LD   HL,(Y2)		;second y-coordinate --> reg. HL
	LD   DE,(Y1)		;first  y-coordinate --> reg. DE
	CALL CMP		;y2 >= y1 ?
	JP   M,LINE7		;jump if y2 < y1
	LD   BC,1		;dy = 1
	JR   LINE8
LINE7:	LD   BC,-1		;dy = -1
	EX   DE,HL		
LINE8:	LD   (DY),BC		;store dx
	OR   A
	SBC  HL,DE		;py = y2 - y1 + 1 (y1 - y2 + 1)
	INC  HL
	LD   (PY),HL
	
;plot first dot:
	CALL LPLOT		;plot first point of line

;py <= px:
	LD   HL,(PX)		;px --> reg. HL
	LD   DE,(PY)		;py --> reg. DE
	CALL CMP		;py <= px ?
	JP   M,YLIN		;jump if py > px
XLIN:	LD   HL,(X1)
	LD   DE,(X2)
	CALL CMP		;x1 == x2 ?
	JP   Z,ENDLIN		;break if yes
	LD   HL,(PP)		;pp += py
	LD   DE,(PY)
	ADD  HL,DE	
	LD   (PP),HL
	LD   DE,(PX)
	CALL CMP		;pp >= px
	JP   M,XLIN1		;jump pp < px
	OR   A
	SBC  HL,DE		;pp -= px
	LD   (PP),HL
	LD   HL,(Y1)		;y1 += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (Y1),HL
XLIN1:	LD   HL,(X1)		;x1 += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (X1),HL
	CALL LPLOT		;plot next point of line
	JR   XLIN 	

;py > px:
YLIN:	LD   HL,(Y1)
	LD   DE,(Y2)
	CALL CMP		;y1 == y2 ?
	JR   Z,ENDLIN		;break if yes
	LD   HL,(PP)		;pp += px
	LD   DE,(PX)
	ADD  HL,DE	
	LD   (PP),HL
	LD   DE,(PY)
	CALL CMP		;pp >= py
	JP   M,YLIN1		;jump pp < py
	OR   A
	SBC  HL,DE		;pp -= py
	LD   (PP),HL
	LD   HL,(X1)		;x1 += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (X1),HL
YLIN1:	LD   HL,(Y1)		;y1 += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (Y1),HL
	CALL LPLOT		;plot next point of line
	JR   YLIN

;end of draw line routine:
ENDLIN:	POP  HL			;adjust stack
	POP  HL
	RET

;plot (x1, y1):
LPLOT:	POP  HL			;skip return address
 	POP  AF			;get colour
	POP  BC			;get graphic page
	PUSH BC			;save that suckers again
	PUSH AF
	PUSH HL			;save return address
	LD   HL,(Y1)		;y-coordinate --> reg. HL
	LD   DE,(X1)		;x-coordinate --> reg. DE
	JP   $PLOT

;variables for draw line, circle, and arc:
XM:	DEFS 2
YM:	DEFS 2
XX:
X1:	DEFS 2
YY:
Y1:	DEFS 2
X2:	DEFS 2
Y2:	DEFS 2
M1:
PX:	DEFS 2	
M2:
PY:	DEFS 2
DD:
PP:     DEFS 2
N1:	
XB:
XB1:	DEFS 2
N2:	
XB2:	DEFS 2
II:
N3:	DEFS 2
P1:	DEFS 2
P2:	DEFS 2
DX:	DEFS 2
DY:	DEFS 2 


*EJECT
;*******************
;*  $ C I R C L E  *
;*******************

;entry:  A = 0  black
;	     1  white
;        B = graphic page number (0, 1)
;	HL = ^coordinates, radius (xm, ym, r)

;draw circle:
$CIRCLE:PUSH BC			;save page number
	SET  4,A		;force normalizing
	PUSH AF			;save colour & mode
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,XM		;^coordinates --> reg. DE
	LD   B,6		;byte count   --> reg. BC	
	CALL $XMOVE		;get coordinates

	LD   HL,0		;dd = yy = 0
	LD   (DD),HL
	LD   (YY),HL
	LD   HL,(XX)		;m1 = 1 - (xx + xx)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	LD   (M2),HL		;m2 = 1
	OR   A
	SBC  HL,DE
	LD   (M1),HL

*EJECT
;plot first dots:
	LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym      --> reg. HL
	CALL CPLOT
		
	LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym      --> reg. HL
	CALL CPLOT
		
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   DE,(XX)
	ADD  HL,DE
	LD   DE,(XM)		;xm      --> reg. DE
	CALL CPLOT
		
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	LD   DE,(XM)		;xm      --> reg. DE
	CALL CPLOT
		
*EJECT
;circle loop:

;calc next coordinates:
CIRCLE1:LD   HL,(M1)		;p1 = m1 + d
	LD   DE,(DD)
	ADD  HL,DE
	LD   (P1),HL
	LD   HL,(M2)		;p2 = m2 + d
	ADD  HL,DE
	LD   (P2),HL

        LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
        LD   HL,(M2)		;m2 += 2
	INC  HL
	INC  HL
	LD   (M2),HL

	LD   HL,(P2)
	CALL ABS
	EX   DE,HL
	LD   HL,(P1)
	LD   DE,(M2)
	ADD  HL,DE
	CALL ABS
	CALL CMP		;jump if
	JR   C,CIRCLE2		;abs(p1 + m2) < abs(p2)

        LD   HL,(P2)		;dd = p2
	LD   (DD),HL
	JR   CIRCLE3

CIRCLE2:LD   HL,(XX)		;xx--
	DEC  HL
	LD   (XX),HL
	LD   HL,(P1)		;dd = p1 + m2
	LD   DE,(M2)
	ADD  HL,DE
	LD   (DD),HL
	LD   HL,(M1)		;m1 += 2
	INC  HL
	INC  HL
	LD   (M1),HL

*EJECT
;plot dots:
CIRCLE3:LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - yy --> reg. HL
	LD   BC,(YY)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - yy --> reg. HL
	LD   BC,(YY)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm + yy --> reg. DE
	LD   DE,(YY)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   BC,(XX)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - yy --> reg. DE
	LD   DE,(YY)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   BC,(XX)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm + yy --> reg. DE
	LD   DE,(YY)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   BC,(XX)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - yy --> reg. DE
	LD   DE,(YY)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   BC,(XX)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
	LD   HL,(XX)
	LD   DE,(YY)
	CALL CMP		;jump if
	JP   P,CIRCLE1		;xx >= yy

	POP  HL			;adjust stack
	POP  HL	
	RET

;plot (xx, yy):
CPLOT:	POP  IX			;skip return address
 	POP  AF			;get colour & mode
	POP  BC			;get graphic page
	PUSH BC			;save that suckers again
	PUSH AF
	PUSH IX			;save return address
	JP   $PLOT


*EJECT
;*************
;*  $ A R C  *
;*************

;entry:  A = 0  black
;	     1  white
;        B = graphic page number (0, 1)
;	HL = ^coordinates (xm, ym, x1, y1, x2, y2)

;draw arc:
$ARC:   PUSH BC			;save page number
	SET  4,A		;force normalizing
	PUSH AF			;save colour & mode
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,XM		;^coordinates --> reg. DE
	LD   B,12		;byte count   --> reg. BC	
	CALL $XMOVE		;get coordinates

	LD   HL,0		;dd = 0
	LD   (DD),HL
	LD   HL,(X1)		;xx = x1 - xm
	LD   DE,(XM)
	OR   A
	SBC  HL,DE
	LD   (XX),HL
	LD   HL,(X2)		;x2 -= xm
	OR   A
	SBC  HL,DE
	LD   (X2),HL
	LD   HL,(Y1)		;yy = y1 - ym
	LD   DE,(YM)
	OR   A
	SBC  HL,DE
	LD   (YY),HL
	LD   HL,(Y2)		;y2 -= xm
	OR   A
	SBC  HL,DE
	LD   (Y2),HL

;plot first dot:
	LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
		
*EJECT
;arc loop:

;calc next coordinates:
ARC1:   LD   HL,(YY)		
	BIT  7,H		;jump if
	JR   NZ,ARC2		;yy < 0
	LD   HL,-1		;dx = -1
	LD   (DX),HL   
	LD   HL,(XX)		;m1 = 1 - (xx + xx)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	OR   A
	SBC  HL,DE
	JR   ARC3
ARC2:	LD   HL,(XX)		;m1 = 1 + xx + xx
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1		;dx = 1
	LD   (DX),HL
	ADD  HL,DE
ARC3:	LD   (M1),HL

        LD   HL,(XX)		
	BIT  7,H		;jump if
	JR   NZ,ARC4		;xx < 0
     	LD   HL,(YY)		;m2 = 1 + yy + yy
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1		;dy = 1
	LD   (DY),HL
	ADD  HL,DE
	JR   ARC5
ARC4:	LD   HL,-1		;dy = -1
	LD   (DY),HL
	LD   HL,(YY)		;m2 = 1 - (yy + yy)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	OR   A
	SBC  HL,DE
ARC5:	LD   (M2),HL

	LD   DE,(DD)		;p2 = m2 + dd
	ADD  HL,DE
	LD   (P2),HL
	CALL ABS		;n3 = abs(p2)
	LD   (N3),HL
	LD   HL,(M1)		;p1 = m1 + d
	ADD  HL,DE
	LD   (P1),HL
	CALL ABS		;n1 = abs(p1)
	LD   (N1),HL
	LD   HL,(P1)		;n2 = abs(p1 + m2)
	LD   DE,(M2)
	ADD  HL,DE
	CALL ABS
	LD   (N2),HL

	LD   DE,(N1)
	CALL CMP		;jump if
	JR   C,ARC8   		;n1 >= n2
	JR   Z,ARC8   
	LD   HL,(N3)
	CALL CMP		;jump if
	JR   C,ARC6   		;n1 >= n3
	JR   Z,ARC6   

	LD   HL,(XX)		;xx += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (XX),HL
	LD   HL,(P1)		;dd = p1
	LD   (DD),HL
	JR   ARC9

ARC6:   LD   HL,(P2)		;dd = p2
	LD   (DD),HL
ARC7:   LD   HL,(YY)		;yy += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (YY),HL
	JR   ARC9

ARC8:   LD   DE,(N3)
	CALL CMP		;jump if
	JP   P,ARC6   		;n2 >= n3

        LD   HL,(XX)		;xx += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (XX),HL
	LD   HL,(P;******************************************************************************
;*  D R V T B L  *  C P M S Y S 4 e  *  T h o m a s   H o l t e * 8 5 0 9 2 5 *
;******************************************************************************
;*									      *
;*  			     D R I V E   T A B L E			      *
;*                           =====================                            *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	GLOBAL @DTBL
	EXTERNAL DS0,MF0,MF1,FD0,IBMPC,KDS,RAM,RAIR,ALPHAP3,DRIVEP


@DTBL:	DEFW DS0,MF0,MF1,FD0,0,0,0,0
	DEFW IBMPC,0,KDS,0,RAM,RAIR,ALPHAP3,DRIVEP
	DEFW RAM

	END
ntroller:
REQWAIT:IN   A,(RPORT1)		;get cntlr status bits
	AND  REQMASK		;isolate the contoller
	JR   Z,REQWAIT		;request and wait for it
	RET

	ENDC

	END
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее1)		;dd = p1 + m2
	LD   DE,(M2)
	ADD  HL,DE
	LD   (DD),HL
	JR   ARC7


*EJECT
;plot dot:
ARC9:   LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JP   NZ,ARC1		;xx != x2
	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   NZ,ARC1		;yy != y2

	POP  HL			;adjust stack
	POP  HL	
	RET


*EJECT
;***************
;*  $ F I L L  *
;***************

;entry:  A = 0  non-normalized   	(high nibble) 
;	     1      normalized 
;	     graphic page number (0, 1) (low  nibble)
;	BC = ^fill pattern
;       HL = y-coordinate within shape
;	DE = x-coordinate within shape

;fill shape with user supplied pattern:
$FILL	EQU  $			;not implemented yet


*EJECT
;***************
;*  $ C O P Y  *
;***************

;entry:  A = source      page (high nibble)
;	     destination page (low  nibble)
;	     0 = graphic page 0
;	     1 = graphic page 1
;	     F = user buffer
;		 (user/user [FF] = invalid combination)
;	HL = ^parameter block (x1, y1, x2, y2, dx, dy
;			    or x2, y2, dx, dy
;			    or x1, y1, dx, dy)
;	DE = ^user buffer

;copy graphic area:
$COPY:	LD   (UBUF),DE		;save ^user buffer
	LD   C,A		;save source page
	AND  0FH		;mask it
	CP   0FH		;destination == user buffer ?
	JP   Z,COPY17		;jump if yes
	PUSH AF
	LD   A,C		;restore source page
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	CP   0FH		;source == user buffer ?
	JP   Z,COPY10		;jump if yes
	PUSH AF
	
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X1		;^parameter block --> reg. DE
	LD   B,12		;byte count       --> reg. BC	
	CALL $XMOVE		;get coordinates

*EJECT
;copy on screen:

;setup variables:
	LD   HL,(X1)		;xb1 = x1
	LD   (XB1),HL
	LD   HL,(X2)		;xb2 = x2
	LD   (XB2),HL

;determine copy direction of x-coordinate:
	LD   DE,(X1)
  	CALL CMP
	JR   C,COPY1  		;jump if
	JR   Z,COPY1  		;x1 >= x2
	LD   DE,(PX)		;xb2 += dx - 1
	DEC  DE
	ADD  HL,DE
	LD   (XB2),HL
	LD   HL,(XB1)		;xb1 += dx - 1
	ADD  HL,DE
	LD   (XB1),HL
	LD   HL,(X1)		;x1--
	DEC  HL
	LD   (X1),HL
	LD   HL,-1		;dx = -1
	JR   COPY2
COPY1:	LD   HL,(X1)		;x1 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X1),HL
	LD   HL,1		;dx = 1
COPY2:	LD   (PX),HL

;determine copy direction of y-coordinate:
	LD   HL,(Y1)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   P,COPY3		;y1 >= y2
	DEC  HL			;yy = --y1 + dy
	LD   (Y1),HL
	LD   DE,(PY)
	ADD  HL,DE
	LD   (YM),HL
	LD   HL,(Y2)		;y2 += dy - 1
	DEC  DE
	ADD  HL,DE
	LD   (Y2),HL
	LD   HL,-1		;dy = -1
	JR   COPY4
COPY3:	LD   (YM),HL		;yy = y1
	LD   DE,(PY)		;y1 += dy
	ADD  HL,DE
	LD   (Y1),HL
	LD   HL,1		;dy = 1
COPY4:	LD   (PY),HL

*EJECT
;copy area:
COPY5:	LD   HL,(YM)
	LD   DE,(Y1)
	CALL CMP		;jump if
	JR   Z,COPY8		;yy == y1

	LD   HL,(XB1)		;xx = xb1
	LD   (XM),HL
	LD   HL,(XB2)		;x2 = xb2
	LD   (X2),HL

COPY6:	LD   HL,(XM)
	LD   DE,(X1)
	CALL CMP		;jump if
	JR   Z,COPY7		;xx == x1
	
	POP  BC			;source page # --> reg. B
	PUSH BC
	LD   HL,(YM)		;y-coordinate  --> reg. HL
	LD   DE,(XM)		;x-coordinate  --> reg. DE
	CALL $POINT		;read source dot

	POP  HL			;destination page # --> reg. B
	POP  BC
	PUSH BC
	PUSH HL
	LD   HL,(Y2)		;y-coordinate       --> reg. HL
	LD   DE,(X2)		;x-coordinate	    --> reg. DE
	CALL $PLOT		;set destination dot

	LD   HL,(XM)		;xx += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (XM),HL	
	LD   HL,(X2)		;x2 += dx
	ADD  HL,DE
	LD   (X2),HL
	JR   COPY6

COPY7:	LD   HL,(YM)		;yy += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (YM),HL
	LD   HL,(Y2)		;y2 += dy
	ADD  HL,DE
	LD   (Y2),HL
	JR   COPY5

COPY8:	POP  HL			;adjust stack
COPY9:	POP  HL
	RET

*EJECT
;copy from user buffer to screen:
COPY10:	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X2		;^parameter block --> reg. DE
	LD   B,8 		;byte count       --> reg. BC	
	CALL $XMOVE		;get coordinates

;setup variables:
	LD   HL,(Y2)		;yy = y2
	LD   (YY),HL
	LD   HL,(X2)		;xb = x2
	LD   (XB),HL
	LD   HL,(PX)		;pp = dx / 8 + (dx % 8 != 0)
	LD   A,L
	SRL  H
	RR   L
	SRL  H
	RR   L
	SRL  H
	RR   L
	AND  7
	JR   Z,COPY11
	INC  HL
COPY11:	LD   (PP),HL
	LD   HL,(X2)		;x2 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X2),HL
	LD   HL,(Y2)		;y2 += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (Y2),HL

*EJECT
;copy area:
COPY12:	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JR   Z,COPY9		;yy == y2

	LD   HL,(UBUF)		;^user buffer --> reg. HL
	LD   DE,LINBUF		;^temp buffer --> reg. DE
	LD   A,(PP)		;byte count   --> reg. B
	LD   B,A
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	CALL $XMOVE		;get user bytes

	LD   HL,(XB)		;xx = xb
	LD   (XX),HL
	LD   HL,0    		;ii = 0
	LD   (II),HL

COPY13:	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JR   Z,COPY16 		;xx == x2
	
	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(II)		;divide buffer index by 8
	XOR  A
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	ADD  HL,DE		;now reg. HL contains byte address
	RRA			;build BIT instruction
	RRA
	OR   46H
	LD   (COPY14),A
	DEFB 0CBH		;BIT instruction
COPY14:	DEFS 1

	LD   A,0		;initialize colour (black)
	JR   Z,COPY15		;dont't change colour if tested bit = 0
	INC  A			;change colour (white)
COPY15:	POP  BC			;graphic page number # --> reg. B
	PUSH BC
	LD   HL,(YY)		;y-coordinate 	       --> reg. HL
	LD   DE,(XX)		;x-coordinate	       --> reg. DE
	CALL $PLOT 		;set dot

	LD   HL,(XX)		;xx++
	INC  HL
	LD   (XX),HL
	LD   HL,(II)		;ii++
	INC  HL
	LD   (II),HL
	JR   COPY13

COPY16:	LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
	LD   HL,(UBUF)		;bump pointer to user buffer
	LD   DE,(PP)
	ADD  HL,DE
	LD   (UBUF),HL
	JP   COPY12

*EJECT
;copy from screen to user buffer:
COPY17:	LD   A,C		;restore source page
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	PUSH AF

	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X2		;^parameter block --> reg. DE
	LD   B,8 		;byte count       --> reg. BC	
	CALL $XMOVE		;get coordinates

;setup variables:
	LD   HL,(Y2)		;yy = y2
	LD   (YY),HL
	LD   HL,(X2)		;xb = x2
	LD   (XB),HL
	LD   HL,(PX)		;pp = dx / 8 + (dx % 8 != 0)
	LD   A,L
	SRL  H
	RR   L
	SRL  H
	RR   L
	SRL  H
	RR   L
	AND  7
	JR   Z,COPY18
	INC  HL
COPY18:	LD   (PP),HL
	LD   HL,(X2)		;x2 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X2),HL
	LD   HL,(Y2)		;y2 += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (Y2),HL

*EJECT
;copy area:
COPY19:	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   Z,COPY9		;yy == y2

	LD   HL,(XB)		;xx = xb
	LD   (XX),HL
	LD   HL,0    		;ii = 0
	LD   (II),HL

COPY20:	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JR   Z,COPY22 		;xx == x2
	
       	POP  BC			;graphic page number # --> reg. B
	PUSH BC
	LD   HL,(YY)		;y-coordinate 	       --> reg. HL
	LD   DE,(XX)		;x-coordinate	       --> reg. DE
	CALL $POINT		;read dot
	LD   C,A		;colour		       --> reg. C

	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(II)		;divide buffer index by 8
	XOR  A
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	ADD  HL,DE		;now reg. HL contains byte address
	RRA			;build SET/RES instruction
	RRA
	OR   0C6H		;SET instruction
	BIT  0,C		;colour black or white ?
	JR   NZ,$+4		;jump if white
	AND  0BEH		;RES instruction
	LD   (COPY21),A		;load instruction
	DEFB 0CBH		;SET/RES instruction
COPY21:	DEFS 1

	LD   HL,(XX)		;xx++
	INC  HL
	LD   (XX),HL
	LD   HL,(II)		;ii++
	INC  HL
	LD   (II),HL
	JR   COPY20

COPY22:	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(UBUF)		;^user buffer --> reg. DE
	LD   A,(PP)		;byte count   --> reg. B
	LD   B,A
	LD   A,1  		;source bank      = 0
				;destination bank = 1
	CALL $XMOVE		;put user bytes

       	LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
	LD   HL,(UBUF)		;bump pointer to user buffer
	LD   DE,(PP)
	ADD  HL,DE
	LD   (UBUF),HL
	JP   COPY19

UBUF:	DEFS 2			;^user buffer


*EJECT
;division HL / DE, quotient --> HL, remainder --> DE:
DIV:	LD   A,H		;dividend (MSB) --> accu
	LD   C,L		;dividend (LSB) --> reg. C
	LD   HL,0		;clear accumulator
	LD   B,16		;init counter
DIV1:	RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
	SBC  HL,DE		;subtract divisor
	JR   NC,$+3		;subtraction ok
	ADD  HL,DE		;restore accumulator
	CCF			;complement carry flag
	DJNZ DIV1		;counter = 0 ?
	RL   C			;get last result bit
	RLA
	EX   DE,HL		;remainder --> reg. DE
	LD   H,A		;quotient  --> reg. HL
	LD   L,C
	RET  

;compare HL with DE:
CMP:	PUSH HL			;save reg. HL
	OR   A			;clear carry flag
	SBC  HL,DE		;compare operands
	POP  HL			;restore reg. HL
	RET

;HL = abs(HL):
ABS:	BIT  7,H		;number positive ?
	RET  Z			;return if yes
	PUSH DE			;save reg. DE
	EX   DE,HL		;number --> reg. DE
	LD   HL,0
	OR   A			;clear carry flag
	SBC  HL,DE		;negate number
	POP  DE			;restore reg. DE
	RET


*EJECT
;******************************************************************************
;*	       I N T E R R U P T   S E R V I C E   R O U T I N E	      *
;******************************************************************************

INT1:	PUSH BC			;save user register set
	PUSH DE
	PUSH HL
	PUSH IX
	PUSH IY

;scan keyboard:
	CALL $SCAN		;scan the keyboard
	LD   A,C		;get code of pressed key
	OR   A			;key pressed ?
	JR   Z,RTC3		;jump if not
	LD   A,(KLEN)		;A = buffer length
	LD   B,A		;save it
	CP   80			;jump if
	JR   Z,RTC2		;it's full
	LD   A,(REPEAT)		;auto repeat ?
	OR   A
	JR   Z,RTC0		;jump if not
	LD   A,B		;restore buffer length
	OR   A			;buffer empty ?
	JR   NZ,RTC3		;return no repeated key if buffer not empty
RTC0:	LD   A,C		;get code of pressed key
     	LD   HL,(EPTR)		;HL = next location pointer
	LD   (HL),A		;save the key
	INC  HL			;bump the pointer
	LD   DE,KBUF+80		;DE = end of buffer pointer
	EX   DE,HL		;swap the pointers
	SBC  HL,DE		;wrap around the buffer ?
	EX   DE,HL		;swap the pointers
	JR   NZ,RTC1		;jump if no wrap around
	LD   HL,KBUF		;HL = new pointer
RTC1:	LD   (EPTR),HL		;save the pointer
	LD   HL,KLEN		;HL = buffer length pointer
	INC  (HL)		;bump it
	JR   RTC3
RTC2:	CALL BEEP		;alarm

;clock maintenance routine:
RTC3:	LD   HL,RTC$TICK$COUNT	;downdate tick count
	DEC  (HL)
	JR   NZ,INT6		;is not at 0 yet
	LD   (HL),45		;one second has elapsed so 
				;reset to original value

	LD   A,(CLOCK)		;hardware clock ?
	OR   A
	JR   NZ,INT2		;jump if yes	

	LD   B,3		;maximum number of values to update
	LD   DE,TIME$IN$BCD$END	;DE -> seconds of BCD time
	LD   HL,UPDATE$TIME	;HL -> control table
RTC$UPDATE$DIGIT:
	LD   A,(DE)
	INC  A			;bump a time period, seconds
	DAA			;then minutes, then ours
	LD   (DE),A
	SUB  (HL)		;compare period to max. unit value
	JR   NZ,INT2		;jump if unit not max. value
	LD   (DE),A		;else reset period to zero
	DEC  DE			;and bump increment and
	INC  HL			;test addresses to next unit
	DJNZ RTC$UPDATE$DIGIT	;loop till periods incremented or no overflow
				;from one period to the next
	LD   HL,(BINARY$DATE)	;HL -> number of days since Jan 1st, 1978
	INC  HL			;bump day count
	LD   (BINARY$DATE),HL

*EJECT
INT2:	LD   A,(CLOCKON)
	OR   A			;display clock ?
	JR   Z,INT6		;jump if not
	LD   A,(CLOCK)		;hardware clock ?
	OR   A
	JR   Z,INT3		;jump if not 
	LD   HL,BINARY$DATE	;^time & date buffer --> reg. HL
	LD   (INT),A		;mark interrupt service routine
	CALL $GTIME3H		;read hardware clock
	XOR  A
	LD   (INT),A
INT3:	LD   HL,TIME$IN$BCD	;^BCD   time --> reg. HL
	LD   DE,$ATIME		;^ASCII time --> reg. DE
	LD   B,3		;convert hours, minutes, and seconds
INT4:	CALL BCDASC
	DJNZ INT4			
	IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11111110B		;enable memory mapped I/O
	OR   00010000B		;enable video RAM
	OUT  ($SYS1),A
	LD   HL,$ATIME		;^ASCII time 	   --> reg. HL
	LD   DE,(CLOCK$LOC)	;^display location --> reg. DE
	LD   B,8		;byte count 	   --> reg. B
INT5:	LD   A,(DE)		;get screen character
	AND  80H		;mask invert bit
	OR   (HL)		;over clock character
	LD   (DE),A		;display clock character
	INC  DE			;get next clock character
	INC  HL			;get next screen location
	DJNZ INT5		;display whole clock	
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A
	
INT6:	POP  IY
	POP  IX
     	POP  HL			;restore user register set
	POP  DE
	POP  BC
	JP   $INT1		;jump to end of interrupt service routine

;convert BCD to ASCII:
BCDASC:	LD   A,(HL)		;get high nibble
	RRA
	RRA
	RRA
	RRA
        AND  0FH
	ADD  A,'0'		;convert it to ASCII
	LD   (DE),A		;store high digit
        LD   A,(HL)		;get low nibble
	AND  0FH		;get low nibble
	ADD  A,'0'		;convert to ASCII
	INC  DE   
	INC  HL
	LD   (DE),A		;store low digit
	INC  DE			;bump over colon 
	INC  DE
	RET

RTC$TICK$COUNT:
	DEFB 45
UPDATE$TIME:
	DEFB 60H		;BCD 60 seconds
	DEFB 60H		;BCD 60 minutes
	DEFB 24H		;BCD 24 hours
$ATIME:	DEFM 'HH:MM:SS'		;time in ASCII format
INT:	DEFB 0			;marker for interrupt service routine


*EJECT
;******************************************************************************
;*  		  C O M M O N   P A R T   O F   D R I V E R S		      *
;******************************************************************************

	ORG  3500H
	.PHASE 0FE00H		;common memory

;time & date location will not be destroyed during reset:
BINARY$DATE:
	DEFW 1
TIME$IN$BCD:
	DEFB 0
	DEFB 0
TIME$IN$BCD$END:
	DEFB 0

;*****************
;*  $ X M O V E  *
;*****************

;entry:  A  	upper nibble = source 	   bank
;	    	lower nibble = destination bank
;	 B  =   byte count
;      	DE  =   destination address
;	HL  =   source      address

;interbank transfer:
$XMOVE:	LD   C,A		;save source/dest bank #'s
	IN   A,($SYS0)		;read system byte 0
	PUSH AF			;save current bank #
	LD   A,C		;restore source/dest bank #'s
	PUSH DE			;save destination address
	LD   C,B		;byte count --> reg. BC
	LD   B,0
	PUSH BC			;save byte count
	PUSH AF        		;save destination bank number
	SRL  A			;get source bank number
	SRL  A
	SRL  A
	SRL  A
	CALL SWITCH		;select source bank
	LD   DE,SBUF		;^scratch buffer --> reg. DE
	LDIR			;transfer data from source buf to scratch buf
	POP  AF			;get destination bank number
	AND  0FH
	CALL SWITCH		;select destination bank
	POP  BC			;restore byte count
	LD   HL,SBUF		;^scratch buffer --> reg. HL
	POP  DE			;restore destination address
	LDIR			;transfer data from scratch buf to dest buf
	POP  AF			;restore current bank #
	OUT  ($SYS0),A		;select it
	RET
		
;select memory bank:
SWITCH:	RRCA			;lowest two bits --> highest two bits
	RRCA
	AND  0C0H
	OR   1
       	LD   D,A		;save bank number
       	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;RTC interrupt only
				;disable character RAM
	OR   D			;set bank number
	OUT  ($SYS0),A		;write system byte 0
	RET	 

SBUF:	DEFS 128		;scratch buffer


*EJECT
;entry to interrupt service routine:
	DEFS 64			;local stack
$INT:	LD   (SAVESP),SP	;save user stack
	LD   SP,$INT     	;get local stack
	PUSH AF			;save user accu/status
	IN   A,($FDSEL)		;reset interrupt flipflop
	IN   A,($SYS0)		;get current bank #
	PUSH AF          	;save it
	AND  00111111B		;enable bank 0
	OUT  ($SYS0),A		;select it
	JP   INT1		;perform interrupt service routine

$INT1:	POP  AF          	;get user bank
	OUT  ($SYS0),A		;select it
	POP  AF			;restore user accu/status
	LD   SP,(SAVESP)	;restore user stack
	EI			;enable interrupts
	RET			;return to user task
SAVESP:	DEFS 2			;SP save area


*EJECT
;floppy disk I/O:
IO:	CALL SWITCH		;select bank of transfer buffer
	POP  AF			;restore status
	JR   Z,WRITE1		;jump if write

;read sector:
        LD   A,$RDSEC        	;issue "read" command
	DI			;disable interrupts
	OUT  ($FDCMD),A
        LD   BC,12              ;56 usec delay
        CALL DELAY
        LD   C,$FDDATA          ;data register
READ1:	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  0,A                ;full sector transferred ?
        JR   Z,IOEND            ;yes, go end process
	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  7,A                ;drive not ready ?
        JR   Z,READ1            ;no loop
READ2:  LD   A,4                ;error code 4 --> accu
        RET
READ3:  INI                     ;read char
        JR   READ1

;write sector:
WRITE1: LD   A,$WRSEC        	;issue "write" command
	DI			;disable interrupts
	OUT  ($FDCMD),A
        LD   BC,12              ;56 usec delay
        CALL DELAY
        LD   C,$FDDATA          ;data register
WRITE2:	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,WRITE3          ;yes, put byte
        BIT  0,A                ;full sector written ?
        JR   Z,IOEND            ;yes, go end process
	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,WRITE3          ;yes, put byte
        BIT  7,A                ;drive not ready ?
        JR   Z,WRITE2           ;no loop
        JR   READ2              ;jump to error exit
WRITE3: OUTI                    ;write char
        JR   WRITE2             ;put next byte

IOEND:	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;enable bank 0
	OR   00000001B
	OUT  ($SYS0),A		;write system byte 0
	JP   STATUS		;check status

;delay for ((BC-1)*26+17)*2.255 T-states:
DELAY:	DEC  BC			;decrement cycle count
	LD   A,B		;test if count zero
	OR   C			;combine LSB/MSB of count
	JR   NZ,DELAY		;loop until delay count exhausted
	RET			;rtn to caller


*EJECT
;Winchester I/O:
IOW:	CALL SWITCH		;select bank of transfer buffer
	POP  AF			;restore status
	JR   Z,WRITW1		;jump if WRITE

;read sector:
	COND SASI		;Xebec part

	LD   BC,RPORT0		;SASI port 0  --> reg. C
        CALL REQWAIT		;wait for request from cntlr
READW1:	IN   A,(RPORT1)		;get cntlr status lines
	AND  IOMASK+CDMASK+REQMASK
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,WDBACK 		;jump if data transfer finished
	CP   IOMASK+REQMASK
	JR   NZ,READW1 		;wait for request
	INIR 			;transfer memory bytes to sector buffer
	JR   READW1

	ELSE			;WD1002 part

READW1: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;read done ?
	JR   NZ,READW1  	;no, loop
	LD   A,E		;sector length bits --> accu
	OR   A   		;test sector length bits
	JR   Z,R256		;read 256 bytes
	DEC  A
	JR   Z,R512             ;read 512 bytes
        DEC  A
      	JR   Z,R1024		;read 1024 bytes
	LD   B,128 		;load new byte counter
      	JR   R256    		;read 128 bytes
R1024:  INIR		        ;transfer sector
	INIR
R512:   INIR
R256: 	INIR
        JR   WDBACK    		;jump back into banked memory

	ENDC

;write sector:
	COND SASI		;Xebec part

WRITW1:	LD   BC,WPORT0		;SASI port 0 --> reg. C
        CALL REQWAIT		;wait for cntlr request
WRITW2:	IN   A,(RPORT1)		;get cntlr status lines
	AND  IOMASK+CDMASK+REQMASK
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,WDBACK 		;jump if data transfer finished
	CP   REQMASK
	JR   NZ,WRITW2 		;wait for request
	OTIR			;transfer memory bytes to sector buffer
	JR   WRITW2

	ELSE			;WD1002 part

WRITW1:	LD   A,E		;sector length bits --> accu
	OR   A   		;test sector length bits
	JR   Z,W256		;write 256 bytes
	DEC  A
	JR   Z,W512             ;write 512 bytes
        DEC  A
      	JR   Z,W1024		;write 1024 bytes
	LD   B,128 		;load new byte counter
      	JR   W256    		;write 128 bytes
W1024:  OTIR		        ;transfer sector
	OTIR
W512:   OTIR
W256: 	OTIR
WRITW2: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;write done ?
	JR   NZ,WRITW2   	;no, loop

	ENDC

WDBACK:	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;enable bank 0
	OR   00000001B
	OUT  ($SYS0),A		;write system byte 0
	JP   WDCSTAT

	COND SASI		;Xebec part

;wait for data request of SASI controller:
REQWAIT:IN   A,(RPORT1)		;get cntlr status bits
	AND  REQMASK		;isolate the contoller
	JR   Z,REQWAIT		;request and wait for it
	RET

	ENDC

	END
н{ !Ђ ^ #6Ѓ Нш,ю(dю/(`ю: 	НР ЪбV!  ЃQ н°!\ №QХ н°!5ВQ н°СНйНя*0(%>Ђ2ѓ!  Н% 8ю(ю 0у#Н% 8
ю(	ю 8уг*0л!  Ъбъ J8PЇЅ(. $л* . ·нR8> нR87еЭ!я  |ђG! Э~ юя(	_~ЂwЭ#рбяI	л! 	нёл·нRП=йм	Н Г  RELOCATING ERROR
$y
'
3	3				"		

	
	

	
		A			:$





	')
'	/	±
#

“#	o2	>


		!
"	
			


	™		
	]
		
	%
		
M!


	Q	
	
LH 4				KKL				
		
%		#
	2G	%!	

	+
	
			@

	#
	
	(*		*		‘4
"5)	
Зяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяяя       Г“УГ                              PP>   яЂ COMSYMPRNT80    
,.;:_
	
                       dЧПфГLПГЊвГм®Гx«Г­«ЭеэееН¶њбэеБA:µћO:¶ћ·:ґћ(Эеб+#н[ІћэбЭбЙЇ=2ґћ2µћ2¶ћэ! еЭбЩ Э~ юЭ Ђюэ АЭ~Э#Э~ ! Ю!РЭюн(юЛ %ЛГ!IЭЛ{(Э#ЭF> юx(> Г­ќ!jЭ Э#Э~ WЛ~#(ыz®#¦# фН>ќЭ#ЩЙЇ2µћЙzЎЙбЛ~#А~еж!9ќею 8cю`ЪэќЖ‰8Цр!ѓќ‡…o> Њg~#foй! ћ‡…o> Њg~#fo+Н3ќ<Л~#(ы= ш»ЈќЁќћћћІќѕќАќ·ќГќПќЈќ.ќ/ћћ*ћЇ2¶ћЙН3ќH!ЯЖzж85Э#Э~ .ЇyoЭ#Э#Эf ЭnяЭ#ЭебеБ#
O 0	"ІћЇ2ґћ|Нмќ}хНхќсжЖђ'О@'э+Г®!JЯ!XЯzЎў>Н3ќ!FЯю “Л{(ЏЖЛs(‰<†Н3ќz<ЎЛ{('ЛC Pю8Gzоpжx(>zоFжЗ(7x№ ЛЛЭ#ЖЛs(Ж!ХЯНxќЛKИЛ‹·(G>+тxћxнDG>-НэќxНмќ>)Гэќx№(ЙУхyНQћс№ИGzо@ж@ИЇН­ќxЅ‹ЯЙЯ№ЯњЯ”ЯђЯ­Я§ЯmЯ     Э!гН‚¶>№ВЊРн[г*гГЈю  :Ф<ЕХе=_НЎ«бСБЙеЕ! 6 #ы!  6 БбЙНйћХНx°НЎ«<СЙХНЎ«<Кк СНяћКЎЙХНЎ«<СЙХ:ѓ°·Дa°ЪИ СХНЎ«<САН­®CLOSE ђГЪ !№вН¬Іл§!№вНэ±Ъы ЙНXџеНD¶Їё !\ СНйћл н°Й>яЇ2(ЇН­®„Н­Ъ$Ў!Ъв	Нэ±Ъы еНD¶"†ЇНЯ СНРћНяћКЎ>Ђ2 в!я "&ЇГФ Х!\ НІ!l НІСНкџ!Ѓ  6 ю(w#у!Ђ pЙю АщН/ЎНјџНlЎря! НўЎН °Н…УНUДЂ Н“У! еНєбГ«РН/Ўэ!  Н·ћеХ№вНРћНяћ(&Н­®EXISTS, DELETEџНjЇю Ф®Н °юYВЪ Н џНџСбеХ~Нрў#э#НЈ0ф№вН)џэебНK±Н­® SAVEDђНMџЭ!еЭ~·(AНяћД џНџСбН­®‡ХЭFЭN Н‹МФЯў ЭСЭ~· з>Нрў№вН)џН­®DISK ђН…УГЊПН…У#ХНЎ«2эвСЙН­®DIRECTORY ђЯН­®унV1 ь>Ущ>TУъЭ.!·<>э~#Э- ш! 88я6 н°>ЕУъ"ЕНoь·ВШь*Ць 	"Ць:Хь<ю НјьЇ2ХьБЬ!5юын°! 7 DЂн°Г D>РУм:Хью
>8ЛзУа>РУм:Хью
8Ц
Уо*Ць>€Ум НПьпЫмЛO ЛG(ЫмЛO Л(мЙнўзЫмжЙ>TУмЕ НПьБЫмЛG ъЙx± ыЙ  >ДУъ!э <
 н°dЕ  :`8Е    ъБу@НПьБжюDISK ERROREnhanced BIOS written by Thomas Holte  (c) 1985                                                                                                                                                                                                 Ее Л!!; 	N#FЕЭббБЭй                                    Г я4fтєЧч#‰бры жЇю38М°В 4!"x#ћ$ѕ$Ш$%(,€,е-r/П0П0                                                                                                                                 ф€#  
@` aAbBcCdDeEfFgGhHiI	jJ
kKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ[{\|]}^~_^00 1! 2" 3# 4$ 5% 6& 7' 8( 9) :* ;+ ,< -= .> /?  ь э 
	   ЂЂ ЃЃ ‚‚ ѓѓ „„ …… †† ‡‡ 00 11 23 33 44 55 66 77        ЊЊ ‹‹ ЉЉ ‰‰ €€ 88 99 юю    ,, -- ..  ы @` aAbBcCdDeEfFgGhHiI	jJ
kKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ[{\|]}^~_^00 1! 2" 3# 4$ 5% 6& 7' 8( 9) :* ;+ ,< -= .> /?  ЌЋэ Џђ‘’“”  •      –– —— 00 11 23 33 44 55 66 77            		 88 99 юю    ,, -- ..  ы Lќо?ђб2ѓФ%vЗimquy}Ѓ…‰Ќ‘                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Y  R E C X S D O H J    
    я=яFяIяJяKяLя яяяAяDяEяGяNяOяRяSяXяYяPяVяQ яW       яя         яяшшяя              яя         шш                   шш         8ра                   ар8  *         *          ~            ~           >>         6>         >>         kk      UЄUЄUЄUЄUЄUЄUЄUЄ  <B№……№B<        ъЖF&Юъ        я А?@?         ?@?               |*(((         "AAc"c         <BҐЃҐ™B<        <BҐЃ™ҐB<                                                >>         <
(         &&22         

*,                                        >           >                         >                                     ""*""                  " >         >  "         >         >  "         ""         >           """"         ""<                                            > >                    "           ":*:         "">""         $$$$         ""         $$$$$         >>         >         ":""         """>"""                       "         "

"         >         "6**"""         ""&*2""         """""         ""         """*,         ""
"         " "         >         """"""         """         """***         """"         ""         > >                                      "                     >                     <         """           <<           <"""<           "         $           <"""<        """"                            

                    ****           """"           """           """         <"""<           &           <          $           """"           """           ""**           ""           """"<          >>                                      L2               >>>>>          ":*:                                                                   L2             "
$("     " "">""       " """""       " """"""          <          """          """"         """"     pЂP pЂP pЂP pЂP 
 M 
 M 
 M 
 M 
`@ И Ђя	d @ И nPV
 
j
    AДД >VНю !VyУц~Уч#ц:`2UЙ                 !tH Л!	N#fiйx«OжАЛЗ2©yжЛч2Ґyж`ц€2§x·Ысжр!њ9т 	Т     OжАЛЗ2рyжЛч2мyж`ц€2оx·ЫсжЛ#Л#Л#Л#!гіУс~·ИG#N#ніхт 	У     :ё·Ау:·(=2*~2ё#pлнRл ! "ыЙ                                                                                   ЫъхжЖцDУъНЃOсУъЙ!¦Э!›а8

жч_®sЈ n#ЭN 
жь_®sЈ `Э##ЭN 
_®sЈ RЭ#т§х*µ:·¦ Ї2№go"±*"ісЙхе*±#"±н[і|є }»б с/¦w>2№!  "±*"ісЂссЙ_ЕнK НЂяБ
ЈИ"µzWyЈ Лчy2·Z bk)нK	:Ђ8ЛG(#	ЛO(##~D:а8Л_(~юa88:Ґ·~(ю0-ю{0'ж_#:Ґ·~(:Ђ8ЛG~ 
ю[8ю_0ю{8ю0о W:№· нKНЂяzЙЂА @                      :|·(=2|*}~#"}O~2ёyГt!ё~юы(юь(>юэ(Cюю8\<w>0ЙеЫъжЦцTУъ! 8Э*LЭ~ WЭ~G~ж#Н	ч>Н	>
Н	 жб#>еНбе>Н:Ґ/2Ґ·(>G>AНбЇ-Л()еO_!~W#¶(fj Л#~_#VІ(2|нS}бГєyб6 ·АНтГє   OЫъжЦцTУъyЭ*L!ГЛV pЛN VЛF 9ю ЛЖЙю 8oЭ~Э–	ш}·тєю 0ЦЂЭ¶*ЖwГ”·И!ЦB н№А45 щЛ†!ЦB н№А45(щ!ь	N#fiйЛЋЦ W:Д!° н№!>zгЛ–Ц ЭѕРЭ†Эw	:ЕЭ†ЭwН–Гi2Д!ГЛОЙЭѕР2Е!ГЛЦЙЫъхжЖУъ  у:`8Е    ъБусУъЙЭ~Эѕ	ъi:И·ИЭ~Эw	Э5	Г$Э~Эѕт~Э4Г–Э~ЭwГіЭ~ЭѕрЭ5Г–Э~Эѕ	шхЭ4	сВ–:И·К\Э~Эw	Н–єЭ~Эw	Г$Э~ЭwЭ~Эw	Г–O:ЙАy·шюР‡Ѓ‡‡Ѓ O!N	"LеЭбЭ~·(Н\Г–Э~Эѕ	8тН–fЭѕ РGЭ–нDъ<ЭwxшЭwЭѕШЭwЭ*LГ–Эѕ РGЭ–ъ<ЭwxЭwЭѕрЭЭ#їЭ#ЯЖ юЂ8ю 0ЛїЭw
ЙЭ6я>
Уц> УчЙЭ6 Э~Э–	шЭ~·А>
Уц:UУчЙЇ2ҐГ€!:Й·ИЇ!К:Й·А/*LК н°!¶н[L н°2ЙГ–>яИ!
"Й!чЭ6ЂЙЭ6 Й>я2ИЙЇ2ИЙ*ЖЭ~Э–	ш(
 O	T]+нё#Э~
wЙЭ~Эw	Э~Э–ЭFЭp(Нее Э^нRС ЭNн°Э5=еНAН–Гi*ЖЭ~Э–	ш(№ OT]#н°+®НеЭ~Э–	шЭN
q#=тNЙЭ~Эw	Э~хНісЭwјНAЭFЭN	ЕЭ~Эw	Э~ђG(
Э4ЕНAБцБЭpЭq	ЙНѕТНе"Ж 8·нRц>нyнa<нyнiЙЭ~	хЭ~Эw	Э~Э–(Нее Э^С ЭNн°Э4=жНAсЭw	Й! 8 Э^ЭF(эЭ^	Й7So‡”µѕ!!!!!!!Xe†‘ґёїДЙОФЩф*AUh‘*Н'@DHNP  OP     P  OP     P  OP     P  OP     P  OP     P  OP     P  OP     P  OP     P OP        8               !еH Л!	N#fiййрЫэжро0ЙЫХжро0Й!H Л!	N#fiй	OНй ыyУэЙOНр ыyУФЇУХ<УХЙ!1H Л!	N#fiй5_ЫТжАG>УТ:§ЛПУТЫТЛG ш >УТ:§УТyЙЫУжАG>УУ:оЛПУУЫУЛG ш >УУ:оУУyЙ!—H Л!	N#fiй›ѕЫТЛG >УТ:§ЛПУТЫТЛG(ъ>УТ:§УТЫРЙЫУЛG >УУ:оЛПУУЫУЛG(ъ>УУ:оУУЫСЙ>ТЂO>нyнxж,Ц,Й_Нб ынYЙO>яOЇ2гyж2Myжю8>Й2Ъ"ЮНЈ{Эѕ8>Й2ЫxЭѕ8>Й2Э:<2в>яЭЛ n =УмА:Ъю0Л±yУо!  "д>РУмЫм2бНґЭЛF ЭЛЖ>яЭwЇ[:ЫЭЛ n(ЭЛ f <ЭЛ V(‡Эѕ 3O>РУмyЭЛ V(Л?Ун:ЭЭЛ v(ЭЛn 	ЭFЛ8ё8ђЭЛ ^(<Уо\OЭ–0нD2дyУп>РУмЭ~УнЭ~ жх*д(T]GэDM)	:Ъю0) 	"дсцУмНґЫмЛВGяЛG т НЂяЫнЭwГ~:Ъ!аѕw:б8($!2 	ЭЛ ~ х! нKд·нB8(э НЂя+|µ хЫмЪGяНґ*Ю:г·х:MГ яЫмЛw(>ЙЛo(>ЙжИЭЛ†!в5ВZЛg(>ЙЛ_(>Й>	ЙХ& o‡…‡oЧеЭбСЙ:Ъж·G>(эЭЛ v(O:ЭЭFЛ8ёy8ЛзУаЙ      я     уеНVЭ!ЌЭ~ж& ox‡…oљ н°Э~Э~Э~ж3Э~Э~ Э~Э~ж3Э~Э~	Э~
Э~Э~С!љ>ГюЫъхжїУъ!ЌД{У[’_ЫZжц0w#ссУъЙSatSunMonTueWedThuFri             WWW MM/DD/YY HH:MM:SSуЭ!ЌЭw}жЭw}жЭw xжЭwxжЭw|жЭw|жЭwzжЭrzжЭw{жЭw
{жЭw	Э6 Э6 !ЌТЫъж—цУъ{’_У[~УZ#хЫъц@УъГVO>яOЇ2гyж2Myжю8>яЙ2Ъ"ЮН;zЭѕ8(>юЙ{Эѕ0чнSЫxЭѕ8>эЙ2Э:ЛO·т…У:Ъ2Л№(Xэ!№ЭfЭn Э^ Л;ьэsНЃ3эt эuэtэu& Эn))эtэu>НN!№ НГяЫжю(ю фнірНЄ ;ЭЛF > НNНЄ ц>НNНЄ !ЭЛЖ*Ю:г·х(>>
НN:MГ†яНЄИ>НNНГяЫ WЫ Ы Ы НЄ кzжЙХ& o‡…‡…oеЭбСЙ еэеэ!Бэw :Ъэwн[Ы!  ЭFэ :Э_эtэuЭ~ ж>  >эwЫж ъ>У УЫж(ш!Б НГяніэббЙНГяЫ OНГяЫ yжЙ                ялуГ’уеНVЭ!Ќэ! юЭ~жOЭ~жЃэwЭ~	жOЭ~
жЃэwЭ~жOЭ~жЃэwЭ~жOЭ~ жН¦2­Э~жOЭ~жН¦2®Э~жOЭ~жН¦2Ї:­ЦN0ЖdЛ?ЛЛ?ЛЛ9ь!  ·(Gµэлy‡‡O‡ЃO:®=Ѓ‡O!b 	~#fo:ЇO	эu эtС! ю:…4·>Кю н°Й‡G‡‡ЂЃЙ   у" ю!юr#s#6 ЙХе+ЇµнR8<щл‡‡2­>/& o)b 	F#fhнR8(=тХ Ц8щЖ2®:­ЂЦ0Жd2­}нD<2Їб|M !  ЛнjнR0?у}х:®НO W:ЇНO g:­88Лф:­НO oBсСЛъГЇ Ц
8щЖ
Л!ьЃЙ   ; Z x — µ Ф у 0NmЊЁЗе"A`~ќ»Ъщ5SrђЇОм)HgѓўАЯэ;Yx–жх#!>НюБЫъжЦцDУъЫщж?цуУщ: <23!x2 <#!! „w>„gч: <цЂ2 <#!! „/w>„gц:3!2 <Ыщж=УщЙ                 ЫъжЦцDУъЫщж?цуУщ: <23!ЇЧ2 <! „w>„gч: <<тO!Ч2 <! „/w>„gц: << и:3!2 <Ыщж?цуУщ: <23!Э!":Ґ·(WЧЭ~ ·(Э#2 <! „w>„gчеЭ!":Ґ·(WЧЭ~ ·(цЂЭ#2 <! „/w>„gцв:3!2 <Ыщж=УщыЙ@[\]{|}~ Э*L2&#еХЭ~2!#Э~	2"#Э~2##Э~2$#:И2%#(НЙНДНXНФНѕС(Э~Э~Се2'#:&#· Yэ!(#ЭFЫъжЦцTУъЕ*Ж~жЭѕ
 > ю 0ЖЂэw э#Н”БбЫъцUУъ!(#СХЭF>НюЭ~Эѕ(UНµНo*'#& Се§бе(#ЭF>Нюэ!(#ЭFЫъжЦцTУъЕэ~ НЈэ#БфЫъцUУъЭ~Эѕ(НµНo*'#& Сјб:!#Эw:"#Эw	:##Эw:$#Эw:%#2ИН–Гi                                                                                       унVЫщж3УщН4!Ї!Н6>Н:.Н */}\Нf*1}\Нf!№#~·(G#N#ніфЦЧПрХ >РУм>!8 ќ$Ню:ќ$юГ Ї! " ю!юЇw#w#w/2>!8 T]хНюс= с:3·(!С"_ !ѕ"a ЇGНШ$ЇНШ$нK&н[$ bjэ+"‚%нK#„%! ЂЕ"›$нK&}|>„gф*›$P 	БбЭ!¤(  ХнK&!  э НЃ3{ю	8#)„%~Эw Э##~Эw Э#С!ВНњ3 МЙ   Э*L! 8K Э^(эY"ј$2»$Й   OЫщж!(ЛзУщЫъжХ(ЛПУъЙOЫщж(ЛпУщЫъц]уУъy! ЂЂя·(>яwн°ЫъжЧУъЙЕхХжр(л·!БнRС8Х)¤(^#Vл·*‚%нRС0ббЙХ)„%^#VбЇЛ<ЛЛ<ЛЛ<ЛO|· Ю}юP0ЩyЛьцЖБЛ@ жѕ2y%ЫщжБ(ЛпУщЫъц]уУъЛ ЫъжЧУъыЙ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ЕХл·*‚%нRС0ЇбЙХ)„%^#VбЇЛ<ЛЛ<ЛЛ<ЛO|· Ю}юP0ЩyЛьцF2{,ЫщжБ(ЛпУщЫъц]уУъЛ ЫъЛџУъы> И<ЙЕх>Й-НюсOжрyх(9сжхЭ!Л-ЕнK&ЭVЭ^ !  э НЃ3{ю	8#ЭtЭu Э#Э#Э#Э#БС!  "Х-*Н-н[Й-Нњ3ън, яялнCб-·нR#"С-*П-н[Л-Нњ3ъ- яялнCг-·нR#"У-Нµ-*С-н[У-Нњ3ъp-*Й-н[Н-Нњ3КІ-*Х-н[У-"Х-н[С-Нњ3ъ`-·нR"Х-*Л-н[г-"Л-*Й-н[б-"Й-Нµ-Ѕ*Л-н[П-Нњ3(6*Х-н[С-"Х-н[У-Нњ3ъў-·нR"Х-*Й-н[б-"Й-*Л-н[г-"Л-Нµ-ѕббЙбсБЕхе*Л-н[Й-Г%                                ЕЛзх>Е-Ню!  "Х-"Л-*Й-)л! "У-·нR"С-*Е-н[Й-л*З-Нg/*Е-н[Й-·нRл*З-Нg/*З-н[Й-н[Е-Нg/*З-н[Й-·нRн[Е-Нg/*С-н[Х-"Э-*У-"Я-*Л-#"Л-*У-##"У-*Я-Нў3л*Э-н[У-Нў3Нњ38*Я-"Х-*Й-+"Й-*Э-н[У-"Х-*С-##"С-*Е-н[Й-л*З-нKЛ-	Нg/*Е-н[Й-·нRл*З-нKЛ-	Нg/*Е-н[Й-л*З-нKЛ-·нBНg/*Е-н[Й-·нRл*З-нKЛ-·нBНg/*Е-н[Л-л*З-нKЙ-	Нg/*Е-н[Л-·нRл*З-нKЙ-	Нg/*Е-н[Л-л*З-нKЙ-·нBНg/*Е-н[Л-·нRл*З-нKЙ-·нBНg/*Й-н[Л-Нњ3тM.ббЙЭбсБЕхЭеГ%ЕЛзх>Е-Ню!  "Х-*Й-н[Е-·нR"Й-*Н-·нR"Н-*Л-н[З-·нR"Л-*П-·нR"П-*Е-н[Й-л*З-нKЛ-	Нg/*Л-Л| !яя"б-*Й-)л! ·нR*Й-)л! "б-"С-*Й-Л| *Л-)л! "г-!яя"г-*Л-)л! ·нR"У-н[Х-"Я-Нў3"Ы-*С-"Э-Нў3"Ч-*Э-н[У-Нў3"Щ-н[Ч-Нњ382(0*Ы-Нњ38(*Й-н[б-"Й-*Э-"Х-5*Я-"Х-*Л-н[г-"Л-"н[Ы-Нњ3тi0*Й-н[б-"Й-*Э-н[У-"Х-С*Е-н[Й-л*З-нKЛ-	Нg/*Й-н[Н-Нњ3ВЖ/*Л-н[П-Нњ3ВЖ/ббЙнS3OжюКҐ2хyжюКЧ1х>Й-Ню*Й-"Ч-*Н-"Щ-н[Й-Нњ38(н[С-"Щ-*Ч-"Ч-*Й-+"Й-!яя*Й-н[С-"Й-! "С-*Л-н[П-Нњ3т]1+"Л-н[У-"З-*П-"П-!яя"З-н[У-"Л-! "У-*З-н[Л-Нњ3(Z*Ч-"Е-*Щ-"Н-*Е-н[Й-Нњ3(.БЕ*З-н[Е-Н(,бБЕе*П-н[Н-Н%*Е-н[С-"Е-*Н-"Н-Ж*З-н[У-"З-*П-"П-љббЙ>Н-Ню*П-"Л-*Н-"Ч-*С-}Л<ЛЛ<ЛЛ<Лж(#"Х-*Н-н[С-"Н-*П-н[У-"П-*Л-н[П-Нњ3(®*3(#:Х-G>Ню*Ч-"Й-!  "Ы-*Й-н[Н-Нњ3(B!(#н[Ы-ЇЛ:ЛЛ:ЛЛ:ЛцF2n2Л > (<БЕ*Л-н[Й-Н%*Й-#"Й-*Ы-#"Ы-І*Л-#"Л-*3н[Х-"3Г2yжх>Н-Ню*П-"Л-*Н-"Ч-*С-}Л<ЛЛ<ЛЛ<Лж(#"Х-*Н-н[С-"Н-*П-н[У-"П-*Л-н[П-Нњ3КХ1*Ч-"Й-!  "Ы-*Й-н[Н-Нњ3(DБЕ*Л-н[Й-Н(,O!(#н[Ы-ЇЛ:ЛЛ:ЛЛ:ЛцЖЛA жѕ2I3Л *Й-#"Й-*Ы-#"Ы-°!(#н[3:Х-G>Ню*Л-#"Л-*3н[Х-"3Гс2  |M!  ЛнjнR0?уЛлgiЙе·нRбЙЛ|ИХл!  ·нRСЙЕХеЭеэеНpy·(0:GюP(%:№·(x· y*w#pлнRл ! "!4Н7!y45 g6-:3· ю!z4<'– #ф* ю#" ю:»$·(>:3·(! ю2…4НСЇ2…4!ю}4Нd4ыЫъхжюцУъ!}4н[ј$жЂ¶#чсУъэбЭббСБГя~жЖ0~жЖ0#Й-``$HH:MM:SS                                                                                                                               OЫщхyХH ЕхЛ?Л?Л?Л?Н1ю@юн°сжН1юБ!@юСн°сУщЙжАцWЫщж=ІУщЙ                                                                                                                                                                                                нsя1 яхЫаЫщхж?УщГЇ3сУщсн{яыЙ  Н1юс((>€уУм НЂяпЫмЛO ЛG(8ЫмЛO Л(м>Йнўе>ЁуУм НЂяпЫмЛO ЛG(ЫмЛO Л(мЦнЈжЫщж=цУщГtx± ыЙН1юс(  НГяЫжю(ю фнІр  НГяЫжю(ю фнірЫщж=цУщГЫж(ъЙнўе>ЁуУм НЂяпЫмЛO ЛG(ЫмЛO Л(мЦнЈжЫщж=цУщГt1ЃEН NНЌE	%EНЌE«DНЌEюяПDКўDЂCНЏDН•D!ЂCЃE~#В4DН•D	ЂCНЌE:‚Eg:ЃEНsD:„E·К_Dg:ѓEНsD!]C~ю$ВoD#~юBМ©D1…EЙ·W |gлЂя	лХеНЏDН•DбС%ВzDЙНЌEЙ«DНЌE·ъDИ	НЌEуюЙ CPM3    SYS                        
CPMLDR error:  failed to open CPM3.SYS
$
CPMLDR error:  failed to read CPM3.SYS
$























CP/M V3.0 Loader
Copyright (C) 1982, Digital Research
$021182                л"ЯLлyюЪҐE2вLЇ2·L:ЮL2ѕL{2єL!  "	G"бL9"@F1’F!NLеyю2ТКEK!ЬEГПEЮdЪ›J_ ^#V*ЯLлйиFиF»FиFиFиFиFиFиFЯFиFиFиF LLLиFиFиFиF;LиFиFиFиFALGLиFиFиFиFиFиFиFиFиFиFиFиFиFиFиFиFиFиFиFиFиFиFиF  ЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗЗ:оF·ВћFЕНNБy!ЪLюИ4ю Р5~·ИyюВµF5Йю
А6 Йyю	В’F Н’F:ЪLжВБFЙ!ЫL
ѕИЕOН»FБГПFлMDГПF2	GЙ>ГеF 
BDOS ERR: $Select$Perm.$  пFНПFьFГ GпFНПFGНПFю{•_zњWРЙ{…_zЊWРЙИ)ЏГ8GѕА#ИГ?GИw#ГJGJНN|µИ^#V###"ђL##"’L######л"ёL!LНIG*Lл!ҐLНIG*ЄL|!ЅL6я·К•G6 7ЙНNЇ*ђLw#w*’Lw#w#wЙ!ГL^#V#FЙНЄGН'N·ИOюЪGГG*гLН&I л!ГLs#r#pЙ*ђLN#FЕ*’L^#V#F*ГL:ЕLO}“|љyеТH*ҐLН%Gбг+гГрG*ҐLН.Gб}“|љyЪHг#геГHге*ҐLН%GбХЕел*ІLDM"ОLНNС*ђLs#rБС*’Ls#r#pБy“oxљgНkHDM*ёLлН0NMD"РLН!N*ЉLMDГ$N:ґLOГ&I!§LN:БL·ВyHG>–O:АLКђH·Г‡HЂЙ*ЯL ЙН’H	:ЅL·КЁHn`Й	~#foЙНrH2»LO НљH"ГL}ґЙ:§LO*ГLЇН7G"ГL2ЕL"ЖL:ЁLO:БLЎG2¶L!ГL¶wЙ*ЯL Й*ЯL ЙНоHл! ЙНцH~2БLл~2їLНжH:©L¦2АLЙНцH:БLЃwл:їLwЙИ|·g}oГ'IИ)Г4I:ЮLЕO! Н3IБyµoxґgЙ:ЮLOН&I}жЙ*ЊL:ЙL…oР$ЙНжH~жwЙ{•ozњgЙХ
 ^#VлСЙНЖG:µL·КЏI>НиLГ›IНЎI"ЊLНЪGНіG*ЬLГ§I*ћLНrI"ЉLЙ!гL~#ѕА<Й!яя"гLЙ*¬Lл*гL#"гLНkIЪґI:гLж‡ВУI2ЙL·АЕН}IБЙЕх:©L/Gy Oс ‘жБЙНцHAЕБЇ+ѕВ	JВяIy2»L:ЅL·xВJЕеo& :§LW>’OН&IE:©LёбЪьIНжHN/жЎ°БЙ*ЯL"еLy2зLНґIН—G Н»IН«IК›J*еLлНXI:зLO ~юеКJJy·К”JxюКЌJюК‚J–жВJJГЌJЕNНгIБ·ВJJ#ГhJЇ2	GGЙ>яGГеFН:JИНжH~хНXIл*ЯL НIGНфIOсw л! ‘КШJxТТJ>ЂFwx2јLЙ2јL~·А:»L·И:вLюИ6ЂЙе:јL·КэJ wЇ2јLбЙНжH~OНгIК!K>ЎwН:JНЁJНяHЇ2БLГеF4НфIOѕТ.K5ГйFНмJНїJГKНяH:БL!їLѕЪSKюЂВйFНяJ:	G·ВйFН®HКйFНАH:µL·ВТLН›IНЪGНіGГI:ЮL<КG=!ВLѕИwW*€LНMI_ХНSGбТG-И*€LMDН:I"€LЙ:єL2ЮLЙЇ2ИLГТK>ЂG=O*ЯL л~ ~Ўw#~ 2ИL~ЎwНcIНоH~ КТK~Ўp2јL!  "КL>я2бL*ЯL~ж=2єLюяКцK~2КLН›KНoK> *ЯLwЙ!  "€LЇ2ЮL=2ВL!Ђ "ЬLГ›IН›KГoKНўKНўJН'LЙН«IИНцH~<В7Lwб@ЙН©KГ7K:ЮLГеFл"ЬLГ›I:вLюЪ~L:ѕL2ЮL:бL·К~L*ЯL6 :КL·КpLw#:ИL¶wНоH:јL¶w*@Fщ*	G}DЙ                                                          я               >НоLГI $Ђ           *ћLГсL* LхНTM:ГL_ 2ЛL{Ў2ГL"МLНrI"ЉLН[MсхюТMН?GК,MЇНdM>НlMН[MНIG6 :ЛL<Ђ !Ђя=В6Mл*ЉLсюВJM"ЊLЙл*ЬLЂ ГKN:µLG/OЙ*МLВLЙ *МLЙхНЪGс=фіGНdM##ОLГIG                                                                                                                              ГZNГ6OГ6OГ6OГ]NГ6OГ6OГ6OГcNГhNГёNГЅNГВNГЗNГ6OГ6OГ/OГ6OГ6OГ6OГ6OГ6OГ6OГ6OГ6OГ2OГ6OГ6OГ6OГ6OГ7OyГVP  P!vNЙ                     ЏN  ЂP N¬Nяя D ?яр    я         KQя         KSнCzPЙнC|PЙнC~PЙ!HUн[zP:|PO ###НO(0у##~++№(0зКOyЂНO2|P л	"zPлГСN ђт	OЂЙ#~є+А~»Й:|PGЇн[zP*~PНVP·И>Йi`Йлн°лЙунVНVPЭ!ээ./!  TЭ^ Э#э- ц}нDo|/?Љgвр·нR(!P
Н7PPnЭ!>ээ.!  TЭ^ Э#э- ц}нDo|/?ЉgDMн[6 ·нRКEP·нB(!)PН7P)P0нC6 Ї_goНVP·КEPPНVPщю!P
Н7PPНVPщ! 8 C>ФУъЇеНVPб урDISK ERRORјеЇ°­¦ё¶«·©Я°¶ѕіє«Я»¶еііёєіѕјЯЇ°Я¦~/O#~/+w#q#уЙЇW_G!KUНVP·ИГЕOнsxP1 бЕХеЭеэеуЗх>ХУъсэбЭббСБн{xPЙ        Fщ*	G}DЙ                                                          я               >НоLГI $Ђ           *ћLГсL* LхНTM:ГL_ 2ЛL{Ў2ГL"МLНrI"ЉLН[MсхюТMН?GК,MЇНdM>НlMН[MНIG6 :ЛL<Ђ !Ђя=В6Mл*ЉLсюВJM"ЊLЙл*ЬLЂ ГKN:µLG/OЙ*МLВLЙ *МLЙхНЪGс=фіGНdM##ОLГIG                                                                                                                              ;ASCII code > 0A0H ?
	JR   NC,NORMAL1		;jump if yes
	SUB  80H		;convert code if special char
NORMAL1:OR   (IX+11)		;put invert mask over character
	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   (HL),A		;output char
	JP   CURRGT		;output cursor

;handling of control codes: 
CNTRL:	OR   A			;control code = 0 ?
	RET  Z
      	LD   HL,TAB1E+1		;^end of control code table --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length               --> reg. BC
CAGAIN:	CPDR			;search char
	RET  NZ			  .                                                                                                                                                                                                                                                                 `л"Ыылy2ЯыюЪ; !  "(:Ъы2¤(=2ј(:жы=К; !• ~·К; №К4#Г. {2ћ(!  "џ"Эы9"2!;(еyю3Т] K!Ж Гo юЂТ\ЦbЪАюТА!,_ ^#V*Ыылй Е!J		^#VлНЂБ:зы·АГ#!"( COPYRIGHT (C) 1982, DIGITAL RESEARCH 151282/В(
яЂы
+
1
7
И=
}!ѓ!–! !‡"›"м"х"ы"##п#х#ы#$$У$$#$-$A$J$S$@Y$u
u
J$Аu
u
}$‹$ђ$Н$Я$*%P%и$И%¦&'('d'с'ю'(('({
‰
•
•
AgXJ    v…‘юА!)$е*Ыы^#VХ#^#VблеЇw# Нl Нl Нl НlНsю:беВ¬НMКаЦAЪцюТц<w#НMКа ю.ККю;КыНВ¶Габе	 	 ю;КыНВФБХНsНMбА!  ·ИюИлЙББ!яяЙбе 	НВ>ђбе 	wГаНMИю ЪхъхВ2ю*К7w#·Й6?#т7Й	 .,:;[]=<>| е!?ѕК]45#ВR·бИюaШю{Тiж_жЙp#ВlЙю Кsю	КsЙеН‚:Є(ЖA2=/НоБ:уыТоНо:Яы0!юdЪЇ61#ЦdЦ
ЪёГЇp#Ж:w#6 !6 :Эы·Ке6 Х*Ыы#л!Н)6.#Н)СН‚ыГо
·ИЕOН(БГоBDOS Function =     File =              !эяГ,Н$-"¬ыГhы  !  9"f!ўеН	Н‰:жых2™(Нt·В™:Яыю!ФюНс=ВHgoЙ  ЗЗЗЗЗЗЗЗЗЗ  :ЯыO*ЫылГ; *ШыЂ Г“*Шы"rЙ*r"ШыГїБ<И:жыђgЙе:Яыю!ФНђС*fщл}DЙ! э~6 ·АГtы!r
еН·НрЪЦхOН(сЙНАюВеН^ГЖюКЖюКЖЙюИю
Ию	ИюИю Й: э·ВљНnыжЙ!Хы6@гйG:ПыжxЙНВя: э·ВP:Мы<КяНА: эюКPННnыб6 жИННtыб6 юВ! эѕВ^6 ННtыб6 юВu:ПыжК)ЇЦИ<Н Г^! эG:ПыТЋ>ѕИxюКќюКќw>ЙЇwЙМ©ДzыЙ:ПыжВ»!Фы>®жwЙЇЙ:Яы=КzыxжВzыГzы:ј
·Вц:ПыжGЕ:Яы=Д/БЕНЅБx·ВцЕ:Фы·ДЂыБy!·ыюИ4ю Р5~·ИyюВ5ЙюА6 ЙyНрТ(х^ННсц@OНАИ:Яы=К7:ПыжВНyю	ВН:ЯыюВIНАИ НН:·ыжВ=ЙНe:ї
юИ НzыГzы#ННН‚:·ы!Ѕ
ѕР ННГrНН
ГН!Уы
ѕИЕOН(БГЊ*(~2**єы}ґК·Н!э#·В¶!  "єы"јыАГ·:¶ы_:·ы»Йл*(л·И#wГОx·ИЕHел!ВН)6 "&бБЙ:ґыР!ВБ
В
лx·И2А
ХЕGHГ)б+6 Й:·ы2,Й:·ы!-ѕР ННГ:,!·ыѕРННГ+Ее*( ~·КL#ГBxѓ№хФzысбБШССГя:*·И:ї
юИюИюИеЕН*(~·К“OНАЪЉ{2·ыГ“еНб#Гw:·ы2.НН+:.2-БбЙ!%"(Ї2*Й!В"&Й!*~·А4:·ы2-ЙНАФ‚:А
G НоНіНЁН^Ї2+>2Яы:·ы2Ѕ
*ЫыN#еЇG2ѕ
№ВяЕе:+·Мњ2ї
бБюКз	ю
Кз	юВ5НА»Тял*(~·Кo#"(лГM	юВљл*(~·К`лНА»лЪUлНoлГj*(~#"(Г‘!*~6 ·Кs!+6 лГя:+·В‚x·ВoНі*&~·2+Кo#"&!+6лГM	юВЕ:Ѕ
W:·ыєКя2ј
x·К	еНєС*(+"(wлГ	юВ:ѕ
ёВЬ>2*2ї
Г:л*(:ѕ
ёКр+wГб"(ЕХНє:·ыG:Ѕ
ёКННГшюВл!%"(лН^ГяюВ-:*·КяГ$юВP:Кы<К\:Ѕ
W:·ыєКя2ј
x·КMГ	юВs:Лы<К9>2ї
:*·В9x·Кя~+Гq	юВ’Еx2ѕ
е:*·ДН‚Н^Ї2Ѕ
ГюВўеЕЇН БбГяюВДб:Ѕ
!·ыѕЪЅ*(~·ВЭГЧ5НWГЁюВХгНШгНjбГЧюВM	Ї2ѕ
лНЁлx·КОл*(Кш+wГн"(ЕХНj>2+2*ГЕНjБбеЕx·К.	#NСХzђWЕе:ѕ
єЬбБГ	е:ј
·К!·ы–2ј
НW!ј
5В=	Н^Гхx№Ъ^	сЕеНzыГ:ї
юКm	:*·Д;с#wЕеOННбБ:ї
юК9юКЊ	Н^:ПыжВ—	~юxВ 	юК)№Та	ЕеНАЪ:*·КА	:ї
юКЕ	юКЕ	>ГбБл*(+"(wл+ЕеН+Ї2+ГЇ2+ГяНЙбpЕНШБяНо!  "єыГННяГr
y<К 
<К
<К%
ГzыНяВАГr
Ня·ИН·Гr
Н6яГr
Н9яГr
лMDГЊ:ПыТo
!Хы6Ђе!h
е: эюКљНnы·ИНtыюК2 эЇЙНr
б6 ЙН2џЙ>Гr
zЈ<*ПыК)$л"ПыЙ!УыzЈ<~Кr
sЙл^#V#N#Fлx±ИЕеN:ЯыюoКІ
НЂыГµ
Н(б#БГћ
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   CP/M Error On  :  Disk I/O Invalid Drive Read/Only File Read/Only Disk Password Error File Exists ? in Filename   ГІГІ>я2©(a.я"џ:Є(2ны:зы<Дыы:ЯыюК5(юК5(Г;(:ј(2эЙЇ2ј(2эЙ{•_zњWРЙ{…_zЊWРЙИ)ЏГчН74А#4А#4ЙНлГ)Н7®(ЙНГѕА#ИГИw#Г*JНя|µИ^#V#"i(##"k(##"m(###"o(#"q(##л"љ(!s(Н)*s(л!Ђ(Н)*…(|!Ј(6я·К~6 7ЙНяЇ*k(w#w*m(w#w#wЙ>2ґ(Н'яГҐЇ2ґ(Н*я·ИOН¶yюЪІГІ<АНлИ*e(НИНІб:Яыю0И!Є(:¤(ѕВжН:ґ(·АГІЇ2ЮыЙ*‹(>ЂјАЇЅЙ*быН«"‘( л!«(s#r#pЙ*k(N#FЕ*m(^#V#F*«(:­(O}“|љyеТ9*Ђ(Ндбг+гГ"*Ђ(Ннб}“|љyЪPг#геГ9ге*Ђ(НдбХЕел*Ќ(DM"ы(НяС*k(s#rБС*m(s#r#pБy“oxљgНќDM*љ(лН0яMD"э(Н!я*эMDГ$я:Џ(OГ«!‚(N:Ё(·В«G>–O:¦(КВ·Г№ЂЙ*Ыы ЙНД	:Ј(·КЪn`Й	~#foЙН¤2џ(O НМ"«(}ґЙ:‚(O*«(ЇНц"«(2­("±(:ѓ(O:Ё(ЎG2“(!«(¶wЙ*Ыы ~‡хzWсw+В!zЙН?#~Й*Ыы! Й*Ыы Й*Ыы ЙНGл! ЙНO~2Ё(л~·ВmН—OНэ~юЃЪt>Ђ2Ґ(Н?:„(¦2¦(ЙНO:Ё(w:ЯыюТ’4л~юЂР:Ґ(wЙН?r##rЙp#ИГ¤И|·g}oГ¬*g(  Ї†#ВБЁGВѕЙН1*q(ѕДг:µ(·И*ЫыЇwЙ*эл*юыНТч*’ыНИбб>
Гr
И)Гяe(:©(O! НюµґЙ*c(:©(OН«}жЙН@Н2РГ¦	 ~ЙНИГЎ*g(:·(…oР$Й*Ыы ~ЙНK6 ЙН?~жwЙНKцЂwЙ*был*i({–#zћЙНiШr+sЙ{•ozњgЙю*‘(л*‹(|жgНРЕНё*u(л*‘(БКЖКСѕИН НR>я2Юы2њыНиНГZ$ѕwИ*q(>¶wЙwЙ:¤(c(Н*‡(#л*i(s#rЙ*ђыНИ’ыГ:Њ(жЂА!А(:ЯыG~ёИ#·В<Й*q(#~·Й!;(е!Н(НюКщ!Ф(НюКАбЙ!Юы~·И6 Нk!  "быЇ2·(Й*q(NН1qЙ*{(Г]*{(Г[*y(}¤<И^#VлеЕЄ(НБбВt6я ^#Vл}ґИГeХ
 ^#V#~2ъ(лСЙНх>ГўН9Н†>!  "–(*y(юВі*р(НX)*ШыГїН‚"эЙ*g(л*эЂ НKя!џ~<И:быжwЙНb##>яw#wЙНДГыНиАб>	Гr
!бы~#ѕА<Й!яя"быЙНГ@*‡(л*бы#"быНЪ:быж‡В&2·(·АЕН’Б:Юы·АГ€Н0:Юы·ИНН+Г’yж<_W`iН«DM*w(	~ВbЙХНNжюБ±ВpwЙхНЮDM*w(T]	сКKялГKяЕН¦БЕНЮл*w(Бе"w(Н¦б"w(ЙН@ ЕСИХ:Ј(·КГЕеN ГЙЕN#Fеy°КШ*…(}‘|Фhб#БГ°*…(Н«#ЙН6 НлВя*q(ѕ  КяГ@-НRНXНЮDM*w(6 #x±В*o(w*‰(л*w(s#rНЂ*i(6#6 Н*}("±(яННшКj-Н@л*±(|Ґ<лДЏ+>!ѕК8>еѕК8> ѕКt>¦ВnН¦НvГ8 ~*o(wГn:ќ(Гr
Ех:„(/Gy Oс ‘жБЙНOAЕБЇ+ѕВ¬Вўy2џ(:Ј(·xВ№Ееo& :‚(W>’OН«E:„(ёбЪџН?N/жЎ°БЙ*Ыы" (y2еыН¦+>я2ќ(ЙГчНЭННхМЂЇ2ѕ(Нk,Вє ННшКє* (люеК*ХНiСТєН@:еыO ~юеМнЇ2ў(~жпѕКWлѕлВW:э·К2ў(Г”y·К›ю?К”xюК”юК|юМ·–жВЗГ”ЕNН†G:ѕ(<КЮЇ2Ѕ(xБ·В#ГW:ў(<В­:эююМкГЇ2ќ(2џGЙж?ЙНнН>яGГr
x·В~·В:Ѕ(·К2ѕ(Г”°БЕА##~·АНхе*э$Вы*бы"эбЙ>я2э>ю2эЙ:эююИН
ЇНя* (~цwНгГ*бы"эЙН
НЭГН2і(>юНяНхИК„Н@~жВk:і(Ф(НsЪ~*ЫыН9К~ГЉНsТ~НФ К~Н…Г<НГEНхКЂН@~жВ›:і(жЂВќ6ехН!·В¦wНљ сМ‹НИ,НГ‡PY*…({•zњТоЕХBKНNТжСБy°КєХЕНNТжБСГє<НpбСЙy°ВТ!  ЙЂНКљ~ ЕGж°wБ#ГэХ *Ыы	#~Ц$М%+лН@БЙіыцЙ*ЫыН9А>	Ге##>?–жИВ;·Й*Ыы~ 	wЙН-НxД…НэНH" (Н0* (НгНъВг#НДЉНHНэНхИН(НчНИ,НВ€НКЂНHГ€Н2і(НxД…НхИ НН):і(ж@КОеНO~б#wНљНКЂГґНѓ-ИНb_е++VХН@л*Ыы Н)Н—OСбs++r л! ‘КxТ>Ђ¶wЙ~·А6 :џ(·И6ЂЙ~#¶+Аw#w+Йе ~юЃЪ;жwбЙЇ2џНАНKжЂАНиКтНь,OFЕqН-yёЬэНlН?БNpГэНрИ Нg&:Ј(·К“~·В†w·ВЊ~ѕВтГЁНлНлѕВт#ѕВт#Вxлмя	еН—СНшwЕ 	л	БКЩКЪѕЪЩ·ВЪНлwН@ ~жwНbНђГљНЭГАѕАлѕлАЙ!яя"эЙ*э>ьҐo+"быЙНv-НыД
*Ыые!b("ЫыНЭНб"ЫыИ:э·А r#~хеж?w#>r#ВL=JМ!·
КLНv   НщбсwНИ,ГbНЬН?~OН†КЪеЕН=Бб:џ<И>Ўw##~2§(В 4~ж?КЙННѓ-В№:њ(<КЙНКЙГјНЮНAНXЇ2Ё(Гr
НK:§(w++~=жwГv
4Н—OѕТм5:њ(<Кv
4Н-НэГјНо>я2њ(НX:Ё(!Ґ(ѕЪюЂВv
Нq:џ·Вv
НХНаКv
НтНMЪ‚В?Н¶Н>НTяН“Г‚!  "–(>Ня(Г‚:“(G:ђ(O х:(юЪh=2(с7АЇЙсКry·ИцЙy/W!Ё(:™(юЪl†юЂЪ€>ЂЕF6Еех:ѓ(_/ Gб:њ(·К§:Ґ(ўјЪЁ|ђO»ЪЕН¤G:џ(ё_КэOЕ НМеНМСz”W{•ІКВ|µВх:њ(·Вх*…(}“|љЪхЕХBKНNбБТВСz№Ъэy“G:ѓ(<OКЃГБAO:њ(·Кx№ЪyбБpБ!™(VђєТ+Wy/ў2(Кoх:њ(·КBН %Н¶сgНќ|юOДEяЇЙНKжwЙНKж@х~ц@wсЙ> 2њ(Н9:¶(·>Ве#:µ(·>Ве#*ЫыН+НоНS!НX:Ё(юЂЪњНq:џ·АНаКє!Є(•(НКµ>я2”( ГНЬН¤2џ(  ·КСOНМDMНё}ґВЮ>Гr
"«("–(Ї2”(:Є(2•(л*Ыы 	:Ј(·:џ(КНFsГO 		s#rЕНт:Яыю(В„y==В„Бх*«(е!ђ(^WХ*y(^#VлеНx+СВ7л=2”(wНјСХЇw#тKWВK*±("«(ЕНJНЇНTяБНћ*«(СХ:ѓ(Ґ В[бб"«(Н¶С:Ё(WХНMЪєК›>Ня(ГєН¶Н>НTяНJБЕ:«(!ѓ(¦К· НћБx!Ґ(ѕЪЗw4ВПНPНWВЮНPНЬГ‚НХГ‚Е*Ыыл!! ~жх~#~жO~жр#¶G~жьб.|В°!  w:ЯыюcКkХНиСК[! x–ж?В[! ~№К¤Н†В[ЕН—Б№ТPСХВPСГv
qOН-НэГЎЕХН=СБ.:џ<К°Н! еVq##~_Хж@°wНЪ:џ<ВњСбБЕеХ.К©Н.К©ББНAНЬБЇГr
Сгr##sбНЬ<Б}Гr
яНдМхЙ НдМcЙлN ! ~жЂЃO> €G~жЂG! ~‡‡‡‡·ЂGх~жoс> ЌЙ_y–W#xћ#хІWс{ћЙs+p+qЙН7еr#r#rНхК>Н@ НЛбеНюФН> 2џГбЙл  НЛ!! q#p#wЙ2Є(wW*e(Н_ХН3бТ«-Й!¤(s:¤(!©(ѕВxюяАНQИНи*q(~жх†wсДиНЙЇ2µ(2¶(Г№Ђ*Ыы л~ 2¶(~Ўw#~ 2µ(~ЎwНZ!  "э"эЇ2Ѕ(=2Эы*Ыы~2ї(ж=2ћ(юяКЯ2¤(Нk:аы*ЫыwНхМXНхГ/НИ6 НX*быеНЂН Н!Юы~·К$6 б:Яыю0ИН3ГНiЪб"быЙ!ры~·И6 *e(>=)ТQхе!©(НQНXДхбс·В<Гk*{(}¤<И^#V{ІИ! ~·А! Г_*o(~ЙНsжЂИНѓ ИГ Ї2эН@л!Ч(еН)#wС*Ыы~ел"ЫыНрКдН!·ВТл!д(Fw·КдЁжаКТНѓ КТ:д(wНМљб"Ыы:ЯыюИюИ>Ге#Ї2д(НВэНѓ х*Ыы~цwсД‡б"ЫыЙ#Fx·В T]##	#~И·К ю К л
 л*эЁѕВ4 #В' ЙВ4 !з(Ге  л*эЇх~·К^ ю К^ 33хЂG#ВP с°бВv :ЯыюdКv 6 ЁВy #Й*Ыы~хцwНх> 2џ*ЫыБpИН@л! ~жацЙе*э"эбЙНvЕН@л*Ыыл°w#Н)БИ6 #ГМ Н™ еН бЙ Гд Н!·АљХфыеХ НNяНСбВ)бЙН@	u
ХГн :быжюИG*g(` ~Ц!Аx‡_‡‡ѓ<Ѓ_ЇЙН@!А*o(y¦В<Й:„(ца/GН?~ А##~ж?Й Н6!АНKж@АН?F6 е##N6 ЕНрДв Ї2џБбp##qЙ:ЎыГr
!яяНZ$Ї2Ъы!Ђ "ШыГ¶Нg:¤(2ЪыЙНTНђН-:аы·К№!>ю2э<2Ѕ(НЪНз!!Ѕ(ѕИw:эююИН
>Ђ2µ(*Ыы6 НЭННЭНз!ЙНшИНO~<Вч!wб:µ(Т"*Ыы
 ~жЂВ"2µ(ГАНAНsжЂКv"Н@!ВN"Н!·ВN"~жАКv"Н$Нѓ ВW"Н+ИН!·Вv"wНМљГv"Н$Нѓ Кr"Н Кr"Н…:д(жАКr"жЂВЯ>Ђ2¶(Н+ИНA@Н2!МЭ ђыГНљНAНШН=:џ<ИГ%лЇх~ю?ВЇ"НkНй ГГ"Н?~ю?Кѕ"НZНTНђсхКЪ"*бые>ьҐo"быН’б"быс!ГеКч:еыOНЭГл" (цГќ"Н}-Г6НљНОГхНљНОГcН2і(НZНTНђН-ННЪНш·К3#Н—ѕТг#хН@!КY#НsжЂКY#Нѓ КY#НЧ КY#Н…:д(жАВЯсФНшИНAНsжЂКТ#:і(ж@КТ#Н@!ВТ#Н$Нѓ В—#>я2эНВ—#НрН‡ГАН± л*э 	лжаВ«#>Ђ2д(хН™ сwНB pН'Н+ИН!·ВТ#:д(wНљНAPН{" Н2!АНв ГW>O2 НАГёН}-ГR*e(Г)$:¤(Гr
л"ШыГ¶Нk*w(Г)$*c(Г)$Н-Н}-Н¤ГЂНk*s("џЙ:ћ(юяВ;$:аыГr
ж2аыЙНљНОГ№НљНОГВНљГл}/_|/*e(¤W}Ј_*c(л"e(}Јo|ўg"c(>я2©(Й{·КАюЃТА2жыЙ{2зыЙНg*w(лНЮ  ·КЄ$Тў$Гћ$+}ґВќ$*…(#}‘o|g:‚(OЇНцл*эs#r#wЙ!іы~цЂwВ/~ц@wГ/Н/НHяНҐ*e(>=)Т%хе_Нg:Яыю0К%НwГ:-Н %:ћ(<В%НRбс·Вн$ЙНHяНҐ:ђ(·И>Гя(л~юcРл!њы…oл#~ююТE%л^#VлГ)$G#~И#~Й!°%ел~юИюВb%‹%Хю	Вk%ђ%Хе##N#F#^#V#~#foг~еo‡…! я…oг#~бгЙ>ГTя}ґИл!
 6 *щыНлРл*Ыы#е НKябЙ"џG*Ыы~ю	ИюИюИюИxГr
НђН-НxД…яНдВАН@ НЛН7НюЪАІКАН(НљНS!НхКЂНq&Ъ&х Н‹сК"&Н@6еНИ,НљНГю%НXН¤Н‹&Н—ѕwхНO~<слД:џ(·М Нg&л~жw#w#6 ##Н)Н‹Г&Н@	л*Ыы	Й Нg&~ж?GёА++NН†ИѕЙ<!Ј(4К”&‡5НДO 	>№Иp#Гћ&Нђ*Ыы6!НчВї&Н?~жpВА*Ыы6 ННчВд&>я2эНИН±  Н!НЭ  Н!Нв НФ ВЯ  Н· цwе*o(wбжК' Н§ НB pшяН§ НИ,ГљНgНsГr
НђН-НњНрИНД Н¤е Н!·ВS'СлН)Г_'б Н¤Нѓ И~Н?wЙНђНsТАН-Н?FеЕНњНрБбpИНН!·Кд'Нѓ ВЎ'>я2эНхИНИН± НФ ВЯеН?Сл~·Вѕ'жВѕ'Н'ГК'жаВЖ'>ЂwН'Н™ =2д(НњНрИН!·А:д(wГљ~хНѓ БК‘'pГЎ'!фыН(6 яГNя НNя!фылН(Гr
Г)!о(л еГN !  лГ)zЈ<*¬ыК)$л"¬ыЙ!яя"џ:Эы·КX(*Ыы:ї(w :¶(¶w#:µ(¶w*2щ*џ}DЙе                                                                      яя                     #cdfg !"()                                          *{(юВX)^#V!яя"ы(л:Є(ѕВ<)л! ~л<В<)ел^#V*ы(НбТ<)л"ы(л"э(Нx+В)!ы(НыИ*э(Ї>НX)*{(Г)хНQ*:«(_ 2п({Ў2«(схД’*"р(Н‚"эНX*~<КВ)схюТЌ)Н-Кт)ЇНa*юКљ)~·КВ)6 *«(е:­(хНX*лН)!©(:Є(ѕДT>Мq*БСННkсюРхюВЦ)!”(:“(ѕТа)Н-6я>Гг)<wЇНq*НX*Н)6 #Нѓ+:п(<Ђ !Ђя=Вь)л*эсюВ*"g(Йл*ШыЂ юВ3*:ъы=єЪэ:ъ(OНi*Ђ Гэл:ъы=јЪH*:ъ(GНi*Ђ НэНa*6яЙ:ђ(G/OЙ*р(Є(Й *р(ЙеХНWяСбЙхН:ъ(НTяс=Кћф“Нa*##ы(Г)Н0-уя"т(Нx+еНx+бИл!  "ц("ш(л"р(НX*НКC+*р(~<ВО*л*т("ц(Гу*:Є(ѕВф*л! :ђ(·Ку*ѕВу*:9-· Ву**т("ш(леНx+СК+л"т(лГ°**ц(}ґВ+*ш(}ґК+"т(*т(Нx+"р(Нx+лНm+*ф(^#V*р( 	s#r*р(л*ф(s#rлЙ*р( :п(ѕКY+4ѕКY+Нѓ+*р(л*ф(~#ngНµлИГ+*т( 	s#rЙ 	^#Vл|µЙ:п(w·И:ђ(<wЙеХНа+бќы :(Н	э"±(бЙ·ИюЪЬ+>Кґ+>2њылНd,Ил:ЯыюКа+ю#КП+юТа+>2њыеН9бВа+Ї2њы~2ќы#л!  ж В,ЕК,К,)ЏхxЪ,с)ЏхжЦ Т,O с	О БВс+"ћы!ќыж¶wж В[,жOж?WжGzжа±O:„(ТV,хxGyOсГG,xж¶w qЙ*}(}ґ<ЙНd,И:њы<И:еы·И*i(^#Vл=В‡,*‡("э:(*}(НэВ®,:э· Д=:ЯыЦИ:њы<МЇЙНшАНхА>я2њы*i(^#Vл+НЇЙНd,И!ё(ќы еХЕНKя*}(еН@На+*бы))СБСХЕ:(Н	эБбСГKя:Њ(Ъ—>я2#-Г—юВ:#-<ВбГЦ)Ї2#-*р(Й !  "єы"±ы++Й"ф(Ц29-Й НC-Г%Нw*{(}¤<И^#VzіИ!Є(ѕВc-! >яѕВc-! ГJ-Нw*q(~·А6ЙН9!эЙНђГ9НbГр                                                                                                                        BI$""	HB @      UUUUUUUUUUUUUUUUUAPD  A$! ’@ IЂ    ђ!@  D @BDI@ !B$      ’@$I$$  "@’$‚$@@H’‚HB  D‚‘"D$ЂH	ђD@Ђ!ђIB€@  A"B		„HBIB$$ ‘" $ „€DЃ$Ѓ!„ "D$’H$D€$‚I’@D B€D"‰	 H$BHHђBDHB"H„‘Ѓ!"!!$$HH‘	‘!‰"BB$HHђ€€DAЃ!	" „D‰"H $„€B’!’$! ‰A’I!$’	„„$ H ‘  H                                                                                             A$‰I!   ЂI Ђ" „ €$$BD"$H „"AH’D	Ђ@’ Ѓ	€ €I	 Ђ€B" $‰$€H  @@@@"	BH‰ЂB   ‘!I$	 @	$@$ Ђ "$A€I$’$IЂBI$„I  H@ @I!$’DA Ѓ $Ѓ $€’@$	!$ !!"€Ђ  Ѓ„!$I€‚@I	$@‚ „ђ$  @! Ђ€H"BI"HI DI €H’A ђDD$HHђ	‘$ ‰ B ‰ ’D$ђ‘ ‘"I$I$’H$ €‚I„  Ђ! Ђ 	$’I$‘I$’I $„@’HЂD$  € @   ‘ђ!$"A$A  €D‚ BI  €’D„€Ђ  B	’	@Ѓ$‘$’D’ D""I	$BH’I$ђ’IB ! @"BD B BDЃ €"@‘B @$	$’BI	I B„‘$@‰" 	! " „„H‰‘	!$„„€B I$‘    D@‘!	!$  ‘ ђЂ „‚@        H!$$ ђ€D€"@A @ ‚DH‚II‰	 ’D@@„’	   $ €ђDH€I"DЂ$€ЂЂ €@  „$ "" @ B!  „ @@D €$’$‘’A$	$D "@I	$A$‘$’I!H„’I$ BA$Ѓ $DH‘	$’I$’I"HI$ђ‰I!$’D „B$"B ’I$‰$’I$‘	!I$Ђ@DBB$@D@ђ"I A!$‘ ‰ @   ‚@    	" $ђ’	$I$’ђ’I$ Ђ B ! ђ$‚@’ ђI ЂЂ‚@’I$‘ HBDђH$„€’ A$H’!€’$D$‚	$I"                    B  	II„’B‘B"$€B@DЃђH €"$$	 IH $’$€‰	!I"A D„‘	  ђB!B   ђ    BI$‚A€$"@$I $!!""@H!	$ ! @I ‘$Ђ              $€H  @@@@"	BH‰ЂB   ‘!I$	 @	$@$ Ђ "$A€I$’$IЂBI$„I  H@ @I!$’DA Ѓ $Ѓ $€’@$	!$ !!"€Ђ  Ѓ„!$I€‚@I	$@‚ „ђ$  @! Ђ€H"BI"HI DI €H’A ђDD$HHђ	‘$ ‰ B ‰ ’D$ђ‘ ‘"I$I$’H$ €‚I„  Ђ! Ђ 	$’I$‘I$’I $„@’HЂD$ of lines to scroll
SCRLU1: JR   Z,SCRLU2		;clear last line if count = 0
        CALL CALC		;calculate start position
	PUSH HL			;save itЉ	LD   D,0 		;maximum column count --> reg. DE
	LD   E,(IX+1)
	ADD  HL,DE		;now HL contains address of line to scroll
	POP  DE			;restore ^line before
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll up one line
	INC  (IX+8)		;increment current line
	DEC  A			;decrement counter
	JR   SCRLU1             ;scroll up all lines
SCRLU2:	CALL ERAEO;******************************************************************************
;*  B N K B I O S  *  C P M S Y S 4  *  T h o m a s   H o l t e * 8 5 0 7 1 7 *
;******************************************************************************
;*									      *
;*   R O O T   M O D U L E   O F   R E L O C A T A B L E   B I O S   F O R    *
;*   =====================================================================    *
;*									      *
;*  	      C P / M   3 . 0   O N   T H E   G E N I E   I I I s 	      *
;*	      ===================================================	      *
;*									      *
;* 		    M I C R O C O M P U T E R   S Y S T E M		      *
;*		    =======================================		      *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	TITLE 'ROOT MODULE OF RELOCATABLE BIOS FOR CP/M 3.0'

;version 1.0  15 Sept 82

;			Copyright (c), 1982
;	       	       Digital Research, Inc
;		   	   P.O. Box 579
;	      	      Pacific Grove, CA 93950

;This is the invariant portion of the modular BIOS and is distributed as source
;for informational purposes only. All desired modifications should be performed
;by adding or changing externally defined modules. This allows producing
;"standard" I/O modules that can be combined to support a particular system
;configuration.


;ASCII control codes
BEL	EQU  07H		;bell
DC1	EQU  11H		;device control 1
DC3	EQU  13H		;device control 3
ESC	EQU  1BH		;escape

CCP	EQU  0100H		;Console Command Processor gets loaded 
				;into the TPA

	CSEG			;GENCPM puts CSEG stuff in common memory

;Variables in system data page
	EXTERNAL @COVEC,@CIVEC	;I/O redirection vectors
	EXTERNAL @AOVEC,@AIVEC,@LOVEC
	EXTERNAL @MXTPA		;addr of system entry point

;Initialization
	EXTERNAL ?INIT		;general initialization and signon
	EXTERNAL ?LDCCP,?RLCCP	;load & reload CCP for BOOT & WBOOT

;User defined character I/O routines
	EXTERNAL ?CI,?CO,?CIST	;each take device in reg. B
	EXTERNAL ?COST
	EXTERNAL ?CINIT		;(re)initialize device in reg. C
	EXTERNAL @CTBL		;physical character device table

;Disk communication data items
	EXTERNAL @DTBL		;table of pointers to XDPHs
	GLOBAL @ADRV,@RDRV,@TRK	;parameters for disk I/O
	GLOBAL @SECT,@DMA,@DBNK

;Memory control
	GLOBAL @CBNK		;current bank 
	EXTERNAL ?XMOVE,?MOVE	;select move bank, and block move
	EXTERNAL ?BANK		;select CPU bank
	EXTERNAL ?USERF		;call hardware drivers

;Clock support
	EXTERNAL ?TIME		;signal time operation

;General utility routines
	GLOBAL ?PMSG,?PDEC	;print message, print number from 0 to 65535
	GLOBAL ?PDERR		;print BIOS disk error message header
	INCLUDE MODEBAUD	;define mode bits

;External names for BIOS entry points
	GLOBAL ?BOOT,?WBOOT,?CONST,?CONIN,?CONO,?LIST,?AUXO,?AUXI,?HOME,?SLDSK
	GLOBAL ?SLDSK,?STTRK,?STSEC,?STDMA,?READ,?WRITE,?LISTS,?SCTRN,?CONOS
	GLOBAL ?AUXIS,?AUXOS,?DVTBL,?DEVIN,?DRTBL,?MLTIO,?FLUSH,?MOV,?TIM
	GLOBAL ?BNKSL,?STBNK,?XMOV


*EJECT
;BIOS jump vector.

;All BIOS routines are invoked by calling these entry points.

?BOOT:	JP   BOOT		;initial entry on cold start
?WBOOT:	JP   WBOOT		;reentry on program exit, warm start

?CONST:	JP   CONST		;return console input status
?CONIN:	JP   CONIN		;return console input character
?CONO:	JP   CONOUT		;send console output character
?LIST:	JP   LIST		;send list output character
?AUXO:	JP   AUXOUT		;send auxiliary output character
?AUXI:	JP   AUXIN		;return auxiliary input character

?HOME:	JP   HOME		;set disks to logical home
?SLDSK:	JP   SELDSK		;select disk drive, return disk parameter info
?STTRK:	JP   SETTRK		;set disk track
?STSEC:	JP   SETSEC		;set disk sector
?STDMA:	JP   SETDMA		;set disk I/O memory address
?READ:	JP   READ		;read physical block(s)
?WRITE:	JP   WRITE		;write physical blocks

?LISTS:	JP   LISTST		;return list device status
?SCTRN:	JP   SECTRN		;translate logical to physical sector

?CONOS:	JP   CONOST		;return console output status
?AUXIS:	JP   AUXIST		;return aux input status
?AUXOS:	JP   AUXOST		;return aux output status
?DVTBL:	JP   DEVTBL		;return address of device def table
?DEVIN:	JP   ?CINIT		;change baud rate of device

?DRTBL:	JP   GETDRV		;return address of disk drive table
?MLTIO:	JP   MULTIO		;set multiple record count for disk I/O
?FLUSH:	JP   FLUSH		;flush BIOS maintained disk caching

?MOV:	JP   ?MOVE		;block move memory to memory
?TIM:	JP   ?TIME		;signal time and date operation
?BNKSL:	JP   BNKSEL		;select bank for code execution and default DMA
?STBNK:	JP   SETBNK		;select different bank
				;for disk I/O DMA operations
?XMOV:	JP   ?XMOVE		;set source and destination banks
				;for one operation

?USER:	JP   ?USERF		;call hardware drivers (user function)
	JP   DUMMY		;reserved for future expansion
	JP   DUMMY


*EJECT
	DSEG			;this part can be banked

BOOT:
;====

;Initial entry point for system startup.
	LD   SP,BOOT$STACK	

	CALL ?INIT		;perform any additional system initialization
				;and print signon message 
	
	LD   BC,16*256+0	;init all 16 logical disk drives
	LD   HL,@DTBL
D$INIT$LOOP:
	PUSH BC			;save remaining count and abs drive
	LD   E,(HL)		;grap @DRV entry
	INC  HL
	LD   D,(HL)
	INC  HL
	LD   A,E		;if null, no drive
	OR   D
	JR   Z,D$INIT$NEXT
	PUSH HL			;save @DRV pointer
	EX   DE,HL		;XDPH address in <HL>
	DEC  HL			;get relative drive code
	DEC  HL
	LD   A,(HL)
	LD   (@RDRV),A
	LD   A,C		;get absolute drive code
	LD   (@ADRV),A
	DEC  HL			;point to init pointer
	LD   D,(HL)		;get init pointer
	DEC  HL
	LD   E,(HL)
	EX   DE,HL		;call init routine
	CALL IPCHL
	POP  HL			;recover @DRV pointer
D$INIT$NEXT:
	POP  BC			;recover counter and drive #
	INC  C			;and loop for each drive
	DEC  B
	JR   NZ,D$INIT$LOOP

	JP   BOOT$1

	CSEG			;following in resident memory

BOOT$1:	CALL SET$JUMPS
	CALL ?LDCCP		;fetch CCP for first time
	JP   CCP


WBOOT:
;=====

;Entry for system restarts.

	LD   SP,BOOT$STACK
	CALL SET$JUMPS		;initialize page zero
	CALL ?RLCCP		;reload CCP
	JP   CCP		;then reset jmp vectors and exit to CCP

SET$JUMPS:
	LD   A,1
	CALL ?BNKSL
	LD   A,0C3H
	LD   (0000H),A		;set up jumps in page zero
	LD   (0005H),A		
	LD   HL,?WBOOT		;BIOS warm start entry
	LD   (0001H),HL
	LD   HL,(@MXTPA)	;BDOS system call entry
	LD   (0006H),HL
	RET

	DEFS 64
BOOT$STACK EQU $


*EJECT
CONST:
;=====

;Console input status. Return true if any selected console input device has an
;available character.

	LD   HL,(@CIVEC)	;get console input vector
	JP   IST$SCAN


CONIN:
;=====

;Console input. Return character from first ready console input device.

	LD   HL,(@CIVEC)
	JR   IN$SCAN


CONOUT:
;======

;Console output. Send character in reg. C to all selected devices.

	LD   HL,(@COVEC)	;fetch console output bit vector
	JR   OUT$SCAN


LIST:
;====

;List output. Send character in reg. C to all selected devices.

	LD   HL,(@LOVEC)	;fetch list output bit vector

OUT$SCAN:
	LD   B,0 		;start with device 0 
CO$NEXT:ADD  HL,HL		;shift out next bit
	JR   NC,NO$OUT$DEVICE
	PUSH HL			;save the vector
	PUSH BC			;save the count and character
NOT$OUT$READY:
	CALL COSTER
	OR   A
	JR   Z,NOT$OUT$READY
	POP  BC			;restore and resave the character and device
	PUSH BC
	CALL ?CO		;if device selected, print it
	POP  BC			;recover count and character
	POP  HL			;recover the rest of the vector
NO$OUT$DEVICE:
	INC  B			;next device number
	LD   A,H		;see if any devices left
	OR   L
	JR   NZ,CO$NEXT		;and go find them ...
	RET


AUXOUT:
;======

;Auxiliary output. Send character in reg. C to all selected devices.

	LD   HL,(@AOVEC)	;fetch aux output bit vector
	JR   OUT$SCAN


AUXIN:
;=====

;Auxiliary input. Return character from first ready auxiliary input device.

	LD   HL,(@AIVEC)

IN$SCAN:PUSH HL			;save bit vector
	LD   B,0 
CI$NEXT:ADD  HL,HL		;shift out next bit
	LD   A,0		;insure zero a (nonexistent device not ready)
	CALL C,CISTL		;see if the device has a character
	OR   A
	JR   NZ,CI$RDY		;this device has a character
	INC  B			;else, next device
	LD   A,H		;see if any more devices
	OR   L
	JR   NZ,CI$NEXT		;go look at them
	POP  HL			;recover bit vector
	JR   IN$SCAN		;loop til we find a character
CI$RDY:	POP  HL			;discard extra stack
	JP   ?CI


*EJECT
;Utility subroutines

IPCHL:	JP   (HL)		;vectored CALL point

;print message (^ in reg. HL) up to a null
?PMSG:	PUSH BC			;saves reg. BC & reg. DE
	PUSH DE
PMSG$LOOP:
	LD   A,(HL)
	OR   A
	JR   Z,PMSG$EXIT
	LD   C,A
	PUSH HL
	CALL ?CONO
	POP  HL
	INC  HL
	JR   PMSG$LOOP
PMSG$EXIT:
	POP  DE
	POP  BC
	RET

;print binary number 0-65535 from reg. HL
?PDEC:	LD   BC,TABLE10
	LD   DE,-10000
NEXT:	LD   A,'0'-1
PDEC1:	PUSH HL
	INC  A
	ADD  HL,DE
	JR   NC,STOPLOOP
	INC  SP
	INC  SP
	JR   PDEC1
STOPLOOP:
	PUSH DE
	PUSH BC
	LD   C,A
	CALL ?CONO
	POP  BC
	POP  DE
NEXTDIGIT:
	POP  HL
	LD   A,(BC)
	LD   E,A
	INC  BC
	LD   A,(BC)
	LD   D,A
	INC  BC
	LD   A,E
	OR   D
	JR   NZ,NEXT
	RET
TABLE10:DEFW -1000,-100,-10,-1,0

?PDERR:	LD   HL,DRIVE$MSG	;error header
	CALL ?PMSG
	LD   A,(@ADRV)		;drive code
	ADD  A,'A'
	LD   C,A
	CALL ?CONO
	LD   HL,TRACK$MSG	;track header
	CALL ?PMSG
	LD   HL,(@TRK)		;track number
	CALL ?PDEC
	LD   HL,SECTOR$MSG	;sector header
	CALL ?PMSG
	LD   HL,(@SECT)		;sector number
	JR   ?PDEC
	
	
XOFFLIST:
	DEFB -1,-1,-1,-1	;CTL-S clears to zero
	DEFB -1,-1,-1,-1	
	DEFB -1,-1,-1,-1	
	DEFB -1,-1,-1,-1	


*EJECT
	DSEG			;following resides in banked memory

HOME:
;====

;Home selected drive. Treated as SETTRK (0).

	LD   BC,0		;same as set track zero
	JR   SETTRK


SELDSK:
;======

;Select disk drive. Drive code in reg. C. Invoke login procedure for drive if
;this is first select. Return address of disk parameter header in reg. HL.

	LD   A,C		;save drive select code
	LD   (@ADRV),A
	LD   L,C		;create index from drive code
	LD   H,0		
	ADD  HL,HL
	LD   BC,@DTBL		;get pointer to dispatch table
	ADD  HL,BC
	LD   A,(HL)		;point at disk descriptor
	INC  HL
	LD   H,(HL)
	LD   L,A
	OR   H			;if no entry in table, no disk
	RET  Z
	LD   A,E		;examine login bit
	AND  1
	JR   NZ,NOT$FIRST$SELECT
	PUSH HL			;put pointer in stack & <HL>
	EX   DE,HL
	LD   HL,-2		;get relative drive
	ADD  HL,DE
	LD   A,(HL)
	LD   (@RDRV),A
	LD   HL,-6		;find LOGIN addr
	ADD  HL,DE
	LD   A,(HL)		;get address of LOGIN routine
	INC  HL
	LD   H,(HL)
	LD   L,A
	CALL IPCHL		;call LOGIN
	POP  HL			;recover DPH pointer
NOT$FIRST$SELECT:
	RET


SETTRK:
;======

;Set track. Saves track address from reg. BC in @TRK for further operations.

	LD   (@TRK),BC
	RET


SETSEC:
;======

;Set sector. Saves sector number from reg. BC in @SECT for further operations.

	LD   (@SECT),BC
	RET


SETDMA:
;======

;Set disk memory address. Saves DMA address from reg. BC in @DMA.

	LD   (@DMA),BC
	RET


READ:
;====

;Read physical record from currently selected drive. Finds address of proper
;read routine from extended disk parameter header (XDPH).

	LD   HL,(@ADRV)		;get drive code and double it
	LD   H,0
	ADD  HL,HL
	LD   DE,@DTBL		;make address of table entry
	ADD  HL,DE
	LD   A,(HL)		;fetch table entry
	INC  HL
	LD   H,(HL)
	LD   L,A
	PUSH HL			;save address of table
	LD   DE,-8		;point to read routine address
	ADD  HL,DE
	JR   RW$COMMON		;use common code


WRITE:
;=====

;Write physical sector from currently selected drive. Finds address of proper
;write routine from extended disk parameter header (XDPH).

	LD   HL,(@ADRV)		;get drive code and double it
	LD   H,0
	ADD  HL,HL
	LD   DE,@DTBL		;make address of table entry
	ADD  HL,DE
	LD   A,(HL)		;fetch table entry
	INC  HL
	LD   H,(HL)
	LD   L,A
	PUSH HL			;save address of table
	LD   DE,-10		;point to write routine address
	ADD  HL,DE

RW$COMMON:
	LD   A,(HL)		;get address of routine
	INC  HL
	LD   H,(HL)
	LD   L,A
	POP  DE			;recover address of table
	DEC  DE			;point to relative drive
	DEC  DE
	LD   A,(DE)		;get relative drive code and post it
	LD   (@RDRV),A
	JP   (HL)		;leap to driver


*EJECT
	CSEG

LISTST:
;======

;List output status. Return true if all selected list output devices are ready.

	LD   HL,(@LOVEC)	;get list output bit vector

OST$SCAN:
	LD   B,0 		;start with device 15
COS$NEXT:
	ADD  HL,HL		;check next bit
	PUSH HL			;save the vector
	PUSH BC			;save the count
	LD   A,0FFH		;assume device ready
	CALL C,COSTER		;check status for this device
	POP  BC			;recover count
	POP  HL			;recover bit vector
	OR   A			;see if device ready
	RET  Z			;if any not ready, return false
	INC  B			;drop device number
	LD   A,H		;see if any more selected devices
	OR   L
	JR   NZ,COS$NEXT
	LD   A,0FFH		;all selected were ready, return true
	RET

;check for output device ready, including optional XON/XOFF support 
COSTER:	LD   L,B		;make device code 16 bits
	LD   H,0
	PUSH HL			;make it in stack
	ADD  HL,HL		;create offset into device characteristics tbl
	ADD  HL,HL
	ADD  HL,HL
	LD   DE,@CTBL+6		;make address of mode byte
	ADD  HL,DE
	LD   A,(HL)
	AND  MB$XON$XOFF
	POP  HL			;recover console number in reg. HL
	JP   Z,?COST		;not a XON device, go get output status direct
	LD   DE,XOFFLIST	;make pointer to proper XON/XOFF flag
	ADD  HL,DE
	CALL CISTL		;see if this keyboard has character
	LD   A,(HL)		;get flag or read key if any
	CALL NZ,CIL
	CP   DC1		;if its a CTL-Q,
	JR   NZ,NOT$Q
	LD   A,0FFH		;set the flag ready
NOT$Q:	CP   DC3		;if its a CTL-S,
	JR   NZ,NOT$S
	XOR  A			;clear the flag
NOT$S:	LD   (HL),A		;save the flag
	CALL COSTL		;get the actual output status
	AND  (HL)		;and mask with CTL-Q/CTL-S flag
	RET			;return this as the status

CISTL:	PUSH BC			;get input status with regs. BC and HL saved
	PUSH HL
	CALL ?CIST
	POP  HL
	POP  BC
	OR   A
	RET

COSTL:	PUSH BC			;get output status, saving reg. BC & reg. HL
	PUSH HL
	CALL ?COST
	POP  HL
	POP  BC
	OR   A
	RET

CIL:	PUSH BC			;get input, saving reg. BC & reg. HL
	PUSH HL
	CALL ?CI
	POP  HL
	POP  BC
	RET


*EJECT
	DSEG

SECTRN:
;======

;Sector translate. Indexes skew table in reg. DE with sector in reg. BC.
;Returns physical sector in reg. HL. If no skew table (reg. DE = 0) then
;returns physical = logical.

	LD   L,C
	LD   H,B
	LD   A,D
	OR   E
	RET  Z
	EX   DE,HL
	ADD  HL,BC
	LD   L,(HL)
	LD   H,0
	RET


*EJECT
	CSEG

CONOST:
;======

;Console output status. Return true if all selected console output devices are
;ready.

	LD   HL,(@COVEC)	;get console output bit vector
	JR   OST$SCAN


AUXIST:
;======

;Auxiliary input status. Return true if any selected auxiliary input device has
;an available character.

	LD   HL,(@AIVEC)	;get aux input bit vector

IST$SCAN:
	LD   B,0 		;start with device 15
CIS$NEXT:
	ADD  HL,HL		;check next bit
	LD   A,0		;assume device not ready
	CALL C,CISTL		;check status for this device
	OR   A			;if any ready, return true
	RET  NZ
	INC  B			;drop device number
	LD   A,H		;see if any more selected devices
	OR   L
	JR   NZ,CIS$NEXT
	XOR  A			;all selected devices were not ready,
	RET			;return false


AUXOST:
;======

;Auxiliary output status. Return true if all selected auxiliary output devices
;are ready.

	LD   HL,(@AOVEC)	;get aux output bit vector
	JP   OST$SCAN


DEVTBL:
;======

;Return address of character device table.

	LD   HL,@CTBL
	RET


*EJECT
GETDRV:
;======

;Return address of drive table.

	LD   HL,@DTBL


MULTIO:
;======

;Set multiple sector count (not implemented).

DUMMY:	RET


	DSEG

FLUSH:
;=====

;BIOS deblocking buffer flush. Not implemented.

	XOR  A			;return with no error
	RET


*EJECT
	CSEG

BNKSEL:
;======

;Bank select. Select CPU bank for further execution.

	LD   (@CBNK),A		;remember current bank
	JP   ?BANK		;and go exit through users 
				;physical bank select routine
  

	DSEG

SETBNK:
;======

;Set disk memory bank. Saves bank number in @DBNK for future disk data
;transfers.

	LD   (@DBNK),A
	RET 	


;error message components:
DRIVE$MSG:
	DEFB ESC,'E',BEL
	DEFM 'BIOS Error on '
	DEFB 0
TRACK$MSG:
	DEFM ': T-'
	DEFB 0
SECTOR$MSG:
	DEFM ', S-'
	DEFB 0


@ADRV:	DEFS 1			;currently selected disk drive
@RDRV:	DEFS 1			;controller relative disk drive
@TRK:	DEFS 2			;current track number
@SECT:	DEFS 2			;current sector number
@DMA:	DEFS 2			;current DMA address
@DBNK:	DEFB 0			;bank for DMA operations

	CSEG			;common memory

@CBNK:	DEFB 0			;bank for processor operations

	END
 	;return with no error
	RET


*EJECT
	CSEG

BNKSEL:
;======

;Bank select. Select CPU bank for further execution.

	LD   (@CBNK),A		;remember current bank
	JP   ?BANK		;and go exit through users 
				;physical bank select routine
  

	DSEG

SETBNK:
;======

;Set disk memory bank. Saves bank number in @DBNK for future disk data
;transfers.

	LD   (@DBNK),A
	         ;jump to error exit
        BIT  0,A                ;seek done ?
        JR   NZ,TRKS12          ;no, loop
        LD   BC,4000            ;load delay counter
        CALL DELAY              ;15 msec head settle delay
        IN   A,($FDTRK)         ;get current track
        LD   (IX+5),A           ;store in drive's DCT
        JP   TRKSEC             ;check track # again

;motor on / head load time:
WAITEN: LD   A,(DRIVE)          ;get drive #
        LD   HL,OLDDRV          ;^previous drive # --> reg. HL
        CP   (HL)               ;new drive # same as old drive # ?
        LD   (HL),A             ;store new drive #
        LD   A,(OLDSTAT)        ;get old FDC status
        RLCA                    ;drive rotating already
        JR   C,WAITE2           ;jump to motor on delay loop, if not
        JR   Z,WAITE6           ;jump if same drive #
WAITE1: LD   HL,50              ;50 msec head load time
        JR   WAITE3
WAITE2: BIT  7,(IX)             ;8 inch drive
        JR;******************************************************************************
;*  B O O T  *  C P M S Y S 4 b  *  T h o m a s   H o l t e   *  8 5 1 0 2 5  *
;******************************************************************************
;*									      *
;*  	 B O O T   L O A D E R   M O D U L E   F O R   C P / M   3 . 0	      *
;*       =============================================================        *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	TITLE 'BOOT LOADER MODULE FOR CP/M 3.0'

;ASCII control codes
BEL	EQU  07H		;bell
LF	EQU  0AH		;line feed
CR	EQU  0DH		;carriage return
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape
RS	EQU  1EH		;record separator

        GLOBAL ?INIT,?LDCCP,?RLCCP,?TIME
	EXTERNAL ?PMSG,?CONIN,?USERF
	EXTERNAL @CIVEC,@COVEC,@AIVEC,@AOVEC,@LOVEC
	EXTERNAL @DATE,@HOUR,@MIN

BDOS	EQU  0005H

	DSEG			;init done from banked memory

?INIT:  LD   HL,8000H           ;assign console to CRT 
        LD   (@CIVEC),HL
        LD   (@COVEC),HL
	LD   HL,4000H		;assign printer to LPT1
        LD   (@LOVEC),HL
        LD   HL,1000H           ;assign AUX to TTY1
        LD   (@AIVEC),HL
        LD   (@AOVEC),HL
	LD   HL,SIGNON$MSG	;print signon message
	JP   ?PMSG


	CSEG			;boot loading must be done from resident memory

;This version of the boot loader loads the CCP from a file called CCP.COM on
;the system drive (A:).

;First time, load the A:CCP.COM file into TPA
?LDCCP:	XOR  A                  ;zero extent
	LD   (CCP$FCB+15),A
	LD   HL,0               ;start at beginning of file
	LD   (FCB$NR),HL
     	LD   DE,CCP$FCB		;open file containing CCP
        CALL OPEN
	INC  A                  ;error if no file ...
	JR   Z,NO$CCP
	LD   DE,0100H 		;start of TPA
	CALL SETDMA
	LD   DE,128  		;allow up to 16k bytes
	CALL SETMULTI
	LD   DE,CCP$FCB		;load the thing
	CALL READ		;now, copy CCP to secret bank for reloading

;move copy of CCP into secret bank:
	LD   HL,0100H		;source      address --> reg. HL
	LD   DE,3500H		;destination address --> reg. DE
     	LD   B,25		;record count        --> reg. B
LDLOOP: PUSH BC			;save record count
	LD   A,10H		;source      bank = 1
        			;destination bank = 0
	LD   BC,128 SHL 8+15	;byte count --> reg. B
	          		;function # --> reg. C
	CALL ?USERF		;move CCP record
	LD   BC,128		;record length --> reg. BC
	ADD  HL,BC		;bump source address
	EX   DE,HL
	ADD  HL,BC		;bump destination address
	EX   DE,HL
	POP  BC			;restore record count
	DJNZ LDLOOP		;move next record	
	RET			;return to caller
	
;here if we couldn't find the file:
NO$CCP:	LD   HL,CCP$MSG		;report this ...
	CALL ?PMSG
	CALL ?CONIN		;get response
	JR   ?LDCCP		;and try again

;reload CCP:
?RLCCP:	LD   HL,3500H		;source      address --> reg. HL
	LD   DE,0100H		;destination address --> reg. DE
     	LD   B,25		;record count        --> reg. B
RLLOOP: PUSH BC			;save record count
	LD   A,01H		;source      bank = 0
        			;destination bank = 1
	LD   BC,128 SHL 8+15	;byte count --> reg. B
	          		;function # --> reg. C
	CALL ?USERF		;move CCP record
	LD   BC,128		;record length --> reg. BC
	ADD  HL,BC		;bump source address
	EX   DE,HL
	ADD  HL,BC		;bump destination address
	EX   DE,HL
	POP  BC			;restore record count
	DJNZ RLLOOP		;move next record	
	RET			;return to caller
	

*EJECT
;External clock.
?TIME:	PUSH HL			;save reg. HL & DE
	PUSH DE
        INC  C  		;time get/set flag ?
	JR   Z,SET$TIM		;set time
	LD   HL,@DATE		;^(time & date buffer) --> reg. HL
	LD   C,18		;function # 	       --> reg. C
	JR   GET$TIM		;get time & date and return to caller
SET$TIM:LD   HL,(@DATE)		;date		       --> reg. HL
	LD   A,(@HOUR)		;hours		       --> reg. D
	LD   D,A
	LD   A,(@MIN)		;minutes	       --> reg. E
	LD   E,A
	LD   C,19 		;function #	       --> reg. C
GET$TIM:CALL ?USERF		;set time & date and return to caller
	POP  DE			;restore reg. HL & DE
	POP  HL
	RET


;CP/M BDOS function interfaces
OPEN:	LD   C,15		;open file control block
	JP   BDOS
SETDMA:	LD   C,26		;set data transfer address
	JP   BDOS
SETMULTI:
	LD   C,44		;set record count
	JP   BDOS
READ:	LD   C,20		;read records
	JP   BDOS
	

*EJECT
SIGNON$MSG:
        DEFB CR,LF,LF,LF,LF,LF,LF,LF,LF,RS,ESC,'R'
	DEFM ' C P / M   V e r s i o n   3 '
	DEFB ESC,'S',CR,LF,LF
	DEFM 'GENIE IIIs SYSTEM (+ 10.4 MBytes Winchester)'
	DEFB CR,LF
	DEFM 'Version b of BIOS (851122)'
	DEFB CR,LF
	DEFM 'Thomas Holte '
	DEFB 98H
	DEFM ' 1985'
	DEFB CR,LF,LF,LF,LF,LF,LF,LF,LF,LF,LF,LF,LF,0
ENDMSG	EQU  $

CCP$MSG:DEFB CR,LF,CR,LF
	DEFM 'BIOS Err on A: No CCP.COM file'
	DEFB 0

CCP$FCB:DEFB 1
	DEFM 'CCP     COM'
	REPT 20
	DEFB 0
	ENDM

FCB$NR:	DEFB 0,0,0

	END
 C,19 		;function #	       --> reg. C
GET$TIM:CALL ?USERF		;set time & date and return to caller
	POP  DE			;restore reg. HL &LD   L,A
	ADD  HL,DE
	LD   DE,ATIMBUF		;^ASCII buffer 	       --> reg. DE	
	LD   BC,3		;length of table entry --> reg. BC
	LDIR			;move weekday into ASCII buffer
	INC  DE			;bump buffer ptr over space

	LD   A,(IX+2)		;month (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+3)		;month (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		Љ
	LD   A,(IX+4)		;day (tenths) --> accu
	AND  '3'		;mask leapyear bit
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+5)		;day (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX)		;year (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+1)		;year (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over space		

	LD   A,(IX+7)		;hours (tenths) --> accu
	AND  '3'		;mask format bit 
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+8)		;hours (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE;******************************************************************************
;*  B O O T E R  *  C P M S Y S 2  *  T h o m a s   H o l t e  *  8 5 1 1 2 0 *
;******************************************************************************
;*									      *
;*    B O O T S T R A P   L O A D E R   F O R   C P / M   3   O N   T H E     *
;*    ===================================================================     *
;*									      *
;*        G E N I E  I I I s   M I C R O C O M P U T E R   S Y S T E M        *
;*	  ============================================================        *
;*									      *
;*									      *
;*  Thomas Holte			                         Version 1.1  *
;*									      *
;******************************************************************************
  
	.Z80

	ASEG
	ORG  0000H
	.PHASE 0FC00H

;load CP/M-system:
SECLEN	EQU  512		;length of a disk sector
$BUZZ	EQU  3860H		;buzzer address
$SYS0	EQU  0F9H		;port of system byte 0
$SYS1	EQU  0FAH		;port of system byte 1

	DI			;disable interrupts
	IM   1
	LD   SP,0FC00H		;init stackpointer

;clear screen:
	LD   A,00000001B	;enable bank 0
				;disable character RAM
	OUT  ($SYS0),A		;write system byte 0
	LD   A,01010100B	;enable memory mapped I/O
				;disable graphic display
				;disable boot EPROM
				;disable graphic page
				;enable full screen
				;disable video display
	OUT  ($SYS1),A		;write system byte 1

	.XLIST
	.XCREF

	DEFB 0DDH,2EH,7		;LD LX,7     length of serial # --> reg. LX
	LD   HL,3CB7H		;location of displayed serial # --> reg. HL
	LD   DE,SERNO		;save location			--> reg. DE
MOVE:	LD   A,(HL)		;get first byte of serial #
	LD   (DE),A 		;store it
	INC  HL			;inc ^source 
	INC  DE			;inc ^destination
	DEFB 0DDH,2DH		;DEC LX      dec counter
	JR   NZ,MOVE		;get next byte

	.CREF
	.LIST

	LD   HL,3800H
	LD   DE,3801H
	LD   BC,7FFH
	LD   (HL),' '
	LDIR
	LD   A,11000101B	;disable memory mapped I/O
				;disable graphic display
				;disable boot EPROM
				;disable graphic page
				;enable keyboard
				;enable video display
	OUT  ($SYS1),A		;write system byte 1

;read first two tracks:
	LD   B,34              	;sector counter	        --> reg. B
LOOP: 	PUSH BC        		;save it
	CALL RDSEC 		;read selected sector into main memory
	OR   A			;disk error ?
	JP   NZ,ERROR
	LD   HL,(BUFFER)
	LD   BC,SECLEN
	ADD  HL,BC		;calc new load address
	LD   (BUFFER),HL
	LD   A,(SECTOR)
	INC  A			;increment sector #
	CP   20			;track exhausted ?
	JR   NZ,NXTSEC		;jump if not
	CALL STEPIN		;step in one track
	XOR  A			;reset sector #	
NXTSEC: LD   (SECTOR),A		;store sector #
	POP  BC			;restore sector counter
     	DJNZ LOOP		;read next sector

;move common code to the right place:
	LD   HL,3505H          	;source address      --> reg. HL
	LD   DE,0FE05H		;destination address --> reg. DE
	LD   BC,1FBH            ;byte count	     --> reg. BC	
	LDIR

;move CP/M loader to the right place:
	LD   HL,3700H          	;source address      --> reg. HL
	LD   DE,4400H		;destination address --> reg. DE
	LD   BC,0C80H           ;byte count	     --> reg. BC	
	LDIR
	JP   4400H		;jump into CP/M loader


*EJECT
;micro disk driver:

;FDC registers:
$FDSEL  EQU  0E0H               ;FDC select  register
$FDCMD  EQU  0ECH               ;FDC command register
$FDSTAT EQU  0ECH               ;FDC status  register
$FDSEC  EQU  0EEH               ;FDC sector  register
$FDDATA EQU  0EFH               ;FDC data    register

;FDC commands:
$STPIN	EQU  54H		;step in one track
$RDSEC  EQU  88H                ;read sector
$FCINT  EQU  0D0H               ;force interrupt


RDSEC:  LD   A,$FCINT           ;force interrupt
        OUT  ($FDCMD),A         ;reset FDC
        LD   A,(SECTOR)         ;sector #       	 --> accu
        CP   10                 ;front or back side ?
        LD   A,1                ;select code for drive 0 --> accu
        JR   C,SELECT           ;jump if front side
        SET  4,A                ;set side select bit
SELECT: OUT  ($FDSEL),A         ;select drive and side
	LD   A,$FCINT		;force interrupt
	OUT  ($FDCMD),A
	LD   A,(SECTOR)		;sector # --> accu
	CP   10			;back side ?
	JR   C,SETSEC		;jump if front side
	SUB  10			;adjust sector # 
SETSEC: OUT  ($FDSEC),A         ;store sector # in FDC reg
        LD   HL,(BUFFER)        ;get buffer pointer
        LD   A,$RDSEC        	;issue "read" command
	OUT  ($FDCMD),A
        LD   BC,12              ;56 usec delay
        CALL DELAY
        LD   C,$FDDATA          ;data register
READ1:	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,READ2           ;yes, get byte
        BIT  0,A                ;full sector transferred ?
        JR   Z,STATUS           ;yes, go end process
	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,READ2           ;yes, get byte
        BIT  7,A                ;drive not ready ?
        JR   Z,READ1            ;no loop
        RET                     ;return with error
READ2:  INI                     ;read char
        JR   READ1
STATUS: IN   A,($FDSTAT)        ;get FDC status
        AND  1CH                ;any errors ?
        RET

STEPIN: LD   A,$STPIN		;step in one track
	OUT  ($FDCMD),A
       	PUSH BC			;save reg. BC
        LD   BC,5               ;24 usec delay
        CALL DELAY
	POP  BC			;restore reg. BC
STEPIN1:IN   A,($FDSTAT)	;get FDC status
	BIT  0,A		;busy ?
	JR   NZ,STEPIN1		;jump if yes
	RET

DELAY:	DEC  BC			;decrement cycle count
	LD   A,B		;test if count zero
	OR   C			;combine LSB/MSB of count
	JR   NZ,DELAY		;loop until delay count exhausted
	RET			;rtn to caller


SECTOR:	DEFB 1			;current sector #
BUFFER:	DEFW 0000               ;current load address


*EJECT
ERROR:	LD   A,11000100B	;enable memory mapped I/O
	OUT  ($SYS1),A		;write system byte 1

	LD   HL,MSG		;^message		--> reg. HL	
        LD   DE,3C00H		;^first screen position --> reg. DE
	LD   BC,COPYRGT-MSG	;length of message	--> reg. BC
	LDIR			;output error message
	LD   B,100		;beep counter  --> reg. B
ALARM:	PUSH BC			;save counter

	LD   BC,0     		;repeat counter --> reg. B
                                ;  wait counter --> reg. C
BEEP:	LD   A,($BUZZ)		;turn on buzzer
	PUSH BC			;save base value of wait counter
BUZZON:	NOP			;little delay for lower frequency
	NOP
	NOP
	DEC  C			;decrement wait counter
	JR   NZ,BUZZON		;wait `til end of buzz
	POP  BC			;restore wait counter
	DJNZ BEEP		;turn on buzzer eleven times
	
	LD   BC,8000
        CALL DELAY

	POP  BC			;restore beep counter
	DJNZ ALARM		;beep 100 times
	JR   $			;hang up		

MSG:	DEFM 'DISK ERROR'

COPYRGT:DEFM 'Enhanced BIOS written by Thomas Holte  (c) 1985'
SERNO:	DEFS 7			;serial number field
	.DEPHASE


*EJECT
	ORG  01E0H

LDRBYTE:DEFB 2


	END
	--> reg. HL	
        LD   DE,3C00H		;^first screen position --> reg. DE
	LD   BC,COPYRGT-MSG	;length of message	--> reg. BC
,DE		;store track #
	LD   A,B       		;sector # --> accu
	CP   (IX+4)		;legal sector # ?
	JR   C,INITW		;jump if yes
	LD   A,-3		;error code 3 --> accu
	RET

;actual I/O handler:		
INITW:	LD   (SECTOR),A		;store sector #Љ

*EJECT
	COND SASI		;Xebec part

	LD   A,(OLDW)		;number of previously accessed drive --> reg. C
	LD   C,A
	OR   A			;no drive previously accessed ?
	JP   P,INITW1		;select controller
	OUT  (WPORT1),A		;reset controller
INITW1:	LD   A,(DRIVE)		;drive # --> accu
	LD   (OLDW),A		;save it
	CP   C			;same as old drive ?
	JR   Z,INITW2 		;no drive selection needed if yes

;select Winchester drive:
       	LD   IY,WPARS		;^Winchster parameters --> reg. IY
	LD   H,(IX+6)		;track count --> reg. HL
	LD   L,(IX+5)
	LD   D,0   		;clear MSB of divisor
    	LD   E,(IX)  		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	LD   (IY+2),E		;load head count
	CALL DIV		;calc cylinder count
	LD   (IY),H		;load cylinder count
	LD   (IY+1),L
	LD   (IY+3),H		;load starM80
<=BOOTER
<=DRIVER
<=LDRBIOS
<

L80 BOOTER/N,BOOTER/E
<N
L80 DRIVER/N,DRIVER/E
<N

LINK CPMLDR[L4400,NR]=CPMLDR,LDRBIOS

ERA BOOTER.REL
ERA DRIVER.REL
ERA LDRBIOS.REL
ERA $$TEMP$$

T80
<LOAD BOOTER 1000
<LOAD DRIVER 1200
<LOAD CPMLDR 4900
<A 49A8
<JR 49A8
<
<A 4C23
<JR 4C23
<
<SAVE $$TEMP$$. 100 557F
<BYE

ERA BOOTER.COM
ERA DRIVER.COM
ERA CPMLDR.COM

COPYSYS $$TEMP$$
<B
<Nain
	AND  IOMASK+CDMASK+REQMASK	
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,SELDRV1		;jump if data transfer finished
	CP   REQMASK
	JR   NZ,SELDRV 		;wait for request
	OTIR			;load disk parameters
	JR   SELDRV

SELDRV1:CALL GETSTAT		;get error status
	JR   NZ,ERREXIT		;any errors ?

INITW2:	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,RWINI		;jump if yes

;restore drive heads:
RESTOW:	LD   A,$TSTDRV		;test drive readyЉ	CALL TASKOUT
	CALL GETSTAT		;get error status
	JR   NZ,RESTOW		;retry if drive not ready
        LD   A,$REST  		;recalibrate drive
	CALL TASKOUT
	CALL GETSTAT		;get error status
	JR   NZ,ERREXIT		;any errors ?
      	SET  0,(IX+1)		;set init bit in WCT


*EJECT
	ELSE			;WD1002 part

	EX   DE,HL		;track #  --> reg. HL
	LD   D,0   		;clear MSB of divisor
    	LD   E,(IX)  		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	CALL DIV		;cylinder # = track # / head count (HL)
				;surface #  = track # % head count (DE)
	LD   A,(DRIVE)		;drive # --> accu
	ADD  A,A		;shift drive # 3 bits left
	ADD  A,A
	ADD  A,A
	ADD  A,E		;add surface #
	LD   E,A		;and save it
	LD   A,(IX+1)		;get sector length bits
	RRA
	AND  60H		;mask sector length bits
	ADD  A,E		;add surface # and drive #
	OR   80H		;set ECC error correction bit
	LD   E,A		;save drive select bits
	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,TRKSEW 		;yes, skip init process

;restore drive heads:
RESTOW:	IN   A,($STATUS)	;read WDC status
	AND  0C0H		;mask it
	CP   40H		;busy ?
	JR   ;******************************************************************************
;*  C H A R I O  *  C P M S Y S 4 c  *  T h o m a s   H o l t e * 8 5 0 7 1 7 *
;******************************************************************************
;*									      *
;*    C H A R A C T E R   I / O   H A N D L E R   F O R   Z 8 0   C H I P     *
;*    ===================================================================     *
;*									      *
;*  	       		    B A S E D   S Y S T E M			      *
;*	                    =======================              	      *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	TITLE 'CHARACTER I/O HANDLER FOR Z80 CHIP BASED SYSTEMS'

;Character I/O for the modular CP/M 3 BIOS

;ASCII control code
SUB	EQU  1AH		;substitute

	INCLUDE MODEBAUD	;define mode bits and baud equates

	GLOBAL ?CINIT,?CI,?CO,?CIST,?COST,@CTBL
	EXTERNAL ?USERF

MAX$DEVICES EQU 5


	CSEG

?CINIT: LD   A,C		
	CP   MAX$DEVICES
	RET  NC			;illegal device
        SUB  2          	;RS232C interface ?
	RET  C 			;no initializing
	RET  Z
	DEC  A
	LD   B,A		;number of RS232C interface --> reg. B
	LD   L,C		;make 16 bits from device number
	LD   H,0
	ADD  HL,HL		;* 8
	ADD  HL,HL
	ADD  HL,HL
	LD   DE,@CTBL+7		;get baud rate
	ADD  HL,DE
	LD   L,(HL)
	LD   H,0		;get baud rate	
        LD   DE,SPEED$TABLE     ;point to counter entry
        ADD  HL,DE
        LD   E,(HL)             ;get baud rate factor
	LD   A,11000100B        ;load data format
	LD   C,1       		;function # --> reg. C
        JP   ?USERF		;init RS232C interface and return to caller

;character input
?CI:	LD   A,B
	OR   A
	JR   Z,CON$IN		;jump to console input
	DEC  A
	JR   Z,NULL$INPUT	;can't read from centronics
	DEC  A
	JR   Z,NULL$INPUT      	;can't read from centronics
	DEC  A
	JR   NZ,RS$1IN
	LD   B,A		;RS232C interface 0
	JR   TTY$IN 
RS$1IN:	DEC  A
	JR   NZ,NULL$INPUT
	LD   B,1		;RS232C interface 1
TTY$IN:	LD   C,8		;function # --> reg. C
	JP   ?USERF		;receive char from RS232C interface 
CON$IN: LD   C,3                ;function # --> reg. C
	JP   ?USERF           	;wait for keyboard character

NULL$INPUT:
	LD   A,SUB		;return a CTL-Z for no device
	RET


;character input status
?CIST:  LD   A,B
	OR   A
	JR   Z,CON$ST		;jump to console input status
        DEC  A
	JR   Z,NULL$STATUS      ;can't read from centronics
	DEC  A
	JR   Z,NULL$STATUS      ;can't read from centronics
	DEC  A
	JR   NZ,RS$1IST
	LD   B,A		;RS232C interface 0
	JR   TTY$IST
RS$1IST:DEC  A
	JR   NZ,NULL$STATUS
	LD   B,1		;RS232C interface 1
TTY$IST:LD   C,7		;function # --> reg. C
	JR   CON$ST+2
CON$ST:	LD   C,2		;function # --> reg. C
        CALL ?USERF		;check input status
	OR   A			;char ready
	RET  Z
STAT$OK:LD   A,0FFH
	RET

NULL$STATUS:
        XOR  A
	RET


;character output
?CO:	LD   A,B
        OR   A
        LD   A,C		;char --> accu
	JR   Z,CON$OUT		;jump to console output
        DEC  B
	JR   Z,LST$OUT 		;parallel printer 0
        DEC  B
	JR   NZ,RS$0OUT
	INC  B			;parallel printer 1
	JR   LST$OUT
RS$0OUT:DEC  B
	JR   Z,TTY$OUT		;RS232C interface 0
	DEC  B
	RET  NZ
	INC  B			;RS232C interface 1
TTY$OUT:LD   C,10		;function # --> reg. C
       	JP   ?USERF             ;transmit char to RS232C interface
CON$OUT:LD   C,4  		;function # --> reg. C
      	JP   ?USERF		;display char
LST$OUT:LD   C,6                ;function # --> reg. C
      	JP   ?USERF		;output char to printer


;character output status
?COST:  LD   A,B
        OR   A
        JR   Z,STAT$OK
        DEC  A
        JR   NZ,PR$1ST		;jump to list status
	LD   B,A		;parallel printer 0
	JR   LST$ST
PR$1ST: DEC  A
	JR   NZ,RS$0OST
	LD   B,1		;parallel printer 1
	JR   LST$ST
RS$0OST:DEC  A
	JR   NZ,RS$1OST
	LD   B,A		;RS232C interface 0
	JR   TTY$OST
RS$1OST:DEC  A
	JR   NZ,NULL$STATUS
	LD   B,1		;RS232C interface 1
TTY$OST:LD   C,9		;function # --> reg. C
       	JR   LST$ST+2
LST$ST:	LD   C,5		;function # --> reg. C
        CALL ?USERF		;check output status
        OR   A			;ok ?
        JR   NZ,NULL$STATUS
	JR   STAT$OK


*EJECT
@CTBL:  DEFM 'CRT   '		;device 0, CRT
	DEFB MB$IN$OUT
        DEFB BAUDNONE
	DEFM 'LPT1  '		;device 1, LPT1
	DEFB MB$OUTPUT
	DEFB BAUDNONE
	DEFM 'LPT2  '		;device 2, LPT2
	DEFB MB$OUTPUT
	DEFB BAUDNONE
        DEFB 'TTY1  '		;device 3, TTY1
	DEFB MB$IN$OUT+MB$SERIAL+MB$SOFT$BAUD
	DEFB BAUD9600
        DEFB 'TTY2  '		;device 4, TTY2
	DEFB MB$IN$OUT+MB$SERIAL+MB$SOFT$BAUD
	DEFB BAUD9600
	DEFB 0			;table terminator

SPEED$TABLE:
	DEFB 0,2,3,15,4,14,13,6,11,10,7,0,9,0,8,0

	END

PR$1ST: DEC  A
	JR   NZ,RS$0OST
	LD   B,1		;parallel printer 1
	JR   LST$ST
RS$0OST:DEC  A
	JR   NZ,RS$1OST
	LD   B,A		;RS232C interface 0
	JR   TTY$OST
RS$1OST:DEC  A
	JR   NZ,NULL$STATUS
	LD   B,1		;RS232C interface 1
TTY$OST:LD   C,9		;functentry: HL = pointer to a 5 byte buffer containing on exit
;	     date and time in the form DDDDHHMMSS
Љ;	      DDDD = number of days since January 1st, 1978 (binary    )
;		HH = hours   				    (BCD format)
;		MM = minutes 				    (BCD format)
;		SS = seconds 				    (BCD format)

;get time & date in CP/M 3 format (software clock):
$GTIME3S:
	EX   DE,HL		;^user buffer --> reg. DE
	DI			;critical phase
	JP   GTIME5		;transfer time & date into caller's buffer

;get time & date in CP/M 3 format (hardware clock):
$GTIME3H:
	DI			;critical code (not reentrant)
	PUSH HL			;save ^user buffer
        CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer   --> reg. IX
	LD   IY,BINARY$DATE 	;^result buffer --> reg. IY	

	LD   A,(IX+7)		;hours (tenths) --> reg. C
	AND  3			;make binary
	RLCA    		;hours (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	--> reg. C
	LD   A,(IX+8)		;hours (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add uM80
<=BNKBIOS
<=SCB
<=BOOT
<=CHARIO
<=MOVE
<=DRVTBL
<=DISKIO
<

LINK BNKBIOS3[B,NR]=BNKBIOS,SCB,BOOT,CHARIO,MOVE,DRVTBL,DISKIO

GENCPM

ERA BNKBIOS.REL
ERA SCB.REL
ERA BOOT.REL
ERA CHARIO.REL
ERA MOVE.REL
ERA DRVTBL.REL
ERA DISKIO.REL
ERA BNKBIOS3.SPR
	DEFB MB$OUTPUT
	DEFB BAUDNONE
        DEFB 'TTY1  '		;device 3, TTY1
	DEFB MB$IN$OUT+MB$SERIAL+MB$SOFT$BAUD
	DEFB BAUD9600RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+12)		;seconds (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+4),A           ;store BCD seconds

	LD   A,(IX+1)		;year (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;year (ones)   --> reg. C
	LD   A,(IX)		;year (tenths) --> accu
	AND  0FH		;make binary
	CALL BCDBIN		;convert BCD year to binaryЉ	LD   (YEAR),A		;store it

	LD   A,(IX+3)		;month (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;month (ones)   --> reg. C
	LD   A,(IX+2)		;month (tenths) --> accu
	AND  1  		;make binary
	CALL BCDBIN		;convert BCD month to binary
	LD   (MONTH),A		;store it

	LD   A,(IX+5)		;day (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;day (ones)   --> reg. C
	LD   A,(IX+4)		;day (tenths) --> accu
	AND  3  		;make binary
	CALL BCDBIN		;convert BCD day to binary
	LD   (DAY),A		;store it

	LD   A,(YEAR)		;binary year --> accu
	SUB  78                 ;subtract base year
	JR   NC,GTIME1          ;result negative ?
	ADD  A,100              ;correct year	
GTIME1: SRL  A			;year / 4 --> accu
	RR   C        		;year % 4 --> reg. C
	SRL  A
	RR   C
	LD   B,6
GTIME2: SRL  C
	DJNZ GTIME2
	LD   HL,0               ;clear daycount
	OR   A			;year / 4 == 0 ?
	JR   Z,GTIME4		;no multiplication
	LD   B,A                ;year / 4 --> reg. B
	LD   DE,1461		;number of days in 4 years --> reg. DE
GTIME3: ADD  HL,DE              ;daycount = year / 4 * 1461
	DJNZ GTIME3
GTIME4:	EX   DE,HL		;юаC ш          Copyright (C) 1982, Digital Research     `                                                                     
 RESBIOS3 SPR  F800  0600
 BNKBIOS3 SPR  CB00  1500
 RESBDOS3 SPR  F200  0600
 BNKBDOS3 SPR  9D00  2E00
 
 60K TPA
$$$$$ї n  Ђ  Ђ    P ї я А @                                                                                                 нs:э1эЕХеЭеэехЫщ2<эж=цУщсЗых:<эУщЫъжЧцEУъсэбЭббСБн{:эЙ   М)М                          oМLМD ?яр  Ђ P  …ї а 0   
 	  >я2 ьy‡‡‡‡Ђ2џьЙ  л: ь·(Ї2 ь:џьЕAНэБ	л	Йн°лЙЕжАцOЫщж=±УщБЙ                                                Нэ·И>яЙЇЙx·y(( (А
ГэГэГэx·(Ф= G= = G= Б	Нэ· і®CRT    LPT1   LPT2   TTY1  TTY2   P     COM                       yюРЦШИ=Gi& )))^ьn& Ђь^>ДГэx·(=(=(= G= ГэГэ>Йx·(=(=(= G=  (+ 10.4 MBytes Winchester)
Version b of BIOS (851122)
Thomas Holte  1985











 

BIOS Err on A: No CCP.COM file CCНэЂ 	л	лБнЙеХ(!фч*фч:цчW:чч_НэСбЙГ Г ,Г Г 







R C P / M   V e r s i o n   3 S

GENIE IIIs SYSTEM )> ЬЮщ·А|µ уЇЙ*ДчГљщ!WьЙ!=эЙ2%ъГїь Ї2Њы!  "ќы}ыН­ъ<(. НІъЂ Н·ъ}ыНјъ!  5Е>ЂНэЂ 	л	лБнЙ!ZыН щН	шґ! 5 Е>Ђ щ*ЩЛ«яяяяяяяяяяяяяяяя*Жч )еЕ>яЬ°щБб·И|µ п>яЙh& е)))]ь~жбК-ь‡щНЮщ~Дрщю >яю ЇwНзщ¦ЙЕеНеыбБ·ЙЕеН-ьбБ·ЙЕеНГыбБЙ*Ачќ*ВчДчб*Вче )> ЬЮщ· |µ тбмбГГыйЕХ~·(	OеНшб#уСБЙWщрШ>/е<033чХЕOНшБСб
_
W{І вЙьњяцяяя  !№ЛН щ:ХЛЖAOНш!ЛЛН щ*ЧЛН2щ!РЛН  2 !ш" *юч" Й                                                                *ѕчГ ъ*ѕч**Ач*Жч )0еЕН°щ·(ъБЕН
ьБб|µ йЙ*Г ЛГlшГТшГШшГЭшГвшГяшГщГ2ЛГ7ЛГeЛГjЛГoЛГtЛГ‰ЛГ—щГЁЛГшщГэщГъГъГ ыГъГъГіЛГЎьГЋъГъГµЛГђьГэГъГъНxшН&ъГ 1ТшНxшНrъГ >НQш>Г2ГшГѓу                 т       1                    O                         jц$  њчЂ               яяя       Ђ    аГ|ќт                                                                                                        ГшГѓуГшГѓуГ	шГѓуГшГѓу                                                                                                                                ѓ  ‚‚BB   ‚‚        ѓ                                                                                                 члб+"бчБ}жюИ{жь_}жьoНЭхµИ>я2тЇЙ~жК7х®жВ7хГёх~юхВ7хлб"тГ9х:њч·ИOG® Ае#НдхбЙхЇНQшсЙ{•ozњgЙѕА#ИГдх   ѓ‚""‚‚ѓ      !ЦхеЇ2т*%цDM*тл*бчеНЭхСµИеле+))	 ќч®жВHхНАхК~хлб#г+}ґгелВ#х<ббЙ:т<КІх<В7хХНАхСВ7х:т<Кўх<Кoх~жВ7хГ~х®жВ7х~ж0ю0К7х*бЕХ",ц!.ц"*цЂ НKш6 *цНХфБ}ґКґф}¤<Кґф.ц}“o|љg	"(цбС$ ГKшюКtф> ЪИф=2(ц*fчщ*(ц}DЙЇНQшНќ"(ц>ГQш·КKшНQшНKшЇГQш>НQшГлф"%цНQш!*ц$ НKш*цбБЕе"тНХфСБxжьИ!*цл! Ъ@ф$Ъ@фЪhфЪKшЪ\фГKш:т·КKш 	л	~#~	л	wЙ*Шч NцГKш*ШчЂ NцГKшл^#V#N#F!ЇцешxЙЌуХ>НQшйGЇНQшxЙю3Ъ°уюbЪјфюqТјфюoК5уюpК5уГПуюКЗуюКЛуюВПул"Шч"тЙл"гч*гчл!вхyюbЪЫу!іх 	~GЕХЪнуЪьуГф*Шчл!Nц НKшСХЇ2ттл}ґВу!,ц"єч*Шче*цХ NлНKш6 СХ
НХф:+цO СбГKш2$цл^#V#N#Fлx±ИЕеNpуХ:$цюpКш:ПчGжКjуxжКjужВшГшYГХфб#БГAу>НQшFЇНQ      шХфХфћт¤тЁт¬тгтйтптуХфНшГИфKГшKГш{<КГт<КЅт<КИтKГшНОтГИфНОт·ИНШтГИф: т·>яАГш! т~6 ·АГ	шН6шГИфН9шГИфBK!Уч
ѕИЕOНSуБГс    `Г$тГдфГтфГъф       Nц      Гwуy!  "(ц9"fч1fч!ЛфеюТ”у2Яч!†т 		~#foйCOPYRIGHT (C) 1982, DIGITAL RESEARCH 151282                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Ђ™                                                                                                                                      Ђ‰ Эя         Ђ‹ Эя         ЂЌ +Эя         ЂЏ :Эя         Ђ‘   я         Ђ“   я         Ђ•   я         Ђ—   я          Ђw †Ья         Ђy •Ья         Ђ{ ¤Ья         Ђ} іЬя         Ђ ВЬя         ЂЃ СЬя         Ђѓ аЬя         Ђ… пЬя         Ђ‡ юЬя          Ђg Ья         Ђi Ья         Ђk ,Ья         Ђm ;Ья         Ђo JЬя         Ђq YЬя         Ђs hЬя         Ђu wЬя          ЂU ‡Ыя         ЂW –Ыя         ЂY ҐЫя         Ђ[ ґЫя         Ђ] ГЫя         Ђ_ ТЫя         Ђa бЫя         Ђc рЫя         Ђe яЫя disk drive,  Data record not found,  Parity error during write,  Lost data during write,  Retry (Y/N) ?  D xЫIЭXЭgЭvЭя       read,  Illegal drive #,  Track # too high,  Sector # too high,  Device not available,  Write protected diskette,  Write fault on too high,  Device not available,   Locked/deleted record,  Data record not found,  Parity error during read,  Lost data during 	е©Щ н°!€МСХ н°!љЩеЭй!©ЩС н°!‰МЛЖЙ     ТЩдЩчЩЪ"Ъ#Ъ;ЪSЪnЪ†ЪЪ«ЪїЪЦЪсЪЫ%ЫAЫ Illegal drive #,  Track # too high,  Sector #ЫН щyюYК±Ш:.Щю>А<ЙНш·(Н	шхН	шхOНшсюAШжЯЙ >яЇ2hЩ:ЧЛЖ‡‡‡‡!ЭЛ†хн[ЫЛ*ЩЛ#)эЂ:hЩ· схлсНэЇЙ Э!UШЭ!±Ш:mМ‡O‡Ѓ O!Ч<(+Нaщ*.Щ& -)®Щ	~#foН щ!ZЫН щНЩO!jЫН щyюYКUШ>Й:ЩЛG:ЧЛ_:ЦЛO:ЭЛЛ'Л'Л'Л'±*ЫЛНэ2.Щ·ВЩШЙ:зч<(+Нaщ*.Щ& -)АЩ	~#foН щ!ZЫН щНЩO!j                                            яя:TШO:ЩЛG:ЭЛЛ'Л'Л'Л'!ЦЛ†н[ЧЛ*ЫЛНэ·И>Й :ЩЛG:ЧЛ_:ЦЛO:ЭЛЛ'Л'Л'Л'±*ЫЛНэ2.Щ·В}ШЙ:зч                                                                                                                                                                                                                                                                                                                                                                                                К.ШyЂНЦ2ЩЛ л	"ЧЛлГдХ ђтЦЂЙ#~є+А~»Й                                                                                           ЇW_G!,ЦНэ·И!ќХН щюHARD DISK FAULT :·И Ђ ЕХ!РХ>Нэб  лБ йЙе>>2TШ!)Цн[ЧЛ:ЩЛO ###Н$Ц(0у##~++№(0з                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ‡С                                                                                                                                                                                                                                 iНxНя         ‡Н   я       НeНgНяя pА
P 	
 !"#$%&'()*+,-./0123                                                               Щ‡Х             _э  …ЭnЫpЫ B ±ШUШЩЩ              pэ-ЯЛЮrЫtЫ R 3Щ/ЩЩ®Х             Ѓэ  ]ЯvЫяя U oЩiЩЩЩ ЌМ          ’эБМfoешя*ХЛ& )=э~#foеця~#foС2ЦЛйi`zіИл	n& ЙЇЙ2ЭЛЙEBIOS Error on  : T- , S-          ! Ђ"ѕч"Ач! @"Жч! "Вч"Дч!БъГ щХХСХ1ТшНЮЛ !=эЕ^#V#{І(ел++~2ЦЛy2ХЛ+V+^лНщбБ ЭГcш  .y2ХЛi& )=э	~#foґИ{ж ел!юя~2ЦЛ!ъя~#foНщбЙнCЧЛЙнCЩЛЙнCЫЛЙ*ХЛ& )=э~#Г9®Нb®Гр±                                                                                                                       Ъ—±>я2#КГ—±юВ«:#К<В«бГЦЖЇ2#К*рЕЙ !  "єч"±ч++Й"фЕЦ29КЙ НCКГВНw°*{Е}¤<И^#VzіИ!ЄЕѕВcК! >яѕВcК! ГJКНw°*qЕ~·А6ЙН9®!тЙНђ»=В‡Й*‡Е"т:Е*}ЕНтВ®Й:т· Д=°:ЯчЦИ:њч<М°ЇЙНшЇАНх®А>я2њч*iЕ^#Vл+Н¶ЇЙНdЙИ!ёЕќч еХЕНKш*}ЕеН@®НаИ*бч))СБСХЕ:ЕН	тБбСГKш:ЊЕЪЙс)ЏхжЦ ТЙO с	О БВсИ"ћч!ќчж¶wж В[ЙжOж?WжGzжа±O:„ЕТVЙхxGyOсГGЙxж¶w qЙ*}Е}ґ<ЙНdЙИ:њч<И:еч·И*iЕ^#Vл|µЙ:пЕw·И:ђЕ<wЙеХНаИбќч :ЕН	т"±ЕбЙ·ИюЪЬИ>КґИ>2њчлНdЙИл:ЯчюКаИю#КПИюТаИ>2њчеН9ґбВаИЇ2њч~2ќч#л!  ж ВЙЕКЙКЙ)ЏхxлГ°З*цЕ}ґВИ*шЕ}ґКИ"тЕ*тЕНxИ"рЕНxИлНmИ*фЕ^#V*рЕ 	s#r*рЕл*фЕs#rлЙ*рЕ :пЕѕКYИ4ѕКYИНѓИ*рЕл*фЕ~#ngН®µлИГИ*тЕ 	s#rЙ 	^#Vлћ«ф“«НaЗ##ыЕГ)«Н0Куя"тЕНxИеНxИбИл!  "цЕ"шЕл"рЕНXЗН«КCИ*рЕ~<ВОЗл*тЕ"цЕГуЗ:ЄЕѕВфЗл! :ђЕ·КуЗѕВуЗ:9К· ВуЗ*тЕ"шЕлеНxИСКИл"тЕЖл*тсюВЗ"gЕЙл*ШчЂ юВ3З:ъч=єЪт:ъЕOНiЗЂ Гтл:ъч=јЪHЗ:ъЕGНiЗЂ НтНaЗ6яЙ:ђЕG/OЙ*рЕЄЕЙ *рЕЙеХНWшСбЙхН¬:ъЕНTшс=КхюТЌЖНККтЖЇНaЗюКљЖ~·КВЖ6 *«Ее:­ЕхНXЗлН)«!©Е:ЄЕѕДT»>МqЗБСН¬Нk»сюРхюВЦЖ!”Е:“ЕѕТаЖНК6я>ГгЖ<wЇНqЗНXЗН)«6 #НѓИ:пЕ<Ђ !Ђя=Вь{ЕюВXЖ^#V!яя"ыЕл:ЄЕѕВ<Жл! ~л<В<Жел^#V*ыЕН®бТ<Жл"ыЕл"эЕНxИВЖ!ыЕНыЇИ*эЕЇ>НXЖ*{ЕГЖхНQЗ:«Е_ 2пЕ{Ў2«ЕсхД’З"рЕН‚Ї"тНXЗ~<КВЖс                                         яя                     #cdfg !"()                                          *НNш!фчлНЕГr§Г)«!оЕл еГNЅ! ќлГ)«zЈ<*¬чК)Бл"¬чЙ!яя"џЄ:Эч·КXЕ*Ыч:їЕw :¶Е¶w#:µЕ¶w*2 щ*џЄ}DЙе                             ИН¶Нѕ·КдДНѓЅВЎД>я2тНх±ИН¶ИН±ЅНФЅВЯјеН?­Сл~·ВѕДжВѕДНДГКДжаВЖД>ЂwНДН™Ѕ=2дЕНњ­Нр±ИНѕ·А:дЕwГљЇ~хНѓЅБК‘ДpГЎД!фчНЕ6 яГNш ЕwбжКД Н§ЅНBЅpшяН§ЅНИЙГљЇНg»НsјГr§Нђ»Н-ґНњ­Нр±ИНД¬ Н¤­е Нѕ·ВSДСлН)«Г_Дб Н¤­НѓЅИ~Н?­wЙНђ»НsјТАІН-ґН?­FеЕНњ­Нр±БбpNН†±ИѕЙ<!ЈЕ4К”Г‡5НД¬O 	>№Иp#ГћГНђ»*Ыч6!Нч±ВїГН?­~жpВАІ*Ыч6 Н¶Нч±ВдГ>я2тН¶ИН±Ѕ НѕНЭЅ НѕНвЅНФЅВЯј  Н·Ѕцwе*o±НqГЪГх Н‹°сК"ГН@®6еНИЙНљЇНІГюВНX­Н¤¬Н‹ГН—±ѕwхНO­~<слДµ:џЕ·Мµ НgГл~жw#w#6 ##Н)«Н‹°ГГН@®	л*Ыч	Й НgГ~ж?GёА++! ш…oг#~бгЙ>ГTш}ґИл!
 6 *щчН®лРл*Ыч#е НKшбЙ"џЄG*Ыч~ю	ИюИюИюИxГr§Нђ»Н-ґНxјД…јяНд№ВАІН@® НЛєН7­НюєЪАІІКАІН(®НљЇНSѕНх±КЂНw°Г:КН В:ћЕ<ВВНRЇбс·ВнБЙНHшНҐ«:ђЕ·И>ГяЕл~юcРл!њч…oл#~ююТEВл^#VлГ)БG#~И#~Й!°Вел~юИюВbВ‹ВХю	ВkВђВХе##N#F#^#V#~#foг~еo‡…АІюЃТАІ2жчЙ{2зчЙНg»*wЕлНЮ°  ·КЄБТўБГћБ+}ґВќБ*…Е#}‘o|g:‚ЕOЇНцЄл*тs#r#wЙ!іч~цЂwВ/ ~ц@wГ/ Н/јНHшНҐ«*eЕ>=)ТВхе_Нg»:Ячю0КВ§л"ШчГ¶ЇНk»*wЕГ)Б*cЕГ)БН-ґН}КН¤ґГЂ±Нk»*sЕ"џЄЙ:ћЕюяВ;Б:ачГr§ж2ачЙНљ»НО­Г№єНљ»НО­ГВєНљ»Г»л}/_|/*eЕ¤W}Ј_*cЕл"eЕ}Јo|ўg"cЕ>я2©ЕЙ{·КВ—А>я2тН¶В—АНр±Н‡іГАІН±Ѕл*т 	лжаВ«А>Ђ2дЕхН™ЅсwНBЅpНДН+іИНѕ·ВТА:дЕwНљЇНAЇPН{ї Н2ѕАНвЅГWё>O2 ЄНАІГёЄН}КГRґ*eЕГ)Б:¤ЕГr­Гх¶Нљ»НО­ГcёН­2іЕНZ®НT®Нђ»Н-ґН¶НЪґНшЇ·К3АН—±ѕТгАхН@ѕКYАНsјжЂКYАНѓЅКYАНЧЅКYАН…ј:дЕжАВЯјсФ¶НшЇИНAЇНsјжЂКТА:іЕж@КТАН@ѕВТАН$іНѓЅЅђчГ®Нљ»НAЇНШ­Н=µ:џЄ<ИГВлЇх~ю?ВЇїНk»Нй» ГГїН?­~ю?КѕїНZ®НT®Нђ»схКЪї*бче>ьҐo"бчН’Їб"бчс!ГЇеКч±:ечOНЭ±ГІл" ЕцГќїН}КГ6іНљ»НОЫч
 ~жЂВї2µЕГАІНAЇНsјжЂКvїН@ѕВNїНѕ·ВNї~жАКvїН$іНѓЅВWїН+іИНѕ·ВvїwН®МљЇГvїН$іНѓЅКrїНЅКrїН…ј:дЕжАКrїжЂВЯј>Ђ2¶ЕН+іИНAЇ@Н2ѕМЭГr§!яяНZБЇ2Ъч!Ђ "ШчГ¶ЇНg»:¤Е2ЪчЙНT®Нђ»Н-ґ:ач·К№ѕ>ю2т<2ЅЕНЪґНзѕ!ЅЕѕИw:тююИН
¶>Ђ2µЕ*Ыч6 НЭ±НІНЭґНзѕЙНшЇИНO­~<Вчѕwб:µЕТї*В)«бЙН@®	u§ХГнЅ:бчжюИG*gЕ` ~Ц!Аx‡_‡‡ѓ<Ѓ_ЇЙН@ѕА*oЕy¦В®<Й:„Еца/GН?­~ А##~ж?Й Н6ѕАНK®ж@АН?­F6 е##N6 ЕНр±ДвЅЇ2џЄБбp##qЙ:ЎчЅ#Й*Ыч~хцwНх±> 2џЄ*ЫчБpИН@®л! ~жацЙе*т"тбЙНv®ЕН@®л*Ычл°w#Н)«БИ6 #ГМЅН™ЅеНЅбЙ ГдЅНѕ·АљЇХфчеХ НNшН«СбчЙ#Fx·ВЅT]##	#~И·КЅю КЅл
 л*тЁѕВ4Ѕ#В'ЅЙВ4Ѕ!зЕГ«е  л*тЇх~·К^Ѕю К^Ѕ33хЂG#ВPЅс°бВvЅ:ЯчюdКvЅ6 ЁВyЅИГЅЇ2тН@®л!ЧЕеН)«#wС*Ыч~ел"ЫчНр±КдјНѕ·ВТјл!дЕFw·КдјЁжаКТјНѓЅКТј:дЕwН®МљЇб"Ыч:ЯчюИюИ>ГеАЇ2дЕН®ВэјНѓЅх*Ыч~цwсД‡іб"ЫчеНЂ«Н° Н°!Юч~·К$ј6 б:Ячю0ИН3ЇГЇНi®Ъјб"бчЙ!рч~·И6 *eЕ>=)ТQјхе!©ЕНQ»НXјДх»бс·В<јГk»*{Е}¤<И^#V{ІИ! ~·А! Г_ј*oЕ~ЙНsјжЂИНѓqЕ~жх†wсДи®Н®ЙЇ2µЕ2¶ЕГ№»Ђ*Ыч л~ 2¶Е~Ўw#~ 2µЕ~ЎwНZ®!  "т"тЇ2ЅЕ=2Эч*Ыч~2їЕж=2ћЕюяКЯ»2¤ЕНk»:ач*ЫчwНх®МXЇНх»Г/јНЇИ6 НXЇ*б–W#xћ#хІWс{ћЙs+p+qЙН7­еr#r#rНх±К>»Н@® НЛєбеНюєФ»НІ> 2џЄГ»бЙл  НЛє!! q#p#wЙ2ЄЕwW*eЕН®_ХН3«бТ«Є-Й!¤Еs:¤Е!©ЕѕВx»юяАНQ»ИНи°*ґ:џЄ<ВњєСбБЕеХ.К©єН¶.К©єББНAЇНЬЄБЇГr§Сгr##sбНЬЄ<Б}Гr§яНд№Мх¶Й Нд№МcёЙлN ! ~жЂЃO> €G~жЂG! ~‡‡‡‡·ЂGх~жoс> ЌЙ_yG~жьб.|В°є!  w:ЯчюcКkєХНиЇСК[є! x–ж?В[є! ~№К¤єН†±В[єЕН—±Б№ТPєСХВPєСГv§qOН-µНэґГЎєЕХН=µСБ.:џЄ<К°єН¶! еVq##~_Хж@°wНЪЕН¶ЇС:ЁЕWХНM·Ъє№К›№>НяЕГє№Н¶ЇН¬>НTшНJЇБЕ:«Е!ѓЕ¦К·№ Нћ«Бx!ҐЕѕЪЗ№w4ВП№НPёНWёВЮ№НPёНЬЄГ‚­НХЄГ‚­Е*Ычл!! ~жх~#~жO~жр#¶НF®sГ№O 		s#rЕНт¬:Ячю(В„№y==В„№Бх*«Ее!ђЕ^WХ*yЕ^#VлеНxИСВ7№л=2”ЕwНјЇСХЇw#тK№WВK№*±Е"«ЕЕНJЇН¬ЇНTшБНћ«*«ЕСХ:ѓЕҐ В[№бб"«Н+®НоЇНSѕНX­:ЁЕюЂЪњёНq¶:џЄ·АНа¬Кєё!ЄЕ•ЕН«Кµё>я2”Е Г№НЬЄН¤¬2џЕ  ·КСёOНМ¬DMНёі}ґВЮё>Гr§"«Е"–ЕЇ2”Е:ЄЕ2•Ел*Ыч 	:ЈЕ·:џЕК№:ѓЕ<OКёЃГёБAO:њЕ·Кёx№ЪёyбБpБ!™ЕVђєТ+ёWy/ў2ЕКo·х:њЕ·КBёН ВН¶ЇсgНќ¬|юOДEшЇЙНK®жwЙНK®ж@х~ц@wсЙ> 2њЕН9®:¶Е·>ВеА:µЕ·>ВеА*Ыч†юЂЪ€·>ЂЕF6Еех:ѓЕ_/ Gб:њЕ·К§·:ҐЕўјЪЁ·|ђO»ЪёЕН¤¬G:џЕё_Кэ·OЕ НМ¬еНМ¬Сz”W{•ІКВ·|µВх·:њЕ·Вх·*…Е}“|љЪх·ЕХBKНN°бБТВ·Сz№Ъэ·y“G:ЁЕ!ҐЕѕЪ·юЂВv§Нq¶:џЄ·Вv§НХЄНа¬Кv§Нт¬НM·Ъ‚­В?·Н¶ЇН¬>НTшН“«Г‚­!  "–Е>НяЕГ‚­:“ЕG:ђЕO х:ЕюЪh·=2Ес7АЇЙсКr·y·ИцЙy/W!ЁЕ:™ЕюЪl·еЕН=µБб:џЄ<И>Ўw##~2§ЕВ ¶4~ж?КЙ¶Н¶НѓКВ№¶:њЕ<КЙ¶Н¶КЙ¶Гј¶НЮґНAЇНX­Ї2ЁЕГr§НK®:§Еw++~=жwГv§4Н—±OѕТм¶5:њЕ<Кv§4Н-µНэґГј¶НоЇ>я2њЕНX­АЙ!яя"тЙ*т>ьҐo+"бчЙНvКНыЇД
¶*Ыче!bЕ"ЫчНЭ±НІб"ЫчИ:т·А r#~хеж?w#>r#ВL¶=JМѕ·
КL¶Нv®   НщібсwНИЙГb®НЬЄН?­~OН†±КЪ¶·В†µw·ВЊµ~ѕВтµГЁµНµлНµлѕВтµ#ѕВтµ#Вxµлмя	еН—±СНшµwЕ 	л	БКЩµКЪµѕЪЩµ·ВЪµНµлwН@® ~жwНb®Нђ°ГљЇНЭЇГАІѕАлѕл! ‘КµxТµ>Ђ¶wЙ~·А6 :џЕ·И6ЂЙ~#¶+Аw#w+Йе ~юЃЪ;µжwбЙЇ2џЄН®АНK®жЂАНиЇКтµНьЙOFЕqН-µyёЬэґНlµН?­БNpГэґНр±И НgГ:ЈЕ·К“µ~ІНх±ИН(®НчіНИЙНІВ€ґНіКЂ±НHґГ€ґН­2іЕНxјД…јНх±И НґН)«:іЕж@КОґеНO­~б#wНљЇНІКЂ±ГґґНѓКИНb®_е++VХН@®л*Ыч Н)«Н—±OСбs++r лЇ~ ЕGж°wБ#ГэіХ *Ыч	#~Ц$М%ґ+лН@®БЙічцЙ*ЫчН9ґА>	ГеА#>?–жИВ;ґ·Й*Ыч~ 	wЙН-ґНxјД…јНэІНHґ" ЕН0ґ* ЕНг±Нъ±ВгАНіДЉіНHґНэІГEіНх±КЂ±Н@®~жВ›і:іЕжЂВќі6ехНѕ·В¦іwНљЇ сМ‹°НИЙНІГ‡іPY*…Е{•zњТоіЕХBKНN°ТжіСБy°КєіХЕНN°ТжіБСГєі<Нp°бСЙy°ВТі!  ЙЂНґКљт>ю2тЙ:тююИН
¶ЇНяІ* Е~цwНг±ГІ*бч"тЙН
¶НЭ±ГІН­2іЕ>юНяІНх±ИК„іН@®~жВkі:іЕФ(®НsјЪ~і*ЫчН9ґК~іГЉіНsјТ~іНФЅК~іН…јГ<іН†±G:ѕЕ<КЮІЇ2ЅЕxБ·ВІ#ГWІ:ўЕ<В­І:тююМкІГІЇ2ќЕ2џЄGЙж?ЙНнІН°>яGГr§x·ВІ~·ВІ:ЅЕ·КІ2ѕЕГ”І°БІЕА##~·АНхІе*т$ВыІ*бч"тбЙ>я2МЂ«Ї2ѕЕНkЙВєІ Н°НшЇКєІ* ЕлюеК*ІХНi®СТєІН@®:ечO ~юеМнІЇ2ўЕ~жпѕКWІлѕлВWІ:т·КІ2ўЕГ”Іy·К›Ію?К”ІxюК”ІюК|ІюМ·І–жВЗІГ”ІЕNН:ќЕГr§Ех:„Е/Gy Oс ‘жБЙНO­AЕБЇ+ѕВ¬±Вў±y2џЕ:ЈЕ·xВ№±Ееo& :‚ЕW>’OН«­E:„ЕёбЪџ±Н?­N/жЎ°БЙ*Ыч" Еy2ечН¦И>я2ќЕЙГч±НЭ±Н°Нх®RЇНXЇНЮ°DM*wЕ6 #x±В±*oЕw*‰Ел*wЕs#rНЂ«*iЕ6#6 Н°*}Е"±ЕяН°НшЇКjКН@®л*±Е|Ґ<лДЏИ>!ѕК8±>еѕК8±> ѕКt±>¦Вn±Н¦°Нv®Г8± ~*oЕwГn±T]	сКKшлГKшЕН¦°БЕНЮ°л*wЕБе"wЕН¦°б"wЕЙН@® ЕСИХ:ЈЕ·КГ°ЕеN ГЙ°ЕN#Fеy°КШ°*…Е}‘|Фh°б#БГ°°*…ЕН«­#ЙНЇ6 Нл«Вя°*qЕѕ  Кя°Г@КНЙ!яя"бчЙН°Г@°*‡Ел*бч#"бчН®Ъ°:бчж‡В&°2·Е·АЕН’ЇБ:Юч·АГ€®Н0°:Юч·ИНЇН+ЇГ’Їyж<_W`iН«­DM*wЕ	~Вb°ЙХНN°жюБ±Вp°wЙхНЮ°DM*wЕeЇХ
 ^#V#~2ъЕлСЙНх«>ГўЇН9®Н†®>!  "–Е*yЕюВіЇ*рЕНXЖ*ШчГїЇН‚Ї"тЙ*gЕл*тЂ НKш!џЄ~<И:бчжwЙНb®##>яw#wЙНД¬ГыЇНиЇАб>	Гr§!бч~#ѕА<чG~ёИ#·ВЇ<Й*qЕ#~·Й!;Ее!НЕНю®Кщ­!ФЕНю®КАІбЙ!Юч~·И6 Нk»!  "бчЇ2·ЕЙ*qЕNН1­qЙ*{ЕГ]Ї*{ЕГ[Ї*yЕ}¤<И^#VлеЕЄЕН«БбВtЇ6я ^#Vл}ґИГ•ozњgЙю*‘Ел*‹Е|жgН®РЕНё­*uЕл*‘ЕБКЖ®КС®ѕИН® НRЇ>я2Юч2њчНи®Н®ГZБѕwИ*qЕ>¶wЙwЙ:¤ЕcЕН®*‡Е#л*iЕs#rЙ*ђчН®И’чГ®:ЊЕжЂА!АЕ:ЯИ)Гя­eЕ:©ЕO! Ню­µґЙ*cЕ:©ЕOН«­}жЙН@®Н2®РГ¦Є	 ~ЙН®ИГЎЄ*gЕ:·Е…oР$Й*Ыч ~ЙНK®6 ЙН?­~жwЙНK®цЂwЙ*бчл*iЕ{–#zћЙНi®Шr+sЙ{ЕЙНO­:ЁЕw:ЯчюТ’­4л~юЂР:ҐЕwЙН?­r##rЙp#ИГ¤­И|·g}oГ¬­*gЕ  Ї†#ВБ­ЁGВѕ­ЙН1­*qЕѕДг­:µЕ·И*ЫчЇwЙ*тл*ючН®Тч­*’чН®Ибб>
Гr§2­Е"±Е:ѓЕO:ЁЕЎG2“Е!«Е¶wЙ*Ыч ~‡хzWсw+В!­zЙН?­#~Й*Ыч! Й*Ыч Й*Ыч ЙНG­л! ЙНO­~2ЁЕл~·Вm­Н—±OНэґ~юЃЪt­>Ђ2ҐЕН?­:„Е¦2¦gНќ¬DM*љЕлН0шMD"эЕН!ш*тMDГ$ш:ЏЕOГ«­!‚ЕN:ЁЕ·В«¬G>–O:¦ЕКВ¬·Г№¬ЂЙ*Ыч ЙНД¬	:ЈЕ·КЪ¬n`Й	~#foЙН¤¬2џЕO НМ¬"«Е}ґЙ:‚ЕO*«ЕЇНцЄ"«Е л!«Еs#r#pЙ*kЕN#FЕ*mЕ^#V#F*«Е:­ЕO}“|љyеТ9¬*ЂЕНдЄбг+гГ"¬*ЂЕНнЄб}“|љyЪP¬г#геГ9¬ге*ЂЕНдЄбХЕел*ЌЕDM"ыЕНшС*kЕs#rБС*mЕs#r#pБy“oxљНшЇ*kЕw#w*mЕw#w#wЙ>2ґЕН'шГҐ«Ї2ґЕН*ш·ИOН¶«yюЪІЄГІЄ<АНл«И*eЕН®ИНІ®б:Ячю0И!ЄЕ:¤ЕѕВж«НЇ:ґЕ·АГІЄЇ2ЮчЙ*‹Е>ЂјАЇЅЙ*бчН«­"‘Е­4А#4А#4ЙН«лГ)«Н7­®ЕЙН«Г«ѕА#ИГ«Иw#Г*«JНш|µИ^#V#"iЕ##"kЕ##"mЕ###"oЕ#"qЕ##л"љЕ!sЕН)«*sЕл!ЂЕН)«*…Е|!ЈЕ6я·К~«6 7Йrror File Exists ? in Filename   ГІЄГІЄ>я2©Еa.я"џЄ:ЄЕ2нч:зч<Дыч:ЯчюК5ЕюК5ЕГ;Е:јЕ2тЙЇ2јЕ2тЙ{•_zњWРЙ{…_zЊWРЙИ)ЏГчЄН7                                               CP/M Error On  :  Disk I/O Invalid Drive Read/Only File Read/Only Disk Password E                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                чК)Бл"ПчЙ!УчzЈ<~Кr§sЙл^#V#N#Fлx±ИЕеN:ЯчюoКІ§НЂчГµ§Н(ўб#БГћ§                                                                    ЎНшГr§y<К §<К§<К%§ГzчНя ВАІГr§Ня ·ИН· Гr§Н6шГr§Н9шГr§лMDГЊў:ПчТo§!Хч6Ђе!h§е: тюКљЎНnч·ИНtчюКЎ2 тЇЙНr§б6 ЙНЎ2џЄЙ>Гr§zЈ<*ПК9ҐюКЊ¦Н^Ј:ПчжВ—¦~юxВ ¦юК) №Та¦ЕеНАўЪ¤:*Є·КА¦:ї§юКЕ¦юКЕ¦>Г¤бБл*(Є+"(Єwл+ЕеН+ЈЇ2+ЄГ¤Ї2+ЄГяЈНЙўбpЕНШўБяНоў!  "єчГН>2+Є2*ЄГ¤ЕНjўБбеЕx·К.¦#NСХzђWЕе:ѕ§єЬўбБГ¦е:ј§·К¤!·ч–2ј§НWў!ј§5В=¦Н^ЈГ¤хx№Ъ^¦сЕеНzчГ¤:ї§юКm¦:*Є·Д;Јс#wЕеOНЈНўбБ:ї§юЄ·ДЈН‚ўН^ЈЇ2Ѕ§Г¤юВўҐеЕЇН ЎБбГяЈюВДҐб:Ѕ§!·чѕЪЅҐ*(Є~·ВЭЈГЧЈ5НWўГЁҐюВХҐгНШўгНjўбГЧЈюВM¦Ї2ѕ§лНЁЈлx·КОҐл*(ЄКшҐ+wГнҐ"(ЄЕХНjўК¤ННЎГш¤юВҐл!%Є"(ЄлН^ЈГяЈюВ-Ґ:*Є·КяЈГ$¤юВPҐ:Кч<К\Ґ:Ѕ§W:·чєКяЈ2ј§x·КMҐГ¦юВsҐ:Лч<К9Ґ>2ї§:*Є·В9Ґx·КяЈ~+Гq¦юВ’ҐЕx2ѕ§е:*іЈ*&Є~·2+ЄКo¤#"&Є!+Є6лГM¦юВЕ¤:Ѕ§W:·чєКяЈ2ј§x·К¦еНєЈС*(Є+"(ЄwлГ¦юВҐ:ѕ§ёВЬ¤>2*Є2ї§Г:¤л*(Є:ѕ§ёКр¤+wГб¤"(ЄЕХНєЈ:·чG:Ѕ§ёе:+Є·Мњў2ї§бБюКз¦ю
Кз¦юВ5¤НАў»ТяЈл*(Є~·Кo¤#"(ЄлГM¦юВљ¤л*(Є~·К`¤лНАў»лЪU¤лНoЈлГj¤*(Є~#"(ЄГ‘¤!*Є~6 ·Кs¤!+Є6 лГяЈ:+Є·В‚¤x·Вo¤НЪЉЈ{2·чГ“ЈеНўб#ГwЈ:·ч2.ЄНЈН+Ј:.Є2-ЄБбЙ!%Є"(ЄЇ2*ЄЙ!ВЁ"&ЄЙ!*Є~·А4:·ч2-ЄЙНАўФ‚ў:А§G НоўНіЈНЁЈН^ЈЇ2+Є>2Яч:·ч2Ѕ§*ЫчN#еЇG2ѕ§№ВяЈЕИ2А§ХЈЕGHГ)«б+6 Й:·ч2,ЄЙ:·ч!-ЄѕР ННЎГЈ:,Є!·чѕРННЎГ+ЈЕе*(Є ~·КLЈ#ГBЈxѓ№хФzчсбБШССГяЈ:*Є·И:ї§юИюИюИеЕНЈ*(Є~·К“ЈOНАўrўННЎ
ГНЎ!Уч
ѕИЕOН(ўБГЊў*(Є~2*Є*єч}ґК· Н!т#·В¶ў!  "єч"јчАГ· :¶ч_:·ч»Йл*(Єл·И#wГОўx·ИЕHел!ВЁН)«6 "&ЄбБЙ:ґчР!ВЁБ§В
Јлx·Р5~·ИyюВў5ЙюА6 ЙyНр Т(ўх^ННЎсц@OНАўИ:Яч=К7ў:ПчжВНЎyю	ВНЎ:ЯчюВIўНАўИ ННЎ:·чжВ=ўЙНeў:ї§юИ НzчГzч#ННЎН‚ў:·ч!Ѕ§ѕР ННЎГ тG:ПчТЋЎ>ѕИxюКќЎюКќЎw>ЙЇwЙМ©ЎДzчЙ:ПчжВ»Ў!Фч>®жwЙЇЙ:Яч=КzчxжВzчГzч:ј§·ВцЎ:ПчжGЕ:Яч=Д/ЎБЕНЅЎБx·ВцЎЕ:Фч·ДЂчБy!·чюИ4ю  т·ВљЎНnчжЙ!Хч6@гйG:ПчжxЙНЎВя : т·ВPЎ:Мч<Кя НЎА: тюКPЎНЎНnчб6 жИНЎНtчб6 юВЎ! тѕВ^Ў6 НЎНtчб6 юВuЎ:ПчжК) ЇЦИ<Н ЎГ^Ў!ШчЂ Г“ *Шч"r Й*r "ШчГїЇБ<И:жчђgЙе:Ячю!Ф«Нђ С*f щл}DЙ! т~6 ·АГtч!r§еН· Нр ЪЦ хOН(ўсЙНЎАюВе Н^ЎГЖ юКЖ юКЖ ЙюИю
Ию	ИюИю Й:Function =     File =              !эяГ, Н$К"¬чГhч  !  9"f !ў еН	«Н‰ :жчх2™ЕНt ·В™ :Ячю!ФюЄН с=ВH goЙ  ЗЗЗЗЗЗЗЗЗЗ  :ЯчO*ЫчлГ;ќ*еН‚ў:ЄЕЖA2=Є/ЄНоџБ:учТоџНоџ:Яч0! юdЪЇџ61#ЦdЦ
ЪёџГЇџp#Ж:w#6 ! 6 :Эч·Кеџ6 Х*Ыч#л! Н)«6.#Н)«СН‚ўыџГоџ
·ИЕOН(ўБГоџBDOS  	НџВџ>ђбе 	wГаћНMџИю ЪхћъхћВ2џю*К7џw#·Й6?#т7џЙ	 .,:;[]=<>| е!?џѕК]џ45#ВRџ·бИюaШю{Тiџж_жЙp#ВlџЙю Кsџю	КsџЙ Нlџ НlџНsџю:беВ¬ћНMџКаћЦAЪцћюТцћ<w#НMџКаћ ю.ККћю;КыћНџВ¶ћГаћбе	 	 ю;КыћНџВФћБХНsџНMџбА!  ·ИюИлЙББ!яяЙбеББ#Б-БAБJБSБ@»YБu§u§JБАІu§u§}Б‹БђБНБЯБ*ВPВиБИВ¦ГД(ДdДсДюДЕЕ'Е{§‰§•§•§AЄgЄXЄJЄ    vЄ…Є‘ЄюА!)Бе*Ыч^#VХ#^#VблеЇw# Нlџ Нlџ!Jћ		^#VлНЂџБ:зч·АГ# !"( COPYRIGHT (C) 1982, DIGITAL RESEARCH 151282/ В (ў§шЂч§+§1§7§ИЈ=§}ѕѓѕ–ѕ ѕ‡ї›їмїхїыїААпАхАыАББУ®    `л"Ычлy2ЯчюЪ;ќ!  "Е:Ъч2¤Е=2јЕ:жч=К;ќ!•ќ~·К;ќ№К4 #Г.ќ{2ћЕ!  "џЄ"Эч9"2 !;Ееyю3Т]ќK!ЖќГoќюЂТ\ћЦbЪАІюТАІ!,ћ_ ^#V*Ычлй Е…ђФSҐ  P ©h  ЖАЂіh P8Н±  аHF’Ђіlh8µ`Ыю„nx*С lы6ЗЂ3lЁ †А„l8~	Д`Ц4 fЩP p$#`?Щ¶4u`ЂLг«Н®`«·eUр8кБЂіk †®яџџВFo џџД&e© ШPJЬ® жwX яєЪ®VmЏ fЩPDJВЇ@ђpi›c@Y а FХЂ3lh
Ь#~Ђ аK6ЖЂјОПцH †P&ЊД Ђ¦Y)Ђ                          AD2Ѓ4D)§#‘јд:ЖI°КdвyАКnКСё¦Y)ѓAB@h(†P&“…!”дr7њ‡BВi6L‚Ўј@r2L‚@љ3Л%0h(HЃ@ P(
Ѓ@ P(
Ѓ@ P(
!”дСXf.	†у	ђКr‚€fуЃддi3љ‚AR ЋG!`Ђ€i3љN†`Ђ¤e9™L'# 
C€аd    Ш l¶[
-‡      Ц"»біЛшЪґ #+ДЇ[pЃХЮ[аѓШКЭ@ 	^ЃИЉ lђ†§9O/б“Jе ’Д7p‡sА[ЖFХ›/…ЂђЙxFV]р‡[¦ф^Ђ+vz Ї@иЅ W 
ф]р+Рz Ї@ ўбt"ф^Ђ+Рz ©ШEиЅ W 
фTЉЋz Ї@иЅ W 
ф^Ђ+Рz Ї@иЅ W 
ф^Ђ+Рz Ї@иЅ W 
ф^Ђ)jЋЗc±Шмv;ЋЗc±Шмv;ЋЗc±Шмv;ЋЗc±Шмv;ЋЗc±Шмv;ЋЗc±Шмv;ЋЗc±Шмv;ЋЗc±Шмv;ЋЗc±Шмv;ЋЗc±Шмv8кч-ШVx	ЉНЎЃLИ†н?ЏмЃЈш@Рџ–мѓЛшВ¶ CVKшА '—р%…dЂЃВm’] ‡0…p@™"¶
_2 lR{6ЭЃ0Xw<	ЦM"0оxК„ЃІGАе AD"!<¦ "”ЉCЎ ђ¦e6LgA!@Кr6‹„’Р°0пfЬр ьaТ 0пfЬр fЬр'™Шц•/ћ“…vЂ’{B—ПHВ»@ЙY”{њ†—МLИaУр0`5ђ;„Дl:”JfС°ЈвХђ^•„b1ЉИДb+$#€Дb1¬En6` fФђ1Uu€m(@8"Н© b«T|ЫРЃіэnКІ c` Э’НЈJсUђ;€Ов«$wќДgvH†б„„ea’Нµ@lЪN·dЯА6Х Xt\UxВА&m& b†sњ„gHЄИ„df(ЄЙ„eaUpВW ћ}IџG”Г•ҐAБV”!›I@Ь.1[Ќ‡| ЕV”!›KЂЬ'Ф™с4yL6Ёр#ЊFгr°и8#ЌК*ґЎЪJбj±\®±UІ‘	ў+њНЈБMUђ9€ОL€ЄЙДg!Б‚yI›П	Ј;6µ‚	ў«pлfУ ўiEtґ„(Ub‚	¤F$
[@‚{“€m8A8upBбрk
ј‚ЗА„±<up¬« ·°м8"’*»бЂ 2ЙfЩ @HкЮ„-ЩV Ь`d‚OВ31Ѕ’Н®@ѓ+vO ¶hEpВ«FHкУ„ЕW!^Н¦аb+†2ёЎ+Њ:µсХБP‘ЖVШ CpВЗvHЄп„AЂ Л$UwВ р e’НЅАЋ±D dіo°!шepBgб•їfЮ`AХ©S® C%›}ЃАХБ@ќЭc«~wdѓ¬ѓвЬ>g>‡Нм:N
І,:h
:»БRx„ fУ0V	еjo<-м‘ХЮ'іi0)хМdЉ¬`@кд„!Mн#%›yЃО`щЭ’{J›ПIГ;%Є %бYЦСdіn0кЪ„-ЩV<|fЮЂ†›fЪQЊfЭ 6mі]А†§Yа†mrX †H†с„„kж с’!їДWЊ!’*µЃ±Uг€ЇC6µ‚¶­ (кс„9Ђ``*
Вє`Ј+’·`1Yµф‚ЙbЅGV¤ ^G<Ё	пEМ`ІY·Ш ѓ¬jјV_0ЁH05…БO#+v:·ЎsГ
‹Ш®Sx :ґбqр$OfТ`R(кФ„.-«ш
НјА„б{>ЎX0Y"«ѕ"јЎ‘•зfЫ@Vm— ¶м›jБYVlUyBlЪ°
:јбр0 ьюrІЄP1еnКІЂЗ‡р5•cAџАЖU‚%њЗцJaШР`УњНј`¬»
ҐД`@kґ+ЖT$ЋdЏџдp#тЃЃмЪtИfЮ`CуХ›V]b«ѕ3jH6ъ“Ю'p0Ц!Ђ!¤‹*мWH|Ђ#П+xЙ[АѓтЭЂ:·av@кс?ЃмЃІ’е[А…»*юѓ@` ЙЭ^2·ЃK6у‰аЖmгeRqр}BwЩґи›j™·ь^2ё!;К4fЯ@RzщҐKЃЖ¬;ТНЅЂМЫ~ГўамЫю:ё!~ѕmU0wт…z@™·ьuB@Цм+ТНµАЊ«ТНё ѓ«j·a] †m›fЭ 6mіaС`QХЮ2ЁXфCp‚Мѓ№\Ubµ4ѕХfХ07J…Ѓ‹Y«M"3iР(ЉД2GVи ew‚*с•ИaЭ qт Ћ='Љ®ш@D u†OКт„о#?(W  ьЎ;іk+6ч”«¤~PњVр B  ®P@щю2ј!«ѕ~sЗЈ+tюІЇ°9шer‚¶l›[БЗАUЯ;ІD   ЉД+ЖWx z2ёA  Ewvl›fБШuј›hЃЩ¶€›IВ,ЫV
ИfЯ`Cрс…MВa°СЭВ 2Y¶¤‡MБЗWx!‡y@ќb+ёГі`Ј«Дю¶«р@кЯ®р@кр„-ЩUш UwВАХК[І«ЂAЬF:№c»6ч­аBШо*Ё O‘U	>‘  ¶0"[-ђ–ЙKe%ІБЩЂ‰lРD¶p"[<- –СKi%ґЎЪp‰m@D¶¤"[T-¬–ЧKl%¶AЫ@‰mЁD¶Ш"[n-ё–ЭKnВ%·ЃЫР‰mрD¶ь"[Ђ-Б–б?еёЎЬ`‰n@D·$"[”-Л–жKs‚%єЭ Ѓр›{‚tX $@            UћaЯЃU zіj Hкб„Ф+–{PЊ®@Љж3kђ(ЉЕ3jШKЕкю4ЁаK6џЃІ©`JЅ›YGА&ml	fХ°–mI W, x@ (шdzВ¦Б.±UЉј_А6J	XА†K¬Uw ( Ґ…­ЁA^OdЉ®`@FбЂЊђ€ *№Ѓ–KХ›vЂЮ#ЧҐіfЦ@‘Њ#s‚АFI–я„Ђ'   ћАЖU‚%њЗцJaШР`УњНј`¬»
ҐД`@kґ+ЖT$ЋdЏџдp#тЃЃмЪtИfЮ`CуХ›V]b«ѕ3jH6ъ“Ю'p0Ц!Ђ!¤‹*мWH|Ђ#П+xЙ[АѓтЭЂ:·av@
	INC B			;test page number
	DEC B
	JR  Z,DISP1		;jump if page 0
  	SET 4,A			;select page 1
DISP1:	OUT ($SYS0),A		;write system byte 0
	
	IN  A,($SYS1)		;read system byte 1
	AND 11010101B		;7.2 MHz clock rate
				;disable graphic page
				;disable boot ROM
				;disable graphic display
				;disable memory mapped I/OЉ	INC C			;test display mode
	DEC C
	JR  Z,DISP2		;jump if no display
	SET 1,A			;enable graphic display
DISP2:	OUT ($SYS1),A		;write system byte 1
	RET			;return to caller


*EJECT
;*************
;*  $ C L S  *
;*************

;entry: A = 0  black
;	    1  white
;	B = graphic page number (0, 1)

;clear graphic page:
$CLS:	LD  C,A			;save colour
	IN  A,($SYS0)		;read system byte 0
	AND 00010001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	INC B			;test page number
	DEC B
	JR  Z,CLS1		;jump if page 0
	SET 5,A			;select page 1
CLS1:	OUT ($SYS0),A		;write system byte 0


	IN  A,($SYS1)		;read system byte 1
;******************************************************************************
;*  D I S K I O  *  C P M S Y S 4 f  *  T h o m a s   H o l t e * 8 5 0 6 2 6 *
;******************************************************************************
;*									      *
;*  			    D I S K   H A N D L E R	      		      *
;*                          =======================                           *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	TITLE 'CP/M 3 DISKETTE HANDLER'

	DSEG

;Disk drive dispatching tables for linked BIOS
	GLOBAL DS0,MF0,RAM,DRIVEP

;Variables containing parameters passed by BDOS
	EXTERNAL @DTBL,@ADRV,@RDRV,@DMA,@TRK,@SECT,@DBNK,@CBNK

;System control block variables
	EXTERNAL @ERDME		;BDOS error mode

	EXTERNAL ?PMSG		;print message ^HL up to 0, saves reg. BC & DE
	EXTERNAL ?PDERR		;print BIOS disk error header
	EXTERNAL ?CONIN,?CONO	;con in and out
	EXTERNAL ?CONST		;get console status

	EXTERNAL ?BANK,?USERF

;ASCII control codes:
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape


;Extended Disk Parameter Headers (XDPHs)

	DEFW DS$WRITE
	DEFW DS$READ
	DEFW FD$LOGIN
	DEFW DS$INIT
	DEFB 0  	        ;relative drive zero
	DEFB 2			;drive type
				;  0 = floppy disk
				;  1 = floppy disk (special format)
				;  2 = Winchester
				;  3 = Winchester (cartridge)
				;  4 = RAM disk
DS0:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB0   		;disk parameter block
	DEFW 0            	;no CSV
	DEFW 0FFFEH,0FFFEH	;ALV, DIRBCB, DTABCB, HASH
	DEFW 0FFFEH,0FFFEH	;alloc'd by GENCPM
	DEFB 0			;hash bank

	DEFW FD$WRITE
	DEFW FD$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 0,0	        ;relative drive zero
MF0:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB1   		;disk parameter block
	DEFW 0FFFEH,0FFFEH	;CSV, ALV, DIRBCB, DTABCB, HASH
	DEFW 0FFFEH,0FFFEH	;alloc'd by GENCPM
	DEFW 0FFFEH
	DEFB 0			;hash bank

*EJECT
;RAM disk:
	DEFW M$WRITE
	DEFW M$READ
	DEFW FD$LOGIN
	DEFW M$INIT0
	DEFB 0,4
RAM:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPBC   		;disk parameter block
	DEFW 0			;no CSV
	DEFW 0FFFEH,0FFFEH	;ALV, DIRBCB alloc'd by GENCPM
	DEFW 0FFFFH       	;no data buffer
	DEFW 0FFFEH		;HASH alloc'd by GENCPM
	DEFB 0			;hash bank

*EJECT
;virtual disk drive P:
	DEFW P$WRITE
	DEFW P$READ
	DEFW FD$LOGIN
	DEFW FD$INIT
	DEFB 1,1	        ;relative drive one
DRIVEP:	DEFW XLT  		;translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPBF 		;disk parameter block
	DEFW CSV,ALV       	;checksumm vector, allocation vector
	DEFW DIBCBH,DTBCBH	;BCB list header
	DEFW 0FFFFH		;no HASH
	DEFB 0			;hash bank
PDCT:	DEFB 01110000B
	DEFB 10000000B
	DEFB 2,20,80

;translation tables:
XLT:	DEFB 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
	DEFB 17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33
	DEFB 34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51

;checksumm vector:
CSV:	DEFS 64

;allocation vectors:
ALV:	DEFS 100

;BCB list header:
DIBCBH:	DEFW DIRBCB
DTBCBH:	DEFW DTABCB

;directory control block:
DIRBCB:	DEFB 0FFH
	DEFS 9
	DEFW DIRBUF
	DEFB 0
	DEFW 0

;data control block:
DTABCB:	DEFB 0FFH
	DEFS 9
	DEFW DTABUF
	DEFB 0
	DEFW 0

;directory buffer:
DIRBUF:	DEFS 1024

;data buffer:
DTABUF:	DEFS 1024


*EJECT
	CSEG			;DPB must be resident

;Disk Parameter Blocks (DPB)
DPB0: 	DEFW 68			;128 byte records per track
	DEFB 6,63		;block shift and mask
	DEFB 3			;extent mask
	DEFW 1298		;maximum block number
	DEFW 1023		;maximum directory entry number
	DEFB 0F0H,0		;alloc vector for directory
	DEFW 8000H		;checksumm size
	DEFW 1			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask

DPB1:	DEFW 80			;128 byte records per track
	DEFB 4,15		;block shift and mask
	DEFB 0			;extent mask
	DEFW 389		;maximum block number
	DEFW 191		;maximum directory entry number
	DEFB 0E0H,0		;alloc vector for directory
	DEFW 48			;checksumm size
	DEFW 2			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask

DPBC:	DEFW 447		;128 byte records per track
	DEFB 3,7 		;block shift and mask
	DEFB 0			;extent mask
	DEFW 110		;maximum block number
	DEFW 31 		;maximum directory entry number
	DEFB 80H,0		;alloc vector for directory
	DEFW 8000H		;checksum size
	DEFW 0			;offset for system tracks
	DEFB 0,0		;physical sector size shift and mask

DPBF: 	DEFW 80			;128 byte records per track
	DEFB 4,15		;block shift and mask
	DEFB 0			;extent mask
	DEFW 394		;maximum block number
	DEFW 191		;maximum directory entry number
	DEFB 0E0H,0		;alloc vector for directory
	DEFW 48			;checksumm size
	DEFW 1			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask


*EJECT
	DSEG			;rest in banked memory

;hard disk init routine:
DS$INIT:XOR  A			;bank 0, drive 0
	LD   D,A		;track 0
	LD   E,A
	LD   B,A		;sector 0
	LD   HL,SPARE$DIRECTORY	;^buffer
	LD   C,16		;function #
	CALL ?USERF		;read in spare directory
	OR   A			;any errors ?
	RET  Z			;return if not
	LD   HL,DS$ERRMSG	;^error message --> reg. HL
	CALL ?PMSG		;print it
	JR   $			;...and hang up!
DS$ERRMSG:
	DEFB SUB
	DEFM 'HARD DISK FAULT'
	DEFB 0


*EJECT
;RAM disk init routine:
POWUP	EQU  111DH		;power up/reset marker	

M$INIT0:LD   A,(POWUP)		;power up ?
	OR   A
	RET  Z			;return if not

;clear RAM disk:
	LD   C,32		;entry count	        --> reg. C
	LD   DE,128		;^first directory entry --> reg. DE
CLRNXT:	PUSH BC			;save remaining entry count
	PUSH DE			;save ^directory entry
	LD   HL,CLRBYT		;^E5 		  --> reg. HL
	LD   BC,1 SHL 8+15      ;byte count 	  --> reg. B
				;function #	  --> reg. C
	LD   A,2		;source      bank # = 0
				;destination bank # = 2
	CALL ?USERF		;clear current entry
	POP  HL			;^current directory entry --> reg. HL
	LD   DE,32		;offset to next entry     --> reg. DE
	ADD  HL,DE		;add offset
	EX   DE,HL		;^next directory entry    --> reg. DE
	POP  BC			;restore entry count
	DEC  C			;decrement it
	JR   NZ,CLRNXT		;clear next entry
	RET
CLRBYT:	DEFB 0E5H


*EJECT
;hard disk read routine:
DS$READ:LD   A,16  		;function number --> accu
	JR   DS$TASK

;hard disk write routine:
DS$WRITE:
	LD   A,17		;function number --> accu
DS$TASK:LD   (DS$MODE),A	;save function number

;*****************************************************
;* Bad block administration (sector skipping method) *
;* originally written by Andy Johnson-Laird	     *
;* modified by Thomas Holte (c) 1985		     *
;* (you've fooled me with many errors, Andy !!!)     *	
;*****************************************************
SECTORS$PER$TRACK EQU 17
SPARE$LENGTH	  EQU 512 	;170 entries, 3 bytes each

	LD   HL,SPARE$DIRECTORY-3
				;HL -> spare directory

	LD   DE,(@TRK)		;get requested track
	LD   A,(@SECT)		;get sector number

CHECK$ENTRY:
	LD   C,A		;save sector number for later
	LD   B,0   		;set counter

CHECK$ENTRY1:
	INC  HL			;update to next (or first entry)
	INC  HL
	INC  HL

	INC  B			;update count

	CALL CMPM		;compare req. track to table entry

	JR   Z,TRACKS$MATCH	;possible match of track and sector
	JR   NC,COMPUTE$INCREMENT
				;requested track < table entry
	JR   CHECK$ENTRY1	;requested track > table entry

TRACKS$MATCH:
	INC  HL			;HL -> MS byte of track
	INC  HL			;HL -> sector
	LD   A,(HL)		;get sector from table
	DEC  HL
	DEC  HL

	CP   C			;compare with requested sector
	JR   Z,SECTORS$MATCH	;track/sector matches
	JR   NC,COMPUTE$INCREMENT
				;req. trk/sec < spare trk/sec
	JR   CHECK$ENTRY1	;move to next table entry

SECTORS$MATCH:
	INC  B			;if track and sectors match with
				;a table entry, then an additional 
				;sector must be skipped

COMPUTE$INCREMENT:		;B contains number of cumulative
				;number of sectors to skip
	DEC  B			;0 sectors to skip ?
	JP   Z,DS$IO		;if yes, go to physical sector read/write 
	LD   A,C		;get requested sector
	ADD  A,B		;skip required number
	LD   B,SECTORS$PER$TRACK;determine final sector number
				;and track increment
	CALL DIV$A$BY$B		;returns C = quotient, A = remainder
	LD   (@SECT),A          ;A = new sector number

	LD   B,0		;make track increment a word
	EX   DE,HL    		;get requested track
	ADD  HL,BC		;add on increment
	LD   (@TRK),HL		;save updated track
	EX   DE,HL		;get table pointer
	JP   CHECK$ENTRY	;go to physical disk read/write

; DIV$A$BY$B
; Divide A by B
;
; This routine divides A by B, returning the quotient in C
; and the remainder in A.
;
; Entry parameters
;
;	A = dividend
;	B = divisor
;
; Exit parameters
;
;	A = remainder
;	C = quotient
;
DIV$A$BY$B:
	LD   C,0		;initialize quotient
DIV$A$BY$B$LOOP:
	INC  C			;increment quotient
	SUB  B			;subtract divisor
	JP   P,DIV$A$BY$B$LOOP	;repeat if result still +ve
	DEC  C			;correct quotient
	ADD  A,B		;correct remainder
	RET

; CMPM
; Compare memory
;
; This subroutine compares the contents of DE to (HL) and (HL+1)
; returning with the flags as though the subtraction (HL) - DE
; were performed.
;
; Entry parameters
;
;	HL -> word in memory
;	DE =  value to be compared
;
; Exit parameters
;
;	Flags set for (HL) - DE
;
CMPM:	INC  HL
	LD   A,(HL)		;get MS byte
	CP   D
	DEC  HL			;return with HL unchanged
	RET  NZ			;return now if MS bytes unequal
	LD   A,(HL)		;get LS byte
	CP   E
	RET

SPARE$DIRECTORY:
	DEFS SPARE$LENGTH	;spare directory itself
	DEFW -1			;end marker

;*****************************************************

DS$IO:	LD   A,(DS$MODE)	;function #    --> reg. C		
	LD   C,A
	LD   A,(@SECT)		;sector number --> reg. B
	LD   B,A
	LD   A,(@DBNK)		;DMA bank      --> accu (upper nibble)
	SLA  A
	SLA  A
	SLA  A
	SLA  A
	LD   HL,@RDRV		;relative drive number --> accu (lower nibble)
	ADD  A,(HL)
	LD   DE,(@TRK)		;track number	       --> reg. DE
	LD   HL,(@DMA)		;DMA address	       --> reg. HL
	CALL ?USERF		;transfer hard disk sector
	OR   A			;any errors ?
	RET  Z			;return if not
	LD   A,1		;return common error code
	RET
DS$MODE:DEFS 1			;access mode
		

*EJECT
;disk read routine:
FD$READ:LD   A,(@SECT)		;sector number	       --> reg. B
	LD   B,A
	LD   A,(@TRK)		;track number	       --> reg. E
	LD   E,A 
FD$REA1:LD   A,(@RDRV)		;relative drive number --> reg. C
	LD   C,A
	LD   A,(@DBNK)		;DMA bank --> accu (upper nibble)
	SLA  A
	SLA  A
	SLA  A
	SLA  A
	OR   C			;set drive number
	LD   HL,(@DMA)		;user buffer address   --> reg. HL
	LD   C,11		;function number       --> reg. C
	CALL ?USERF		;read physical disk sector
	LD   (DISK$STATUS),A	;save status for error messages
	OR   A			;any errors ?
	JP   NZ,RDERR	
	RET

;suppress error message if BDOS is returning errors to application ...
RDERR:	LD   A,(@ERDME)
	INC  A
	JR   Z,R$HARD$ERROR

;had permanent error, print message like:
;	BIOS Error on d: T-nn, S-nn, <type>, Retry ?
	CALL ?PDERR		;print message header
	LD   HL,(DISK$STATUS)	;get status byte from last error
	LD   H,0
	DEC  L
	ADD  HL,HL		;make byte offset
	LD   BC,R$ERROR$TABLE	;point at table of message addresses
	ADD  HL,BC
	LD   A,(HL)		;get specific message address
	INC  HL
	LD   H,(HL)
	LD   L,A
	CALL ?PMSG		;print message
	LD   HL,ERROR$MSG	;print "<BEL>, Retry (Y/N) ? "
	CALL ?PMSG
	CALL U$CONIN$ECHO	;get operator response
	LD   C,A		;save response
	LD   HL,MSG$END		;disable status line
	CALL ?PMSG	
	LD   A,C		;restore response
	CP   'Y'		;yes, then retry 10 more times
	JP   Z,FD$READ
R$HARD$ERROR:			;otherwise,
	LD   A,1		;return hard error to BDOS
	RET


*EJECT
;disk write routine:
FD$WRITE:
        LD   A,(@SECT)		;sector number	       --> reg. B
	LD   B,A
	LD   A,(@TRK)		;track number	       --> reg. E
	LD   E,A 
FD$WRI1:LD   A,(@RDRV)		;relative drive number --> reg. C
	LD   C,A
	LD   A,(@DBNK)		;DMA bank --> accu (upper nibble)
	SLA  A
	SLA  A
	SLA  A
	SLA  A
	OR   C			;set drive number
	LD   HL,(@DMA)		;user buffer address   --> reg. HL
	LD   C,12		;function number       --> reg. C
	CALL ?USERF		;write physical disk sector
	LD   (DISK$STATUS),A	;save status for error messages
	OR   A			;any errors ?
	JP   NZ,WRERR
	RET

;suppress error message if BDOS is returning errors to application ...
WRERR:	LD   A,(@ERDME)
	INC  A
	JR   Z,W$HARD$ERROR

;had permanent error, print message like:
;	BIOS Error on d: T-nn, S-nn, <type>, Retry ?
	CALL ?PDERR		;print message header
	LD   HL,(DISK$STATUS)	;get status byte from last error
	LD   H,0
	DEC  L
	ADD  HL,HL		;make byte offset
	LD   BC,W$ERROR$TABLE	;point at table of message addresses
	ADD  HL,BC
	LD   A,(HL)		;get specific message address
	INC  HL
	LD   H,(HL)
	LD   L,A
	CALL ?PMSG		;print message
	LD   HL,ERROR$MSG	;print "<BEL>, Retry (Y/N) ? "
	CALL ?PMSG
	CALL U$CONIN$ECHO	;get operator response
	LD   C,A		;save response
	LD   HL,MSG$END		;disable status line
	CALL ?PMSG	
	LD   A,C		;restore response
	CP   'Y'		;yes, then retry 10 more times
	JP   Z,FD$WRITE
W$HARD$ERROR:			;otherwise,
	LD   A,(DISK$STATUS)	;return hard error to BDOS
	CP   5			;diskette write protected ?
	LD   A,1		;common error code
	RET  NZ
	INC  A

;no login and init procedures:
FD$LOGIN:
FD$INIT:
	RET

U$CONIN$ECHO:			;get console input, echo it, and shift to
				;upper case
	CALL ?CONST		;see if any character already struck
	OR   A
	JR   Z,U$C1
	CALL ?CONIN		;yes, eat and try again
	JR   U$CONIN$ECHO
U$C1:	CALL ?CONIN
	PUSH AF
	LD   C,A
	CALL ?CONO
	POP  AF
	CP   'A'
	RET  C
	AND  0DFH   		;make upper case
	RET

DISK$STATUS:
	DEFS 1			;last error status code for messages


*EJECT
;RAM disk I/O routines
M$READ:	LD   A,0FFH		;switch on read flag
	JR   TASKM
M$WRITE:XOR  A			;clear read flag
TASKM:	LD   (RDFLAG),A
	LD   A,(@TRK)		;track # --> accu
	ADD  A,2		;calc source bank #
	ADD  A,A
	ADD  A,A
	ADD  A,A
	ADD  A,A
	LD   HL,@DBNK		;get destination bank # 
	ADD  A,(HL)
	PUSH AF			;save bank numbers
	LD   DE,(@DMA)		;DMA address --> reg. DE
	LD   HL,(@SECT)		;sector #    --> reg. HL
	INC  HL			;adjust it
	LD   B,7		;sector # * 128
	ADD  HL,HL
	DJNZ $-1
	LD   BC,128 SHL 8+15	;sector length --> reg. B
				;function #    --> reg. C
	LD   A,(RDFLAG)		;read or write ?
	OR   A
	JR   NZ,TASKM1		;jump if read
	POP  AF			;restore bank numbers
	RLCA			;swap bank numbers
	RLCA
	RLCA
	RLCA
	PUSH AF			;push bank numbers again
	EX   DE,HL
TASKM1:	POP  AF			;restore bank numbers 
	CALL ?USERF		;transfer "sector"
	XOR  A
	RET
RDFLAG:	DEFS 1


*EJECT
;virtual disk drive:
DCT	EQU  10D7H		;drive control table (SYSTAB)

P$READ:	LD   IX,FD$READ		;read  routine vector     --> reg. IX
	JR   P$TASK
P$WRITE:LD   IX,FD$WRITE	;write routine vector     --> reg. IX
P$TASK:	LD   A,(DRIVEP-2)	;relative drive number	  --> accu
	ADD  A,A		;*2
	LD   C,A		;save it
	ADD  A,A		;*4
	ADD  A,C		;*6
	LD   B,0		;relative drive # * 6	  --> reg. BC
	LD   C,A		
	LD   HL,DCT		;^drive control table     --> reg. HL
	ADD  HL,BC		;calc real pointer 
	PUSH HL			;save DCT pointer
	LD   DE,TDCT		;^temporary storage area  --> reg. DE
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;save disk parameters of drive B:
	LD   HL,PDCT		;^parameters for drive P: --> reg. HL
	POP  DE    		;DCT pointer              --> reg. DE
	PUSH DE			;save DCT pointer again
	LD   BC,5		;number of bytes	  --> reg. BC
	LDIR			;load disk parameters of drive P:
	LD   HL,P$RET		;return address		  --> reg. HL
	PUSH HL			;push it
	JP   (IX)		;jump to driver
P$RET:	LD   HL,TDCT		;restore original disk parameters
	POP  DE
	LD   BC,5
	LDIR
	LD   HL,PDCT+1		;get drive status
	SET  0,(HL)		;set init bit
	RET
TDCT:	DEFS 5			;temporary storage area


*EJECT
;tables of pointers to error message strings
R$ERROR$TABLE:
	DEFW R1MSG
	DEFW R2MSG
	DEFW R3MSG
	DEFW R4MSG
	DEFW R5MSG
	DEFW R6MSG
	DEFW R7MSG
	DEFW R8MSG
	DEFW R9MSG
	
W$ERROR$TABLE:
	DEFW W1MSG
	DEFW W2MSG
	DEFW W3MSG
	DEFW W4MSG
	DEFW W5MSG
	DEFW W6MSG
	DEFW W7MSG
	DEFW W8MSG
	DEFW W9MSG
	
R1MSG:	DEFM ' Illegal drive #,'
	DEFB 0
R2MSG:	DEFM ' Track # too high,'
	DEFB 0
R3MSG:	DEFM ' Sector # too high,'
	DEFB 0
R4MSG:	DEFM ' Device not available,'
	DEFB 0
R5MSG:	DEFB 0
R6MSG:	DEFM ' Locked/deleted record,'
	DEFB 0
R7MSG:  DEFM ' Data record not found,'
	DEFB 0
R8MSG:	DEFM ' Parity error during read,'
	DEFB 0
R9MSG:	DEFM ' Lost data during read,'
	DEFB 0

W1MSG:	DEFM ' Illegal drive #,'
	DEFB 0
W2MSG:	DEFM ' Track # too high,'
	DEFB 0
W3MSG:	DEFM ' Sector # too high,'
	DEFB 0
W4MSG:	DEFM ' Device not available,'
	DEFB 0
W5MSG:	DEFM ' Write protected diskette,'
	DEFB 0
W6MSG:	DEFM ' Write fault on disk drive,'
	DEFB 0
W7MSG:  DEFM ' Data record not found,'
	DEFB 0
W8MSG:	DEFM ' Parity error during write,'
	DEFB 0
W9MSG:	DEFM ' Lost data during write,'
	DEFB 0

ERROR$MSG:
	DEFM ' Retry (Y/N) ? '
	DEFB 0

MSG$END:DEFB SUB,ESC,'D',0

	END
gh nibble)
;	     destination page (low  nibble)
;	     0 = graphic page 0
;	     1 = graphic page 1
;	     F = user buffer
;		 (user/user [FF] = invalid combination)
;	HL = ^parameter block (x1, y1, x2, y2, dx, dy
;			    or x2, y2, dx, dy
;			    or x1, y1, dx, dy)
;	DE = ^user buffer

;copy graphic area:
$COPY:	LD   (UBUF),DE		;save ^user buffer
	LD   C,A		;save source page
	AND  0FH		;mask it
	CP   0FH		;destination == user buffer ?
	JP   Z,COPY17		;jump if yes
	PUSH AF
	LD   A,C		;restore source page
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	CP   0FH		;source == user buffer ?
	JP   Z,COPY10		;jump if yes
	PUSH AF
	
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X1		;^parameter block --> reg. DE
	LD   B,12		;byte count       --> reg. BC	
	CALL $XMOVE		;get coordinates

*EJECT
;copy on screen:
Љ;setup variables:
	LD   HL,(X1)		;xb1 = x1
	LD   (XB1),HL
	LD   HL,(X2)		;xb2 = x2
	LD   (XB2),HL

;determine copy direction of x-coordinate:
	LD   DE,(X1)
  ;******************************************************************************
;*  D R I V E R  *  C P M S Y S 1  *  T h o m a s   H o l t e  *  8 6 0 1 1 3 *
;******************************************************************************
;*									      *
;*  	   I / O - D R I V E R S   F O R   T H E   G E N I E  I I I s         *
;*	   ==========================================================         *
;*									      *
;*  		    M I C R O C O M P U T E R   S Y S T E M 		      *
;*		    =======================================		      *
;*									      *
;*									      *
;*  Thomas Holte			                         Version 1.1  *
;*									      *
;******************************************************************************

	.Z80
	.SALL

SASI	EQU  1   		;must be true, if Xebec controller installed

	ASEG

;******************************************************************************
;*  		  B A N K E D   P A R T   O F   D R I V E R S		      *
;******************************************************************************

 	ORG  0000H		;start of 56K bank 0


;ASCII control codes:
NUL	EQU  00H		;null
SOH	EQU  01H		;start of heading
STX	EQU  02H		;start of text
ETX	EQU  03H		;end of text
EOT	EQU  04H		;end of transmission
ENQ	EQU  05H		;enquiry
ACK	EQU  06H		;acknowledge
BEL	EQU  07H		;bell
BS	EQU  08H		;backspace
HT	EQU  09H		;horizontal tabulation
LF	EQU  0AH		;line feed
VT	EQU  0BH		;vertical tabulation
FF	EQU  0CH		;form feed
CR	EQU  0DH		;carriage return
SO	EQU  0EH		;shift out
SI	EQU  0FH		;shift in
DLE	EQU  10H		;data link escape
DC1	EQU  11H		;device control 1
DC2	EQU  12H		;device control 2
DC3	EQU  13H		;device control 3
DC4	EQU  14H		;device control 4
NAK	EQU  15H		;negative acknowledge
SYN	EQU  16H		;synchronous idle
ETB	EQU  17H		;end of transmission block
CAN	EQU  18H		;cancel
EM	EQU  19H		;end of medium
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape
FS	EQU  1CH		;file separator
GS	EQU  1DH		;group separator
RS	EQU  1EH		;record separator
DEL	EQU  7FH		;delete
	

;common entry point for all driver routines
	PUSH BC			;save contents of reg. B & HL
	PUSH HL
	LD   B,0		;vector # * 2 --> reg. BC
	SLA  C
	LD   HL,DRITBL		;base of vector table --> reg. IX
	ADD  HL,BC		;calc table entry
	LD   C,(HL)		;get entry point of driver routine
	INC  HL
	LD   B,(HL)
	PUSH BC
	POP  IX
	POP  HL			;restore contents of reg. B & HL
	POP  BC
	JP   (IX)		;execute driver	routine

	ORG  0036H		;interrupt entry point - 2
	DEFW 0			;checksumm of serial #
      	JP   $INT		;jump to interrupt service routine

;table of driver addresses:
DRITBL:	DEFW $VDINIT		;initialize video  controller chip M6845
	DEFW $RSINIT		;initialize RS232C controller chip SIO
	DEFW $KBCHAR		;get a keyboard character if available
	DEFW $KBWAIT		;wait for keyboard character
	DEFW $VDCHAR		;display a character
	DEFW $PRSTAT		;test printer status
	DEFW $PRCHAR		;output a character to the printer
	DEFW $RSRCST		;test RS232C input status
	DEFW $RSRCV		;receive a character from the RS232C interface
	DEFW $RSTXST		;test RS232C output status
	DEFW $RSTX  		;transmit a character to the RS232C interface
	DEFW $READ		;read a sector
	DEFW $WRITE		;write a sector
	DEFW $GETTIM		;get time and date in ASCII format
	DEFW $SETTIM		;set time and date in binary format
	DEFW $XMOVE		;read/write system data
	DEFW $READW		;read a Winchester sector
	DEFW $WRITW		;write a Winchester sector
$GTIME3:DEFW $GTIME3S		;get time and date in CP/M 3 format
$STIME3:DEFW $STIME3S		;set time and date in CP/M 3 format
	DEFW $LDCHAR		;load character pattern
	DEFW $RSTCHR		;restore original character set
	DEFW $SCRNIO		;direct screen I/O
	DEFW $INIT		;general initialization routine
	DEFW $CLOCK		;display time continuously
	DEFW $DISP		;turn on/off graphic display
	DEFW $CLS		;clear graphic screen
	DEFW $PLOT		;plot dot    on graphic screen
	DEFW $POINT		;read dot  from graphic screen
	DEFW $LINE		;draw line   on graphic screen
	DEFW $CIRCLE		;draw circle on graphic screen
	DEFW $ARC		;draw arc    on graphic screen
	DEFW $FILL		;fill shape (not implemented yet)
	DEFW $COPY		;copy area


*EJECT
	ORG  0100H
;******************************************************************************
;*			     	  S Y S T A B				      *
;******************************************************************************

DELAY1: DEFW 500   		;determines debounce time (start of key press)
DELAY2: DEFW 5000  		;determines debounce time (end   of key press)
DELAY3: DEFW 35    		;determines wait time until key autorepeats
DELAY4:	DEFW 3  		;determines frequency of auto repeat
KEYTAB:	DEFW NBOARD		;contains ^(keyboard table)

;table contains codes for all caps (may be altered by user):
NBOARD:

;address 3801H (letter keys):
	DEFB '@','`',NUL	;@, SHIFT-@, CTRL-@
	DEFB 'a','A',SOH	;A, SHIFT-A, CTRL-A
	DEFB 'b','B',STX	;B, SHIFT-B, CTRL-B
	DEFB 'c','C',ETX	;C, SHIFT-C, CTRL-C
	DEFB 'd','D',EOT	;D, SHIFT-D, CTRL-D
	DEFB 'e','E',ENQ	;E, SHIFT-E, CTRL-E
	DEFB 'f','F',ACK	;F, SHIFT-F, CTRL-F
	DEFB 'g','G',BEL	;G, SHIFT-G, CTRL-G

;address 3802H (letter keys):
	DEFB 'h','H',BS 	;H, SHIFT-H, CTRL-H
	DEFB 'i','I',HT 	;I, SHIFT-I, CTRL-I
	DEFB 'j','J',LF 	;J, SHIFT-J, CTRL-J
	DEFB 'k','K',VT 	;K, SHIFT-K, CTRL-K
	DEFB 'l','L',FF 	;L, SHIFT-L, CTRL-L
	DEFB 'm','M',CR 	;M, SHIFT-M, CTRL-M
	DEFB 'n','N',SO 	;N, SHIFT-N, CTRL-N
	DEFB 'o','O',SI 	;O, SHIFT-O, CTRL-O

;address 3804H (letter keys):
	DEFB 'p','P',DLE	;P, SHIFT-P, CTRL-P
	DEFB 'q','Q',DC1	;Q, SHIFT-Q, CTRL-Q
	DEFB 'r','R',DC2	;R, SHIFT-R, CTRL-R
	DEFB 's','S',DC3	;S, SHIFT-S, CTRL-S
	DEFB 't','T',DC4	;T, SHIFT-T, CTRL-T
	DEFB 'u','U',NAK	;U, SHIFT-U, CTRL-U
	DEFB 'v','V',SYN	;V, SHIFT-V, CTRL-V
	DEFB 'w','W',ETB	;W, SHIFT-W, CTRL-W

;address 3808H (letter keys):
	DEFB 'x','X',CAN	;X, SHIFT-X, CTRL-X
	DEFB 'y','Y',EM 	;Y, SHIFT-Y, CTRL-Y
	DEFB 'z','Z',SUB	;Z, SHIFT-Z, CTRL-Z
	DEFB '[','{',ESC	;[, SHIFT-[, CTRL-[
	DEFB '\','|',FS 	;\, SHIFT-\, CTRL-\
	DEFB ']','}',GS 	;], SHIFT-], CTRL-]
	DEFB '^','~',RS 	;^, SHIFT-^, CTRL-^
	DEFB '_','^',RS 	;_, SHIFT-_, CTRL-_

;address 3810H (number keys):
	DEFB '0','0',0  	;0, SHIFT-0, CTRL-0
	DEFB '1','!',0  	;1, SHIFT-1, CTRL-1
	DEFB '2','"',0  	;2, SHIFT-2, CTRL-2
	DEFB '3','#',0  	;3, SHIFT-3, CTRL-3
	DEFB '4','$',0  	;4, SHIFT-4, CTRL-4
	DEFB '5','%',0  	;5, SHIFT-5, CTRL-5
	DEFB '6','&',0  	;6, SHIFT-6, CTRL-6
	DEFB '7','''',0 	;7, SHIFT-7, CTRL-7

;address 3820H (number & special keys):
	DEFB '8','(',0  	;8, SHIFT-8, CTRL-8
	DEFB '9',')',0  	;9, SHIFT-9, CTRL-9
	DEFB ':','*',0  	;:, SHIFT-:, CTRL-:
	DEFB ';','+',0  	;;, SHIFT-;, CTRL-;
	DEFB ',','<',0  	;,, SHIFT-,, CTRL-,
	DEFB '-','=',0  	;-, SHIFT--, CTRL--
	DEFB '.','>',0  	;., SHIFT-., CTRL-.
	DEFB '/','?',0 		;/, SHIFT-/, CTRL-/

;address 3840H (special keys):	
	DEFB CR,CR,0    	;NEWLINE   , SHIFT-NEWLINE   , CTRL-NEWLINE
	DEFB DEL,0FCH,0 	;CLEAR     , SHIFT-CLEAR     , CTRL-CLEAR
	DEFB ESC,0FDH,0 	;BREAK     , SHIFT-BREAK     , CTRL-BREAK
	DEFB STX,VT,ETB 	;UP-ARROW  , SHIFT-UP-ARROW  , CTRL-UP-ARROW
	DEFB LF,ETX,SUB 	;DOWN-ARROW, SHIFT-DOWN-ARROW, CTRL-DOWN-ARROW
	DEFB SOH,CAN,BS  	;LEFT-ARROW, SHIFT-LEFT-ARROW, CTRL-LEFT-ARROW
	DEFB ACK,HT,BEL  	;RGHT-ARROW, SHIFT-RGHT-ARROW, CTRL-RGHT-ARROW
	DEFB ' ',' ',0 		;SPACE     , SHIFT-SPACE     , CTRL-SPACE

;address 38A0H (function keys):	
	DEFB 80H,80H,0  	;F1, SHIFT-F1, CTRL-F1
	DEFB 81H,81H,0  	;F2, SHIFT-F2, CTRL-F2
	DEFB 82H,82H,0  	;F3, SHIFT-F3, CTRL-F3
	DEFB 83H,83H,0  	;F4, SHIFT-F4, CTRL-F4
	DEFB 84H,84H,0  	;F5, SHIFT-F5, CTRL-F5
	DEFB 85H,85H,0  	;F6, SHIFT-F6, CTRL-F6
	DEFB 86H,86H,0  	;F7, SHIFT-F7, CTRL-F7
	DEFB 87H,87H,0 		;F8, SHIFT-F8, CTRL-F8

;address 38C0H (number keys [numeric keypad]):	
	DEFB '0','0',0  	;1, SHIFT-1, CTRL-1
	DEFB '1','1',0  	;2, SHIFT-2, CTRL-2
	DEFB '2','3',0  	;3, SHIFT-3, CTRL-3
	DEFB '3','3',0  	;4, SHIFT-4, CTPL-4
	DEFB '4','4',0  	;5, SHIFT-5, CTRL-5
	DEFB '5','5',0  	;6, SHIFT-6, CTRL-6
	DEFB '6','6',0  	;7, SHIFT-7, CTRL-7
	DEFB '7','7',0 		;8, SHIFT-8, CTRL-8

;address 3880H (function keys & escape key):
	DEFB 0,0,0      	;SHIFT
	DEFB 0,0,0      	;CTRL
	DEFB ESC,ESC,0  	;ESC
	DEFB 8CH,8CH,0  	;P5, SHIFT-P5, CTRL-P5
	DEFB 8BH,8BH,0  	;P4, SHIFT-P4, CTRL-P4
	DEFB 8AH,8AH,0  	;P3, SHIFT-P3, CTRL-P3
	DEFB 89H,89H,0  	;P2, SHIFT-P2, CTRL-P2
	DEFB 88H,88H,0 		;P1, SHIFT-P1, CTRL-P1

;address 38E0H (number & special keys [numeric keypad]):	
	DEFB '8','8',0  	;8 , SHIFT-8 , CTRL-8
	DEFB '9','9',0  	;9 , SHIFT-9 , CTRL-9
	DEFB 0FEH,0FEH,0	;00, SHIFT-00, CTRL-00
	DEFB 0,0,0      	;LOCK
	DEFB ',',',',0  	;, , SHIFT-, , CTRL-,
	DEFB '-','-',0  	;- , SHIFT-- , CTRL--
	DEFB '.','.',0  	;. , SHIFT-. , CTRL-.
	DEFB 0,0FBH,0		;SHIFT-PRINT


*EJECT
;table contains codes for all caps (special WordStar version):
WBOARD:

;address 3801H (letter keys):
	DEFB '@','`',NUL	;@, SHIFT-@, CTRL-@
	DEFB 'a','A',SOH	;A, SHIFT-A, CTRL-A
	DEFB 'b','B',STX	;B, SHIFT-B, CTRL-B
	DEFB 'c','C',ETX	;C, SHIFT-C, CTRL-C
	DEFB 'd','D',EOT	;D, SHIFT-D, CTRL-D
	DEFB 'e','E',ENQ	;E, SHIFT-E, CTRL-E
	DEFB 'f','F',ACK	;F, SHIFT-F, CTRL-F
	DEFB 'g','G',BEL	;G, SHIFT-G, CTRL-G

;address 3802H (letter keys):
	DEFB 'h','H',BS 	;H, SHIFT-H, CTRL-H
	DEFB 'i','I',HT 	;I, SHIFT-I, CTRL-I
	DEFB 'j','J',LF 	;J, SHIFT-J, CTRL-J
	DEFB 'k','K',VT 	;K, SHIFT-K, CTRL-K
	DEFB 'l','L',FF 	;L, SHIFT-L, CTRL-L
	DEFB 'm','M',CR 	;M, SHIFT-M, CTRL-M
	DEFB 'n','N',SO 	;N, SHIFT-N, CTRL-N
	DEFB 'o','O',SI 	;O, SHIFT-O, CTRL-O

;address 3804H (letter keys):
	DEFB 'p','P',DLE	;P, SHIFT-P, CTRL-P
	DEFB 'q','Q',DC1	;Q, SHIFT-Q, CTRL-Q
	DEFB 'r','R',DC2	;R, SHIFT-R, CTRL-R
	DEFB 's','S',DC3	;S, SHIFT-S, CTRL-S
	DEFB 't','T',DC4	;T, SHIFT-T, CTRL-T
	DEFB 'u','U',NAK	;U, SHIFT-U, CTRL-U
	DEFB 'v','V',SYN	;V, SHIFT-V, CTRL-V
	DEFB 'w','W',ETB	;W, SHIFT-W, CTRL-W

;address 3808H (letter keys):
	DEFB 'x','X',CAN	;X, SHIFT-X, CTRL-X
	DEFB 'y','Y',EM 	;Y, SHIFT-Y, CTRL-Y
	DEFB 'z','Z',SUB	;Z, SHIFT-Z, CTRL-Z
	DEFB '[','{',ESC	;[, SHIFT-[, CTRL-[
	DEFB '\','|',FS 	;\, SHIFT-\, CTRL-\
	DEFB ']','}',GS 	;], SHIFT-], CTRL-]
	DEFB '^','~',RS 	;^, SHIFT-^, CTRL-^
	DEFB '_','^',RS 	;_, SHIFT-_, CTRL-_

;address 3810H (number keys):
	DEFB '0','0',0  	;0, SHIFT-0, CTRL-0
	DEFB '1','!',0  	;1, SHIFT-1, CTRL-1
	DEFB '2','"',0  	;2, SHIFT-2, CTRL-2
	DEFB '3','#',0  	;3, SHIFT-3, CTRL-3
	DEFB '4','$',0  	;4, SHIFT-4, CTRL-4
	DEFB '5','%',0  	;5, SHIFT-5, CTRL-5
	DEFB '6','&',0  	;6, SHIFT-6, CTRL-6
	DEFB '7','''',0 	;7, SHIFT-7, CTRL-7

;address 3820H (number & special keys):
	DEFB '8','(',0  	;8, SHIFT-8, CTRL-8
	DEFB '9',')',0  	;9, SHIFT-9, CTRL-9
	DEFB ':','*',0  	;:, SHIFT-:, CTRL-:
	DEFB ';','+',0  	;;, SHIFT-;, CTRL-;
	DEFB ',','<',0  	;,, SHIFT-,, CTRL-,
	DEFB '-','=',0  	;-, SHIFT--, CTRL--
	DEFB '.','>',0  	;., SHIFT-., CTRL-.
	DEFB '/','?',0 		;/, SHIFT-/, CTRL-/

;address 3840H (special keys):	
	DEFB CR,CR,0    	;NEWLINE   , SHIFT-NEWLINE   , CTRL-NEWLINE
	DEFB 8DH,8EH,DEL	;CLEAR     , SHIFT-CLEAR     , CTRL-CLEAR
				;CLEAR 	     = erase to end of line
				;SHIFT-CLEAR = erase to start of line
				;CTRL -CLEAR = erase previous character
	DEFB NAK,0FDH,0  	;BREAK     , SHIFT-BREAK     , CTRL-BREAK
				;BREAK = abort current operation
	DEFB ENQ,8FH,90H 	;UP-ARROW  , SHIFT-UP-ARROW  , CTRL-UP-ARROW
				;      UP-ARROW = cursor up
				;SHIFT-UP-ARROW = start of text
				;CTRL -UP-ARROW = start of screen
	DEFB CAN,91H,92H 	;DOWN-ARROW, SHIFT-DOWN-ARROW, CTRL-DOWN-ARROW
				;      DOWN-ARROW = cursor down
				;SHIFT-DOWN-ARROW = end of text
				;CTRL -DOWN-ARROW = end of screen
	DEFB DC3,93H,SOH 	;LEFT-ARROW, SHIFT-LEFT-ARROW, CTRL-LEFT-ARROW
				;      LEFT-ARROW = cursor left
				;SHIFT-LEFT-ARROW = start of line
				;CTRL -LEFT-ARROW = word left
	DEFB EOT,94H,ACK  	;RGHT-ARROW, SHIFT-RGHT-ARROW, CTRL-RGHT-ARROW
				;      RIGHT-ARROW = cursor right
				;SHIFT-RIGHT-ARROW = end of line
				;CTRL -RIGHT-ARROW = word right
	DEFB ' ',' ',95H	;SPACE     , SHIFT-SPACE     , CTRL-SPACE
				;CTRL-SPACE = hard space

;address 38A0H (function keys):	
	DEFB SYN,SYN,0  	;F1, SHIFT-F1, CTRL-F1
				;F1 = toggle insert mode
	DEFB SO,SO,0    	;F2, SHIFT-F2, CTRL-F2
				;F2 = insert line
	DEFB BEL,BEL,0  	;F3, SHIFT-F3, CTRL-F3
				;F3 = delete character
	DEFB DC4,DC4,0  	;F4, SHIFT-F4, CTRL-F4
				;F4 = delete word
	DEFB EM,EM,0   		;F5, SHIFT-F5, CTRL-F5
				;F5 = delete line
	DEFB STX,STX,0  	;F6, SHIFT-F6, CTRL-F6
				;F6 = reformat paragraph
	DEFB 96H,96H,0  	;F7, SHIFT-F7, CTRL-F7
				;F7 = toggle hyphen help
	DEFB 97H,97H,0  	;F8, SHIFT-F8, CTRL-F8
				;F8 = toggle right justifying

;address 38C0H (number keys [numeric keypad]):	
	DEFB '0','0',0  	;1, SHIFT-1, CTRL-1
	DEFB '1','1',0  	;2, SHIFT-2, CTRL-2
	DEFB '2','3',0  	;3, SHIFT-3, CTRL-3
	DEFB '3','3',0  	;4, SHIFT-4, CTRL-4
	DEFB '4','4',0  	;5, SHIFT-5, CTRL-5
	DEFB '5','5',0  	;6, SHIFT-6, CTRL-6
	DEFB '6','6',0  	;7, SHIFT-7, CTRL-7
	DEFB '7','7',0 		;8, SHIFT-8, CTRL-8

;address 3880H (function keys & escape key):
	DEFB 0,0,0      	;SHIFT
	DEFB 0,0,0      	;CTRL
	DEFB ESC,ESC,0  	;ESC
	DEFB ETX,ETX,0 		;P5, SHIFT-P5, CTRL-P5
				;P5 = page down
	DEFB DC2,DC2,0  	;P4, SHIFT-P4, CTRL-P4
				;P4 = page up	
	DEFB SUB,SUB,0  	;P3, SHIFT-P3, CTRL-P3
				;P3 = line down
	DEFB ETB,ETB,0  	;P2, SHIFT-P2, CTRL-P2
				;P2 = line up
	DEFB HT,HT,0    	;P1, SHIFT-P1, CTRL-P1
				;P1 = TAB

;address 38E0H (number & special keys [numeric keypad]):	
	DEFB '8','8',0  	;8 , SHIFT-8 , CTRL-8
	DEFB '9','9',0  	;9 , SHIFT-9 , CTRL-9
	DEFB 0FEH,0FEH,0	;00, SHIFT-00, CTRL-00
	DEFB 0,0,0      	;LOCK
	DEFB ',',',',0  	;, , SHIFT-, , CTRL-,
	DEFB '-','-',0  	;- , SHIFT-- , CTRL--
	DEFB '.','.',0  	;. , SHIFT-. , CTRL-.
	DEFB 0,0FBH,0		;SHIFT-PRINT


*EJECT
VECTOR:	DEFW FKEYS 		;function key vector

OFFSET  DEFL 0			;initialize offset

FKEYS:	REPT 13			;function key pointer
	DEFW F0+OFFSET
OFFSET	DEFL OFFSET+81
	ENDM
	DEFW ERAEND,ERABEG,SOTXT,SOCRT,EOTXT,EOCRT
	DEFW SOLIN,EOLIN,HSPACE,HYPHEN,JSTIFY

F0:
;	.XLIST
   	REPT 13			;function key buffer
	DEFB 1
	REPT 80
	DEFB 0
	ENDM
	ENDM
	.LIST

;special WordStar part:
ERAEND:	DEFB 2			;erase to end of line
	DEFB DC1,'Y',0
ERABEG:	DEFB 2			;erase to start of line
	DEFB DC1,DEL,0
SOTXT:	DEFB 2			;start of text
	DEFB DC1,'R',0
SOCRT:	DEFB 2			;start of screen
	DEFB DC1,'E',0
EOTXT:	DEFB 2			;end of text
	DEFB DC1,'C',0
EOCRT:	DEFB 2			;end of screen
	DEFB DC1,'X',0
SOLIN:	DEFB 2			;start of line
	DEFB DC1,'S',0
EOLIN:	DEFB 2			;end of line
	DEFB DC1,'D',0
HSPACE:	DEFB 2			;hard space
	DEFB DLE,'O',0
HYPHEN:	DEFB 2			;toggle hyphen help
	DEFB SI,'H',0
JSTIFY:	DEFB 2			;toggle right justifying
	DEFB SI,'J',0
		

*EJECT
;table of control codes:
;  first byte = 0    	single ASCII control code
;  first byte = 0FFH	escape sequence

TAB1S:	DEFB 0,BEL		;beep
	DEFB 0,BS		;cursor left
	DEFB 0,LF		;cursor down
	DEFB 0,VT		;cursor up
	DEFB 0,FF		;cursor right
	DEFB 0,CR		;carriage return
	DEFB 0,RS		;home cursor
TAB2S:	DEFB 0FFH,'='		;absolute cursor addressing

	DEFB 0FFH,'F'		;select window
	DEFB 0FFH,'I'		;set top line
	DEFB 0FFH,'J'		;set bottom line
	DEFB 0FFH,'K'		;set left column
	DEFB 0FFH,'L'		;set right column

TAB2E:	DEFB 0FFH,' '		;set erase character
	DEFB 0FFH,FF		;cursor off
	DEFB 0FFH,CR		;cursor on
	DEFB 0FFH,'A'		;ASCII character set
	DEFB 0FFH,'D'		;disable status line
	DEFB 0FFH,'E'		;enable status line
	DEFB 0FFH,'G'		;German character set
	DEFB 0FFH,'N'		;normal keyboard
	DEFB 0FFH,'O'		;WordStar keyboard			
	DEFB 0FFH,'R'		;inverse display mode
	DEFB 0FFH,'S'		;normal display mode
	DEFB 0FFH,'X'		;turn on wrap around mode
	DEFB 0FFH,'Y'		;turn off wrap around mode

	DEFB 0FFH,'P'		;insert character
	DEFB 0FFH,'V'		;insert line
	DEFB 0FFH,'Q'		;delete char
	DEFB 0,CAN		;erase to end of line
	DEFB 0FFH,'W'		;delete line
	DEFB 0,EM		;erase to end of screen
TAB1E:	DEFB 0,SUB		;clear screen	


*EJECT
	INCLUDE FONT12		;font set

;drive control tables (5 inch):

;drive 0:
DCT:    DEFB 01110000B          ;bit 7   : reserved
                                ;bit 6   : no. of         0 = single sided
                                ;          surfaces       1 = double sided
                                ;bit 5   : density        0 = single density
                                ;                         1 = double density
                                ;bit 4   : desity of      0 = single density
                                ;          first track    1 = double density
                                ;bit 3   : no. of first   0 = zero
                                ;          sec. on track  1 = one
                                ;bit 2   : steps per      0 = one step
                                ;          trk to trk     1 = two steps
                                ;bits 1,0: track stepping rate
                                ;          0 =  3 msec    1 =  6 msec
                                ;          2 = 10 msec    3 = 15 msec
        DEFB 10000000B          ;bits 7,6: sector length
                                ;          0 = 128 bytes  1 =  256 bytes
                                ;          2 = 512 bytes  3 = 1024 bytes
                                ;bit 5   : 0 = new sector numbering on backside
                                ;          1 = sector numbering continued on
                                ;              backside
                                ;bit 0   : drive status (used by disk driver --
                                ;                        do not alter)
        DEFB 2                  ;interleaving factor
        DEFB 20                 ;sector count per track
        DEFB 80                 ;number of usable tracks
        DEFB 0                  ;current track

;drive 1:
        DEFB 01110000B
        DEFB 10000000B
        DEFB 2
        DEFB 20
        DEFB 80
        DEFB 0

;drive 2:
        DEFB 01110000B,10000000B,2,20,80,0

;drive 3:
        DEFB 01110000B,10000000B,2,20,80,0


;drive control tables (8 inch)

;drive 0:
        DEFB 00001010B
        DEFB 00000000B
        DEFB 1
        DEFB 26
        DEFB 77
        DEFB 0

;drive 1:
        DEFB 00001010B,00000000B,1,26,77,0

;drive 2:
        DEFB 00001010B,00000000B,1,26,77,0

;drive 3:
        DEFB 00001010B,00000000B,1,26,77,0


TRYS:   DEFB 10                 ;# of times to try I/O until routine gives up


*EJECT
;Winchester disk control tables:

;drive 0:
DCTW:   DEFB 01100000B          ;bits 7-5: no. of surfaces
                                ;          0 = one   head    4 = five  heads
                                ;          1 = two   heads   5 = six   heads
                                ;          2 = three heads   6 = seven heads
                                ;          3 = four  heads   7 = eight heads
                                ;bit 4   : no. of first      0 = zero
                                ;          sector on track   1 = one
                                ;bits 3-0: track stepping rate
                                ;0 = 35  usec    6 = 3.0 msec   11 = 5.5 msec
                                ;1 = 0.5 msec    7 = 3.5 msec   12 = 6.0 msec
				;2 = 1.0 msec    8 = 4.0 msec   13 = 6.5 msec
				;3 = 1.5 msec    9 = 4.5 msec   14 = 7.0 msec
				;4 = 2.0 msec   10 = 5.0 msec   15 = 7.5 msec
				;5 = 2.5 msec
        DEFB 01000000B          ;bits 7,6: sector length
                                ;          0 =  256 bytes  1 = 512 bytes
                                ;          2 = 1024 bytes  3 = 128 bytes
                                ;bit 0   : drive status (used by disk driver --
                                ;                        do not alter)
	DEFB 32   		;starting track for write precomp / 4
        DEFB 1                  ;interleaving factor
        DEFB 17                 ;sector count per track
        DEFW 1224               ;number of usable tracks

;drive 1:
        DEFB 00100000B
        DEFB 10000000B
        DEFB 0FFH
        DEFB 1 
        DEFB 9
        DEFW 612

;drive 2:
        DEFB 00100000B,01000000B,0,1,16
        DEFW 1224


*EJECT
;powerup/reset parameters:

;powerup/reset marker:
POWUP:	DEFS 1

;table of video parameters:
VIDPAR: DEFB 110		;horizontal total
	DEFB 80			;horizontal displayed
	DEFB 86			;h sync position
	DEFB 10			;h sync width
	DEFB 28			;vertical total
	DEFB 4			;v total adjust
	DEFB 25  		;vertical displayed
	DEFB 25			;v sync position
	DEFB 0			;interlace mode (non interlace)
	DEFB 10			;max scan line address
	DEFB 6AH		;cursor start
	DEFB 10			;cursor end
	DEFB 0  		;start address (H)
	DEFB 0			;start address (L)
	DEFB 0			;cursor (H)
   	DEFB 0			;cursor (L)

;character set:
CHRSET:	DEFB 'A'		;'A' = ASCII  character set
				;'G' = German character set

;RS-232-C parameters:
SER0:	DEFB 11000100B
	DEFB 8

SER1:	DEFB 11000100B
	DEFB 8

;clock ?
CLOCK:	DEFB 0			;0 = software clock
				;1 = hardware clock 


*EJECT
;*******************
;*  $ V D I N I T  *
;*******************

;entry: HL = address of video parameter table

;  struct {
;	    char R0, R1, R2 , R3 , R4 , R5 , R6 , R7 ,
;		 R8, R9, R10, R11, R12, R13, R14, R15;
;	  } *HL;

;  R0  = This 8 bit write-only register determines the horizontal frequency of
;	 HS. It is the total of displayed plus non-displayed character time
;	 units minus one.
;  R1  = This 8 bit write-only register determines the number of displayed 
;	 characters per horizontal line.
;  R2  = This 8 bit write-only register determines the horizontal sync position
;	 on the horizontal line.
;  R3  = This 4 bit write-only register determines the width of the HS pulse.
;	 It may not be apparent why this width needs to be programmed. However,
;	 consider that all timing widths must be programmed as multiples of the
;	 character clock period which varies. If HS width were fixed as an
;	 integral number of character times, it would vary with character rate
;	 and be out of tolerance for certain monitors. The rate programmable
;	 feature allows compensating HS width.
;  R4
;  R5  = The vertical frequency of VS is determined by both R4 and R5. The
;	 calculated number of character line times is usually an integer plus a
;	 fraction to get exactly a 50 or 60 Hz vertical refresh rate. The
;	 integer number of character line times minus one is programmed in the
;	 7 bit write-only Vertical Total Register (R4); the fraction is
;	 programmed in the 5 bit write-only Vertical Scan Adjust Register (R5)
;	 as a number of scan line times.
;  R6  = This 7 bit write-only register determines the number of displayed
;	 character rows on the CRT screen, and is programmed in character row
;	 times.
;  R7  = This 7 bit write-only register determines the vertical sync position
;	 with respect to the reference. It is programmed in character row
;	 times.
;  R8  = This 2 bit write-only register controls the raster scan mode. When bit
;	 0 and bit 1 are reset, or bit 0 is reset and bit 1 set, the non-
;	 interlace raster scan mode is selected. Two interlace modes are
;	 available. Both are interlaced 2 fields per frame. When bit 0 is set
;	 and bit 1 is reset, the interlace sync raster scan mode is selected.
;	 Also when bit 0 and bit 1 are set, the interlace sync and video raster
;	 scan mode is selected.
;  R9  = This 5 bit write-only register determines the number of scan lines per
;	 character row including spacing. The programmed value is a max address
;	 and is one less than the number of scan lines.
;  R10 = This 7 bit write-only register controls the cursor format. Bit 5 is
;	 the blink timing control. When bit 5 is low, the blink frequency is
;	 1/16 of the vertical field rate, and when bit 5 is high, the blink
;	 frequency is 1/32 of the vertical field rate. Bit 6 is used to enable
;	 a blink. The cursor start scan line is set by the lower 5 bits.
;  R11 = This 5 bit write-only register sets the cursor end scan line.
;  R12
;  R13 = Start Address Register is a 14 bit write-only register which
;	 determines the first address put out as a refresh address after
;	 vertical blanking. It consists of an 8 bit lower register (R13), and a
;	 6 bit higher register (R12).
;  R14
;  R15 = This 14 read/write register stores the cursor location. This register
; 	 consists of an 8 bit lower (R15) and 6 bit higher (R14) register.
 
$CRTREG EQU  0F6H		;CRT controller address register
$CRTCMD EQU  0F7H		;CRTC command register

;initialize the video controller chip M6845:
$VDINIT:LD   A,10H		;source      bank = 1
				;destination bank = 0
VDINIT1:LD   DE,$VIDPAR		;^temp buffer 		   --> reg. DE
	LD   B,16		;length of parameter table --> reg. B
	CALL $XMOVE		;get video parameter table
        LD   BC,1000H		;CRTC register count       --> reg.  B
				;CRTC start register       --> reg.  C
	LD   HL,$VIDPAR		;^video parameter table    --> reg. HL
OUTCMD:	LD   A,C		;CRTC register no.         --> accu
       	OUT  ($CRTREG),A	;select CRTC register
	LD   A,(HL)		;video parameter --> accu
	OUT  ($CRTCMD),A	;output CRTC command
	INC  HL			;bump ^video parameter
	INC  C			;increment CRTC register no.
	DJNZ OUTCMD		;output 16 parameters
	LD   A,($VIDPAR+10)	;get control byte for cursor start
	LD   (CURBEG),A		;store it for subsequent use
	RET  			;return to caller

CURBEG:	DEFS 1			;temporary storage for cursor start byte
$VIDPAR:DEFS 16     		;temporary buffer for video parameter table


*EJECT
;*******************
;*  $ R S I N I T  *
;*******************

;entry: B = number  of RS232C interface (0, 1)
;	A = data format
;	E = baud rate

;  A
;  Bit    0: 0 = no   parity
;	     1 =      parity
;  Bit    1: 0 = odd  parity
;	     1 = even parity
;  Bits 3-2: 1 = 1   stop bit
;	     2 = 1.5 stop bits
;            3 = 2   stop bits
;  Bits 7-6: 0 = 5 bits word length
;	     1 = 7 bits word length
;	     2 = 6 bits word length
;	     3 = 8 bits word length

;  	    Desired Baud Rate  | reg. E
;	  =====================|=======
;          	 50	       |   2
;          	 75	       |   3
;	      	110	       |  15
;	  	134.5	       |   4
;	  	150	       |  14
;		200	       |   5
;	  	300	       |  13
;	  	600	       |   6
;	       1200	       |  11
;	       1800	       |  10
;	       2400	       |   7
;	       4800	       |   9
;	       9600	       |   8
;	      19200	       |   0


RATE	EQU  0F1H		;baud rate register
BTx  	EQU  0F2H		;dual baud rate register

;calc initialization routine entry:
$RSINIT:LD   HL,RSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine
	 
;RS232C initialization driver entry routine:
RSTAB:	DEFW RSINIA,RSINIB	

;control register of SIO A:
WR0A	EQU  0D2H

RSINIA: LD   C,A		;save data format
        AND  0C0H		;mask word length bits
	SET  0,A     		;receiver enable
	LD   (WR3A),A		;load write register 3
        LD   A,C   		;restore data format
	AND  0FH		;mask stop bits and parity
        SET  6,A		;x 16 clock mode
	LD   (WR4A),A		;load write register 4
	LD   A,C		;restore data format
	RRA
	AND  60H		;mask word length bits
	OR   88H   		;set DTR, transmitter enable
	LD   (WR5A),A		;load write register 5
	LD   A,B		;relative port number --> accu
	OR   A
	IN   A,(RATE)		;read baud rates
	AND  0F0H		;mask baud rate of channel A
	LD   HL,INITBLA
	JR   RSINIB1

INITBLA:DEFB 1
	DEFB BTx
	DEFB 0
	DEFB 9
        DEFB WR0A
	DEFB 18H		;channel reset
	DEFB 1
	DEFB 0			;disable interrupts
	DEFB 4
WR4A:	DEFS 1
	DEFB 5
WR5A:	DEFS 1
	DEFB 3
WR3A:	DEFS 1
	DEFB 0


*EJECT
;control register of SIO B:
WR0B	EQU  0D3H

RSINIB: LD   C,A		;save data format
        AND  0C0H		;mask word length bits
	SET  0,A     		;receiver enable
	LD   (WR3B),A		;load write register 3
        LD   A,C   		;restore data format
	AND  0FH		;mask stop bits and parity
        SET  6,A		;x 16 clock mode
	LD   (WR4B),A		;load write register 4
	LD   A,C		;restore data format
	RRA
	AND  60H		;mask word length bits
	OR   88H   		;set DTR, transmitter enable
	LD   (WR5B),A		;load write register 5
	LD   A,B		;relative port number --> accu
	OR   A
	IN   A,(RATE)		;read baud rates
	AND  0FH		;mask baud rate of channel B
	SLA  E			;shift baud rate code into upper nibble
	SLA  E
	SLA  E
	SLA  E
	LD   HL,INITBLB
RSINIB1:OR   E			;set baud rate
	OUT  (RATE),A		;output baud rate
RSINIB2:LD   A,(HL)
	OR   A			;end of table ?
	RET  Z			;return if yes
	LD   B,A		;byte count  --> reg. B
	INC  HL			;bump table pointer
	LD   C,(HL)		;port number --> reg. C
	INC  HL			;bump table pointer
	OTIR			;output bytes
	JR   RSINIB2		;output next byte stream

INITBLB:DEFB 1
	DEFB BTx
	DEFB 0
	DEFB 9
        DEFB WR0B
	DEFB 18H		;channel reset
	DEFB 1
	DEFB 0			;disable interrupts
	DEFB 4
WR4B:	DEFS 1
	DEFB 5
WR5B:	DEFS 1
	DEFB 3
WR3B:	DEFS 1
	DEFB 0

								
*EJECT
;*******************
;*  $ K B C H A R  *  
;*******************

;exit: A = char (0 = no char available)

$SYS0	EQU  0F9H		;bank select port 0
$SYS1	EQU  0FAH		;bank select port 1

;get a keyboard character if available:
$KBCHAR:LD   A,(RDYKEY)		;active key ?
	OR   A
	RET  NZ        		;return if yes
	DI			;disable the interrupts
	LD   A,(KLEN)		;A = buffer length
	OR   A			;jump if
	JR   Z,KBCHAR2		;buffer empty
	DEC  A			;dec the length
	LD   (KLEN),A		;save it
	LD   HL,(CPTR)		;HL = character pointer
	LD   A,(HL)		;A = key value
	LD   (RDYKEY),A		;store it
	INC  HL			;bump pointer
	LD   DE,KBUF+80		;DE = end of bufferr pointer
	EX   DE,HL		;swap the pointers
	SBC  HL,DE		;wrap around the buffer ?
	EX   DE,HL		;swap the pointers
	JR   NZ,KBCHAR1		;jump if no wrap around
	LD   HL,KBUF		;HL = new pointer
KBCHAR1:LD   (CPTR),HL		;save the pointer
KBCHAR2:EI			;reenable interrupts
	RET			;return

KLEN:	DEFB 0			;number of active keys
EPTR:	DEFW KBUF		;pointer to next free location
CPTR:	DEFW KBUF		;pointer to first active key
KBUF:	DEFS 80			;type ahead buffer

*EJECT
;this area makes the preliminary check of keyboard rows:
$SCAN:  IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11000110B		;enable memory mapped I/O
				;disable graphic page
				;enable keyboard
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	CALL SCAN		;scan keyboard
	LD   C,A		;code of scanned key --> reg. C
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A		;write it
	RET			;return to interrupt service routine
	
SCAN:	LD   HL,KEYHLD		;HL = keyboard work area ptr
	LD   IX,KEYBRD		;IX = row address table ptr
	LD   BC,38E0H		;BC = row A10 ptr
	LD   D,10 		; E = column index
	LD   A,(BC)		;load row 10
	AND  0F7H		;mask out LOCK key
	LD   E,A		;8 column bits
	XOR  (HL)               ;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E        		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row 10
	DEC  D			;decrement row index
       	INC  HL			;eleven byte buffer indexed by row
        LD   C,(IX)		;row address (LSB) --> reg. C
	LD   A,(BC)		;load row 9
	AND  0FCH		;mask out SHIFT + CTRL keys
	LD   E,A		;8 column bits
	XOR  (HL)               ;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E        		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row 9
     	INC  IX			;increment ^row address table
	DEC  D			;decrement row index
CHKKEY:	INC  HL			;ten byte buffer indexed by row
        LD   C,(IX)		;row address (LSB) --> reg. C
	LD   A,(BC)		;load row N
	LD   E,A		;8 column bits
	XOR  (HL)		;XOR with previous
	LD   (HL),E   		;store column bits in buffer
	AND  E     		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row N
     	INC  IX			;increment ^row address table
	DEC  D			;decrement row index
	JP   P,CHKKEY		;try next row

;check for previous key:
	PUSH AF			;save column bits
       	LD   HL,(OLDROW)	;^previous row   --> reg. HL
        LD   A,(OLCLMN)		;old column bits --> accu
        AND  (HL)               ;previous key active ?
	JR   NZ,PREV    	;jump to wait/repeat procedure if yes
	XOR  A			;clear repeat mode
	LD   (REPEAT),A
	LD   H,A
	LD   L,A
        LD   (COUNT1),HL        ;reset first counter
	LD   HL,(DELAY3)        ;preset second counter
	LD   (COUNT2),HL
	POP  AF      		;restore column bits
	RET   			;no key depression - return

;delay routine until key autorepeats:
PREV:	PUSH AF                 ;save previous column bits
	PUSH HL                 ;save previous row
	LD   HL,(COUNT1)        ;increment first counter
	INC  HL
   	LD   (COUNT1),HL
	LD   DE,(COUNT2)        ;and compare it with second counter
	LD   A,H
        CP   D
	JR   NZ,REST  
	LD   A,L
	CP   E
REST:  	POP  HL			;restore previous row
	JR   NZ,RTN		;return if first counter <> second counter
	POP  AF			;restore previous column bits
	CPL			;clear previous row
	AND  (HL)
	LD   (HL),A
	LD   A,1		;set repeat mode
	LD   (REPEAT),A		
	LD   HL,0		;clear first counter
	LD   (COUNT1),HL
	LD   HL,(DELAY4)	;initialize second counter
	LD   (COUNT2),HL	
	POP  AF			;adjust stack pointer
	JR   SCAN		;scan keyboard again
RTN:	POP  AF			;restore column bits
	POP  AF
	RET			;no key active - return
	
;fist debounce routine:
ACTIVE:	LD   E,A		;save column bits
	PUSH BC			;save active row address
	LD   BC,(DELAY1)	;delay count value
	CALL DELAY		;delay for 7.33 milliseconds (may be varied)
	POP  BC			;restore row address
	LD   A,(BC)		;and reload original flags from active row
	AND  E			;then combine current flag bits with original
				;flag bits
	RET  Z			;rtn to caller if zero because row was not
				;active on 2nd test
	LD   (OLDROW),HL	;save row

;calculate ordinal number of pressed key:
	LD   A,D		;otherwise we have a legimately active row
	RLCA			;row index * 2
	RLCA			;row index * 4
	RLCA			;row index * 8
	LD   D,A		;save in D
	LD   C,1		;start with bit 0
AGAIN:	LD   A,C		;mask
	AND  E			;test for non-zero column
	JR   NZ,FOUND		;go if found
	INC  D			;bump column number
	RLC  C			;align mask
	JR   AGAIN		;try again
FOUND:	LD   A,C      		;column bits --> accu
	LD   (OLCLMN),A		;store them
	LD   E,D		; row * 8 + column (0 - 7)  --> reg. DE
	LD   D,0
	LD   H,D		; row * 8 + column (0 - 7)  --> reg. HL
	LD   L,E
	ADD  HL,HL		;(row * 8 + column (0 - 7)) * 2
 	ADD  HL,DE		;(row * 8 + column (0 - 7)) * 3
		
;get ASCII code of pressed key:
	LD   BC,(KEYTAB)	;^table of ASCII codes --> reg. BC
	ADD  HL,BC              ;calculate ^ASCII code of pressed key
	LD   A,(3880H)          ;load SHIFT bit
	BIT  0,A		;SHIFT ?
	JR   Z,CTRL             ;jump if not
	INC  HL 		;adjust table pointer
	JR   LOCK
CTRL:	BIT  1,A		;CTRL ?
	JR   Z,LOCK		;jump if not
	INC  HL			;adjust table pointer
	INC  HL
	LD   A,(HL)		;get ASCII code
	JR   DBOUNCE

;check if caps lock:
LOCK:   LD   A,(38E0H)          ;load LOCK bit
	BIT  3,A		;LOCK ?
	JR   Z,UMLAUT           ;jump if not
	LD   A,(HL)    		;restore char
	CP   'a'		;is it a letter ?
	JR   C,DBOUNCE          ;jump if not
	LD   A,(GERMAN)		;German character set ?
	OR   A
	LD   A,(HL)		;restore char
	JR   Z,UCAPS		;jump if US-ASCII
	CP   DEL
	JR   NC,DBOUNCE		;adjust to lower case
	JR   UCASE
UCAPS:  CP   '{'  		;adjust to lower case
	JR   NC,DBOUNCE
UCASE:	AND  5FH                ;force upper case
	JR   DBOUNCE

;check if German character set:
UMLAUT:	LD   A,(GERMAN)		;German character set ?
	OR   A
	LD   A,(HL)		;restore char
	JR   Z,DBOUNCE		;jump if US-ASCII
        LD   A,(3880H) 		;load SHIFT bit
	BIT  0,A      		;SHIFT ?
        LD   A,(HL)   		;restore char
	JR   NZ,SHIFT     	;jump if SHIFT
	CP   '['    		;"Umlaut" ?
      	JR   C,DBOUNCE		;jump if not
	CP   '_'
	JR   NC,DBOUNCE
        JR   FILTER
SHIFT:  CP   '{'   		;"Umlaut" ?
	JR   C,DBOUNCE          ;jump if not
	CP   DEL
	JR   NC,DBOUNCE
FILTER: XOR  20H		;change to upper/lower case

;second debounce routine:
DBOUNCE:LD   D,A      		;save character
	LD   A,(REPEAT)		;auto repeat ?
	OR   A
	JR   NZ,NBOUNCE		;no debounce if repeat mode
	LD   BC,(DELAY2)        ;load delay count
	CALL DELAY 		;delay
NBOUNCE:LD   A,D       		;A = ASCII - like character
	RET			;return

KEYBRD:	DEFB 80H,0C0H,0A0H,40H,20H,10H,08H,04H,02H,01H
GERMAN: DEFB 0    		;switch bit to alter character set
				;(0 = US-ASCII, FF = German)
KEYHLD:	DEFB 0,0,0,0,0,0        ;keyboard work area
	DEFB 0,0,0,0,0
COUNT1: DEFW 0     		;delay counters for auto repeat function
COUNT2: DEFW 0     
OLDROW: DEFW 0     		;temporary memory for keyboard driver
OLCLMN: DEFB 0     
RDYKEY:	DEFB 0			;key code memory
REPEAT:	DEFB 0			;repeat mode


*EJECT
;*******************
;*  $ K B W A I T  *
;*******************

;exit: A = char

;wait for a keyboard character:

;scan for special function key:
$KBWAIT:LD   A,(COUNT3)		;letter counter --> accu
	OR   A			;test it
	JR   Z,DZERO		;jump if counter empty
	DEC  A			;decrement counter
	LD   (COUNT3),A		;store it
	LD   HL,(FPTR)		;load letter pointer
	LD   A,(HL)  		;load next letter
	INC  HL			;bump letter pointer
	LD   (FPTR),HL		;store it
	LD   C,A		;save active key
	LD   A,(HL)		;get next key
	LD   (RDYKEY),A		;store that sucker
	LD   A,C		;restore active key
	JP   TSTKEY+2

;scan for special key "00":
DZERO:  LD   HL,RDYKEY		;^scanned key --> reg. HL
	LD   A,(HL)		; scanned key --> accu
	CP   0FBH		;is it PRINT ?
	JR   Z,PRINT		;jump if yes
	CP   0FCH		;is it SHIFT - CLEAR ?
	JR   Z,ERASE		;jump if yes
	CP   0FDH		;is it SHIFT - BREAK ?
	JR   Z,GERSET		;jump if yes
	CP   0FEH		;is it "00" ?
	JR   C,FKEY  		;jump if not
	INC  A			;bump "00"-counter
	LD   (HL),A		;store "00"-counter
	LD   A,'0'		;return one zero
	RET			;return to caller
PRINT:	PUSH HL			;save reg. HL
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
      	LD   HL,$SCREEN		;address of first screen location --> reg. HL
	LD   IX,(VDTABP)	;^current parameter table	  --> reg. IX
	LD   A,(IX)		;line count of screen		  --> reg. D
	LD   D,A
PRINT1:	LD   A,(IX+1)		;column count of screen		  --> reg. B
	LD   B,A
PRINT2:	LD   A,(HL)		;screen character 		  --> accu
	AND  7FH		;mask it
	INC  HL			;bump screen pointer
 	CALL PRCHR0		;output character to printer 0
	DJNZ PRINT2		;repeat "column count" times
	LD   A,CR		;output a carriage return
	CALL PRCHR0
	LD   A,LF		;output a line feed
	CALL PRCHR0
	DEC  D			;decrement line counter
	JR   NZ,PRINT1		;print next line	
	POP  HL			;restore reg. HL
	JR   GERSE3		;go on
ERASE:	LD   A,SUB
	PUSH HL
	CALL $VDCHAR		;clear screen
	POP  HL
	JR   GERSE3		;go on
GERSET:	PUSH HL
	LD   A,ESC
	CALL $VDCHAR
       	LD   A,(GERMAN)		;load switch bit for changing char set
	CPL			;invert it
	LD   (GERMAN),A		;store it
	OR   A
	JR   Z,GERSE1
	LD   A,'G'		;load German character set
	JR   GERSE2
GERSE1:	LD   A,'A'		;load ASCII character set
GERSE2:	CALL $VDCHAR
	POP  HL
GERSE3:	XOR  A			;clear key code	
	JR   TSTKEY

;test if function key:
FKEY:	BIT  7,A		;check if code >= 80H
	JR   Z,TSTKEY		;jump if not 	 
	PUSH HL			;save ^key memory
	LD   C,A		;save key code
	LD   E,A
	LD   HL,VECTOR		;^function key vector --> reg. HL
	LD   A,(HL)		;function key vector = 0 ?
	LD   D,A		;save LSB of key vector
	INC  HL
	OR   (HL)
	JR   Z,FKEYEND		;jump if no special function
	LD   H,(HL)		;function key vector --> reg. HL
	LD   L,D
	LD   D,0
	SLA  E			;most significant 7 bits of code * 2
	ADD  HL,DE		;calculate vector address
	LD   A,(HL)		;no special function ?
	LD   E,A
	INC  HL
	LD   D,(HL)
	OR   D
	JR   Z,FKEYEND
	LD   A,(DE)		;vector --> accu
	LD   (COUNT3),A		;load counter
	INC  DE
	LD   (FPTR),DE		;load address of first function key character
	POP  HL			;adjust stack pointer
	JP   $KBWAIT
FKEYEND:LD   A,C		;restore original key code	
	POP  HL			;restore ^key memory

;test key memory if legal code:
TSTKEY: LD   (HL),0		;clear key memory
	OR   A			;legal key code ?
	RET  NZ       		;return to caller

;scan keyboard:
        CALL $KBCHAR		;scan keyboard
	JP   $KBWAIT		;test if active key

COUNT3:	DEFB 0     		;letter counter for function keys
FPTR:	DEFW 0     		;letter pointer for function keys


*EJECT
;*******************
;*  $ V D C H A R  *
;*******************

;entry: A = char

$BUZZ	EQU  3860H		;buzzer address
$SCREEN EQU  3800H		;address of first screen location

;character output routine:
$VDCHAR:LD   C,A		;save character
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	LD   A,C		;restore character

        LD   IX,(VDTABP)	;^^screen constants --> reg. IX
	LD   HL,ESCAPE 		;test if escape sequence
	BIT  2,(HL)		
	JR   NZ,ESCSQ2		;cursor addressing routine
	BIT  1,(HL)
	JR   NZ,ESCSQ1		;handle second byte of escape sequence
	BIT  0,(HL)
	JR   NZ,ESCSEQ		;handle first byte of escape sequence
	CP   ESC		;char = ESC ?
	JR   NZ,NORMAL 		;jump if normal ASCII char
	SET  0,(HL)		;remark escape sequence
	RET

;handling of single byte ASCII's:
NORMAL: CP   20H		;control char ?
	JR   C,CNTRL 
	LD   L,A		;save char
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	LD   A,L		;restore char	
        OR   A			;ASCII code > 80H ?
	JP   P,NORMAL1		;jump if not
	CP   0A0H		;ASCII code > 0A0H ?
	JR   NC,NORMAL1		;jump if yes
	SUB  80H		;convert code if special char
NORMAL1:OR   (IX+11)		;put invert mask over character
	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   (HL),A		;output char
	JP   CURRGT		;output cursor

;handling of control codes: 
CNTRL:	OR   A			;control code = 0 ?
	RET  Z
      	LD   HL,TAB1E+1		;^end of control code table --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length               --> reg. BC
CAGAIN:	CPDR			;search char
	RET  NZ			;return to caller if not found
	INC  (HL)		;escape sequence ?
	DEC  (HL)
	JR   NZ,CAGAIN		;search next char
	JR   ESCEND

;first entry into escape sequence:
ESCSEQ:	RES  0,(HL)		;reset escape bit
	LD   HL,TAB1E+1		;^end of ESC-sequence-table-1 --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length                 --> reg. BC
EAGAIN:	CPDR          		;search char
	RET  NZ			;return to caller if not found
	INC  (HL)		;escape sequence ?
	DEC  (HL)
	JR   Z,EAGAIN		;search next char
ESCEND:	LD   HL,CTRLJP		;jump vector --> reg. HL
        DEC  BC			;calc jump address
	ADD  HL,BC
	LD   C,(HL)		;jump address --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute function

;second entry into escape sequence:
ESCSQ1: RES  1,(HL)		;reset second escape bit
	SUB  20H		;adjust line/column no.
	LD   D,A		;save it
	LD   A,(ESCCHR)		;load first byte of escape sequence
	LD   HL,TAB2E+1		;^end of ESC-sequence-table-2 --> reg. HL
	LD   BC,TAB2E-TAB2S+2	;table length                 --> reg. BC
	CPDR			;search char
	LD   HL,ESCJP 		;^jump vector
	LD   A,D		;restore line/column no.
	JR   ESCEND+3

;third entry into escape sequence:
ESCSQ2: RES  2,(HL)		;reset third escape bit
	SUB  20H		;adjust column no.
	CP   (IX+7)		;legal column no. ?
	RET  NC			;return if not
	ADD  A,(IX+3)		;add left column
	LD   (IX+9),A		;store new column no.
	LD   A,(LINE)  		;fetch new line no.
	ADD  A,(IX+2)		;add top line
	LD   (IX+8),A		;store it
	CALL OUTCUR		;output cursor
	JP   CURON+4		;turn on cursor

;handle first byte of two or three byte escape sequence:
ESC1ST: LD   (ESCCHR),A		;store first byte of escape sequence
	LD   HL,ESCAPE
	SET  1,(HL)		;remark it
	RET

;handle second byte of three byte escape sequence:
ESC2ND: CP   (IX+6)		;legal line no. ?
	RET  NC			;return if not
	LD   (LINE),A  		;save new line
	LD   HL,ESCAPE
	SET  2,(HL)		;remark cursor addressing sequence
	RET

;beep:
BEEP:   IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11000110B		;enable memory mapped I/O
				;disable graphic page
				;enable buzzer
	OUT  ($SYS1),A		;write system byte 1

     	LD   BC,0     		;repeat counter --> reg. B
				;  wait counter --> reg. C
	DI			;force clean tone
BEEP1:	LD   A,($BUZZ)		;turn on buzzer
	PUSH BC			;save base value of wait counter
BUZZON: NOP			;little delay for lower frequency
	NOP
	NOP
	DEC  C			;decrement wait counter
	JR   NZ,BUZZON		;wait `til end of buzz
	POP  BC			;restore wait counter
	DJNZ BEEP1 		;turn on buzzer eleven times
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A		;write it
	RET

;cursor left:
CURLFT: LD   A,(IX+3)		;left column --> accu
	CP   (IX+9)		; > current column ?
	JP   M,CURLFT1		;jump if not
	LD   A,(WRAP)		;wrap around mode ?
	OR   A
	RET  Z			;return if not	
       	LD   A,(IX+5)		;right column --> current column
	LD   (IX+9),A
	JR   CURUP
CURLFT1:DEC  (IX+9) 		;decrement column no.
	JP   INSLI3

;cursor down:
CURDWN: LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; >= bottom line ?
	JP   P,CURDW1		;scroll up if yes
	INC  (IX+8) 		;increment line no.
	JP   OUTCUR
CURDW1: LD   A,(IX+2)		;top line --> current line
	LD   (IX+8),A
	JP   SCRLU		;scroll window up one line

;cursor up:
CURUP:  LD   A,(IX+2)		;top line --> accu
	CP   (IX+8)		; >= current line ?
	RET  P			;return if yes
	DEC  (IX+8) 		;decrement line
	JP   OUTCUR

;cursor right:
CURRGT:	LD   A,(IX+5)		;right column --> accu
	CP   (IX+9)		;right column >= current column ?
	RET  M			;return if cursor beyond right column
	PUSH AF			;save status reg.
	INC  (IX+9) 		;increment column no.
	POP  AF			;restore status reg.
	JP   NZ,OUTCUR		;output cursor 
	LD   A,(WRAP)		;wrap around mode ?
	OR   A
	JP   Z,CUROFF+4		;turn cursor off
       	LD   A,(IX+3)		;left column  --> current column
	LD   (IX+9),A
	CALL OUTCUR		;output cursor
	JR   CURDWN		;perform line feed

;carriage return:
NEWLIN:	LD   A,(IX+3)		;left column  --> current column
	LD   (IX+9),A
	JP   INSLI3		;output cursor
	
;home cursor:
HOME:	LD   A,(IX+2)		;top line    --> current line
	LD   (IX+8),A
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	JP   OUTCUR		;output cursor

;select window:
WINDOW:	LD   C,A		;save window # 
	LD   A,(STONOFF)	;status line enabled ?
	RET  NZ			;return if yes 
	LD   A,C		;restore window #
	OR   A			;window # < 0 ?
	RET  M			;return if yes
	CP   8			;window # > 7 ?
	RET  NC			;return if yes
	ADD  A,A		;multiply window number by 13
	ADD  A,C
	ADD  A,A
	ADD  A,A
	ADD  A,C
	LD   B,0		;window number * 13 --> reg. BC 
	LD   C,A
	LD   HL,VDTAB		;^screen constants  --> reg. HL
	ADD  HL,BC		;calc current table entry
	LD   (VDTABP),HL	;store it
	PUSH HL         	;^screen constants  --> reg. IX
	POP  IX
	LD   A,(IX+12)		;cursor off ?
	OR   A
	JR   Z,WINDOW2 		;jump if not
WINDOW1:CALL CUROFF+4		;turn off cursor
	JP   OUTCUR             ;output cursor & return to caller
WINDOW2:LD   A,(IX+5)		;right column --> accu
	CP   (IX+9)		;right column >= current column ?
	JR   C,WINDOW1 		;turn off cursor beyond right column
	CALL OUTCUR		;position cursor
	JR   CURON+4		;turn on cursor & return to caller

;set top line:
SETTOP:	CP   (IX)		;legal  line/column no. ?
	RET  NC			;return if not
	LD   B,A		;save line/column
	SUB  (IX+4)		;top    line   - bottom line
				;left   column - right  column
	NEG			;bottom line   - top    line
				;right  column - left   column
	JP   M,SETTO1		;jump if illegal top line/left column
	INC  A			;adjust line/column count
	LD   (IX+6),A		;store new line/column count
SETTO1:	LD   A,B		;restore line column
	RET  M
	LD   (IX+2),A		;store new top line/left column
	CP   (IX+8)		;current line   > top  line ?
				;current column > left column ?
	RET  C			;return to caller if yes
SETTO2: LD   (IX+8),A		;store new current line/column
       	LD   IX,(VDTABP)	;adjust ^screen constants
	JP   OUTCUR		;output cursor

;set bottom line:
SETBOT:	CP   (IX)		;legal  line/column no. ?
	RET  NC			;return if not
	LD   B,A		;save line/column
	SUB  (IX+2)		;bottom line   - top  line
				;right  column - left column
	JP   M,SETTO1		;jump if illegal bottom line/left column
	INC  A			;adjust line/column count
	LD   (IX+6),A		;store new line/column count
       	LD   A,B		;restore line column
	LD   (IX+4),A		;store new bottom line/left column
	CP   (IX+8)		;current line   > bottom line ?
				;current column > right  column ?
	RET  P			;return to caller if not
	JR   SETTO2

;set left column:
SETLFT: INC  IX			;adjust ^screen constants
	JR   SETTOP		;set left column

;set right column:
SETRGT: INC  IX			;adjust ^screen constants
	JR   SETBOT		;set right column

;set erase character:
SETERA:	ADD  A,20H		;restore ASCII code of erase character
	CP   80H		;ASCII between 80H and 9FH ?
	JR   C,SETERA1
	CP   0A0H
	JR   NC,SETERA1
	RES  7,A		;make code between 00H and 1Fh
SETERA1:LD   (IX+10),A		;store new erase character
	RET			;return to caller

;turn off cursor:
CUROFF:	LD   (IX+12),0FFH	;store remark byte
        LD   A,10		;CRTC register no. --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,20H
	OUT  ($CRTCMD),A	;turn off cursor
	RET

;turn on cursor:
CURON:	LD   (IX+12),0 		;clear remark byte
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	LD   A,(IX+12)		;load remark byte
	OR   A			;test remark byte
	RET  NZ			;no action if cursor is invisible
       	LD   A,10		;CRTC register no. --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,(CURBEG)		;cursor image      --> accu
	OUT  ($CRTCMD),A	;turn on cursor
	RET

;set ASCII character set:
SETASC:	XOR  A			;clear accu
SETAS1:	LD   (GERMAN),A		;set ASCII char set
	JP   SELCHR  		;select ASCII character set and ret to caller

;disable status line:
STATOFF:LD   A,(STONOFF)	;status line enabled ?
	OR   A
	RET  Z			;return if not
	XOR  A 			;clear marker
        LD   HL,VDTEMP		;restore screen parameter table
	JR   STATO1

;enable status line:
STATON:	LD   A,(STONOFF)	;status line already enabled ?
	OR   A
	RET  NZ			;return if yes
	CPL			;set marker
       	LD   HL,(VDTABP)	;save screen parameter table
	LD   DE,VDTEMP
	LD   BC,13
	LDIR
	LD   HL,VDSTAT		;setup status line parameters
STATO1:	LD   DE,(VDTABP)
	LD   BC,13
	LDIR
	LD   (STONOFF),A	;store marker
	JP   OUTCUR		;output cursor

;set German character set:
SETGER:	LD   A,0FFH		;set accu to ones
	JR   SETAS1		;set German char set

;switch on normal keyboard:
SETNKB:	LD   HL,NBOARD		;^normal key table  --> reg. HL
SETNK1:	LD   (KEYTAB),HL	;store it
	RET			;return to caller

;switch on WordStar keyboard:
SETWKB:	LD   HL,WBOARD		;^WordStar key table --> reg. HL
	JR   SETNK1		 

;turn on inverse display mode:
INVON:	LD   (IX+11),80H	;store invert mask
	RET

;turn off inverse display mode:
INVOFF: LD   (IX+11),0  	;clear invert mask
	RET

;turn on wrap around mode:
WRAPON:	LD   A,0FFH
	LD   (WRAP),A   	;remember wrap around mode
	RET

;turn off wrap around mode:
WRAPOFF:XOR  A
	LD   (WRAP),A
	RET

;insert character:
INSCHR:	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   A,(IX+5)		;right column            --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	JR   Z,INSCH1		;no columns to shift
	LD   B,0		;no of columns to shift --> reg. BC
	LD   C,A
	ADD  HL,BC		;now HL contains address of last column
	LD   D,H
	LD   E,L		;now DE contains address of last column
	DEC  HL			;now HL contains address of last column - 1
	LDDR			;shift rest of line right one char
	INC  HL			;now HL contains current cursor address
INSCH1:	LD   A,(IX+10)		;get erase char
        LD   (HL),A  		;insert one space at current cursor location
	RET

;insert line:
INSLIN:	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	LД   A,(IX+4©		;bottoн linе --ѕ accu
	SUB  (IX+8)		;calc. no. of lines to scroll
	LD   B,(IX+4)		;bottom line --> current line
	LD   (IX+8),B
INSLI1: JR   Z,INSLI2		;return if line count = 0
       	CALL CALC		;calculate start position
	PUSH HL			;save it
	LD   D,0 		;maximum column count --> reg. DE
	LD   E,(IX+1)
	SBC  HL,DE		;now HL contains ^(last line - 1)
	POP  DE			;restore ^last line
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll down one line
	DEC  (IX+8)		;decrement current line
	DEC  A			;decrement counter
	JR   INSLI1		;scroll down all lines
INSLI2:	CALL ERAEOLN		;erase current line
INSLI3:	CALL OUTCUR		;output cursor
	JP   CURON+4		;turn on cursor

;delete character:
DELCHR:	LD   HL,(CURADR)	;absolute screen address  --> reg. HL
       	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	JR   Z,INSCH1		;no columns to shift
	LD   B,0		;no. of columns to shift --> reg. BC
	LD   C,A
	LD   D,H
	LD   E,L		;now DE contains absolute screen address
	INC  HL			;now HL contains absolute screen address + 1
	LDIR			;shift rest of line left one char
	DEC  HL			;now HL contains address of last column
	JR   INSCH1		;insert one space at last column

;erase to end of line:
ERAEOLN:CALL CALC		;calculate absolute screen address
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;now accu contains number of columns to erase
	RET  M			;return if cursor beyond right column
       	LD   C,(IX+10)		;get erase char
ERAEO1:	LD   (HL),C  		;clear column
	INC  HL			;bump column ptr
	DEC  A			;decrement column counter
	JP   P,ERAEO1		;erase all columns right to the cursor
	RET

;delete line:
DELLIN: LD   A,(IX+3)		;left  column --> current column
	LD   (IX+9),A
       	LD   A,(IX+8)		;current line no. --> accu
	PUSH AF			;save it
	CALL SCRLU		;scroll rest of window up one line
	POP  AF
	LD   (IX+8),A		;restore current line
	JR   INSLI3		;output cursor
 
;erase to end of screen:
ERAEOS: CALL ERAEOLN		;erase to end of first line
	LD   B,(IX+8)		;save current line
	LD   C,(IX+9)		;save current column
	PUSH BC
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	LD   A,(IX+4)		;bottom line --> accu
	SUB  B			;now accu contains number of lines to erase
	LD   B,A		;counter --> reg. B
        JR   Z,ERAES2		;no further lines to erase
ERAES1: INC  (IX+8)		;increment current line
	PUSH BC			;save counter
	CALL ERAEOLN		;erase current line
	POP  BC			;restore counter
	DJNZ ERAES1		;erase to end of whole window
ERAES2: POP  BC
        LD   (IX+8),B		;restore original line   no.
	LD   (IX+9),C		;restore original column no.
	RET

;clear screen:
ERAALL: CALL HOME		;home cursor
	JR   ERAEOS		;clear to end of screen

;output cursor:
OUTCUR:	CALL CALC               ;calculate absolute screen address
	LD   (CURADR),HL	;store it
	LD   DE,$SCREEN		;base address of video RAM --> reg. DE
	OR   A			;clear carry flag
	SBC  HL,DE		;subtract base address from current cursor
				;address
	LD   C,$CRTREG		;CRTC address register --> reg. C
	LD   A,14		;CRTC register number  --> accu
	OUT  (C),A		;select CRTC register
	INC  C			;CRTC command register --> reg. C
	OUT  (C),H		;output cursor address (MSB)
	INC  A			;increment CRTC register no.
	DEC  C			;decrement port number
	OUT  (C),A		;select CRTC register
	INC  C			;CRTC command register --> reg. C
	OUT  (C),L		;output cursor address (LSB)
	RET

;scroll up routine:
SCRLU:	LD   A,(IX+9)		;current column --> accu
	PUSH AF			;save it
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
      	LD   A,(IX+4)		;bottom line  --> accu
	SUB  (IX+8)		;calc. no. of lines to scroll
SCRLU1: JR   Z,SCRLU2		;clear last line if count = 0
        CALL CALC		;calculate start position
	PUSH HL			;save it
	LD   D,0 		;maximum column count --> reg. DE
	LD   E,(IX+1)
	ADD  HL,DE		;now HL contains address of line to scroll
	POP  DE			;restore ^line before
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll up one line
	INC  (IX+8)		;increment current line
	DEC  A			;decrement counter
	JR   SCRLU1             ;scroll up all lines
SCRLU2:	CALL ERAEOLN		;clear last line
	POP  AF			;restore column no.
	LD   (IX+9),A		;store it
	RET

;calculate absolute cursor address:
CALC:	LD   HL,$SCREEN		;address of first screen loc --> reg. HL
	LD   D,0		;maximum column count        --> reg. DE
	LD   E,(IX+1)
	LD   B,(IX+8)		;current line                --> reg. B
	DEC  B
	INC  B
        JR   Z,CALC2		;jump if line no. = 0
CALC1:	ADD  HL,DE
	DJNZ CALC1		;handle all lines
CALC2:	LD   E,(IX+9)		;current column --> reg. DE
	ADD  HL,DE		;now HL contains absolute screen address
	RET

;jump vectors:
CTRLJP:	DEFW BEEP,CURLFT,CURDWN,CURUP,CURRGT,NEWLIN,HOME,ESC1ST,ESC1ST,ESC1ST
	DEFW ESC1ST,ESC1ST,ESC1ST,ESC1ST,CUROFF,CURON,SETASC,STATOFF,STATON
	DEFW SETGER,SETNKB,SETWKB,INVON,INVOFF,WRAPON,WRAPOFF,INSCHR,INSLIN
	DEFW DELCHR,ERAEOLN,DELLIN,ERAEOS,ERAALL
ESCJP:	DEFW ESC2ND,WINDOW,SETTOP,SETBOT,SETLFT,SETRGT,SETERA

;table of screen constants:
VDTABP:	DEFW VDTAB
VDTAB:	REPT 8
	DEFB 24			;maximum line   count
	DEFB 80			;maximum column count
	DEFB 0			;top     line
	DEFB 0			;left    column
	DEFB 23			;bottom  line
	DEFB 79			;right   column
	DEFB 24			;line    count
	DEFB 80			;column  count
	DEFB 0			;current line
	DEFB 0			;current column
	DEFB ' '		;erase   character 
        DEFB 0     		;0 = normal mode,  80H = inverse mode
       	DEFB 0     		;0 = cursor on  , 0FFH = cursor off
	ENDM

;status line constants:
VDSTAT:	DEFB 25			;maximum line   count
	DEFB 80			;maximum column count
	DEFB 24			;top     line
	DEFB 0			;left    column
	DEFB 24			;bottom  line
	DEFB 79			;right   column
	DEFB 1 			;line    count
	DEFB 80			;column  count
	DEFB 24			;current line
	DEFB 0			;current column
	DEFB ' '		;erase   character 
        DEFB 0     		;0 = normal mode,  80H = inverse mode
       	DEFB 0     		;0 = cursor on  , 0FFH = cursor off

ESCAPE:	DEFB 0     		;contains escape remarks
ESCCHR: DEFB 0     		;memory for escape char
LINE:  	DEFB 0     		;memory for line number
CURADR: DEFW 3800H		;memory for absolute cursor address
WRAP:   DEFB 0			;0 = normal mode, 0FFH = wrap around mode
STONOFF:DEFB 0			;0 = status line off, 0FFH = status line on
VDTEMP:	DEFS 13			;temporary storage area for screen constants


*EJECT
;*******************
;*  $ P R S T A T  *
;*******************

;entry: B = number of Centronics interface (0, 1)

;exit : A = printer status
;       0 = printer ready 
;    <> 0 = printer not ready

;calc entry of printer status routine:
$PRSTAT:LD   HL,PSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
 	LD   L,C
	JP   (HL)		;execute printer status routine

;printer status routine entry table:
PSTAB:	DEFW PRSTA0,PRSTA1

;test status of printer 0:
$PTR0	EQU  0FDH		;printer port 0

PRSTA0:	IN   A,($PTR0)		;read printer status
	AND  0F0H		;mask it
	XOR  30H
	RET			;return to caller

;test status of printer 1:
$PTR1	EQU  0D5H		;printer port 1

PRSTA1:	IN   A,($PTR1)		;read printer status
	AND  0F0H		;mask it
	XOR  30H
	RET			;return to caller


*EJECT
;*******************
;*  $ P R C H A R  *
;*******************

;entry: A = char
;       B = number of Centronics interface (0, 1)

;calc entry of printer output routine:
$PRCHAR:LD   HL,POTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
 	LD   L,C
	JP   (HL)		;execute printer output routine

;printer output routine entry table:
POTAB:	DEFW PRCHR0,PRCHR1

;output a character to printer 0:
PRCHR0:	LD   C,A		;save char
	CALL PRSTA0		;test status of printer 0
	JR   NZ,PRCHR0+1	;wait for printer ready
	LD   A,C		;restore char
	OUT  ($PTR0),A		;print it
	RET			;return to caller
			  
;output a character to printer 1:
$PTR1D	EQU  0D4H		;data port of PIO

PRCHR1:	LD   C,A		;save char
	CALL PRSTA1		;test status of printer 0
	JR   NZ,PRCHR1+1	;wait for printer ready
	LD   A,C		;restore char
	OUT  ($PTR1D),A		;output it
	XOR  A
	OUT  ($PTR1),A		;set STROBE
	INC  A
	OUT  ($PTR1),A		;clear STROBE

	RET			;return to caller
			  

*EJECT
;*******************
;*  $ R S R C S T  *
;*******************

;entry: B = number of RS232C interface (0, 1)

;exit : A = input status
;	0 = no char available
;    <> 0 = char available	

;calc entry of RS232C input status routine:
$RSRCST:LD   HL,RSSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine
	 
;RS232C input status routine entry table:
RSSTAB:	DEFW RSRCSA,RSRCSB	

;get input status of SIO A:
RSRCSA: IN   A,(WR0A)    	;read status
	AND  1   		;character available ?
	RET  NZ 		;return to caller if yes
	LD   B,A		;load counter
	LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0A),A		;request to send
RSRCSA1:IN   A,(WR0A)		;read status	
	BIT  0,A		;character available ?
	JR   NZ,RSRCSA2		;jump if character ready
	DJNZ RSRCSA1		;scan 256 times
	LD   C,0		;no character available
	JR   RSRCSA3
RSRCSA2:LD   C,1		;character available
RSRCSA3:LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	OUT  (WR0A),A		;data terminal ready
        LD   A,C		;get input status
	RET

;get input status of SIO B:
RSRCSB: IN   A,(WR0B)    	;read status
	AND  1   		;character available ?
	RET  NZ 		;return to caller if yes
	LD   B,A		;load counter
	LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0B),A		;request to send
RSRCSB1:IN   A,(WR0B)		;read status	
	BIT  0,A		;character available ?
	JR   NZ,RSRCSB2		;jump if character ready
	DJNZ RSRCSB1		;scan 256 times
	LD   C,0		;no character available
	JR   RSRCSB3
RSRCSB2:LD   C,1		;character available
RSRCSB3:LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	OUT  (WR0B),A		;data terminal ready
        LD   A,C		;get input status
	RET

 
*EJECT
;*****************
;*  $ R S R C V  *
;*****************

;entry: B = number of RS232C interface (0, 1)

;exit : A = char	

;calc entry of RS232C input routine:
$RSRCV: LD   HL,RSRTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine
	 
;RS232C input routine entry table:
RSRTAB:	DEFW RSRCVA,RSRCVB	

;read character from SIO A:
DRA	EQU  0D0H		;data register of SIO A

RSRCVA:	IN   A,(WR0A) 		;read status
	BIT  0,A     		;character available ?
	JR   NZ,RSRCVA2		;jump if yes
	LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0A),A		;request to send
RSRCVA1:IN   A,(WR0A)		;read status	
	BIT  0,A		;character available ?
	JR   Z,RSRCVA1		;loop `til character ready
        LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	OUT  (WR0A),A		;data terminal ready
RSRCVA2:IN   A,(DRA)		;read character
	RET
	
;read character from SIO B:
DRB	EQU  0D1H		;data register of SIO A

RSRCVB:	IN   A,(WR0B) 		;read status
	BIT  0,A     		;character available ?
	JR   NZ,RSRCVB2		;jump if yes
	LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0B),A		;request to send
RSRCVB1:IN   A,(WR0B)		;read status	
	BIT  0,A		;character available ?
	JR   Z,RSRCVB1		;loop `til character ready
        LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	OUT  (WR0B),A		;data terminal ready
RSRCVB2:IN   A,(DRB)		;read character
	RET
	

*EJECT
;*******************
;*  $ R S T X S T  *
;******************* 
	
;entry: B = number of RS232C interface (0, 1)

;exit : A = terminal status
;       0 = data terminal ready
;    <> 0 = data terminal not ready

;get output status of SIO:
$RSTXST:LD   A,WR0A    		;control register of SIO A --> accu
	ADD  A,B		;add relative port number
	LD   C,A		;absolute port address --> reg. C
	LD   A,10H		
	OUT  (C),A		;reset ext/status interrupts
	IN   A,(C)		;read status
	AND  2CH		;buffer empty, data set ready, clear to send ?
        SUB  2CH
	RET
	

*EJECT
;***************
;*  $ R S T X  *
;***************

;entry: A = char
;       B = number of RS232C interface (0, 1)

;write character to SIO:
$RSTX:	LD   E,A		;save character
        CALL $RSTXST  		;test output status
	JR   NZ,$RSTX+1		;wait for CTS
	DEC  C
	DEC  C			;now reg. C points to data port
	OUT  (C),E		;output character
	RET


*EJECT
;disk driver:

;FDC registers:
$FDSEL  EQU  0E0H               ;FDC select  register
$FDCMD  EQU  0ECH               ;FDC command register
$FDSTAT EQU  0ECH               ;FDC status  register
$FDTRK  EQU  0EDH               ;FDC track   register
$FDSIZ  EQU  0EEH               ;FDC size    register
$FDSEC  EQU  0EEH               ;FDC sector  register
$FDDATA EQU  0EFH               ;FDC data    register

;FDC commands:
$SEEK   EQU  10H                ;seek
$RDSEC  EQU  88H                ;read sector
$WRSEC  EQU  0A8H               ;write sector
$SET8   EQU  0C0H               ;set disk size to 5 inch
$FCINT  EQU  0D0H               ;force interrupt
$DDDEN  EQU  0FFH               ;set double density


;***************
;*  $ R E A D  *
;***************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       E  = track  number
;       HL = buffer pointer

;exit : A = error code
;       0 = NO ERROR
;       1 = ILLEGAL DRIVE #
;       2 = TRACK # TOO HIGH
;       3 = SECTOR # TOO HIGH
;       4 = DEVICE NOT AVAILABLE
;       6 = TRIED TO READ LOCKED/DELETED RECORD
;       7 = DATA RECORD NOT FOUND DURING READ
;       8 = PARITY ERROR DURING READ
;       9 = LOST DATA DURING READ

;read a sector:
$READ:  LD   C,A                ;save drive #/bank #
        LD   A,0FFH             ;set READ-flag
        JR   TASK


*EJECT
;*****************
;*  $ W R I T E  *
;*****************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       E  = track  number
;       HL = buffer pointer

;exit : A = error code
;       0 = NO ERROR
;       1 = ILLEGAL DRIVE #
;       2 = TRACK # TOO HIGH
;       3 = SECTOR # TOO HIGH
;       4 = DEVICE NOT AVAILABLE
;       5 = WRITE PROTECTED DISKETTE
;       6 = WRITE FAULT ON DISK DRIVE
;       7 = DATA RECORD NOT FOUND DURING WRITE
;       8 = PARITY ERROR DURING WRITE
;       9 = LOST DATA DURING WRITE

;write a sector:
$WRITE: LD   C,A                ;save drive #/bank #
        XOR  A                  ;clear READ-flag

;dominant controller:
TASK:   LD   (RDFLAG),A         ;set/reset READ-flag
	LD   A,C		;restore drive/bank #
      	RRA   			;get bank number of transfer buffer
	RRA   
	RRA   
	RRA   
	AND  0FH
	LD   (BANK),A		;store bank #
        LD   A,C      		;restore drive/bank #
	AND  0FH		;mask drive #
        CP   8                  ;legal drive # ?
        JR   C,TRKNO            ;jump if yes
        LD   A,1                ;error code 1 --> accu
        RET
TRKNO:  LD   (DRIVE),A          ;store drive #
        LD   (BUFFER),HL        ;store buffer pointer
        CALL GETDCT             ;get control table ptr
        LD   A,E                ;track # --> accu
        CP   (IX+4)             ;legal track # ?
        JR   C,SECNO            ;jump if yes
        LD   A,2                ;error code 2 --> accu
        RET
SECNO:  LD   (TRACK),A          ;store track #
        LD   A,B                ;sector # --> accu
        CP   (IX+3)             ;legal sector # ?
        JR   C,TRYNO            ;jump if yes
        LD   A,3                ;error code 3 --> accu
        RET
TRYNO:	LD   (SECTOR),A		;store sector #
        LD   A,(TRYS)           ;get # of err tries
        INC  A                  ;adjust it
        LD   (TRIES),A          ;store in counter

;set double density & disk size to 8 inch:
        LD   A,$DDDEN           ;set double density command
        BIT  5,(IX)             ;density ?
        JR   NZ,SETDEN          ;jump if double density
        DEC  A                  ;set single density
SETDEN: OUT  ($FDCMD),A         ;set density
        LD   C,$SET8            ;set 8 inch command
        LD   A,(DRIVE)          ;drive # --> accu
	CP   4			;disk size ?
        JR   NC,SETSIZ          ;jump if 8 inch
        RES  6,C                ;set 5 inch command
SETSIZ:	LD   A,C
        OUT  ($FDSIZ),A         ;set disk size

;actual I/O handler:
INIT:   LD   HL,0               ;clear wait counter
        LD   (WAIT),HL
        LD   A,$FCINT           ;force interrupt
        OUT  ($FDCMD),A         ;reset FDC
        IN   A,($FDSTAT)        ;get FDC status
        LD   (OLDSTAT),A        ;save drive status
        CALL SELECT             ;select drive
        BIT  0,(IX+1)           ;is drive initialized ?
        JR   NZ,TRKSEC          ;yes skip init process

;restore drive head:
        SET  0,(IX+1)           ;set init bit in DCT
        LD   A,255              ;max possible track # --> accu
        LD   (IX+5),A           ;make current track # to 255
        XOR  A                  ;desired track # = 0
        JR   TRKSE8

;set track and sector:
TRKSEC: LD   A,(TRACK)          ;track # --> accu
        BIT  5,(IX)             ;disk density ?
        JR   Z,TRKSE1           ;jump if single density
        BIT  4,(IX)             ;density of first track ?
        JR   NZ,TRKSE1          ;jump if double density
        INC  A                  ;increment track #
TRKSE1: BIT  2,(IX)             ;step count from track to track
        JR   Z,TRKSE2           ;jump if step count = 1
        ADD  A,A                ;track # * 2
TRKSE2: CP   (IX+5)             ;same as current track
        JR   NZ,TRKSE6          ;jump to SEEK cmd if not
	LD   C,A		;save track #
	LD   A,$FCINT		;force interrupt
	OUT  ($FDCMD),A
	LD   A,C		;restore track #
        BIT  2,(IX)             ;step count from track to track
        JR   Z,TRKSE3           ;jump if step count = 1
        SRL  A                  ;track # / 2
TRKSE3: OUT  ($FDTRK),A         ;adjust current track #
        LD   A,(SECTOR)         ;sector # --> accu
        BIT  6,(IX)             ;single or double sided ?
        JR   Z,TRKSE4           ;jump if single sided
        BIT  5,(IX+1)           ;sector numbering continued on backside ?
        JR   NZ,TRKSE4          ;jump if yes
        LD   B,(IX+3)           ; sectors/track --> reg. B
        SRL  B                  ;(sectors/track) / 2
        CP   B                  ;front or back side ?
        JR   C,TRKSE4           ;jump if front side
        SUB  B                  ;adjust sector #
TRKSE4: BIT  3,(IX)             ;test number of first sector
        JR   Z,TRKSE5           ;jump if zero
        INC  A                  ;else adjust sector #
TRKSE5: OUT  ($FDSEC),A         ;store sector # in FDC reg
        JR   WAITEN             ;no SEEK
TRKSE6: LD   C,A                ;save track #
        SUB  (IX+5)             ;subtract current track #
        JR   NC,TRKSE7
        NEG                     ;make result positive
TRKSE7: LD   (WAIT),A           ;store calculated step count
        LD   A,C                ;restore track #
TRKSE8: OUT  ($FDDATA),A        ;store track # in FDC reg
	LD   A,$FCINT
        OUT  ($FDCMD),A         ;reset FDC
        LD   A,(IX+5)           ;current track from DCT
        OUT  ($FDTRK),A         ;FDC track register
        LD   A,(IX)
        AND  3                  ;step rate --> accu
	PUSH AF			;save it
        LD   HL,(WAIT)          ;get step count
        JR   Z,TRKS10           ;jump if step rate = 3 msec
        LD   D,H                ;step count --> reg. DE
        LD   E,L
        LD   B,A                ;step rate --> reg. B
TRKSE9: ADD  HL,DE              ;counter = step count * step rate
        DJNZ TRKSE9
TRKS10: LD   B,H                ;counter --> reg. BC
        LD   C,L
        ADD  HL,HL              ;counter * 2
        ADD  HL,BC              ;counter * 3
	LD   A,(DRIVE)		;drive # --> accu
        CP   4                  ;disk size ?
        JR   NC,TRKS11          ;jump if 8 inch
	ADD  HL,HL		;counter * 6
TRKS11: LD   BC,15              ;adjust value for delay loop --> reg. BC
        ADD  HL,BC              ;adjust wait counter
        LD   (WAIT),HL          ;store wait counter (msecs of passed time)
	POP  AF			;restore step rate
        OR   $SEEK              ;or step rate with "seek" command
        OUT  ($FDCMD),A         ;issue seek command
TRKS12: CALL SELECT             ;select drive
	IN   A,($FDSTAT)	;get disk status
        BIT  7,A                ;drive not ready ?
        JP   NZ,READ2           ;jump to error exit
        BIT  0,A                ;seek done ?
        JR   NZ,TRKS12          ;no, loop
        LD   BC,4000            ;load delay counter
        CALL DELAY              ;15 msec head settle delay
        IN   A,($FDTRK)         ;get current track
        LD   (IX+5),A           ;store in drive's DCT
        JP   TRKSEC             ;check track # again

;motor on / head load time:
WAITEN: LD   A,(DRIVE)          ;get drive #
        LD   HL,OLDDRV          ;^previous drive # --> reg. HL
        CP   (HL)               ;new drive # same as old drive # ?
        LD   (HL),A             ;store new drive #
        LD   A,(OLDSTAT)        ;get old FDC status
        RLCA                    ;drive rotating already
        JR   C,WAITE2           ;jump to motor on delay loop, if not
        JR   Z,WAITE6           ;jump if same drive #
WAITE1: LD   HL,50              ;50 msec head load time
        JR   WAITE3
WAITE2: BIT  7,(IX)             ;8 inch drive
        JR   NZ,WAITE1          ;jump if 8 inch drive
        LD   HL,800             ;500 msec delay after motor on
WAITE3: LD   BC,(WAIT)          ;msecs of passed time --> reg. BC
        OR   A                  ;clear carry bit
        SBC  HL,BC              ;calculate remaining wait time
        JR   C,WAITE6           ;no further time to wait
        JR   Z,WAITE6
WAITE5: LD   BC,253             ;1 msec delay
        CALL DELAY
        DEC  HL
        LD   A,H
        OR   L
        JR   NZ,WAITE5          ;loop HL times
WAITE6: IN   A,($FDSTAT)        ;get FDC status
        RLCA                    ;drive rotating already ?
        JP   C,READ2            ;jump if not

;init READ/WRITE:
TASK1:  CALL SELECT             ;select drive
        LD   HL,(BUFFER)        ;get buffer pointer
        LD   A,(RDFLAG)
        OR   A                  ;READ or WRITE ?
	PUSH AF			;save status
	LD   A,(BANK)		;bank # of transfer buffer --> accu
	JP   IO 		;handle disk I/O in common memory

;test controller status:
STATUS: IN   A,($FDSTAT)        ;get FDC status
        BIT  6,A                ;write protect ?
        JR   Z,STATU1           ;jump if not
        LD   A,5                ;error code 5 --> accu
        RET
STATU1: BIT  5,A                ;hardware fault (WRITE) ?
                                ;sector   prot  (READ ) ?
        JR   Z,STATU2           ;jump if no
        LD   A,6                ;error code 6 --> accu
        RET
STATU2: AND  1CH                ;any errors ?
        RET  Z
        RES  0,(IX+1)           ;clear init bit in DCT
        LD   HL,TRIES           ;get tries counter
        DEC  (HL)               ;dec value
        JP   NZ,INIT            ;try again, reseek
        BIT  4,A                ;data record not found ?
        JR   Z,STATU3
        LD   A,7                ;error code 7 --> accu
        RET
STATU3: BIT  3,A                ;parity error ?
        JR   Z,STATU4
        LD   A,8                ;error code 8 --> accu
        RET
STATU4: LD   A,9                ;error code 9 --> accu
        RET

;put drive control table pointer in "IX":
GETDCT: PUSH DE                 ;save reg. DE
        LD   H,0                ;drive # --> reg. HL
        LD   L,A
        ADD  A,A                ; drive # * 2
        ADD  A,L                ; drive # * 3
        ADD  A,A                ; drive # * 6
        LD   L,A                ;(drive # * 6) --> reg. HL
        LD   DE,DCT             ;get drive table start
        ADD  HL,DE              ;add offset and get ^DCT
        PUSH HL                 ;^DCT --> reg. IX
        POP  IX
        POP  DE                 ;restore reg. DE
        RET                     ;return to caller

;select drive:
SELECT: LD   A,(DRIVE)          ;get drive #
	AND  3			;force # between 0 and 3
        OR   A                  ;drive # zero ?
        LD   B,A                ;drive # --> reg. B
        LD   A,1                ;select code for drive zero
        JR   Z,SELEC1           ;jump if drive # zero
        RLCA                    ;rotate left accu
        DJNZ $-1                ;decrement drive #
SELEC1: BIT  6,(IX)             ;single or double sided ?
        JR   Z,SELEC2           ;jump if single sided
        LD   C,A                ;save select code
        LD   A,(SECTOR)         ;sector #       --> accu
        LD   B,(IX+3)           ; sectors/track --> reg. B
        SRL  B                  ;(sectors/track) / 2
        CP   B                  ;front or back side ?
        LD   A,C                ;restore select code
        JR   C,SELEC2           ;jump if front side
        SET  4,A                ;set side select bit
SELEC2: OUT  ($FDSEL),A         ;select drive and side
        RET                     ;return to caller

DRIVE:  DEFS 1                  ;drive
TRACK:  DEFS 2                  ;track
SECTOR: DEFS 1                  ;sector
BUFFER: DEFS 2                  ;I/O buffer
OLDDRV: DEFB 0FFH               ;contains # of previous selected disk
OLDSTAT:DEFS 1			;contains drive status
TRIES:  DEFS 1                  ;counter for counting # of times to try I/O
                                ;after error occurs
RDFLAG: DEFS 1                  ;flag (0 = WRITE, 0FFH = READ)
WAIT:   DEFS 2                  ;counter for passed time


*EJECT
;*******************
;*  $ G E T T I M  *
;*******************

;entry: HL = address of a 21 bytes long buffer, containing on exit
;	     time & date in the form WWW MM/DD/YY HH:MM:SS

;		  WWW = weekday
;		   MM = month
;		   DD = day
;		   YY = year
;		   HH = hours
;		   MM = minutes
;		   SS = seconds		 

;get time & date in ASCII format:
$GETTIM:DI			;critical phase
	PUSH HL			;save ^user buffer
        CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer --> reg. IX

	LD   A,(IX+6)		;weekday      --> accu
	AND  7			;make binary
	LD   H,0		;weekday      --> reg. HL			
	LD   L,A
	LD   DE,DAYTAB		;base of weekday table --> reg. DE
	ADD  A,A		;calc table entry
	ADD  A,L
	LD   L,A
	ADD  HL,DE
	LD   DE,ATIMBUF		;^ASCII buffer 	       --> reg. DE	
	LD   BC,3		;length of table entry --> reg. BC
	LDIR			;move weekday into ASCII buffer
	INC  DE			;bump buffer ptr over space

	LD   A,(IX+2)		;month (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+3)		;month (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX+4)		;day (tenths) --> accu
	AND  '3'		;mask leapyear bit
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+5)		;day (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX)		;year (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+1)		;year (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over space		

	LD   A,(IX+7)		;hours (tenths) --> accu
	AND  '3'		;mask format bit 
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+8)		;hours (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon	

	LD   A,(IX+9)		;minutes (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+10)		;minutes (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon	

	LD   A,(IX+11)		;seconds (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+12)		;seconds (ones)   --> accu
	LD   (DE),A		;store them

	POP  DE			;restore ^user buffer
	LD   HL,ATIMBUF		;^(time & date buffer) 	      --> reg. HL
	LD   B,21		;length of time & date string --> reg. BC
	LD   A,01H		;source bank      = 0
				;destination bank = 1
	JP   $XMOVE		;transfer time & date string and return

;read time & date from clock chip:
GETTIM:	IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  10111111B		;1.78 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
        LD   HL,TIMBUF		;^temp buffer --> reg. HL
	LD   DE,10C4H		;register address displacement --> reg. D
				;register address & read mode  --> reg. E
	LD   B,13		;byte counter 		       --> reg. B
GETTI1:	LD   A,E		;read date & time
	OUT  (5BH),A
	SUB  D
	LD   E,A
	IN   A,(5AH)	 	
	AND  0FH		;mask undesired bits
	OR   '0'		;make ASCII digit
	LD   (HL),A
	INC  HL			;bump ^(time & date)
	DJNZ GETTI1
	POP  AF       		;restore system byte 1
	OUT  ($SYS1),A		;write system byte 1
	RET			;return to caller

DAYTAB:	DEFM 'SatSunMonTueWedThuFri'
TIMBUF:	DEFS 13
ATIMBUF:DEFM 'WWW MM/DD/YY HH:MM:SS'


*EJECT
;*******************
;*  $ S E T T I M  *
;*******************

;entry:  A = weekday (0 - 6, 0 = Sat)
;	 B = month   (MM)
;        D = hours   (HH)
;	 E = minutes (MM)
;	 H = day     (DD)
;	 L = year    (YY)


;set time and date in binary format:
$SETTIM:DI			;critical phase
	LD   IX,TIMBUF		;^temp buffer --> reg. IX
	LD   (IX+6),A		;weekday      --> buffer
	LD   A,L		;year (ones)  --> accu
	AND  0FH		;mask it
	LD   (IX+1),A		;year (ones)  --> buffer
	LD   A,L		;shift reg. L four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX),A		;year  (tenths) --> buffer
	LD   A,B		;month (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+3),A		;month (ones)   --> buffer
	LD   A,B		;shift reg. B four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+2),A		;month (tenths) --> buffer
	LD   A,H		;day   (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+5),A		;day   (ones)   --> buffer
	LD   A,H		;shift reg. H four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+4),A		;day   (tenths) --> buffer
	LD   A,D		;hours (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+8),D		;hours (ones)	--> buffer
	LD   A,D		;shift reg. D four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+7),A		;hours   (tenths) --> buffer
	LD   A,E		;minutes (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+10),A		;minutes (ones)   --> buffer
	LD   A,E		;shift reg. E four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+9),A		;minutes (tenths) --> buffer
	LD   (IX+11),0		;seconds (tenths) --> buffer
	LD   (IX+12),0		;seconds (ones)   --> buffer
	LD   HL,TIMBUF		;^buffer	  --> reg. HL
	LD   DE,10D2H		;register address displacement --> reg. D
				;register address	       --> reg. E
	LD   B,13		;byte counter 		       --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  10010111B		;disable graphic page
				;1.78 MHz clock frequency
	OR   00000101B		;disable memory mapped I/O
				;disable boot EPROM
	OUT  ($SYS1),A		;write system byte 1
SETTI1:	LD   A,E		;set date & time
	SUB  D
	LD   E,A
	OUT  (05BH),A
	LD   A,(HL)
	OUT  (5AH),A
	INC  HL			;bump ^(time & date)
	DJNZ SETTI1
	IN   A,($SYS1)		;read system byte 1
	OR   01000000B		;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	JP   GETTIM		;adjust clock chip and return to caller


*EJECT
;Winchester disk driver:

	COND SASI		;Xebec part

MAXDRIVE EQU 2			;drive count

;DC registers:
WPORT0	EQU  00H		;SASI write port 0 - write data
WPORT1	EQU  01H		;SASI write port 1 - software reset
WPORT2	EQU  02H		;SASI write port 2 - cntlr select
RPORT0	EQU  00H		;SASI read  port 0 - read data
RPORT1	EQU  01H		;SASI read  port 1 - read status

;DC commands:
$TSTDRV	EQU  00H		;test drive ready
$REST  	EQU  01H		;recalibrate
$STATUS	EQU  03H		;request sense status
$$READ	EQU  08H		;read
$$WRITE	EQU  0AH		;write
$INIDRV EQU  0CH		;initialize drive characteristics

;DC status bits:
REQMASK EQU  01H		;request mask for bit test
BUSYMASK EQU 02H		;busy    mask for bit test
CDMASK	EQU  08H                ;command/data bit position test
IOMASK	EQU  10H		;input/output bit mask
ERROR	EQU  02H		;test for an error

	ELSE			;WD1002 part

MAXDRIVE EQU 3			;drive count

;WDC registers:
$DATA  	EQU  50H  		;data register	
$WPC    EQU  51H  		;write precomp register
$ERROR  EQU  51H  		;error register
$SECNO 	EQU  53H  		;sector number register
$CYLLO  EQU  54H  		;cylinder low register
$CYLHI  EQU  55H  		;cylinder high register
$SDH	EQU  56H		;size/drive/head register
$COMND  EQU  57H		;command register
$STATUS	EQU  57H		;status register

;WDC commands:
$REST   EQU  10H		;restore
$$READ 	EQU  20H		;read sector
$$WRITE	EQU  30H		;write sector
$DSEL	EQU  98H		;deselect drive

	ENDC


*EJECT
;*****************
;*  $ R E A D W  *
;*****************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       DE = track  number
;       HL = buffer pointer

;exit : A  = error status returned from controller
;	 0 = NO ERROR
;	-1 = ILLEGAL DRIVE #
;	-2 = TRACK # TOO HIGH
;	-3 = SECTOR # TOO HIGH
;	else error code returned by controller

;read a sector:
$READW:	LD   C,A		;save drive/bank number
       	LD   A,0FFH
	JR   TASKW		;read sector


*EJECT
;*****************
;*  $ W R I T W  *
;*****************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       DE = track  number
;       HL = buffer pointer

;exit : A  = error code
;	 0 = NO ERROR
;	-1 = ILLEGAL DRIVE #
;	-2 = TRACK # TOO HIGH
;	-3 = SECTOR # TOO HIGH
;	else error code returned by controller

;write a sector:
$WRITW:	LD   C,A		;save drive/bank number
       	XOR  A


;dominant controller:
TASKW:	LD   (RDFLAG),A		;set/cear READ-flag
	LD   A,C		;restore drive/bank #
      	RRA    			;get bank number of transfer buffer
	RRA
	RRA
	RRA
	AND  0FH
	LD   (BANK),A		;store bank #
        LD   A,C      		;restore drive/bank #
	AND  0FH		;mask drive #
     	CP   MAXDRIVE		;legal drive # ?
	JR   C,TRKNOW		;jump if yes
	LD   A,-1		;error code 1 --> accu
	RET
TRKNOW: LD   (DRIVE),A		;store drive #
	LD   (BUFFER),HL	;store buffer pointer
       	CALL GETWCT		;get control table ptr
	LD   A,D        	;track # (MSB) --> accu
      	CP   (IX+6)		;legal track # ?
	JR   C,SECNOW		;jump if yes
	JR   Z,CPLOW		;compare LSB's
TRKERR:	LD   A,-2		;error code 2 --> accu
	RET
CPLOW:	LD   A,E      		;track (LSB) --> accu
	CP   (IX+5)		;legal track # ?
	JR   NC,TRKERR		;jump if not
SECNOW:	LD   (TRACK),DE		;store track #
	LD   A,B       		;sector # --> accu
	CP   (IX+4)		;legal sector # ?
	JR   C,INITW		;jump if yes
	LD   A,-3		;error code 3 --> accu
	RET

;actual I/O handler:		
INITW:	LD   (SECTOR),A		;store sector #


*EJECT
	COND SASI		;Xebec part

	LD   A,(OLDW)		;number of previously accessed drive --> reg. C
	LD   C,A
	OR   A			;no drive previously accessed ?
	JP   P,INITW1		;select controller
	OUT  (WPORT1),A		;reset controller
INITW1:	LD   A,(DRIVE)		;drive # --> accu
	LD   (OLDW),A		;save it
	CP   C			;same as old drive ?
	JR   Z,INITW2 		;no drive selection needed if yes

;select Winchester drive:
       	LD   IY,WPARS		;^Winchster parameters --> reg. IY
	LD   H,(IX+6)		;track count --> reg. HL
	LD   L,(IX+5)
	LD   D,0   		;clear MSB of divisor
    	LD   E,(IX)  		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	LD   (IY+2),E		;load head count
	CALL DIV		;calc cylinder count
	LD   (IY),H		;load cylinder count
	LD   (IY+1),L
	LD   (IY+3),H		;load starting cylinder 
	LD   (IY+4),L		;for reduced write current
	LD   H,0		;calc startimg cylinder for write precomp
	LD   L,(IX+2)
	ADD  HL,HL
	ADD  HL,HL
	LD   (IY+5),H		;load starting cylinder for write precomp
	LD   (IY+6),L
	LD   A,$INIDRV		;initialize drive data
	CALL TASKOUT

	LD   HL,WPARS		;^Winchester parameters --> reg. HL
	LD   BC,8 SHL 8+WPORT0	;number of bytes	--> reg. B
				;SASI port 0 		--> reg. C
        CALL REQWAIT		;wait for data request
SELDRV:	IN   A,(RPORT1)		;read status again
	AND  IOMASK+CDMASK+REQMASK	
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,SELDRV1		;jump if data transfer finished
	CP   REQMASK
	JR   NZ,SELDRV 		;wait for request
	OTIR			;load disk parameters
	JR   SELDRV

SELDRV1:CALL GETSTAT		;get error status
	JR   NZ,ERREXIT		;any errors ?

INITW2:	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,RWINI		;jump if yes

;restore drive heads:
RESTOW:	LD   A,$TSTDRV		;test drive ready
	CALL TASKOUT
	CALL GETSTAT		;get error status
	JR   NZ,RESTOW		;retry if drive not ready
        LD   A,$REST  		;recalibrate drive
	CALL TASKOUT
	CALL GETSTAT		;get error status
	JR   NZ,ERREXIT		;any errors ?
      	SET  0,(IX+1)		;set init bit in WCT


*EJECT
	ELSE			;WD1002 part

	EX   DE,HL		;track #  --> reg. HL
	LD   D,0   		;clear MSB of divisor
    	LD   E,(IX)  		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	CALL DIV		;cylinder # = track # / head count (HL)
				;surface #  = track # % head count (DE)
	LD   A,(DRIVE)		;drive # --> accu
	ADD  A,A		;shift drive # 3 bits left
	ADD  A,A
	ADD  A,A
	ADD  A,E		;add surface #
	LD   E,A		;and save it
	LD   A,(IX+1)		;get sector length bits
	RRA
	AND  60H		;mask sector length bits
	ADD  A,E		;add surface # and drive #
	OR   80H		;set ECC error correction bit
	LD   E,A		;save drive select bits
	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,TRKSEW 		;yes, skip init process

;restore drive heads:
RESTOW:	IN   A,($STATUS)	;read WDC status
	AND  0C0H		;mask it
	CP   40H		;busy ?
	JR   NZ,RESTOW		;wait `til WDC is ready to accept a command
	OUT  ($SDH),A		;select drive
	LD   A,(IX)		;get step rate bits
	AND  0FH		;mask them
	OR   $REST		;or with "restore" command
	OUT  ($COMND),A		;restore drive heads
RESTO1: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;restore done ?
	JR   NZ,RESTO1 		;no, loop
      	SET  0,(IX+1)		;set init bit in WCT

;set track and sector:
TRKSEW: LD   A,(IX+2)		;set starting track for write precomp
	OUT  ($WPC),A
        LD   A,(SECTOR)		;sector # --> accu
	BIT  4,(IX)		;test number of first sector
	JR   Z,TRKSW1		;jump if zero
	INC  A			;else adjust sector #
TRKSW1:	OUT  ($SECNO),A         ;set sector #
	LD   A,L     		;set cylinder # (LSB)
	OUT  ($CYLLO),A
	LD   A,H                ;set cylinder # (MSB)
	OUT  ($CYLHI),A
	LD   A,E		;restore drive select bits
	OUT  ($SDH),A		;select drive

;init READ/WRITE:
	LD   E,(IX+1)		;get sector length bits
	LD   B,6
	SRL  E
	DJNZ $-2
	LD   C,$DATA		;init byte counter and data port number

	ENDC

RWINI:  LD   HL,(BUFFER)	;get buffer pointer	
	LD   A,(RDFLAG)		;READ or WRITE ?
	OR   A
	PUSH AF			;save status
	JR   Z,RWINI1		;jump if write
	LD   A,$$READ		;issue read command
	JR   RWINI2
RWINI1:	LD   A,$$WRITE		;issue write command
	
	COND SASI		;Xebec part

RWINI2:	CALL TASKOUT

	ELSE

RWINI2:	OUT  ($COMND),A		;WD1002 part

	ENDC

	LD   A,(BANK)		;bank # of transfer buffer --> accu
	JP   IOW		;handle Winchester I/O in common memory

;test controller status:

	COND SASI		;Xebec part

WDCSTAT:CALL GETSTAT		;get status
	RET  Z			;return if no errors
ERREXIT:LD   A,$STATUS		;request sense status
	CALL TASKOUT
	
        CALL REQWAIT		;wait for data request
        IN   A,(RPORT0)		;read error code
	LD   D,A		;save it temporarily
	IN   A,(RPORT0)		;skip rest
	IN   A,(RPORT0)
	IN   A,(RPORT0)
	CALL GETSTAT		;get status 
	JR   NZ,ERREXIT

        LD   A,D      		;restore error code
	AND  7FH
	RET

	ELSE			;WD1002 part

WDCSTAT:IN   A,($STATUS)	;get WDC status
	AND  1  		;any errors ?
	LD   C,A		;save error status
	JR   Z,DSEL		;return if no errors
	IN   A,($ERROR)	        ;read WDC error register
	LD   C,A		;save error code

DSEL:	LD   A,$DSEL 		;deselect drive
	OUT  ($SDH),A
	LD   A,C		;error code --> accu
	RET			;return to caller

	ENDC

;put drive control table pointer in "IX":
GETWCT: PUSH DE			;save reg. DE
	LD   H,0		;drive # --> reg. HL	
	LD   L,A		
	ADD  A,A		;drive # * 2
	ADD  A,L		;drive # * 3
	ADD  A,A		;drive # * 6
	ADD  A,L  		;drive # * 7	
	LD   L,A		;drive # * 7 --> reg. H
	LD   DE,DCTW		;get drive table start
  	ADD  HL,DE		;add offset and get ^DCT
	PUSH HL			;^DCT --> reg. IX
	POP  IX
	POP  DE			;restore reg. DE
	RET			;return

BANK:	DEFS 1			;bank number of transfer buffer


*EJECT
	COND SASI		;Xebec part

;output a command to SASI controller:
TASKOUT:PUSH HL			;save regs. HL & IY
	PUSH IY			;save reg. IY
	LD   IY,DCCMD		;^command block --> reg. IY
	LD   (IY),A		;store command
	LD   A,(DRIVE)		;load drive #
	RRCA
	RRCA
	RRCA
	LD   (IY+1),A
	LD   DE,(TRACK)		;track #         	 --> reg. DE
	LD   HL,0		;clear result
	LD   B,(IX+4)		;sectors/track 		 --> reg. B
TASKO1: ADD  HL,DE		;track # * sectors/track --> reg. HL
	DJNZ TASKO1
	LD   D,0		;sector # 		 --> reg. DE
	LD   A,(SECTOR)
	LD   E,A
	ADD  HL,DE		;block # = track # * sectors/track + sector #
	LD   (IY+2),H		;load block #
	LD   (IY+3),L
	LD   A,(IX)		;get step rate ?
	AND  0FH
	LD   A,0
	JR   NZ,TASKO2  	;jump if not
	LD   A,5		;set buffered step mode
TASKO2: LD   (IY+5),A		;load control byte

TASKO3:	IN   A,(RPORT1)		;read status port
	AND  BUSYMASK		;mask busy bit
	JR   NZ,TASKO3		;jump, if busy
	LD   A,1		;cntlr default select code
	OUT  (WPORT0),A		;send it to transparent latch
TASKO4:	OUT  (WPORT2),A		;generate a select strobe
      	IN   A,(RPORT1)		;get cntlr response
	AND  BUSYMASK		;isolate the busy mask
	JR   Z,TASKO4		;wait for cntlr busy

	LD   HL,DCCMD		;^command block --> reg. HL
	LD   BC,6 SHL 8+WPORT0	;byte count	--> reg. B
				;port number	--> reg. C
	CALL REQWAIT   		;wait for controller request
	OTIR			;load command

	POP  IY			;restore regs. HL & IY
	POP  HL
	RET

;get status:
GETSTAT:CALL REQWAIT		;wait for request
	IN   A,(RPORT0)		;read in the status byte
	LD   C,A		;save status temporarily
	CALL REQWAIT		;wait for second byte
	IN   A,(RPORT0)		;get the null byte
	LD   A,C		;restore status to A
	AND  ERROR		;isolate the error bit
	RET

;Winchester drive parameters:
WPARS:	DEFS 2			;cylinder count
	DEFS 1			;head 	  count
	DEFS 2          	;starting cylinder for reduced write current
	DEFS 2			;starting cylinder for write precompensation
	DEFB 11			;length of ECC impulse

;command control block:
DCCMD:	DEFS 1			;opcode
	DEFS 1			;luno
	DEFS 2			;block number
	DEFB 1			;block count
	DEFS 1			;control field

SENSE:	DEFS 4			;sense status bytes
OLDW:	DEFB 0FFH		;previously accessed drive

	ENDC


*EJECT
;*******************
;*  $ G T I M E 3  *
;*******************

;entry: HL = pointer to a 5 byte buffer containing on exit
;	     date and time in the form DDDDHHMMSS

;	      DDDD = number of days since January 1st, 1978 (binary    )
;		HH = hours   				    (BCD format)
;		MM = minutes 				    (BCD format)
;		SS = seconds 				    (BCD format)

;get time & date in CP/M 3 format (software clock):
$GTIME3S:
	EX   DE,HL		;^user buffer --> reg. DE
	DI			;critical phase
	JP   GTIME5		;transfer time & date into caller's buffer

;get time & date in CP/M 3 format (hardware clock):
$GTIME3H:
	DI			;critical code (not reentrant)
	PUSH HL			;save ^user buffer
        CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer   --> reg. IX
	LD   IY,BINARY$DATE 	;^result buffer --> reg. IY	

	LD   A,(IX+7)		;hours (tenths) --> reg. C
	AND  3			;make binary
	RLCA    		;hours (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	--> reg. C
	LD   A,(IX+8)		;hours (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+2),A           ;store BCD hours	

	LD   A,(IX+9)		;minutes (tenths) --> reg. C
	AND  7			;make binary
	RLCA    		;minutes (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+10)		;minutes (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+3),A           ;store BCD minutes

	LD   A,(IX+11)		;seconds (tenths) --> reg. C
	AND  7			;make binary
	RLCA    		;seconds (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+12)		;seconds (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+4),A           ;store BCD seconds

	LD   A,(IX+1)		;year (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;year (ones)   --> reg. C
	LD   A,(IX)		;year (tenths) --> accu
	AND  0FH		;make binary
	CALL BCDBIN		;convert BCD year to binary
	LD   (YEAR),A		;store it

	LD   A,(IX+3)		;month (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;month (ones)   --> reg. C
	LD   A,(IX+2)		;month (tenths) --> accu
	AND  1  		;make binary
	CALL BCDBIN		;convert BCD month to binary
	LD   (MONTH),A		;store it

	LD   A,(IX+5)		;day (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;day (ones)   --> reg. C
	LD   A,(IX+4)		;day (tenths) --> accu
	AND  3  		;make binary
	CALL BCDBIN		;convert BCD day to binary
	LD   (DAY),A		;store it

	LD   A,(YEAR)		;binary year --> accu
	SUB  78                 ;subtract base year
	JR   NC,GTIME1          ;result negative ?
	ADD  A,100              ;correct year	
GTIME1: SRL  A			;year / 4 --> accu
	RR   C        		;year % 4 --> reg. C
	SRL  A
	RR   C
	LD   B,6
GTIME2: SRL  C
	DJNZ GTIME2
	LD   HL,0               ;clear daycount
	OR   A			;year / 4 == 0 ?
	JR   Z,GTIME4		;no multiplication
	LD   B,A                ;year / 4 --> reg. B
	LD   DE,1461		;number of days in 4 years --> reg. DE
GTIME3: ADD  HL,DE              ;daycount = year / 4 * 1461
	DJNZ GTIME3
GTIME4:	EX   DE,HL		;daycount --> reg. DE

;calc table index:
	LD   A,C		;year %  4    --> accu
	ADD  A,A		;accu *  2
 	ADD  A,A		;accu *  4
	LD   C,A     		;accu *  4    --> reg. C
  	ADD  A,A		;accu *  8
	ADD  A,C   		;accu * 12
	LD   C,A		;accu * 12    --> reg. C
	LD   A,(MONTH)          ;binary month --> accu
	DEC  A     		;normalize
	ADD  A,C		;index = year % 4 * 12 + month - 1
	ADD  A,A		;make byte index
	LD   C,A		;table index       --> reg. BC
	LD   HL,MONTAB          ;base of day table --> reg. HL
	ADD  HL,BC		;add index
	LD   A,(HL)		;table[index]      --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,A

	ADD  HL,DE 		;daycount += table[index]
	LD   A,(DAY)		;binary day --> accu
	LD   C,A   		;day        --> reg. BC
	ADD  HL,BC		;now reg. HL contains number of days
	        		;since January 1st, 1978

	LD   (IY),L 		;store daycount
	LD   (IY+1),H           

	POP  DE			;restore ^user buffer
GTIME5:	LD   HL,BINARY$DATE	;^temporary buffer --> reg. HL
	LD   B,5		;buffer length	   --> reg. B
	LD   A,(INT)		;called from interrupt service routine ?
	OR   A
	LD   A,1  		;source bank      = 0
				;destination bank = 1
	JP   Z,$XMOVE		;move time & date into user buffer and return,
				;if not called from interrupt service routine

	LD   BC,5		;buffer length --> reg. BC
	LDIR			;no interbank move, if called from interrupt
	RET			;service routine

;convert BCD to binary:
BCDBIN:	ADD  A,A		;lower nibble *  2
	LD   B,A		;lower nibble *  2 --> reg. B
	ADD  A,A		;lower nibble *  4
	ADD  A,A		;lower nibble *  8
	ADD  A,B		;lower nibble * 10
	ADD  A,C		;add lower nibble
	RET

YEAR:	DEFS 1
MONTH:	DEFS 1
DAY:	DEFS 1


*EJECT
;*******************
;*  $ S T I M E 3  *
;*******************

;entry:  D = hours   (HH)
;	 E = minutes (MM)
;	HL = number of days since January 1st, 1978 (binary)

;set time & date in CP/M 3 format (software clock):
$STIME3S:
	DI			;critical phase
	LD   (BINARY$DATE),HL	;load binary date
	LD   HL,TIME$IN$BCD	;^BCD time --> reg. HL
	LD   (HL),D		;load BCD hours
	INC  HL
	LD   (HL),E		;load BCD minutes
	INC  HL
	LD   (HL),0		;reset BCD seconds
	RET			;return to caller

;set time & date in CP/M 3 format (hardware clock):
$STIME3H:
	PUSH DE			;save hours & minutes
	PUSH HL			;save daycount
	DEC  HL			;normalize

        XOR  A     		;clear quotient
	LD   DE,1461  		;number of days in 4 years --> reg. DE
STIME1: SBC  HL,DE              ;daycount / 1461 	   --> accu
	JR   C,STIME2
	INC  A
	JR   STIME1
STIME2: ADD  HL,DE              ;adjust remainder
	EX   DE,HL		;remainder --> reg. DE
	ADD  A,A		;accu * 2
	ADD  A,A		;accu * 4
	LD   (YEAR),A           ;year = daycount / 1461 * 4

;search table entry:
	LD   A,47               ;last index 	   --> accu
STIME3: LD   H,0                ;index #           --> reg. HL
	LD   L,A
	ADD  HL,HL  		;make byte index
	LD   BC,MONTAB          ;dase of day table --> reg. BC
	ADD  HL,BC		;calc table entry
	LD   B,(HL)             ;table[index]      --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,B
	SBC  HL,DE              ;daycount >= table index ?
	JR   C,STIME4 		;if yes search finished
	JR   Z,STIME4
	DEC  A  		;index = index - 1
	JP   P,STIME3

STIME4: LD   B,0                ;clear quotient
STIME5:	SUB  12                 ;index / 12 --> accu
	JR   C,STIME6
	INC  B			;increment quotient
	JR   STIME5
STIME6:	ADD  A,13		;adjust remainder and calc month
	LD   (MONTH),A          ;store it
	LD   A,(YEAR) 		;year --> accu
	ADD  A,B   		;year += index / 12
	SUB  22			;normalize
	JR   NC,STIME7          ;year negative ?
	ADD  A,100		;correct it
STIME7: LD   (YEAR),A           ;store it
	LD   A,L		;table[index] - daycount --> accu
	NEG     		;daycount - table[index] --> accu
	INC  A     		;day = daycount - table[index] + 1
	LD   (DAY),A            ;store it

	POP  HL			;restore day count
	LD   A,H		;daycount (MSB)	      --> accu
	LD   C,L		;daycount (LSB)	      --> reg. C
	LD   DE,7		;no. of days per week --> reg. DE
	LD   HL,0		;clear accumulator
	LD   B,16		;init counter
STIME8:	RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
	SBC  HL,DE		;subtract divisor
	JR   NC,$+3		;subtraction ok
	ADD  HL,DE		;restore accumulator
	CCF			;complement carry flag
	DJNZ STIME8		;counter = 0 ?
	LD   A,L		;weekday no. --> accu
        PUSH AF 		;save weekday

	LD   A,(MONTH)		;binary month --> accu
	CALL BINBCD		;convert to BCD format
	LD   D,A     		;save month

	LD   A,(DAY)		;binary day --> accu
	CALL BINBCD		;convert to BCD format
	LD   H,A		;BCD day     --> reg. H
	LD   A,(YEAR)		;binary year --> accu
	RRA			;year / 4
	JR   C,STIME9
	RRA
	JR   C,STIME9
       	SET  6,H		;set leapyear flag

STIME9:	LD   A,(YEAR)		;binary year --> accu
	CALL BINBCD		;convert to BCD format
	LD   L,A   		;BCD year    --> reg. L

	LD   B,D		;BCD month   --> reg. B
	POP  AF			;weekday     --> accu
	POP  DE			;BCD hours   --> reg. D
				;BCD minutes --> reg. E
	SET  7,D		;set "24 hour" format
	JP   $SETTIM		;set time & date and return to caller

;convert binary to BCD:
BINBCD:	LD   C,0		;clear result
BINBC1: SUB  10			;accu / 10
	JR   C,BINBC2
	INC  C  		;increment quotient
	JR   BINBC1
BINBC2: ADD  A,10		;adjust remainder
	LD   B,4
BINBC3:	SLA  C			;quotient --> upper nibble
	DJNZ BINBC3
	ADD  A,C		;add remainder
	RET

;day table:
;	     Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec	
MONTAB:	DEFW 0000,0031,0059,0090,0120,0151,0181,0212,0243,0273,0304,0334  ;1978
        DEFW 0365,0396,0424,0455,0485,0516,0546,0577,0608,0638,0669,0699  ;1979
        DEFW 0730,0761,0790,0821,0851,0882,0912,0943,0974,1004,1035,1065  ;1980
        DEFW 1096,1127,1155,1186,1216,1247,1277,1308,1339,1369,1400,1430  ;1981


*EJECT
;*******************
;*  $ L D C H A R  *
;*******************

;entry:  A = ASCII code of character to be loaded (00 - 7F)
;	HL = address of dot matrix (16 bytes)

;load user character:
$LDCHAR:AND  7FH		;make seven bit ASCII code
	PUSH AF			;save ASCII code
	LD   DE,PATTERN		;^dot matrix     --> reg. DE
	LD   B,16		;number of bytes --> reg. B
	LD   A,10H		;source bank 	  = 1
				;destination bank = 0
	CALL $XMOVE		;load matrix
	POP  BC			;ASCII code --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	LD   A,B		;ASCII code --> accu
	LD   (3C00H),A		;load ASCII code
	LD   DE,PATTERN		;^dot matrix 	  	     --> reg. DE
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
LDCHAR1:LD   A,(DE)		;get first scan	line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ LDCHAR1		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	OR   80H		;set MSB
	LD   (3C00H),A		;reload code	
	LD   DE,PATTERN		;^dot matrix 	  	     --> reg. DE
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
LDCHAR2:LD   A,(DE)		;get first scan	line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ LDCHAR2		;load next scan line
	LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A
	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;disable character RAM
	OUT  ($SYS0),A		;write system byte 0
	RET			;return to caller
PATTERN:DEFS 16			;temporary storage area for dot matrix
SAVECH:	DEFS 1


*EJECT
;*******************
;*  $ R S T C H R  *
;*******************

;restore original character set:
$RSTCHR:IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	XOR  A  		;reset code counter
	LD   DE,FONTSET		;^dot matrices --> reg. DE
RSTCHR1:LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
RSTCHR2:LD   A,(DE)		;get first scan	line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ RSTCHR2		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	INC  A			;increment ASCII code
	JP   P,RSTCHR1		;load next character

;load inverted characters
	LD   DE,FONTSET		;^dot matrices --> reg. DE
RSTCHR3:LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
RSTCHR4:LD   A,(DE)		;get first scan	line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ RSTCHR4		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	INC  A			;increment ASCII code
	JR   NZ,RSTCHR3		;load next character
	LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A

;select ASCII or national character set:
SELCHR:	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	LD   IX,NATIONAL	;^national codes --> reg. IX
	LD   A,(GERMAN)		;national char set ?
	OR   A
	JR   Z,SELCHR1		;jump if no 
	LD   DE,FONTSET+136*16	;^dot matrices  --> reg. DE
	JR   SELCHR2
SELCHR1:LD   DE,FONTSET+128*16	;^dot matrices  --> reg. DE
SELCHR2:LD   A,(IX)		;character code --> accu
	OR   A			;end of table ?
	JR   Z,SELCHR4		;jump if yes
	INC  IX			;bump table ptr
        LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
SELCHR3:LD   A,(DE)		;get first scan	line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ SELCHR3		;load next scan line
	JR   SELCHR2  		;load next character

;load inverted characters:
SELCHR4:LD   IX,NATIONAL	;^national codes --> reg. IX
        LD   A,(GERMAN)		;national char set ?
	OR   A
	JR   Z,SELCHR5		;jump if no 
	LD   DE,FONTSET+136*16	;^dot matrices  --> reg. DE
	JR   SELCHR6
SELCHR5:LD   DE,FONTSET+128*16	;^dot matrices  --> reg. DE
SELCHR6:LD   A,(IX)		;character code --> accu
	OR   A			;end of table ?
	JR   Z,SELCHR8		;jump if yes
	OR   80H		;make code of inverted char
	INC  IX			;bump table ptr
        LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
SELCHR7:LD   A,(DE)		;get first scan	line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ SELCHR7		;load next scan line
	JR   SELCHR6  		;load next character

SELCHR8:LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A
	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;disable character RAM
	OUT  ($SYS0),A		;write system byte 0
	EI			;reenable interrupts
	RET			;return to caller


;codes of national character set:
NATIONAL:
	DEFM '@[\]{|}~' 
	DEFB 0


*EJECT
;*******************
;*  $ S C R N I O  *
;*******************

;entry:  A = control code
;	     0  read  window
;	     1  write window
;	HL = address of user buffer
;	 D = 0  contiguous  buffer
;	     1  full screen buffer 	
;	 E = attribute
;	     0  normal   display
;	     1  inverted display	

;direct screen I/O:
$SCRNIO:LD   IX,(VDTABP)	;^screen constants --> reg. IX
	LD   (IOMODE),A		;save I/O mode
	PUSH HL			;save ^user buffer
	PUSH DE			;save buffer mode
	LD   A,(IX+8)		;save current line
	LD   (SLINE),A
	LD   A,(IX+9)		;save current column
	LD   (SCOLUMN),A
	LD   A,(IX+11)		;save current display mode
	LD   (SMODE),A	
	LD   A,(IX+12)		;save cursor state
	LD   (SCUROFF),A
	LD   A,(WRAP)		;save "wrap around" mode
	LD   (SWRAP),A
	DEC  E			;test display mode
	JR   Z,SCRNIO1		;jump if inverse display mode
	CALL INVOFF		;turn on normal display mode 
	JR   SCRNIO2
SCRNIO1:CALL INVON		;turn on inverse display mode
SCRNIO2:CALL CUROFF		;turn off cursor
	CALL WRAPOFF		;turn off "wrap around" mode
	CALL HOME		;home cursor
	
	POP  DE			;get buffer mode
	DEC  D			;calc buffer increment
	JR   Z,SCRNIO3		;jump if full screen buffer
	LD   A,(IX+7)		;buffer increment = column count
	JR   SCRNIO4
SCRNIO3:LD   A,(IX+1)		;buffer increment = maximum column count
	POP  DE			;get base address of screen buffer
	ADD  HL,DE		;add cursor address (returned from "HOME")
	PUSH HL			;save actual buffer address
SCRNIO4:LD   (BINC),A		;store buffer increment

;screen I/O:
	LD   A,(IOMODE)		
	OR   A			;read or write screen ?
	JR   NZ,SCRNIO9		;jump if write screen


*EJECT
;read screen:
SCRNIO5:LD   IY,LINBUF		;^temp buffer --> reg. IY
	LD   B,(IX+7)		;column count --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1

SCRNIO6:PUSH BC			;save remaining column count
	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   A,(HL)		;character under cursor  --> accu
	AND  7FH		;mask it
	CP   (IX+10)		;erase character ?
	JR   NZ,SCRNIO7		;jump if not
	LD   A,' '		;convert it to space
SCRNIO7:CP   ' '		;graphic character ?
	JR   NC,SCRNIO8		;jump if not
	ADD  A,80H		;convert code of graphic character
SCRNIO8:LD   (IY),A		;store character
	INC  IY			;inc buffer pointer
	CALL CURRGT		;move cursor right
	POP  BC			;restore column count
	DJNZ SCRNIO6		;read next character

	IN   A,($SYS1)		;read system byte 1
	OR   01010101B		;disable memory mapped I/O
	OUT  ($SYS1),A		;write system byte 1
	LD   HL,LINBUF		;source      address --> reg. HL
	POP  DE			;destination address --> reg. DE
	PUSH DE
	LD   B,(IX+7)		;byte count	     --> reg. B
	LD   A,1		;source      bank = 0
				;destination bank = 1
	CALL $XMOVE		;transfer screen line into user buffer

        LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; == bottom line ?
	JR   Z,SCRNI12      	;jump if yes

	CALL NEWLIN		;carriage return
	CALL CURDWN		;line feed

	LD   HL,(BINC)		;buffer increment --> reg. HL
	LD   H,0
	POP  DE			;buffer pointer   --> reg. DE
	ADD  HL,DE		;increment buffer pointer
	PUSH HL			;save it
	JR   SCRNIO5		;read next line


*EJECT
;write screen:
SCRNIO9:POP  HL			;source      address --> reg. HL
SCRNI10:PUSH HL			;save it
	LD   DE,LINBUF		;destination address --> reg. HL
	LD   B,(IX+7)		;byte count	     --> reg. B
	LD   A,10H		;source      bank = 1
				;destination bank = 0
	CALL $XMOVE		;transfer screen line into user buffer

        LD   IY,LINBUF		;^temp buffer --> reg. IY
	LD   B,(IX+7)		;column count --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1

SCRNI11:PUSH BC			;save remaining column count
	LD   A,(IY)		;character --> accu
	CALL NORMAL		;display character
	INC  IY			;inc buffer pointer
	POP  BC			;restore column count
	DJNZ SCRNI11		;display next character

	IN   A,($SYS1)		;read system byte 1
	OR   01010101B		;disable memory mapped I/O
	OUT  ($SYS1),A		;write system byte 1

        LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; == bottom line ?
	JR   Z,SCRNI12		;jump if yes

	CALL NEWLIN		;carriage return
	CALL CURDWN		;line feed

	LD   HL,(BINC)		;buffer increment --> reg. HL
	LD   H,0
	POP  DE			;buffer pointer   --> reg. DE
	ADD  HL,DE		;increment buffer pointer
	JR   SCRNI10		;write next line


*EJECT
;restore old screen state:
SCRNI12:POP  HL			;adjust stack pointer
	LD   A,(SLINE)		;restore current line
	LD   (IX+8),A
	LD   A,(SCOLUMN)	;restore current column
	LD   (IX+9),A
	LD   A,(SMODE)		;restore current display mode
	LD   (IX+11),A		
	LD   A,(SCUROFF)	;restore cursor state
	LD   (IX+12),A		
	LD   A,(SWRAP)		;restore "wrap around" mode
	LD   (WRAP),A
	CALL OUTCUR		;position cursor
	JP   CURON+4		;turn on (?) cursor and return to caller

;temporary storage area:
SLINE:	DEFS 1			;current cursor line
SCOLUMN:DEFS 1			;current cursor column
SMODE:	DEFS 1			;current display mode
SCUROFF:DEFS 1			;current cursor state
SWRAP:	DEFS 1			;current "wrap around" mode
IOMODE:	DEFS 1			;read or write screen ?
BINC:	DEFS 1			;buffer pointer increment
LINBUF:	DEFS 80			;line buffer


*EJECT
;***************
;*  $ I N I T  *
;***************

;general initialization routine:
$INIT:	DI			;disable interrupts
	IM   1			;select interrupt mode 1 (RST 38H)
 	IN   A,($SYS0)		;read system byte 0
	AND  00110011B		;enable bank 0
				;RTC interrupt only
	OUT  ($SYS0),A		;write system byte 0

	CALL $RSTCHR		;load character set

	XOR  A			;source bank      = 0
				;destination bank = 0
	LD   HL,VIDPAR		;^video parameters --> reg. HL
	CALL VDINIT1		;initialize video controller chip MC6845

	LD   A,ESC		;select national character set
	CALL $VDCHAR
	LD   A,(CHRSET)
	CALL $VDCHAR

	LD   B,0		;# of RS232C interface --> reg. B
	LD   HL,(SER0)		;data format 	       --> accu
	LD   A,L
	LD   E,H		;baud rate   	       --> reg. E
	CALL $RSINIT		;initialize Z80 SIO A

	LD   B,1		;# of RS232C interface --> reg. B
	LD   HL,(SER1)		;data format 	       --> accu
	LD   A,L
	LD   E,H		;baud rate   	       --> reg. E
	CALL $RSINIT		;initialize Z80 SIO B

	LD   HL,PIO$INIT$TBL	;initialize Z80 PIO 
STREAM$OUT:
	LD   A,(HL)
	OR   A
	JR   Z,$FCINIT
	LD   B,A
	INC  HL
	LD   C,(HL)
	INC  HL
	OTIR
	JR   STREAM$OUT		;now Z80 PIO acts as Centronics interface
PIO$INIT$TBL:
	DEFB 2,0D6H,0FH,07H
	DEFB 3,0D7H,0CFH,0F0H,07H
	DEFB 1,0D5H,01H
	DEFB 0

$FCINIT:LD   A,$FCINT           ;initialize floppy disk controller chip WD2791
        OUT  ($FDCMD),A


*EJECT
;powerup/reset test:
	LD   A,10H		;source      bank    = 1
				;destination bank    = 0
	LD   HL,0038H		;source      address = interrupt entry point
	LD   DE,JUMP		;destination address = test variable
	LD   B,1		;byte count 	     = 1
	CALL $XMOVE		;get byte from interrupt entry point in bank 1

	LD   A,(JUMP)		;JP ?
	CP   0C3H
	JR   NZ,$POWUP		;jump if power up
	XOR  A			;clear power up marker
	JR   $RESET
$POWUP:	LD   HL,1		;reset binary date
	LD   (BINARY$DATE),HL
	LD   HL,TIME$IN$BCD	;^BCD time --> reg. HL
	XOR  A
	LD   (HL),A		;reset BCD hours
	INC  HL
	LD   (HL),A		;reset BCD minutes
	INC  HL
	LD   (HL),A		;reset BCD seconds
	CPL        		;set power up marker
$RESET: LD   (POWUP),A

;set interrupt jump vectors:
	LD   A,3		;initialize bank number
$SETINT:LD   HL,0038H		;interrupt entry point --> reg. HL & DE
	LD   D,H
	LD   E,L
	LD   B,3		;byte count 	       --> reg. B
	PUSH AF			;save bank number
	CALL $XMOVE		;transfer jump vector
	POP  AF			;restore bank number
	DEC  A			;decrement bank number
	JR   NZ,$SETINT		;load next interrupt entry point

;hardware clock ?
	LD   A,(CLOCK)
	OR   A
	JR   Z,$CLSGR		;jump if not
	LD   HL,$GTIME3H	;alter entry vectors to 
	LD   ($GTIME3),HL	;clock maintenance routine
	LD   HL,$STIME3H
	LD   ($STIME3),HL

;clear graphic pages:
$CLSGR:	XOR  A			;colour = black
	LD   B,A		;clear graphic page 0
	CALL $CLS
	XOR  A			;colour = black
	LD   B,1		;clear graphic page 1
	CALL $CLS

;calc number of graphic scan lines:
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   DE,(VIDPAR+6)	;number of text	lines		    --> reg. DE
	LD   D,0
	LD   H,D
	LD   L,D
LOOP:	ADD  HL,DE		;calc total number of scan lines - 1
	DJNZ LOOP
	DEC  HL
	LD   (YMAX),HL		;store them		

;build table of y-addresses:
	LD   BC,(VIDPAR+5)	;number of text lines --> reg. B
	LD   DE,YTAB		;^address table	      --> reg. DE
	LD   HL,8000H   	;^graphic screen      --> reg. HL
OLOOP:	PUSH BC			;save line counter
	LD   (YBASE),HL		;store base address
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
ILOOP:	LD   A,L		;calc y address
	LD   (DE),A
	INC  DE
	LD   A,H
	LD   (DE),A
	INC  DE
	LD   A,8
	ADD  A,H
	LD   H,A
	DJNZ ILOOP		;process next scan line
	LD   HL,(YBASE)		;bump base address
	LD   BC,80
	ADD  HL,BC
	POP  BC			;restore line counter
	DJNZ OLOOP		;process next text line

;build table of normalized y-addresses:
	LD   IX,YNTAB		;^address table --> reg. IX
	LD   DE,0		;initialize scan line counter

NOLOOP:	PUSH DE			;save it

	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   HL,0			
NILOOP:	ADD  HL,DE		;y-coordinate * # of scan lines
	DJNZ NILOOP

	LD   DE,18		;load divisor
	CALL DIV
	LD   A,E		;remainder --> accu
	CP   9			;remainder >= 9 ?
	JR   C,$+3  		;jump if not
	INC  HL			;round normalized y-coordinate

	ADD  HL,HL		;make word index
	LD   DE,YTAB		;^unnormalized address table --> reg. DE
	ADD  HL,DE		;calc entry address
	LD   A,(HL)		;copy table entry
	LD   (IX),A
	INC  IX
	INC  HL
	LD   A,(HL)
	LD   (IX),A
	INC  IX
	
	POP  DE			;restore scan line counter
	INC  DE			;increment it
	LD   HL,450		;total count of scan lines --> reg. HL
	CALL CMP		;reached ?
	JR   NZ,NOLOOP		;process next scan line if not
	RET

YBASE:	DEFS 2       		;base address of graphic screen - 80
JUMP:	DEFS 1			;byte at 0038H in bank 1


*EJECT
;*****************
;*  $ C L O C K  *
;*****************

;entry: A =  0  clock display off
;	  <> 0  clock display on
;	B = line   number (0 - 24)
;	E = column number (0 - 79)

;set clock display on/off:
$CLOCK:	LD   IX,(VDTABP)	;^screen constants 		  --> reg. IX
	LD   HL,$SCREEN		;address of first screen location --> reg. HL
	LD   C,E		;display column			  --> reg. C
	LD   D,0		;maximum column count		  --> reg. DE
	LD   E,(IX+1)
	DEC  B			;calc absolute screen address
	INC  B
	JR   Z,CLOCK2
CLOCK1:	ADD  HL,DE
	DJNZ CLOCK1
CLOCK2:	LD   E,C
	ADD  HL,DE
	LD   (CLOCK$LOC),HL	;save display address
       	LD   (CLOCKON),A	;set/reset display marker
	RET			;return to caller
CLOCKON:DEFB 0
CLOCK$LOC:
	DEFS 2


*EJECT
;***************
;*  $ D I S P  *
;***************

;entry: A =  0  turn off graphic display
;	  <> 0  turn on  graphic display
;	B =  graphic page number (0, 1)

$DISP:	LD  C,A			;save accu
	IN  A,($SYS0)		;read system byte 0
	AND 00100001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	INC B			;test page number
	DEC B
	JR  Z,DISP1		;jump if page 0
  	SET 4,A			;select page 1
DISP1:	OUT ($SYS0),A		;write system byte 0
	
	IN  A,($SYS1)		;read system byte 1
	AND 11010101B		;7.2 MHz clock rate
				;disable graphic page
				;disable boot ROM
				;disable graphic display
				;disable memory mapped I/O
	INC C			;test display mode
	DEC C
	JR  Z,DISP2		;jump if no display
	SET 1,A			;enable graphic display
DISP2:	OUT ($SYS1),A		;write system byte 1
	RET			;return to caller


*EJECT
;*************
;*  $ C L S  *
;*************

;entry: A = 0  black
;	    1  white
;	B = graphic page number (0, 1)

;clear graphic page:
$CLS:	LD  C,A			;save colour
	IN  A,($SYS0)		;read system byte 0
	AND 00010001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	INC B			;test page number
	DEC B
	JR  Z,CLS1		;jump if page 0
	SET 5,A			;select page 1
CLS1:	OUT ($SYS0),A		;write system byte 0


	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	LD  A,C			;restore colour
	LD  HL,8000H		;^graphic memory        --> reg. HL
	LD  DE,8001H		;^graphic memory + 1    --> reg. DE
	LD  BC,7FFFH		;size of graphic memory --> reg. BC
	OR  A			;colour ?
	JR  Z,CLS2		;jump if black
	LD  A,0FFH		;select white
CLS2:	LD  (HL),A
	LDIR			;clear graphic page

	IN  A,($SYS1)		;read system byte 1
	AND 11010111B		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	RET			;return to caller


*EJECT
;***************
;*  $ P L O T  *
;***************

;entry:  A = 0  non-normalized (high nibble) 
;	     1      normalized 
;	     0  black          (low  nibble)
;	     1  white
;        B = graphic page number (0, 1)
;	HL = y-coordinate (0 - YYY)
;	DE = x-coordinate (0 - 639)

$PLOT:	PUSH BC			;save graphic page #
      	PUSH AF			;save colour
	PUSH DE			;save x-coordinate
	AND  0F0H		;normalize y-coordinate ?
	JR   Z,PLOT1		;jump if not
	
;normalize y-coordinate:
      	EX   DE,HL		;y-coordinate 		  --> reg. DE
	OR   A			;clear carry flag
 	LD   HL,449   		;maximum scan line number --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   C,PLOT2		;jump if overflow

      	PUSH DE			;save x-coordinate
	
 	ADD  HL,HL        	;make word index
	LD   DE,YNTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL) 
	JR   PLOT4


*EJECT
PLOT1:	EX   DE,HL		;y-coordinate 		  --> reg. DE
	OR   A			;clear carry flag
 	LD   HL,(YMAX)		;maximum scan line number --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   NC,PLOT3		;jump if no overflow
PLOT2:	POP  HL			;adjust stack
	POP  HL
	RET

PLOT3:	PUSH DE			;save x-coordinate
	
 	ADD  HL,HL        	;make word index
	LD   DE,YTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL) 

PLOT4:	POP  HL			;get x-coordinate
;divide x-coordinate by 8:
	XOR  A			;clear remainder
	SRL  H			;/ 2
	RR   L
	RRA
	SRL  H			;/ 4
	RR   L
	RRA
	SRL  H			;/ 8
	RR   L
	RRA

	LD   C,A		;save accu
	LD   A,H		;test MSB of result
	OR   A
	JR   NZ,PLOT2		;return if overflow
	LD   A,L		;test LSB of result
	CP   80
	JR   NC,PLOT2		;return if overflow
	LD   A,C		;restore accu

	ADD  HL,DE		;final result = y-address + x / 8
	SET  7,H		;select upper 32K page

	RRA			;build SET/RES instruction
	RRA
	OR   0C6H		;SET instruction
	POP  BC			;get colour
	BIT  0,B		;black or white ?
	JR   NZ,$+4		;jump if white
	AND  0BEH		;RES instruction
	LD   (SETRES),A		;load instruction

	IN   A,($SYS0)		;read system byte 0
	AND  00010001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	POP BC			;get  page number
	INC B			;test page number
	DEC B
	JR  Z,PLOT5		;jump if page 0
	SET 5,A			;select page 1
PLOT5:	OUT ($SYS0),A		;write system byte 0

	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	DEFB 0CBH		;SET/RES dot
SETRES:	DEFS 1

	IN  A,($SYS1)		;read system byte 1
	AND 11010111B		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	EI			;reenable interrupts
	RET			;return to caller

YMAX:	DEFS 2			;total number of scan lines
YTAB:	DEFS 800		;addresses of all y-coordinates
YNTAB:	DEFS 900		;address of all normalized y-coordinates


*EJECT
;*****************
;*  $ P O I N T  *
;*****************

;entry:  B = graphic page number (0, 1)
;	HL = y-coordinate (0 - YYY)
;	DE = x-coordinate (0 - 639)
;
;exit :  A = 0  black
;	     1  white

$POINT:	PUSH BC			;save graphic page #
	PUSH DE			;save x-coordinate
	
POINT1:	EX   DE,HL		;y-coordinate 		    --> reg. DE
	OR   A			;clear carry flag
 	LD   HL,(YMAX)		;total number of scan lines --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   NC,POINT3		;jump if no overflow
POINT2:	XOR  A			;clear accu
	POP  HL			;adjust stack
	RET

POINT3:	PUSH DE			;save x-coordinate
	
 	ADD  HL,HL        	;make word index
	LD   DE,YTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL) 

      	POP  HL			;get x-coordinate
;divide x-coordinate by 8:
	XOR  A			;clear remainder
	SRL  H			;/ 2
	RR   L
	RRA
	SRL  H			;/ 4
	RR   L
	RRA
	SRL  H			;/ 8
	RR   L
	RRA

	LD   C,A		;save accu
	LD   A,H		;test MSB of result
	OR   A
	JR   NZ,POINT2		;return if overflow
	LD   A,L		;test LSB of result
	CP   80
	JR   NC,POINT2		;return if overflow
	LD   A,C		;restore accu

	ADD  HL,DE		;final result = y-address + x / 8
	SET  7,H		;select upper 32K page

	RRA			;build BIT instruction
	RRA
	OR   46H
	LD   (BITTST),A		;load instruction

	IN   A,($SYS0)		;read system byte 0
	AND  00010001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	POP BC			;get  page number
	INC B			;test page number
	DEC B
	JR  Z,POINT4		;jump if page 0
	SET 5,A			;select page 1
POINT4:	OUT ($SYS0),A		;write system byte 0

	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	DEFB 0CBH		;BIT test
BITTST:	DEFS 1

	IN  A,($SYS1)		;read system byte 1
	RES 3,A      		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	EI			;reenable interrupts

	LD   A,0		;clear accu
	RET  Z			;accu = 0 if dot = black
	INC  A			;accu = 1 if dot = white
	RET			;return to caller


*EJECT
;***************
;*  $ L I N E  *
;***************

;entry:  A = 0  non-normalized (high nibble) 
;	     1      normalized 
;	     0  black          (low  nibble)
;	     1  white
;        B = graphic page number (0, 1)
;	HL = ^coordinates (x1, y1, x2, y2)

;draw line:
$LINE:	PUSH BC			;save page number
	PUSH AF			;save mode & colour
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X1		;^coordinates --> reg. DE
	LD   B,8		;byte count   --> reg. BC	
	CALL $XMOVE		;get coordinates
	POP  AF			;get mode
	LD   C,A		;save colour
	AND  0F0H		;normalize y-coordinates ?
	LD   A,C		;restore colour
	PUSH AF			;save colour
	JR   Z,LINE4		;jump if not

;normalize y-coordinates:
	POP  AF			;get colour
	AND  0FH		;mask mode
	PUSH AF
	LD   B,2		;y1, y2
	LD   IX,Y1		;^first y-coordinate 		    --> reg. IX
LINE1:	PUSH BC			;save counter
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   D,(IX+1)		;y-coordinate 			    --> reg. DE
	LD   E,(IX)
	LD   HL,0
LINE2:	ADD  HL,DE		;y-coordinate * # of scan lines
	DJNZ LINE2

	LD   DE,18		;load divisor
	CALL DIV
	LD   A,E		;remainder --> accu
	CP   9			;remainder >= 9 ?
	JR   C,LINE3		;jump if not
	INC  HL			;round normalized y-coordinate
LINE3:	LD   (IX+1),H		;store normalized y-coordinate
	LD   (IX),L
	INC  IX			;get ^second y-coordinate
	INC  IX 		
	INC  IX 
	INC  IX
	POP  BC			;restore counter
	DJNZ LINE1		;normalize second y-coordinate
	 	
;calc px and dx:
LINE4:	LD   HL,0		;clear pp
	LD   (PP),HL
      	LD   HL,(X2)		;second x-coordinate --> reg. HL
	LD   DE,(X1)		;first  x-coordinate --> reg. DE
	CALL CMP		;x2 >= x1 ?
	JP   M,LINE5		;jump if x2 < x1
	LD   BC,1		;dx = 1
	JR   LINE6
LINE5:	LD   BC,-1		;dx = -1
	EX   DE,HL		
LINE6:	LD   (DX),BC		;store dx
	OR   A
	SBC  HL,DE		;px = x2 - x1 + 1 (x1 - x2 + 1)
	INC  HL
	LD   (PX),HL
	
;calc py and dy:
      	LD   HL,(Y2)		;second y-coordinate --> reg. HL
	LD   DE,(Y1)		;first  y-coordinate --> reg. DE
	CALL CMP		;y2 >= y1 ?
	JP   M,LINE7		;jump if y2 < y1
	LD   BC,1		;dy = 1
	JR   LINE8
LINE7:	LD   BC,-1		;dy = -1
	EX   DE,HL		
LINE8:	LD   (DY),BC		;store dx
	OR   A
	SBC  HL,DE		;py = y2 - y1 + 1 (y1 - y2 + 1)
	INC  HL
	LD   (PY),HL
	
;plot first dot:
	CALL LPLOT		;plot first point of line

;py <= px:
	LD   HL,(PX)		;px --> reg. HL
	LD   DE,(PY)		;py --> reg. DE
	CALL CMP		;py <= px ?
	JP   M,YLIN		;jump if py > px
XLIN:	LD   HL,(X1)
	LD   DE,(X2)
	CALL CMP		;x1 == x2 ?
	JP   Z,ENDLIN		;break if yes
	LD   HL,(PP)		;pp += py
	LD   DE,(PY)
	ADD  HL,DE	
	LD   (PP),HL
	LD   DE,(PX)
	CALL CMP		;pp >= px
	JP   M,XLIN1		;jump pp < px
	OR   A
	SBC  HL,DE		;pp -= px
	LD   (PP),HL
	LD   HL,(Y1)		;y1 += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (Y1),HL
XLIN1:	LD   HL,(X1)		;x1 += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (X1),HL
	CALL LPLOT		;plot next point of line
	JR   XLIN 	

;py > px:
YLIN:	LD   HL,(Y1)
	LD   DE,(Y2)
	CALL CMP		;y1 == y2 ?
	JR   Z,ENDLIN		;break if yes
	LD   HL,(PP)		;pp += px
	LD   DE,(PX)
	ADD  HL,DE	
	LD   (PP),HL
	LD   DE,(PY)
	CALL CMP		;pp >= py
	JP   M,YLIN1		;jump pp < py
	OR   A
	SBC  HL,DE		;pp -= py
	LD   (PP),HL
	LD   HL,(X1)		;x1 += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (X1),HL
YLIN1:	LD   HL,(Y1)		;y1 += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (Y1),HL
	CALL LPLOT		;plot next point of line
	JR   YLIN

;end of draw line routine:
ENDLIN:	POP  HL			;adjust stack
	POP  HL
	RET

;plot (x1, y1):
LPLOT:	POP  HL			;skip return address
 	POP  AF			;get colour
	POP  BC			;get graphic page
	PUSH BC			;save that suckers again
	PUSH AF
	PUSH HL			;save return address
	LD   HL,(Y1)		;y-coordinate --> reg. HL
	LD   DE,(X1)		;x-coordinate --> reg. DE
	JP   $PLOT

;variables for draw line, circle, and arc:
XM:	DEFS 2
YM:	DEFS 2
XX:
X1:	DEFS 2
YY:
Y1:	DEFS 2
X2:	DEFS 2
Y2:	DEFS 2
M1:
PX:	DEFS 2	
M2:
PY:	DEFS 2
DD:
PP:     DEFS 2
N1:	
XB:
XB1:	DEFS 2
N2:	
XB2:	DEFS 2
II:
N3:	DEFS 2
P1:	DEFS 2
P2:	DEFS 2
DX:	DEFS 2
DY:	DEFS 2 


*EJECT
;*******************
;*  $ C I R C L E  *
;*******************

;entry:  A = 0  black
;	     1  white
;        B = graphic page number (0, 1)
;	HL = ^coordinates, radius (xm, ym, r)

;draw circle:
$CIRCLE:PUSH BC			;save page number
	SET  4,A		;force normalizing
	PUSH AF			;save colour & mode
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,XM		;^coordinates --> reg. DE
	LD   B,6		;byte count   --> reg. BC	
	CALL $XMOVE		;get coordinates

	LD   HL,0		;dd = yy = 0
	LD   (DD),HL
	LD   (YY),HL
	LD   HL,(XX)		;m1 = 1 - (xx + xx)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	LD   (M2),HL		;m2 = 1
	OR   A
	SBC  HL,DE
	LD   (M1),HL

*EJECT
;plot first dots:
	LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym      --> reg. HL
	CALL CPLOT
		
	LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym      --> reg. HL
	CALL CPLOT
		
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   DE,(XX)
	ADD  HL,DE
	LD   DE,(XM)		;xm      --> reg. DE
	CALL CPLOT
		
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	LD   DE,(XM)		;xm      --> reg. DE
	CALL CPLOT
		
*EJECT
;circle loop:

;calc next coordinates:
CIRCLE1:LD   HL,(M1)		;p1 = m1 + d
	LD   DE,(DD)
	ADD  HL,DE
	LD   (P1),HL
	LD   HL,(M2)		;p2 = m2 + d
	ADD  HL,DE
	LD   (P2),HL

        LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
        LD   HL,(M2)		;m2 += 2
	INC  HL
	INC  HL
	LD   (M2),HL

	LD   HL,(P2)
	CALL ABS
	EX   DE,HL
	LD   HL,(P1)
	LD   DE,(M2)
	ADD  HL,DE
	CALL ABS
	CALL CMP		;jump if
	JR   C,CIRCLE2		;abs(p1 + m2) < abs(p2)

        LD   HL,(P2)		;dd = p2
	LD   (DD),HL
	JR   CIRCLE3

CIRCLE2:LD   HL,(XX)		;xx--
	DEC  HL
	LD   (XX),HL
	LD   HL,(P1)		;dd = p1 + m2
	LD   DE,(M2)
	ADD  HL,DE
	LD   (DD),HL
	LD   HL,(M1)		;m1 += 2
	INC  HL
	INC  HL
	LD   (M1),HL

*EJECT
;plot dots:
CIRCLE3:LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - yy --> reg. HL
	LD   BC,(YY)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - yy --> reg. HL
	LD   BC,(YY)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm + yy --> reg. DE
	LD   DE,(YY)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   BC,(XX)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - yy --> reg. DE
	LD   DE,(YY)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   BC,(XX)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm + yy --> reg. DE
	LD   DE,(YY)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   BC,(XX)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - yy --> reg. DE
	LD   DE,(YY)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   BC,(XX)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
	LD   HL,(XX)
	LD   DE,(YY)
	CALL CMP		;jump if
	JP   P,CIRCLE1		;xx >= yy

	POP  HL			;adjust stack
	POP  HL	
	RET

;plot (xx, yy):
CPLOT:	POP  IX			;skip return address
 	POP  AF			;get colour & mode
	POP  BC			;get graphic page
	PUSH BC			;save that suckers again
	PUSH AF
	PUSH IX			;save return address
	JP   $PLOT


*EJECT
;*************
;*  $ A R C  *
;*************

;entry:  A = 0  black
;	     1  white
;        B = graphic page number (0, 1)
;	HL = ^coordinates (xm, ym, x1, y1, x2, y2)

;draw arc:
$ARC:   PUSH BC			;save page number
	SET  4,A		;force normalizing
	PUSH AF			;save colour & mode
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,XM		;^coordinates --> reg. DE
	LD   B,12		;byte count   --> reg. BC	
	CALL $XMOVE		;get coordinates

	LD   HL,0		;dd = 0
	LD   (DD),HL
	LD   HL,(X1)		;xx = x1 - xm
	LD   DE,(XM)
	OR   A
	SBC  HL,DE
	LD   (XX),HL
	LD   HL,(X2)		;x2 -= xm
	OR   A
	SBC  HL,DE
	LD   (X2),HL
	LD   HL,(Y1)		;yy = y1 - ym
	LD   DE,(YM)
	OR   A
	SBC  HL,DE
	LD   (YY),HL
	LD   HL,(Y2)		;y2 -= xm
	OR   A
	SBC  HL,DE
	LD   (Y2),HL

;plot first dot:
	LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
		
*EJECT
;arc loop:

;calc next coordinates:
ARC1:   LD   HL,(YY)		
	BIT  7,H		;jump if
	JR   NZ,ARC2		;yy < 0
	LD   HL,-1		;dx = -1
	LD   (DX),HL   
	LD   HL,(XX)		;m1 = 1 - (xx + xx)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	OR   A
	SBC  HL,DE
	JR   ARC3
ARC2:	LD   HL,(XX)		;m1 = 1 + xx + xx
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1		;dx = 1
	LD   (DX),HL
	ADD  HL,DE
ARC3:	LD   (M1),HL

        LD   HL,(XX)		
	BIT  7,H		;jump if
	JR   NZ,ARC4		;xx < 0
     	LD   HL,(YY)		;m2 = 1 + yy + yy
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1		;dy = 1
	LD   (DY),HL
	ADD  HL,DE
	JR   ARC5
ARC4:	LD   HL,-1		;dy = -1
	LD   (DY),HL
	LD   HL,(YY)		;m2 = 1 - (yy + yy)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	OR   A
	SBC  HL,DE
ARC5:	LD   (M2),HL

	LD   DE,(DD)		;p2 = m2 + dd
	ADD  HL,DE
	LD   (P2),HL
	CALL ABS		;n3 = abs(p2)
	LD   (N3),HL
	LD   HL,(M1)		;p1 = m1 + d
	ADD  HL,DE
	LD   (P1),HL
	CALL ABS		;n1 = abs(p1)
	LD   (N1),HL
	LD   HL,(P1)		;n2 = abs(p1 + m2)
	LD   DE,(M2)
	ADD  HL,DE
	CALL ABS
	LD   (N2),HL

	LD   DE,(N1)
	CALL CMP		;jump if
	JR   C,ARC8   		;n1 >= n2
	JR   Z,ARC8   
	LD   HL,(N3)
	CALL CMP		;jump if
	JR   C,ARC6   		;n1 >= n3
	JR   Z,ARC6   

	LD   HL,(XX)		;xx += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (XX),HL
	LD   HL,(P1)		;dd = p1
	LD   (DD),HL
	JR   ARC9

ARC6:   LD   HL,(P2)		;dd = p2
	LD   (DD),HL
ARC7:   LD   HL,(YY)		;yy += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (YY),HL
	JR   ARC9

ARC8:   LD   DE,(N3)
	CALL CMP		;jump if
	JP   P,ARC6   		;n2 >= n3

        LD   HL,(XX)		;xx += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (XX),HL
	LD   HL,(P1)		;dd = p1 + m2
	LD   DE,(M2)
	ADD  HL,DE
	LD   (DD),HL
	JR   ARC7


*EJECT
;plot dot:
ARC9:   LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JP   NZ,ARC1		;xx != x2
	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   NZ,ARC1		;yy != y2

	POP  HL			;adjust stack
	POP  HL	
	RET


*EJECT
;***************
;*  $ F I L L  *
;***************

;entry:  A = 0  non-normalized   	(high nibble) 
;	     1      normalized 
;	     graphic page number (0, 1) (low  nibble)
;	BC = ^fill pattern
;       HL = y-coordinate within shape
;	DE = x-coordinate within shape

;fill shape with user supplied pattern:
$FILL	EQU  $			;not implemented yet


*EJECT
;***************
;*  $ C O P Y  *
;***************

;entry:  A = source      page (high nibble)
;	     destination page (low  nibble)
;	     0 = graphic page 0
;	     1 = graphic page 1
;	     F = user buffer
;		 (user/user [FF] = invalid combination)
;	HL = ^parameter block (x1, y1, x2, y2, dx, dy
;			    or x2, y2, dx, dy
;			    or x1, y1, dx, dy)
;	DE = ^user buffer

;copy graphic area:
$COPY:	LD   (UBUF),DE		;save ^user buffer
	LD   C,A		;save source page
	AND  0FH		;mask it
	CP   0FH		;destination == user buffer ?
	JP   Z,COPY17		;jump if yes
	PUSH AF
	LD   A,C		;restore source page
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	CP   0FH		;source == user buffer ?
	JP   Z,COPY10		;jump if yes
	PUSH AF
	
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X1		;^parameter block --> reg. DE
	LD   B,12		;byte count       --> reg. BC	
	CALL $XMOVE		;get coordinates

*EJECT
;copy on screen:

;setup variables:
	LD   HL,(X1)		;xb1 = x1
	LD   (XB1),HL
	LD   HL,(X2)		;xb2 = x2
	LD   (XB2),HL

;determine copy direction of x-coordinate:
	LD   DE,(X1)
  	CALL CMP
	JR   C,COPY1  		;jump if
	JR   Z,COPY1  		;x1 >= x2
	LD   DE,(PX)		;xb2 += dx - 1
	DEC  DE
	ADD  HL,DE
	LD   (XB2),HL
	LD   HL,(XB1)		;xb1 += dx - 1
	ADD  HL,DE
	LD   (XB1),HL
	LD   HL,(X1)		;x1--
	DEC  HL
	LD   (X1),HL
	LD   HL,-1		;dx = -1
	JR   COPY2
COPY1:	LD   HL,(X1)		;x1 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X1),HL
	LD   HL,1		;dx = 1
COPY2:	LD   (PX),HL

;determine copy direction of y-coordinate:
	LD   HL,(Y1)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   P,COPY3		;y1 >= y2
	DEC  HL			;yy = --y1 + dy
	LD   (Y1),HL
	LD   DE,(PY)
	ADD  HL,DE
	LD   (YM),HL
	LD   HL,(Y2)		;y2 += dy - 1
	DEC  DE
	ADD  HL,DE
	LD   (Y2),HL
	LD   HL,-1		;dy = -1
	JR   COPY4
COPY3:	LD   (YM),HL		;yy = y1
	LD   DE,(PY)		;y1 += dy
	ADD  HL,DE
	LD   (Y1),HL
	LD   HL,1		;dy = 1
COPY4:	LD   (PY),HL

*EJECT
;copy area:
COPY5:	LD   HL,(YM)
	LD   DE,(Y1)
	CALL CMP		;jump if
	JR   Z,COPY8		;yy == y1

	LD   HL,(XB1)		;xx = xb1
	LD   (XM),HL
	LD   HL,(XB2)		;x2 = xb2
	LD   (X2),HL

COPY6:	LD   HL,(XM)
	LD   DE,(X1)
	CALL CMP		;jump if
	JR   Z,COPY7		;xx == x1
	
	POP  BC			;source page # --> reg. B
	PUSH BC
	LD   HL,(YM)		;y-coordinate  --> reg. HL
	LD   DE,(XM)		;x-coordinate  --> reg. DE
	CALL $POINT		;read source dot

	POP  HL			;destination page # --> reg. B
	POP  BC
	PUSH BC
	PUSH HL
	LD   HL,(Y2)		;y-coordinate       --> reg. HL
	LD   DE,(X2)		;x-coordinate	    --> reg. DE
	CALL $PLOT		;set destination dot

	LD   HL,(XM)		;xx += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (XM),HL	
	LD   HL,(X2)		;x2 += dx
	ADD  HL,DE
	LD   (X2),HL
	JR   COPY6

COPY7:	LD   HL,(YM)		;yy += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (YM),HL
	LD   HL,(Y2)		;y2 += dy
	ADD  HL,DE
	LD   (Y2),HL
	JR   COPY5

COPY8:	POP  HL			;adjust stack
COPY9:	POP  HL
	RET

*EJECT
;copy from user buffer to screen:
COPY10:	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X2		;^parameter block --> reg. DE
	LD   B,8 		;byte count       --> reg. BC	
	CALL $XMOVE		;get coordinates

;setup variables:
	LD   HL,(Y2)		;yy = y2
	LD   (YY),HL
	LD   HL,(X2)		;xb = x2
	LD   (XB),HL
	LD   HL,(PX)		;pp = dx / 8 + (dx % 8 != 0)
	LD   A,L
	SRL  H
	RR   L
	SRL  H
	RR   L
	SRL  H
	RR   L
	AND  7
	JR   Z,COPY11
	INC  HL
COPY11:	LD   (PP),HL
	LD   HL,(X2)		;x2 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X2),HL
	LD   HL,(Y2)		;y2 += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (Y2),HL

*EJECT
;copy area:
COPY12:	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JR   Z,COPY9		;yy == y2

	LD   HL,(UBUF)		;^user buffer --> reg. HL
	LD   DE,LINBUF		;^temp buffer --> reg. DE
	LD   A,(PP)		;byte count   --> reg. B
	LD   B,A
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	CALL $XMOVE		;get user bytes

	LD   HL,(XB)		;xx = xb
	LD   (XX),HL
	LD   HL,0    		;ii = 0
	LD   (II),HL

COPY13:	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JR   Z,COPY16 		;xx == x2
	
	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(II)		;divide buffer index by 8
	XOR  A
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	ADD  HL,DE		;now reg. HL contains byte address
	RRA			;build BIT instruction
	RRA
	OR   46H
	LD   (COPY14),A
	DEFB 0CBH		;BIT instruction
COPY14:	DEFS 1

	LD   A,0		;initialize colour (black)
	JR   Z,COPY15		;dont't change colour if tested bit = 0
	INC  A			;change colour (white)
COPY15:	POP  BC			;graphic page number # --> reg. B
	PUSH BC
	LD   HL,(YY)		;y-coordinate 	       --> reg. HL
	LD   DE,(XX)		;x-coordinate	       --> reg. DE
	CALL $PLOT 		;set dot

	LD   HL,(XX)		;xx++
	INC  HL
	LD   (XX),HL
	LD   HL,(II)		;ii++
	INC  HL
	LD   (II),HL
	JR   COPY13

COPY16:	LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
	LD   HL,(UBUF)		;bump pointer to user buffer
	LD   DE,(PP)
	ADD  HL,DE
	LD   (UBUF),HL
	JP   COPY12

*EJECT
;copy from screen to user buffer:
COPY17:	LD   A,C		;restore source page
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	PUSH AF

	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X2		;^parameter block --> reg. DE
	LD   B,8 		;byte count       --> reg. BC	
	CALL $XMOVE		;get coordinates

;setup variables:
	LD   HL,(Y2)		;yy = y2
	LD   (YY),HL
	LD   HL,(X2)		;xb = x2
	LD   (XB),HL
	LD   HL,(PX)		;pp = dx / 8 + (dx % 8 != 0)
	LD   A,L
	SRL  H
	RR   L
	SRL  H
	RR   L
	SRL  H
	RR   L
	AND  7
	JR   Z,COPY18
	INC  HL
COPY18:	LD   (PP),HL
	LD   HL,(X2)		;x2 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X2),HL
	LD   HL,(Y2)		;y2 += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (Y2),HL

*EJECT
;copy area:
COPY19:	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   Z,COPY9		;yy == y2

	LD   HL,(XB)		;xx = xb
	LD   (XX),HL
	LD   HL,0    		;ii = 0
	LD   (II),HL

COPY20:	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JR   Z,COPY22 		;xx == x2
	
       	POP  BC			;graphic page number # --> reg. B
	PUSH BC
	LD   HL,(YY)		;y-coordinate 	       --> reg. HL
	LD   DE,(XX)		;x-coordinate	       --> reg. DE
	CALL $POINT		;read dot
	LD   C,A		;colour		       --> reg. C

	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(II)		;divide buffer index by 8
	XOR  A
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	ADD  HL,DE		;now reg. HL contains byte address
	RRA			;build SET/RES instruction
	RRA
	OR   0C6H		;SET instruction
	BIT  0,C		;colour black or white ?
	JR   NZ,$+4		;jump if white
	AND  0BEH		;RES instruction
	LD   (COPY21),A		;load instruction
	DEFB 0CBH		;SET/RES instruction
COPY21:	DEFS 1

	LD   HL,(XX)		;xx++
	INC  HL
	LD   (XX),HL
	LD   HL,(II)		;ii++
	INC  HL
	LD   (II),HL
	JR   COPY20

COPY22:	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(UBUF)		;^user buffer --> reg. DE
	LD   A,(PP)		;byte count   --> reg. B
	LD   B,A
	LD   A,1  		;source bank      = 0
				;destination bank = 1
	CALL $XMOVE		;put user bytes

       	LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
	LD   HL,(UBUF)		;bump pointer to user buffer
	LD   DE,(PP)
	ADD  HL,DE
	LD   (UBUF),HL
	JP   COPY19

UBUF:	DEFS 2			;^user buffer


*EJECT
;division HL / DE, quotient --> HL, remainder --> DE:
DIV:	LD   A,H		;dividend (MSB) --> accu
	LD   C,L		;dividend (LSB) --> reg. C
	LD   HL,0		;clear accumulator
	LD   B,16		;init counter
DIV1:	RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
	SBC  HL,DE		;subtract divisor
	JR   NC,$+3		;subtraction ok
	ADD  HL,DE		;restore accumulator
	CCF			;complement carry flag
	DJNZ DIV1		;counter = 0 ?
	RL   C			;get last result bit
	RLA
	EX   DE,HL		;remainder --> reg. DE
	LD   H,A		;quotient  --> reg. HL
	LD   L,C
	RET  

;compare HL with DE:
CMP:	PUSH HL			;save reg. HL
	OR   A			;clear carry flag
	SBC  HL,DE		;compare operands
	POP  HL			;restore reg. HL
	RET

;HL = abs(HL):
ABS:	BIT  7,H		;number positive ?
	RET  Z			;return if yes
	PUSH DE			;save reg. DE
	EX   DE,HL		;number --> reg. DE
	LD   HL,0
	OR   A			;clear carry flag
	SBC  HL,DE		;negate number
	POP  DE			;restore reg. DE
	RET


*EJECT
;******************************************************************************
;*	       I N T E R R U P T   S E R V I C E   R O U T I N E	      *
;******************************************************************************

INT1:	PUSH BC			;save user register set
	PUSH DE
	PUSH HL
	PUSH IX
	PUSH IY

;scan keyboard:
	CALL $SCAN		;scan the keyboard
	LD   A,C		;get code of pressed key
	OR   A			;key pressed ?
	JR   Z,RTC3		;jump if not
	LD   A,(KLEN)		;A = buffer length
	LD   B,A		;save it
	CP   80			;jump if
	JR   Z,RTC2		;it's full
	LD   A,(REPEAT)		;auto repeat ?
	OR   A
	JR   Z,RTC0		;jump if not
	LD   A,B		;restore buffer length
	OR   A			;buffer empty ?
	JR   NZ,RTC3		;return no repeated key if buffer not empty
RTC0:	LD   A,C		;get code of pressed key
     	LD   HL,(EPTR)		;HL = next location pointer
	LD   (HL),A		;save the key
	INC  HL			;bump the pointer
	LD   DE,KBUF+80		;DE = end of buffer pointer
	EX   DE,HL		;swap the pointers
	SBC  HL,DE		;wrap around the buffer ?
	EX   DE,HL		;swap the pointers
	JR   NZ,RTC1		;jump if no wrap around
	LD   HL,KBUF		;HL = new pointer
RTC1:	LD   (EPTR),HL		;save the pointer
	LD   HL,KLEN		;HL = buffer length pointer
	INC  (HL)		;bump it
	JR   RTC3
RTC2:	CALL BEEP		;alarm

;clock maintenance routine:
RTC3:	LD   HL,RTC$TICK$COUNT	;downdate tick count
	DEC  (HL)
	JR   NZ,INT6		;is not at 0 yet
	LD   (HL),45		;one second has elapsed so 
				;reset to original value

	LD   A,(CLOCK)		;hardware clock ?
	OR   A
	JR   NZ,INT2		;jump if yes	

	LD   B,3		;maximum number of values to update
	LD   DE,TIME$IN$BCD$END	;DE -> seconds of BCD time
	LD   HL,UPDATE$TIME	;HL -> control table
RTC$UPDATE$DIGIT:
	LD   A,(DE)
	INC  A			;bump a time period, seconds
	DAA			;then minutes, then ours
	LD   (DE),A
	SUB  (HL)		;compare period to max. unit value
	JR   NZ,INT2		;jump if unit not max. value
	LD   (DE),A		;else reset period to zero
	DEC  DE			;and bump increment and
	INC  HL			;test addresses to next unit
	DJNZ RTC$UPDATE$DIGIT	;loop till periods incremented or no overflow
				;from one period to the next
	LD   HL,(BINARY$DATE)	;HL -> number of days since Jan 1st, 1978
	INC  HL			;bump day count
	LD   (BINARY$DATE),HL

*EJECT
INT2:	LD   A,(CLOCKON)
	OR   A			;display clock ?
	JR   Z,INT6		;jump if not
	LD   A,(CLOCK)		;hardware clock ?
	OR   A
	JR   Z,INT3		;jump if not 
	LD   HL,BINARY$DATE	;^time & date buffer --> reg. HL
	LD   (INT),A		;mark interrupt service routine
	CALL $GTIME3H		;read hardware clock
	XOR  A
	LD   (INT),A
INT3:	LD   HL,TIME$IN$BCD	;^BCD   time --> reg. HL
	LD   DE,$ATIME		;^ASCII time --> reg. DE
	LD   B,3		;convert hours, minutes, and seconds
INT4:	CALL BCDASC
	DJNZ INT4			
	IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11111110B		;enable memory mapped I/O
	OR   00010000B		;enable video RAM
	OUT  ($SYS1),A
	LD   HL,$ATIME		;^ASCII time 	   --> reg. HL
	LD   DE,(CLOCK$LOC)	;^display location --> reg. DE
	LD   B,8		;byte count 	   --> reg. B
INT5:	LD   A,(DE)		;get screen character
	AND  80H		;mask invert bit
	OR   (HL)		;over clock character
	LD   (DE),A		;display clock character
	INC  DE			;get next clock character
	INC  HL			;get next screen location
	DJNZ INT5		;display whole clock	
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A
	
INT6:	POP  IY
	POP  IX
     	POP  HL			;restore user register set
	POP  DE
	POP  BC
	JP   $INT1		;jump to end of interrupt service routine

;convert BCD to ASCII:
BCDASC:	LD   A,(HL)		;get high nibble
	RRA
	RRA
	RRA
	RRA
        AND  0FH
	ADD  A,'0'		;convert it to ASCII
	LD   (DE),A		;store high digit
        LD   A,(HL)		;get low nibble
	AND  0FH		;get low nibble
	ADD  A,'0'		;convert to ASCII
	INC  DE   
	INC  HL
	LD   (DE),A		;store low digit
	INC  DE			;bump over colon 
	INC  DE
	RET

RTC$TICK$COUNT:
	DEFB 45
UPDATE$TIME:
	DEFB 60H		;BCD 60 seconds
	DEFB 60H		;BCD 60 minutes
	DEFB 24H		;BCD 24 hours
$ATIME:	DEFM 'HH:MM:SS'		;time in ASCII format
INT:	DEFB 0			;marker for interrupt service routine


*EJECT
;******************************************************************************
;*  		  C O M M O N   P A R T   O F   D R I V E R S		      *
;******************************************************************************

	ORG  3500H
	.PHASE 0FE00H		;common memory

;time & date location will not be destroyed during reset:
BINARY$DATE:
	DEFW 1
TIME$IN$BCD:
	DEFB 0
	DEFB 0
TIME$IN$BCD$END:
	DEFB 0

;*****************
;*  $ X M O V E  *
;*****************

;entry:  A  	upper nibble = source 	   bank
;	    	lower nibble = destination bank
;	 B  =   byte count
;      	DE  =   destination address
;	HL  =   source      address

;interbank transfer:
$XMOVE:	LD   C,A		;save source/dest bank #'s
	IN   A,($SYS0)		;read system byte 0
	PUSH AF			;save current bank #
	LD   A,C		;restore source/dest bank #'s
	PUSH DE			;save destination address
	LD   C,B		;byte count --> reg. BC
	LD   B,0
	PUSH BC			;save byte count
	PUSH AF        		;save destination bank number
	SRL  A			;get source bank number
	SRL  A
	SRL  A
	SRL  A
	CALL SWITCH		;select source bank
	LD   DE,SBUF		;^scratch buffer --> reg. DE
	LDIR			;transfer data from source buf to scratch buf
	POP  AF			;get destination bank number
	AND  0FH
	CALL SWITCH		;select destination bank
	POP  BC			;restore byte count
	LD   HL,SBUF		;^scratch buffer --> reg. HL
	POP  DE			;restore destination address
	LDIR			;transfer data from scratch buf to dest buf
	POP  AF			;restore current bank #
	OUT  ($SYS0),A		;select it
	RET
		
;select memory bank:
SWITCH:	RRCA			;lowest two bits --> highest two bits
	RRCA
	AND  0C0H
	OR   1
       	LD   D,A		;save bank number
       	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;RTC interrupt only
				;disable character RAM
	OR   D			;set bank number
	OUT  ($SYS0),A		;write system byte 0
	RET	 

SBUF:	DEFS 128		;scratch buffer


*EJECT
;entry to interrupt service routine:
	DEFS 64			;local stack
$INT:	LD   (SAVESP),SP	;save user stack
	LD   SP,$INT     	;get local stack
	PUSH AF			;save user accu/status
	IN   A,($FDSEL)		;reset interrupt flipflop
	IN   A,($SYS0)		;get current bank #
	PUSH AF          	;save it
	AND  00111111B		;enable bank 0
	OUT  ($SYS0),A		;select it
	JP   INT1		;perform interrupt service routine

$INT1:	POP  AF          	;get user bank
	OUT  ($SYS0),A		;select it
	POP  AF			;restore user accu/status
	LD   SP,(SAVESP)	;restore user stack
	EI			;enable interrupts
	RET			;return to user task
SAVESP:	DEFS 2			;SP save area


*EJECT
;floppy disk I/O:
IO:	CALL SWITCH		;select bank of transfer buffer
	POP  AF			;restore status
	JR   Z,WRITE1		;jump if write

;read sector:
        LD   A,$RDSEC        	;issue "read" command
	DI			;disable interrupts
	OUT  ($FDCMD),A
        LD   BC,12              ;56 usec delay
        CALL DELAY
        LD   C,$FDDATA          ;data register
READ1:	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  0,A                ;full sector transferred ?
        JR   Z,IOEND            ;yes, go end process
	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  7,A                ;drive not ready ?
        JR   Z,READ1            ;no loop
READ2:  LD   A,4                ;error code 4 --> accu
        RET
READ3:  INI                     ;read char
        JR   READ1

;write sector:
WRITE1: LD   A,$WRSEC        	;issue "write" command
	DI			;disable interrupts
	OUT  ($FDCMD),A
        LD   BC,12              ;56 usec delay
        CALL DELAY
        LD   C,$FDDATA          ;data register
WRITE2:	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,WRITE3          ;yes, put byte
        BIT  0,A                ;full sector written ?
        JR   Z,IOEND            ;yes, go end process
	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,WRITE3          ;yes, put byte
        BIT  7,A                ;drive not ready ?
        JR   Z,WRITE2           ;no loop
        JR   READ2              ;jump to error exit
WRITE3: OUTI                    ;write char
        JR   WRITE2             ;put next byte

IOEND:	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;enable bank 0
	OR   00000001B
	OUT  ($SYS0),A		;write system byte 0
	JP   STATUS		;check status

;delay for ((BC-1)*26+17)*2.255 T-states:
DELAY:	DEC  BC			;decrement cycle count
	LD   A,B		;test if count zero
	OR   C			;combine LSB/MSB of count
	JR   NZ,DELAY		;loop until delay count exhausted
	RET			;rtn to caller


*EJECT
;Winchester I/O:
IOW:	CALL SWITCH		;select bank of transfer buffer
	POP  AF			;restore status
	JR   Z,WRITW1		;jump if WRITE

;read sector:
	COND SASI		;Xebec part

	LD   BC,RPORT0		;SASI port 0  --> reg. C
        CALL REQWAIT		;wait for request from cntlr
READW1:	IN   A,(RPORT1)		;get cntlr status lines
	AND  IOMASK+CDMASK+REQMASK
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,WDBACK 		;jump if data transfer finished
	CP   IOMASK+REQMASK
	JR   NZ,READW1 		;wait for request
	INIR 			;transfer memory bytes to sector buffer
	JR   READW1

	ELSE			;WD1002 part

READW1: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;read done ?
	JR   NZ,READW1  	;no, loop
	LD   A,E		;sector length bits --> accu
	OR   A   		;test sector length bits
	JR   Z,R256		;read 256 bytes
	DEC  A
	JR   Z,R512             ;read 512 bytes
        DEC  A
      	JR   Z,R1024		;read 1024 bytes
	LD   B,128 		;load new byte counter
      	JR   R256    		;read 128 bytes
R1024:  INIR		        ;transfer sector
	INIR
R512:   INIR
R256: 	INIR
        JR   WDBACK    		;jump back into banked memory

	ENDC

;write sector:
	COND SASI		;Xebec part

WRITW1:	LD   BC,WPORT0		;SASI port 0 --> reg. C
        CALL REQWAIT		;wait for cntlr request
WRITW2:	IN   A,(RPORT1)		;get cntlr status lines
	AND  IOMASK+CDMASK+REQMASK
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,WDBACK 		;jump if data transfer finished
	CP   REQMASK
	JR   NZ,WRITW2 		;wait for request
	OTIR			;transfer memory bytes to sector buffer
	JR   WRITW2

	ELSE			;WD1002 part

WRITW1:	LD   A,E		;sector length bits --> accu
	OR   A   		;test sector length bits
	JR   Z,W256		;write 256 bytes
	DEC  A
	JR   Z,W512             ;write 512 bytes
        DEC  A
      	JR   Z,W1024		;write 1024 bytes
	LD   B,128 		;load new byte counter
      	JR   W256    		;write 128 bytes
W1024:  OTIR		        ;transfer sector
	OTIR
W512:   OTIR
W256: 	OTIR
WRITW2: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;write done ?
	JR   NZ,WRITW2   	;no, loop

	ENDC

WDBACK:	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;enable bank 0
	OR   00000001B
	OUT  ($SYS0),A		;write system byte 0
	JP   WDCSTAT

	COND SASI		;Xebec part

;wait for data request of SASI controller:
REQWAIT:IN   A,(RPORT1)		;get cntlr status bits
	AND  REQMASK		;isolate the contoller
	JR   Z,REQWAIT		;request and wait for it
	RET

	ENDC

	END
;******************************************************************************
;*  D R V T B L  *  C P M S Y S 4 e  *  T h o m a s   H o l t e * 8 5 0 9 2 6 *
;******************************************************************************
;*									      *
;*  			     D R I V E   T A B L E			      *
;*                           =====================                            *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	GLOBAL @DTBL
	EXTERNAL DS0,MF0,RAM,DRIVEP


@DTBL:	DEFW DS0,MF0,0,0,0,0,0,0
	DEFW 0,0,0,0,RAM,0,0,DRIVEP
	DEFW RAM

	END
ntroller:
REQWAIT:IN   A,(RPORT1)		;get cntlr status bits
	AND  REQMASK		;isolate the contoller
	JR   Z,REQWAIT		;request and wait for it
	RET

	ENDC

	END
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;******************************************************************************
;*  F O N T 1 2  *  C P M S Y S 1 a  *  T h o m a s   H o l t e * 8 5 1 1 2 6 *
;******************************************************************************
;*									      *
;*  		   F O N T S E T   F O R   M O N I T O R S 		      *
;*		   =======================================		      *
;*									      *
;*  	  W I T H   1 2   S C A N L I N E S   P E R   T E X T L I N E	      *
;*	  ===========================================================         *
;*									      *
;*									      *
;*  Thomas Holte			                         Version 1.0  *
;*									      *
;******************************************************************************

	.RADIX 16

;storage area for font set:
FONTSET:

;graphic characters:
	DEFB 18,18,18,18,18,18,18,18	;	vertical bar
	DEFB 18,18,18,18,18,18,18,18
	DEFB 00,00,00,00,00,0FF,0FF,00	;	horizontal bar
	DEFB 00,00,00,00,00,00,00,00
	DEFB 18,18,18,18,18,0FF,0FF,18	;	cross
	DEFB 18,18,18,18,18,18,18,18
	DEFB 18,18,18,18,18,1F,1F,18	;	left half of a cross
	DEFB 18,18,18,18,18,18,18,18 
	DEFB 18,18,18,18,18,0F8,0F8,18	;	right half of a cross
	DEFB 18,18,18,18,18,18,18,18
	DEFB 18,18,18,18,18,0FF,0FF,00	;	upper half of a cross
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,00,00,0FF,0FF,18	;	lower half of a cross
	DEFB 18,18,18,18,18,18,18,18
	DEFB 18,18,18,18,18,1F,1F,00	;	upper left corner
	DEFB 00,00,00,00,00,00,00,00
	DEFB 18,18,18,18,18,0F8,0F8,00	;	upper right corner
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,00,00,1F,1F,18	;	lower left corner
	DEFB 18,18,18,18,18,18,18,18
	DEFB 00,00,00,00,00,0F8,0F8,18	;	lower right corner
	DEFB 18,18,18,18,18,18,18,18
	DEFB 18,18,18,18,1C,0F,07,00	;	upper left arc
	DEFB 00,00,00,00,00,00,00,00
	DEFB 18,18,18,18,38,0F0,0E0,00	;	upper right arc
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,00,00,07,0F,1C	;	lower left arc
	DEFB 18,18,18,18,18,18,18,18
	DEFB 00,00,00,00,00,0E0,0F0,38	;	lower right arc
	DEFB 18,18,18,18,18,18,18,18
	DEFB 00,00,08,1C,2A,08,08,08	;	up arrow
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,08,08,08,08,2A,1C	;	down arrow
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,00,08,04,7E,04,08	;	left arrow
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,10,20,7E,20,10	;	right arrow
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,08,1C,3E,7F,7F,3E	;	spades
	DEFB 08,08,00,00,00,00,00,00
	DEFB 00,00,00,36,7F,7F,3E,1C	;	hearts
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,08,1C,3E,7F,3E,1C	;	diamonds
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,1C,1C,08,6B,7F,6B	;	clubs
	DEFB 08,1C,00,00,00,00,00,00
	DEFB 55,0AA,55,0AA,55,0AA,55,0AA;	shaded area
	DEFB 55,0AA,55,0AA,55,0AA,55,0AA
	DEFB 00,00,3C,42,0B9,85,85,0B9	;	copyright
	DEFB 42,3C,00,00,00,00,00,00
	DEFB 00,00,0FA,06,0C6,46,26,0DE	;	1st part of a hand
	DEFB 06,0FA,00,00,00,00,00,00
	DEFB 00,00,0FF,20,0C0,3F,40,3F	;	2nd part of a hand
	DEFB 20,1F,00,00,00,00,00,00
	DEFB 00,00,3F,40,3F,00,00,00	;	3rd part of a hand
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,00,7C,2A,28,28	;	Pi
	DEFB 28,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,41,41,63,22	;	Omega
	DEFB 63,00,00,00,00,00,00,00
	DEFB 00,00,3C,42,0A5,81,0A5,99	;	"Smiley"
	DEFB 42,3C,00,00,00,00,00,00
	DEFB 00,00,3C,42,0A5,81,99,0A5	;	"Laetschi"
	DEFB 42,3C,00,00,00,00,00,00


*EJECT
;ASCII characters:
	DEFB 00,00,00,00,00,00,00,00	;	space
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,08,08,08,08,08,00	;	!
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,14,14,00,00,00,00	;	"
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,14,14,3E,14,3E,14	;	#
	DEFB 14,00,00,00,00,00,00,00
	DEFB 00,00,08,3C,0A,1C,28,1E	;	$
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,26,26,10,08,04,32	;	%
	DEFB 32,00,00,00,00,00,00,00
	DEFB 00,00,04,0A,0A,04,2A,12	;	&
	DEFB 2C,00,00,00,00,00,00,00
	DEFB 00,00,0C,0C,08,04,00,00	;	'
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,10,08,04,04,04,08	;	(
	DEFB 10,00,00,00,00,00,00,00
	DEFB 00,00,04,08,10,10,10,08	;	)
	DEFB 04,00,00,00,00,00,00,00
	DEFB 00,00,00,14,08,3E,08,14	;	*
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,08,08,3E,08,08	;	+
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,00,00,00,00,0C	;	,
	DEFB 0C,08,04,00,00,00,00,00
	DEFB 00,00,00,00,00,3E,00,00	;	-
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,00,00,00,00,0C	;	.
	DEFB 0C,00,00,00,00,00,00,00
	DEFB 00,00,20,20,10,08,04,02	;	/
	DEFB 02,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,22,2A,22,22	;	0
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,08,0C,08,08,08,08	;	1
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,20,10,08,04	;	2
	DEFB 3E,00,00,00,00,00,00,00
	DEFB 00,00,3E,20,10,18,20,22	;	3
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,10,08,14,12,3E,10	;	4
	DEFB 10,00,00,00,00,00,00,00
	DEFB 00,00,3E,02,1E,20,20,22	;	5
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,1C,02,02,1E,22,22	;	6
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,3E,20,20,10,08,04	;	7
	DEFB 02,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,22,1C,22,22	;	8
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,22,3C,20,20	;	9
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,00,00,0C,0C,00,0C	;	:
	DEFB 0C,00,00,00,00,00,00,00
	DEFB 00,00,00,00,0C,0C,00,0C	;	;
	DEFB 0C,08,04,00,00,00,00,00
	DEFB 00,00,10,08,04,02,04,08	;	<
	DEFB 10,00,00,00,00,00,00,00
	DEFB 00,00,00,00,3E,00,3E,00	;	=
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,02,04,08,10,08,04	;	>
	DEFB 02,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,20,10,08,00	;	?
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,3A,2A,3A,02	;	@
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,08,14,22,22,3E,22	;	A
	DEFB 22,00,00,00,00,00,00,00
	DEFB 00,00,1E,24,24,1C,24,24	;	B
	DEFB 1E,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,02,02,02,22	;	C
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,1E,24,24,24,24,24	;	D
	DEFB 1E,00,00,00,00,00,00,00
	DEFB 00,00,3E,02,02,1E,02,02	;	E
 	DEFB 3E,00,00,00,00,00,00,00
	DEFB 00,00,3E,02,02,1E,02,02	;	F
	DEFB 02,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,02,3A,22,22	;	G
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,22,22,22,3E,22,22	;	H
	DEFB 22,00,00,00,00,00,00,00
	DEFB 00,00,1C,08,08,08,08,08	;	I
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,20,20,20,20,20,22	;	J
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,22,12,0A,06,0A,12	;	K
	DEFB 22,00,00,00,00,00,00,00
	DEFB 00,00,02,02,02,02,02,02	;	L
	DEFB 3E,00,00,00,00,00,00,00
	DEFB 00,00,22,36,2A,2A,22,22	;	M
	DEFB 22,00,00,00,00,00,00,00
	DEFB 00,00,22,22,26,2A,32,22	;	N
	DEFB 22,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,22,22,22,22	;	O
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,1E,22,22,1E,02,02	;	P
	DEFB 02,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,22,22,2A,12	;	Q
	DEFB 2C,00,00,00,00,00,00,00
	DEFB 00,00,1E,22,22,1E,0A,12	;	R
	DEFB 22,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,02,1C,20,22	;	S
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,3E,08,08,08,08,08	;	T
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,22,22,22,22,22,22	;	U
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,22,22,22,14,14,08	;	V
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,22,22,22,2A,2A,2A	;	W
	DEFB 14,00,00,00,00,00,00,00
	DEFB 00,00,22,22,14,08,14,22	;	X
	DEFB 22,00,00,00,00,00,00,00
	DEFB 00,00,22,22,14,08,08,08	;	Y
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,3E,20,10,08,04,02	;	Z
	DEFB 3E,00,00,00,00,00,00,00
	DEFB 00,00,1C,04,04,04,04,04	;	[
	DEFB 1C,00,00,00,00,00,00,00	
	DEFB 00,00,02,02,04,08,10,20	;	\
	DEFB 20,00,00,00,00,00,00,00
	DEFB 00,00,1C,10,10,10,10,10	;	]
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,08,14,22,00,00,00	;	^
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,00,00,00,00,00	;	_
	DEFB 00,00,3E,00,00,00,00,00
	DEFB 00,00,18,18,08,10,00,00	;	`
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,00,1C,12,12,12	;	a
	DEFB 3C,00,00,00,00,00,00,00
	DEFB 00,00,02,02,1E,22,22,22	;	b
	DEFB 1E,00,00,00,00,00,00,00
	DEFB 00,00,00,00,3C,02,02,02	;	c
	DEFB 3C,00,00,00,00,00,00,00
	DEFB 00,00,20,20,3C,22,22,22	;	d
	DEFB 3C,00,00,00,00,00,00,00
	DEFB 00,00,00,00,1C,22,1E,02	;	e
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,18,24,04,0E,04,04	;	f
	DEFB 04,00,00,00,00,00,00,00
	DEFB 00,00,00,00,3C,22,22,22	;	g
	DEFB 3C,20,1E,00,00,00,00,00
	DEFB 00,00,02,02,1E,22,22,22	;	h
	DEFB 22,00,00,00,00,00,00,00
	DEFB 00,00,08,00,0C,08,08,08	;	i
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,10,00,10,10,10,10	;	j
	DEFB 12,0C,00,00,00,00,00,00
	DEFB 00,00,02,02,12,0A,06,0A	;	k
	DEFB 12,00,00,00,00,00,00,00
	DEFB 00,00,04,04,04,04,04,04	;	l
	DEFB 18,00,00,00,00,00,00,00
	DEFB 00,00,00,00,1E,2A,2A,2A	;	m
	DEFB 2A,00,00,00,00,00,00,00
	DEFB 00,00,00,00,1E,22,22,22	;	n
	DEFB 22,00,00,00,00,00,00,00
	DEFB 00,00,00,00,1C,22,22,22	;	o
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,00,00,1E,22,22,22	;	p
	DEFB 1E,02,02,00,00,00,00,00
	DEFB 00,00,00,00,3C,22,22,22	;	q
	DEFB 3C,20,20,00,00,00,00,00
	DEFB 00,00,00,00,1A,26,02,02	;	r
	DEFB 02,00,00,00,00,00,00,00
	DEFB 00,00,00,00,3C,02,1C,20	;	s
	DEFB 1E,00,00,00,00,00,00,00
	DEFB 00,00,04,04,0E,04,04,24	;	t
	DEFB 18,00,00,00,00,00,00,00
	DEFB 00,00,00,00,22,22,22,22	;	u
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,00,00,22,22,22,14	;	v
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,00,00,22,22,2A,2A	;	w
	DEFB 14,00,00,00,00,00,00,00
	DEFB 00,00,00,00,22,14,08,14	;	x
	DEFB 22,00,00,00,00,00,00,00
	DEFB 00,00,00,00,22,22,22,22	;	y
	DEFB 3C,20,1E,00,00,00,00,00
	DEFB 00,00,00,00,3E,10,08,04	;	z
	DEFB 3E,00,00,00,00,00,00,00
	DEFB 00,00,18,04,04,02,04,04	;	{
	DEFB 18,00,00,00,00,00,00,00
	DEFB 00,00,08,08,08,00,08,08	;	|
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,0C,10,10,20,10,10	;	}
	DEFB 0C,00,00,00,00,00,00,00
	DEFB 00,00,4C,32,00,00,00,00	;	~
	DEFB 00,00,00,00,00,00,00,00
	DEFB 00,00,00,3E,3E,3E,3E,3E	;	block
	DEFB 00,00,00,00,00,00,00,00


*EJECT
;language dependent ASCII characters:
	DEFB 00,00,1C,22,3A,2A,3A,02	;	@
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,1C,04,04,04,04,04	;	[
	DEFB 1C,00,00,00,00,00,00,00	
	DEFB 00,00,02,02,04,08,10,20	;	\
	DEFB 20,00,00,00,00,00,00,00
	DEFB 00,00,1C,10,10,10,10,10	;	]
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,18,04,04,02,04,04	;	{
	DEFB 18,00,00,00,00,00,00,00
	DEFB 00,00,08,08,08,00,08,08	;	|
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,0C,10,10,20,10,10	;	}
	DEFB 0C,00,00,00,00,00,00,00
	DEFB 00,00,4C,32,00,00,00,00	;	~
	DEFB 00,00,00,00,00,00,00,00

;German characters:
	DEFB 00,1C,22,04,0A,12,24,28	;	paragraph
	DEFB 10,22,1C,00,00,00,00,00
	DEFB 22,00,08,14,22,22,3E,22	;	"Ae"
	DEFB 22,00,00,00,00,00,00,00
	DEFB 22,00,1C,22,22,22,22,22	;	"Oe"
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 22,00,22,22,22,22,22,22	;	"Ue"
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,14,00,1C,12,12,12	;	"ae"
	DEFB 3C,00,00,00,00,00,00,00
	DEFB 00,00,14,00,1C,22,22,22	;	"oe"
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,14,00,22,22,22,22	;	"ue"
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,1C,22,22,1E,22,22	;	"sharp" "s"
	DEFB 1E,02,02,00,00,00,00,00


*EJECT
	.RADIX 10
DEFB 00,00,1C,10,10,10,10,10	;	]
	DEFB 1C,00,00,00,00,00,00,00
	DEFB 00,00,18,04,04,02,04,04	;	{
	DEFB 18,00,00,00,00,00,00,00
	DEFB 00,00,08,08,08,00,08,08	;	|
	DEFB 08,00,00,00,00,00,00,00
	DEFB 00,00,0C,10,10,20,10,10	;	}
	DEFB 0C,00,00,00,00,00,ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееPRTMSG   = Y
PAGWID   = 4F
PAGLEN   = 17
BACKSPC  = N
RUBOUT   = Y
BOOTDRV  = A
MEMTOP   = FD
BNKSWT   = Y
COMBAS   = E0
LERROR   = Y
NUMSEGS  = 01
MEMSEG00 = 42,5A,00
MEMSEG01 = 00,C0,02
MEMSEG02 = 00,C0,03
MEMSEG03 = 00,C0,04
MEMSEG04 = 00,C0,05
MEMSEG05 = 00,C0,06
MEMSEG06 = 00,C0,07
MEMSEG07 = 00,C0,08
MEMSEG08 = 00,C0,09
MEMSEG09 = 00,C0,0A
MEMSEG0A = 00,C0,0B
MEMSEG0B = 00,C0,0C
MEMSEG0C = 00,C0,0D
MEMSEG0D = 00,C0,0E
MEMSEG0E = 00,C0,0F
MEMSEG0F = 00,C0,10
HASHDRVA = Y
HASHDRVB = Y
HASHDRVC = Y
HASHDRVD = Y
HASHDRVE = Y
HASHDRVF = Y
HASHDRVG = Y
HASHDRVH = Y
HASHDRVI = Y
HASHDRVJ = Y
HASHDRVK = Y
HASHDRVL = Y
HASHDRVM = Y
HASHDRVN = Y
HASHDRVO = Y
HASHDRVP = Y
ALTBNKSA = Y
ALTBNKSB = Y
ALTBNKSC = Y
ALTBNKSD = N
ALTBNKSE = N
ALTBNKSF = N
ALTBNKSG = N
ALTBNKSH = N
ALTBNKSI = N
ALTBNKSJ = N
ALTBNKSK = N
ALTBNKSL = N
ALTBNKSM = N
ALTBNKSN = N
ALTBNKSO = N
ALTBNKSP = N
NDIRRECA = 1F
NDIRRECB = 01
NDIRRECC = 01
NDIRRECD = 01
NDIRRECE = 01
NDIRRECF = 01
NDIRRECG = 01
NDIRRECH = 01
NDIRRECI = 01
NDIRRECJ = 01
NDIRRECK = 01
NDIRRECL = 01
NDIRRECM = 01
NDIRRECN = 01
NDIRRECO = 01
NDIRRECP = 01
NDTARECA = 01
NDTARECB = 01
NDTARECC = 01
NDTARECD = 01
NDTARECE = 01
NDTARECF = 01
NDTARECG = 01
NDTARECH = 01
NDTARECI = 01
NDTARECJ = 01
NDTARECK = 01
NDTARECL = 01
NDTARECM = 01
NDTARECN = 01
NDTARECO = 01
NDTARECP = 01
ODIRDRVA = A
ODIRDRVB = A
ODIRDRVC = A
ODIRDRVD = A
ODIRDRVE = A
ODIRDRVF = A
ODIRDRVG = A
ODIRDRVH = A
ODIRDRVI = A
ODIRDRVJ = A
ODIRDRVK = A
ODIRDRVL = A
ODIRDRVM = A
ODIRDRVN = A
ODIRDRVO = A
ODIRDRVP = A
ODTADRVA = A
ODTADRVB = A
ODTADRVC = A
ODTADRVD = A
ODTADRVE = A
ODTADRVF = A
ODTADRVG = A
ODTADRVH = A
ODTADRVI = A
ODTADRVJ = A
ODTADRVK = A
ODTADRVL = A
ODTADRVM = A
ODTADRVN = A
ODTADRVO = A
ODTADRVP = A
OVLYDIRA = Y
OVLYDIRB = Y
OVLYDIRC = Y
OVLYDIRD = Y
OVLYDIRE = Y
OVLYDIRF = Y
OVLYDIRG = Y
OVLYDIRH = Y
OVLYDIRI = Y
OVLYDIRJ = Y
OVLYDIRK = Y
OVLYDIRL = Y
OVLYDIRM = Y
OVLYDIRN = Y
OVLYDIRO = Y
OVLYDIRP = Y
OVLYDTAA = Y
OVLYDTAB = Y
OVLYDTAC = Y
OVLYDTAD = Y
OVLYDTAE = Y
OVLYDTAF = Y
OVLYDTAG = Y
OVLYDTAH = Y
OVLYDTAI = Y
OVLYDTAJ = Y
OVLYDTAK = Y
OVLYDTAL = Y
OVLYDTAM = Y
OVLYDTAN = Y
OVLYDTAO = Y
OVLYDTAP = Y
CRDATAF  = N
DBLALV   = Y
NDTARECP = 01
ODIRDRVA = A
ODIRDRVB = A
ODIRDRVC = A
ODIRDRVD = A
ODIRDRVE = A
ODIRDRVF = A
ODIRDRVG = A
ODIRDRVH = A
Oееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;******************************************************************************
;*  L D R B I O S  *  C P M S Y S 3  *  T h o m a s   H o l t e * 8 5 0 9 0 8 *
;******************************************************************************
;*									      *
;*  		 M I N I M U M   B I O S   F O R   C P M L D R		      *
;*               =============================================                *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

;ASCII control codes:
BEL	EQU  07H		;bell
LF	EQU  0AH		;line feed
CR	EQU  0DH		;carriage return
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape
RS	EQU  1EH		;record separator

$SYS1 	EQU  0FAH		;system byte 1

PUSHHL	EQU  0E5H		;machine code of PUSH HL

;BIOS jump vector.

;All BIOS routines are invoked by calling these entry points.

?BOOT:	JP   BOOT		;initial entry on cold start
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
?CONO:	JP   CONOUT		;send console output character
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
?HOME:	JP   HOME		;set disks to logical home
?SLDSK:	JP   SELDSK		;select disk drive, return disk parameter info
?STTRK:	JP   SETTRK		;set disk track
?STSEC:	JP   SETSEC		;set disk sector
?STDMA:	JP   SETDMA		;set disk I/O memory address
?READ:	JP   READ		;read physical block(s)
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
?SCTRN:	JP   SECTRN		;translate logical to physical sector
        JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
?MOVE:	JP   MOVE		;block move memory to memory
	JP   DUMMY		;not used jumps in LDRBIOS
	JP   DUMMY
	JP   DUMMY
	JP   DUMMY
 	

*EJECT
BOOT:
;====

;Initial entry point for system startup.

	JP   ?INIT		;perform any additional system initialization
				;and print signon message 


CONOUT:
;======

;Console output. Send character in reg. C to all selected devices.
	LD   A,C		;character  --> accu
        LD   C,4  		;function # --> reg. C
      	JP   ?USERF		;display char


HOME:
;====

;Home selected drive. Treated as SETTRK (0).

	LD   BC,0		;same as set track zero
	JR   SETTRK


SELDSK:
;======

;Select disk drive. Drive code in reg. C. Invoke login procedure for drive if
;this is first select. Return address of disk parameter header in reg. HL.

	LD   HL,DS0             ;^extended disk parameter header --> reg. HL
	RET

;Extended Disk Parameter Headers (XDPHs)

	DEFS 8
	DEFB 0,2	        ;relative drive zero
DS0:  	DEFW 0			;no translation table
	DEFW 0,0,0,0		;BDOS scratch area
	DEFB 0,0		;media flag
	DEFW DPB0   		;disk parameter block
	DEFW 0            	;no CSV
	DEFW ALV0  		;allocation vector
	DEFW DIRBCB		;DIRBCB alloc'd by GENCPM
	DEFW DTABCB	
	DEFW 0FFFFH		;no HASH
	DEFB 0			;hash bank

;Disk Parameter Block (DPB)
DPB0: 	DEFW 68			;128 byte records per track
	DEFB 6,63		;block shift and mask
	DEFB 3			;extent mask
	DEFW 1298		;maximum block number
	DEFW 1023		;maximum directory entry number
	DEFB 0F0H,0		;alloc vector for directory
	DEFW 0			;checksumm size
	DEFW 1			;offset for system tracks
	DEFB 2,3		;physical sector size shift and mask


;directory buffer control block:
DIRBCB:	DEFB 0FFH		;drive
	DEFS 4			;record #, written ?
	DEFB 0
	DEFS 4			;track, sector
	DEFW DIR		;buffer address

;data buffer:
DTABCB:	DEFB 0FFH		;drive
	DEFS 4			;record #, written ?
	DEFB 0
	DEFS 4			;track, sector
	DEFW DATA		;buffer address


SETTRK:
;======

;Set track. Saves track address from reg. BC in @TRK for further operations.

	LD   (@TRK),BC
	RET


SETSEC:
;======

;Set sector. Saves sector number from reg. BC in @SECT for further operations.

	LD   (@SECT),BC
	RET


SETDMA:
;======

;Set disk memory address. Saves DMA address from reg. BC in @DMA.

	LD   (@DMA),BC
	RET


READ:
;====

;Read physical record from currently selected drive. Finds address of proper
;read routine from extended disk parameter header (XDPH).

;*****************************************************
;* Bad block administration (sector skipping method) *
;* originally written by Andy Johnson-Laird	     *
;* modified by Thomas Holte (c) 1985		     *
;* (you've fooled me with many errors, Andy !!!)     *	
;*****************************************************
SECTORS$PER$TRACK EQU 17
SPARE$LENGTH	  EQU 512 	;170 entries, 3 bytes each

	LD   HL,SPARE$DIRECTORY-3
				 ;HL -> spare directory

	LD   DE,(@TRK)		;get requested track
	LD   A,(@SECT)		;get sector number

CHECK$ENTRY:
	LD   C,A		;save sector number for later
	LD   B,0   		;set counter

CHECK$ENTRY1:
	INC  HL			;update to next (or first entry)
	INC  HL
	INC  HL

	INC  B			;update count

	CALL CMPM		;compare req. track to table entry

	JR   Z,TRACKS$MATCH	;possible match of track and sector
	JR   NC,COMPUTE$INCREMENT
				;requested track < table entry
	JR   CHECK$ENTRY1	;requested track > table entry

TRACKS$MATCH:
	INC  HL			;HL -> MS byte of track
	INC  HL			;HL -> sector
	LD   A,(HL)		;get sector from table
	DEC  HL
	DEC  HL

	CP   C			;compare with requested sector
	JR   Z,SECTORS$MATCH	;track/sector matches
	JR   NC,COMPUTE$INCREMENT
				;req. trk/sec < spare trk/sec
	JR   CHECK$ENTRY1	;move to next table entry

SECTORS$MATCH:
	INC  B			;if track and sectors match with
				;a table entry, then an additional 
				;sector must be skipped

COMPUTE$INCREMENT:		;B contains number of cumulative
				;number of sectors to skip
	DEC  B			;0 sectors to skip ?
	JP   Z,DS$IO		;if yes, go to physical sector read/write 
	LD   A,C		;get requested sector
	ADD  A,B		;skip required number
	LD   B,SECTORS$PER$TRACK;determine final sector number
				;and track increment
	CALL DIV$A$BY$B		;returns C = quotient, A = remainder
	LD   (@SECT),A          ;A = new sector number

	LD   B,0		;make track increment a word
	EX   DE,HL    		;get requested track
	ADD  HL,BC		;add on increment
	LD   (@TRK),HL		;save updated track
	EX   DE,HL		;get table pointer
	JP   CHECK$ENTRY	;go to physical disk read/write

; DIV$A$BY$B
; Divide A by B
;
; This routine divides A by B, returning the quotient in C
; and the remainder in A.
;
; Entry parameters
;
;	A = dividend
;	B = divisor
;
; Exit parameters
;
;	A = remainder
;	C = quotient
;
DIV$A$BY$B:
	LD   C,0		;initialize quotient
DIV$A$BY$B$LOOP:
	INC  C			;increment quotient
	SUB  B			;subtract divisor
	JP   P,DIV$A$BY$B$LOOP	;repeat if result still +ve
	DEC  C			;correct quotient
	ADD  A,B		;correct remainder
	RET

; CMPM
; Compare memory
;
; This subroutine compares the contents of DE to (HL) and (HL+1)
; returning with the flags as though the subtraction (HL) - DE
; were performed.
;
; Entry parameters
;
;	HL -> word in memory
;	DE =  value to be compared
;
; Exit parameters
;
;	Flags set for (HL) - DE
;
CMPM:	INC  HL
	LD   A,(HL)		;get MS byte
	CP   D
	DEC  HL			;return with HL unchanged
	RET  NZ			;return now if MS bytes unequal
	LD   A,(HL)		;get LS byte
	CP   E
	RET

;*****************************************************

DS$IO:	LD   A,(@SECT)		;sector number 	       --> reg. B
	LD   B,A
	XOR  A			;drive number	       --> accu
	LD   DE,(@TRK)		;track number	       --> reg. DE
	LD   HL,(@DMA)		;DMA address	       --> reg. HL
	LD   C,16		;function #	       --> reg. C
	CALL ?USERF		;transfer hard disk sector
	OR   A			;any errors ?
	RET  Z			;return if not
	LD   A,1		;return common error code
	RET


SECTRN:
;======

;Sector translate. Indexes skew table in reg. DE with sector in reg. BC.
;Returns physical sector in reg. HL. If no skew table (reg. DE = 0) then
;returns physical = logical.

	LD   L,C
	LD   H,B
	RET


MOVE:
;====
      	EX   DE,HL		;we are passed source in DE and dest in HL
	LDIR			;use Z80 block move instruction
        EX   DE,HL              ;need next addresses in same regs
DUMMY:  RET


*EJECT
?INIT:	DI			;disable interrupts
	IM   1			;interrupt mode 1 (RST 7)
      	LD   C,23		;function # --> reg. C
	CALL ?USERF		;general system initialization

	.XLIST
	.XCREF

;check copyright message of boot sector:
COPYRGT	EQU  0FD0FH		;location of copyright message
CGTLEN	EQU  47			;length of copyright message
CHKSUM	EQU  0F0E2H		;checksumm of copyright message

	LD   IX,COPYRGT		;^copyright message 	         --> reg. IX
	DEFB 0FDH,2EH,CGTLEN	;LD LY,CGTLEN (length of message --> reg. LY)
	LD   HL,0		;clear reg. HL (accumulator)
	LD   D,H		;clear MSB of summand
ADDC:	LD   E,(IX)		;load first char of message
	ADD  HL,DE
	INC  IX			;bump message pointer
	DEFB 0FDH,2DH		;DEC LY (decrement loop counter)
	JR   NZ,ADDC		;add all chars of message
	LD   A,L		;make 2'complement of checksumm
	NEG
	LD   L,A
	LD   A,H
	CPL
	CCF
	ADC  A,D
	LD   H,A 
	LD   DE,CHKSUM		;compare value of checksumm --> reg. DE
	OR   A          	;16 bit compare
	SBC  HL,DE
	JR   Z,SERCHK		;jump if match
	LD   HL,VIOMSG		;^violate message      --> reg. HL
	LD   B,VIOLEN/2         ;length of message / 2 --> reg. B		
	CALL DECODE		;decode violate message
	LD   DE,VIOMSG		;^violate message  --> reg. DE
	LD   B,VIOLEN-1     	;length of message --> reg. B
	JR   DISPMSG

;check serial number:
SERNO  	EQU  0FD3EH		;location of serial number
SERLEN	EQU  7			;length of serial number

SERCHK:	LD   IX,SERNO  		;^serial number     	        --> reg. IX
	DEFB 0FDH,2EH,SERLEN	;LD LY,SERLEN (length of number --> reg. LY)
	LD   HL,0		;clear reg. HL (accumulator)
	LD   D,H		;clear MSB of summand
ADDS:	LD   E,(IX)		;load first char of serial number
	ADD  HL,DE
	INC  IX			;bump serial number pointer
	DEFB 0FDH,2DH		;DEC LY (decrement loop counter)
	JR   NZ,ADDS		;add all digits of number 
	LD   A,L		;make 2'complement of checksumm
	NEG
	LD   L,A
	LD   A,H
	CPL
	CCF
	ADC  A,D
	LD   H,A 
	LD   B,H		;checksumm		    --> reg. BC
	LD   C,L
	LD   DE,(0036H)		;compare value of checksumm --> reg. DE
	OR   A          	;16 bit compare
	SBC  HL,DE
	JP   Z,DS$INIT		;jump if match
	OR   A
	SBC  HL,BC		;compare value not initialized ?
	JR   Z,INISER		;jump to serialization
	LD   HL,ILLMSG		;^illegal message      --> reg. HL
	LD   B,ILLEN/2          ;length of message / 2 --> reg. B		
	CALL DECODE		;decode illegal message
	LD   DE,ILLMSG		;^violate message  --> reg. DE
	LD   B,ILLEN-1     	;length of message --> reg. B
	JR   DISPMSG

;initialize serial number:
INISER:	LD   (0036H),BC		
	XOR  A			;bank   0, drive 0
	LD   B,1		;sector 1
	LD   E,A		;track  0
	LD   H,A 		;^buffer    --> reg. HL
	LD   L,A
	LD   C,$WRITE		;function # --> reg. C
	CALL ?USERF		;write serial #
	OR   A			;any errors ?
	JP   Z,DS$INIT		;jump if not
DISPERR:LD   DE,ERRMSG		;^violate message  --> reg. DE
	LD   B,ERRLEN-1		;length of message --> reg. B
	LD   C,$VDCHAR		;function #     --> reg. C
DISPER1:LD   A,(DE)		;next character --> accu
	CALL ?USERF		;clear screen
	INC  DE			;bump char pointer
	DJNZ DISPER1		;display message
	JR   $			;hang up

;display message:
	LD   HL,VIOMSG		;^violate message      --> reg. HL
	LD   B,VIOLEN/2         ;length of message / 2 --> reg. B		
	CALL DECODE		;decode violate message
	LD   DE,VIOMSG		;^violate message  --> reg. DE
	LD   B,VIOLEN-1     	;length of message --> reg. B



DISPMSG:LD   C,$VDCHAR		;vector # 	   --> reg. C
DISPMS1:LD   A,(DE)		;next character    --> accu
	CALL ?USERF		;clear screen
	INC  DE			;bump char pointer
	DJNZ DISPMS1   		;display message
	LD   C,$WRITE		;vector # --> reg. C
	LD   HL,3800H     	;^screen  --> reg. HL
	LD   E,0    		; track # --> reg. E 
      	LD   B,E      		;begin with sector 0
CLEAR:	LD   A,11010100B	;enable  memory mapped I/O
				;disable graphic display
				;disable boot EPROM
				;disable graphic page
				;7.2 MHz clock frequency
				;enable video display
	OUT  ($SYS1),A		;write system byte 1
      	XOR  A			; drive # --> accu 
	PUSH HL			;save buffer pointer
       	CALL ?USERF		;destroy selected sector
	POP  HL			;restore buffer pointer
	INC  B			;increment sector #
	JR   NZ,CLEAR           ;destroy all sectors
	INC  E   		;destory all tracks
	JR   CLEAR    		;endless loop

;disk error message:
ERRMSG:	DEFB SUB
	DEFM 'DISK ERROR'
	DEFB BEL,BEL,BEL,BEL,BEL,BEL,BEL
ERRLEN	EQU  $-ERRMSG

;violate message is encrypted for harder disassembly:
VIOMSG:	DEFB NOT 'C',NOT SUB
	DEFW NOT 'OP',NOT 'YR',NOT 'IG',NOT 'HT',NOT ' V'
 	DEFW NOT 'IO',NOT 'LA',NOT 'TE',NOT 'D ' 
VIOLEN	EQU  $-VIOMSG

;illegal copy message is encrypted for harder disassembly:
ILLMSG:	DEFB NOT 'I',NOT SUB
	DEFW NOT 'LL',NOT 'EG',NOT 'AL',NOT ' C',NOT 'OP', NOT 'Y '
ILLEN	EQU  $-ILLMSG


DECODE:	LD   A,(HL)		;first byte of message --> accu
	CPL  			;decode it
	LD   C,A		;save it
	INC  HL			;bump message pointer
	LD   A,(HL)		;second byte of message --> accu
	CPL			;decode it
	DEC  HL			;swap both bytes
	LD   (HL),A
	INC  HL
	LD   (HL),C
	INC  HL			;bump message pointer
	DJNZ DECODE 		;decode and swap next two bytes
	RET

	.CREF
	.LIST

;hard disk init routine:
DS$INIT:XOR  A			;bank 0, drive 0
	LD   D,A		;track 0
	LD   E,A
	LD   B,A		;sector 0
	LD   HL,SPARE$DIRECTORY	;^buffer
	LD   C,16		;function #
	CALL ?USERF		;read in spare directory
	OR   A			;any errors ?
	RET  Z			;return if not
	JP   DISPERR     	;display error message and hang up


*EJECT
;table of driver entry vectors:
$VDINIT	EQU  0    		;initialize the video controller chip M6845
$RSINIT	EQU  1    		;initialize the RS-232-C interface
$KBCHAR	EQU  2    		;get a keyboard character if available
$KBWAIT	EQU  3     		;wait for a keyboard character
$VDCHAR	EQU  4    		;display a character
$PRSTAT	EQU  5    		;test printer status
$PRCHAR	EQU  6    		;output a character to the printer
$RSRCST	EQU  7    		;get a character from the RS-232-C interface if
				;available
$RSRCV	EQU  8    		;receive a character from the RS-232-C
				;interface
$RSTXST	EQU  9    		;test the RS-232-C output status
$RSTX	EQU  10    		;transmit a character to the RS-232-C interface
$READ	EQU  11   		;read a disk sector
$WRITE	EQU  12   		;write a disk sector
$GETTIM	EQU  13   		;get time and date in binary format
$SETTIM	EQU  14   		;set time and date in binary format
$XMOVE	EQU  15			;interbank data transfer
$GTIME3	EQU  18			;get time and date in CP/M 3 format
$STIME3	EQU  19			;set time and date in CP/M 3 format
$LDCHAR	EQU  20			;load bit pattern into character RAM
$RSTCHR	EQU  21			;restore original character set
$SCRNIO EQU  22			;direct screen I/O
$INIT	EQU  23			;general system initialization
$CLOCK	EQU  24			;turn clock display on/off
$DISP	EQU  25			;turn on/off graphic display
$CLS	EQU  26			;clear graphic screen
$PLOT	EQU  27			;plot dot    on graphic screen
$POINT	EQU  28			;read dot  from graphic screen
$LINE	EQU  29			;draw line   on graphic screen
$CIRCLE	EQU  30			;draw circle on graphic screen
$ARC	EQU  31			;draw arc    on graphic screen
$COPY	EQU  33			;copy area

;call ROM driver routines:
?USERF:	LD   (SAVESP),SP	;save stack pointer
	LD   SP,0E100H  	;temporary stack --> stack pointer
        PUSH BC			;save register set
	PUSH DE
	PUSH HL
	PUSH IX
	PUSH IY
	DI			;disable interrupts
       	RST  0     		;call driver routine
	PUSH AF    		;save accu
	LD   A,11010101B	;disable memory mapped I/O
				;disable graphic display
				;disable boot EPROM
				;disable graphic page
				;7.2 MHz clock frequency
				;enable video display
	OUT  ($SYS1),A		;write system byte 1
	POP  AF    		;restore accu
	POP  IY			;restore register set
	POP  IX
	POP  HL
	POP  DE
	POP  BC
	LD   SP,(SAVESP)	;restore stack pointer
	RET			;return to caller

SAVESP: DEFS 2			;temporary memory for stack pointer


*EJECT
@TRK:	DEFS 2			;current track number
@SECT:	DEFS 2			;current sector number
@DMA:	DEFS 2			;current DMA address


ALV0    EQU  $
DIR     EQU  ALV0+203
DATA   	EQU  DIR+512 
SPARE$DIRECTORY EQU DATA+512 

	END
;******************************************************************************
;*  M O D E B A U D * C P M S Y S 4 g * T h o m a s   H o l t e * 8 4 1 0 0 5 *
;******************************************************************************
;*									      *
;*  	E Q U A T E S   F O R   M O D E   B Y T E   B I T   F I E L D S       *
;*      ===============================================================       *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

MB$INPUT     EQU 00000001B	;device may do input
MB$OUTPUT    EQU 00000010B	;device may do output
MB$IN$OUT    EQU MB$INPUT+MB$OUTPUT
MB$SOFT$BAUD EQU 00000100B	;software selectable baud rates
MB$SERIAL    EQU 00001000B	;device may use protocol
MB$XON$XOFF  EQU 00010000B	;XON/XOFF protocol enabled

BAUDNONE     EQU 0		;no baud rate associated with device
BAUD50       EQU 1		;50 baud
BAUD75       EQU 2		;75 baud
BAUD110      EQU 3		;110 baud
BAUD134      EQU 4		;134.5 baud
BAUD150      EQU 5		;150 baud
BAUD300      EQU 6		;300 baud
BAUD600      EQU 7		;600 baud
BAUD1200     EQU 8		;1200 baud
BAUD1800     EQU 9		;1800 baud
BAUD2400     EQU 10		;2400 baud
BAUD3600     EQU 11		;3600 baud
BAUD4800     EQU 12		;4800 baud
BAUD7200     EQU 13		;7200 baud
BAUD9600     EQU 14		;9600 baud
BAUD19200    EQU 15		;19.2k baud
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее;******************************************************************************
;*  M O V E  *  C P M S Y S 4 d  *  T h o m a s   H o l t e   *  8 5 0 7 1 7  *
;******************************************************************************
;*									      *
;*     M O V E   M O D U L E   F O R   C P / M 3   L I N K E D   B I O S      *
;*     =================================================================      *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	TITLE 'MOVE MODULE FOR CP/M3 LINKED BIOS'

        GLOBAL ?MOVE,?XMOVE,?BANK,?USERF

$SYS0	EQU  0F9H		;system byte 0
$SYS1 	EQU  0FAH		;system byte 1


	CSEG

?XMOVE: LD   A,0FFH		;remark interbank move
	LD   (IBANK),A
	LD   A,C		;source bank number --> accu
	ADД  A,A		;source bank number --> upper nibble
	ADD  A,A
	ADД  A,A
	ADD  A,A
	ADD  A,B		;destination bank number --> lower nibble
	LD   (BANK),A		;store bank numbers
	RET
BANK:	DEFS 1			;bank numbers
IBANK:	DEFB 0			;flag for interbank move


?MOVE:	EX   DE,HL		;we are passed source in DE and dest in HL
	LD   A,(IBANK)		;interbank move ?
	OR   A
	JR   Z,NIBANK		;jump if not
	XOR  A			;clear interbank move flag
	LD   (IBANK),A
	LD   A,(BANK)		;get source and destination bank number
	PUSH BC			;save byte count
	LD   B,C		;byte count --> reg. B
	LD   C,15		;function # --> reg. C
	CALL ?USERF		;perform interbank move
	POP  BC			;restore byte count	
	ADD  HL,BC		;calc new source address
	EX   DE,HL
	ADD  HL,BC		;calc new destination address
	RET
NIBANK:	LDIR			;use Z80 block move instruction
        EX   DE,HL              ;need next addresses in same regs
        RET


?BANK:	PUSH BC			;save reg. BC
      	RRCA			;bank number --> highest two bits
	RRCA
	AND  0C0H
	OR   1
	LD   C,A		;bank number --> reg. C
	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;disable character RAM
	OR   C			;set bank number
       	OUT  ($SYS0),A		;write system byte 0
	POP  BC			;restore reg. BC
	RET


;table of driver entry vectors:
$VDINIT	EQU  0    		;initialize the video controller chip M6845
$RSINIT	EQU  1    		;initialize the RS-232-C interface
$KBCHAR	EQU  2    		;get a keyboard character if available
$KBWAIT	EQU  3     		;wait for a keyboard character
$VDCHAR	EQU  4    		;display a character
$PRSTAT	EQU  5    		;test printer status
$PRCHAR	EQU  6    		;output a character to the printer
$RSRCST	EQU  7    		;get a character from the RS-232-C interface if
				;available
$RSRCV	EQU  8    		;receive a character from the RS-232-C
				;interface
$RSTXST	EQU  9    		;test the RS-232-C output status
$RSTX	EQU  10    		;transmit a character to the RS-232-C interface
$READ	EQU  11   		;read a disk sector
$WRITE	EQU  12   		;write a disk sector
$GETTIM	EQU  13   		;get time and date in binary format
$SETTIM	EQU  14   		;set time and date in binary format
$XMOVE	EQU  15			;interbank move
$GTIME3	EQU  18			;get time and date in CP/M 3 format
$STIME3	EQU  19			;set time and date in CP/M 3 format
$LDCHAR EQU  20			;load bit pattern for user definable char
$RSTCHR	EQU  21			;restore original character set
$SCRNIO	EQU  22			;direct screen I/O
$INIT	EQU  23			;general initialization routine
$CLOCK	EQU  24			;clock/display on/off


;call ROM driver routines:
	DEFS 50			;space for temporary stack
?USERF:	LD   (SAVESP),SP	;save stack pointer
	LD   SP,?USERF  	;temporary stack --> stack pointer
        PUSH BC			;save register set
	PUSH DE
	PUSH HL
	PUSH IX
	PUSH IY
	PUSH AF    		;save accu
	IN   A,($SYS0)		;read system byte 0
	LD   (PORT),A		;remember port data
	AND  00111101B		;enable bank 0
				;disable character RAM
	OR   00000001B		;enable common memory
	OUT  ($SYS0),A		;write system byte 0
	POP  AF    		;restore accu
       	RST  0     		;call driver routine
 	EI			;enable interrupts
	PUSH AF    		;save accu
	LD   A,(PORT)		;select current CPU bank
	OUT  ($SYS0),A
	IN   A,($SYS1)		;read system byte 1
	AND  11010111B		;disable graphic page
	OR   01000101B		;disable memory mapped I/O
				;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	POP  AF    		;restore accu
	POP  IY			;restore register set
	POP  IX
	POP  HL
	POP  DE
	POP  BC
	LD   SP,(SAVESP)	;restore stack pointer
	RET			;return to caller

SAVESP: DEFS 2			;temporary memory for stack pointer
PORT:	DEFS 1			;temporary memory for system byte 0

	END
ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее                                                                                                                                                                                                                                                                   `Г$ ГдГтГъ       N      Гwy!  "(9"f1f!ЛеюТ”2Я!†  		~#foйCOPYRIGHT (C) 1982, DIGITAL RESEARCH 151282                 яХХћ ¤ Ё ¬ г й п ХНяГИKГяKГя{<КГ <КЅ <КИ KГяНО ГИНО ·ИНШ ГИ:  ·>яАГя!  ~6 ·АГ	яН6яГИН9яГИBK!У
ѕИЕOНSБГс л}ґВ!,"є*Ше*Х NлНKя6 СХ
НХ:+O СбГKя2$л^#V#N#Fлx±ИЕеNpХ:$юpКя:ПGжКjxжКjжВяГяYГХб#БГA>НQяFЇНQяxЙЌХ>НQяйGЇНQяxЙю3Ъ°юbЪјюqТјюoК5юpК5ГПюКЗюКЛюВПл"Ш" Йл"г*гл!вyюbЪЫ!і 	~GЕХЪнЪьГ*Шл!N НKяСХЇ2 !*$ НKя*бБЕе" НХСБxжьИ!*л! Ъ@$Ъ@ЪhЪKяЪ\ГKя: ·КKя 	л	~#~	л	wЙ*Ш NГKя*ШЂ NГKял^#V#N#F!ЇеЕХ",!."*Ђ НKя6 *НХБ}ґКґ}¤<Кґ.}“o|љg	"(бС$ ГKяюКt> ЪИ=2(*fщ*(}DЙЇНQяНь"(>ГQя·КKяНQяНKяЇГQя>НQяГл"%НQя!ЦеЇ2 *%DM* л*беНЭСµИеле+))	 ќ®жВHНАК~лб#г+}ґгелВ#<ббЙ: <КІ<В7ХНАСВ7: <Кў<Кo~жВ7Г~®жВ7~ж0ю0К7*блб+"бБ}жюИ{жь_}жьoНЭµИ>я2 ЇЙ~жК7®жВ7Гё~юхВ7лб" Г9:њ·ИOG® Ае#НдбЙхЇНQясЙ{•ozњgЙѕА#ИГд   ѓ‚""‚‚ѓ      ѓ  ‚‚BB   ‚‚        ѓ                                                                                                                                                                                                                                                                                                                                         ГяГѓГяГѓГ	яГѓГяГѓГяГѓ                         1                                               j$  њЂ               яяя       Ђяяяяя  Г|ь  ’@ "H$Ђ       UUT‘€‰$$Ѓ $’‚I 	  D$BA„@„!	B$$A IA ђ$‚!"  	 ђ	 Ѓ ‚@‚$@’$BI!!  @’ ""$D‚  ЃA	                                                   $’I$  @      !    ;******************************************************************************
;*  S C B  *  C P M S Y S 4 a  *  T h o m a s   H o l t e   *   8 5 0 2 0 5   *
;******************************************************************************
;*									      *
;*   S Y S T E M   C O N T R O L   B L O C K   D E F I N I T I O N   F O R    *
;*   =====================================================================    *
;*									      *
;*  	       		    C P / M   3 . 0   B I O S			      *
;*	                    =========================           	      *
;*									      *
;*									      *
;*  Thomas Holte						 Version 1.0  *
;*									      *
;******************************************************************************

	.Z80

	TITLE 'SYSTEM CONTROL BLOCK DEFINITION FOR CP/M 3 BIOS'

	GLOBAL @CIVEC,@COVEC,@AIVEC,@AOVEC,@LOVEC,@ERDME,@DATE,@HOUR,@MIN
	GLOBAL @MXTPA


SCB$BASE EQU 0FE00H		;base of the SCB

@CIVEC  EQU  SCB$BASE+22H	;console   input  redirection vector
				;(word, R/W)
@COVEC  EQU  SCB$BASE+24H       ;console   output redirection vector 
				;(word, R/W)
@AIVEC  EQU  SCB$BASE+26H	;auxiliary input  redirection vector
				;(word, R/W)
@AOVEC	EQU  SCB$BASE+28H	;auxiliary output redirection vector
				;(word, R/W)
@LOVEC	EQU  SCB$BASE+2AH	;list	   output redirection vector
                                ;(word, R/W)
@ERDME	EQU  SCB$BASE+4BH	;BDOS error mode (byte, R/O)
@DATE	EQU  SCB$BASE+58H	;date in days since 1 Jan 78 (word, R/W)
@HOUR	EQU  SCB$BASE+5AH	;hour   in BCD (byte, R/W)
@MIN	EQU  SCB$BASE+5BH	;minute in BCD (byte, R/W)
@MXTPA	EQU  SCB$BASE+62H	;top of user TPA (address at 6, 7) (word, R/O)

        END
SYSTEM CONTROL BLOCK DEFINITION FOR CP/M 3 BIOS'

	GLOBAL @CIVEC,@COVEC,@AIVEC,@AOVEC,@LOVEC,@ERDME,@DATE,@HOUR,@MIN
	GLOBAL @MXTPA


SCB$BASE EQU 0FE00H		;base of the SCB

@CIVEC  EQU  SCB$BASE+22H	;console   input  redirection vector
				;(word,ееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее