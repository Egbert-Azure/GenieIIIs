;******************************************************************************
;*  D R I V E R  *  C P M S Y S 1  *  T h o m a s   H o l t e  *  8 6 0 1 1 3 *
;******************************************************************************
;*									      *
;*  	   I / O - D R I V E R S   F O R   T H E   G E N I E  I I I s         *
;*	   ==========================================================         *
;*									      *
;*  		    M I C R O C O M P U T E R   S Y S T E M 		      *
;*		    =======================================		      *
;*									      *
;*									      *
;*  Thomas Holte			                         Version 1.1  *
;*									      *
;******************************************************************************

	.Z80
	.SALL

SASI	EQU  0   		;must be true, if Xebec controller installed

	ASEG

;******************************************************************************
;*  		  B A N K E D   P A R T   O F   D R I V E R S		      *
;******************************************************************************

 	ORG  0000H		;start of 56K bank 0


;ASCII control codes:
NUL	EQU  00H		;null
SOH	EQU  01H		;start of heading
STX	EQU  02H		;start of text
ETX	EQU  03H		;end of text
EOT	EQU  04H		;end of transmission
ENQ	EQU  05H		;enquiry
ACK	EQU  06H		;acknowledge
BEL	EQU  07H		;bell
BS	EQU  08H		;backspace
HT	EQU  09H		;horizontal tabulation
LF	EQU  0AH		;line feed
VT	EQU  0BH		;vertical tabulation
FF	EQU  0CH		;form feed
CR	EQU  0DH		;carriage return
SO	EQU  0EH		;shift out
SI	EQU  0FH		;shift in
DLE	EQU  10H		;data link escape
DC1	EQU  11H		;device control 1
DC2	EQU  12H		;device control 2
DC3	EQU  13H		;device control 3
DC4	EQU  14H		;device control 4
NAK	EQU  15H		;negative acknowledge
SYN	EQU  16H		;synchronous idle
ETB	EQU  17H		;end of transmission block
CAN	EQU  18H		;cancel
EM	EQU  19H		;end of medium
SUB	EQU  1AH		;substitute
ESC	EQU  1BH		;escape
FS	EQU  1CH		;file separator
GS	EQU  1DH		;group separator
RS	EQU  1EH		;record separator
DEL	EQU  7FH		;delete
	
;common entry point for all driver routines:
	PUSH BC			;save contents of reg. B & HL
	PUSH HL
	LD   B,0		;vector # * 2 --> reg. BC
	SLA  C
	LD   HL,DRITBL		;base of vector table --> reg. IX
	ADD  HL,BC		;calc table entry
	LD   C,(HL)		;get entry point of driver routine
	INC  HL
	LD   B,(HL)
	PUSH BC
	POP  IX
	POP  HL			;restore contents of reg. B & HL
	POP  BC
	JP   (IX)		;execute driver	routine

	ORG  0036H		;interrupt entry point - 2
	DEFW 0			;checksumm of serial #
      	JP   $INT		;jump to interrupt service routine

;table of driver addresses:
DRITBL:	DEFW $VDINIT		;initialize video  controller chip M6845
	DEFW $RSINIT		;initialize RS232C controller chip SIO
	DEFW $KBCHAR		;get a keyboard character if available
	DEFW $KBWAIT		;wait for keyboard character
	DEFW $VDCHAR		;display a character
	DEFW $PRSTAT		;test printer status
	DEFW $PRCHAR		;output a character to the printer
	DEFW $RSRCST		;test RS232C input status
	DEFW $RSRCV		;receive a character from the RS232C interface
	DEFW $RSTXST		;test RS232C output status
	DEFW $RSTX  		;transmit a character to the RS232C interface
	DEFW $READ		;read a sector
	DEFW $WRITE		;write a sector
	DEFW $GETTIM		;get time and date in ASCII format
	DEFW $SETTIM		;set time and date in binary format
	DEFW $XMOVE		;read/write system data
	DEFW $READW		;read a Winchester sector
	DEFW $WRITW		;write a Winchester sector
$GTIME3:DEFW $GTIME3S		;get time and date in CP/M 3 format
$STIME3:DEFW $STIME3S		;set time and date in CP/M 3 format
	DEFW $LDCHAR		;load character pattern
	DEFW $RSTCHR		;restore original character set
	DEFW $SCRNIO		;direct screen I/O
	DEFW $INIT		;general initialization routine
	DEFW $CLOCK		;display time continuously
	DEFW $DISP		;turn on/off graphic display
	DEFW $CLS		;clear graphic screen
	DEFW $PLOT		;plot dot    on graphic screen
	DEFW $POINT		;read dot  from graphic screen
	DEFW $LINE		;draw line   on graphic screen
	DEFW $CIRCLE		;draw circle on graphic screen
	DEFW $ARC		;draw arc    on graphic screen
	DEFW $FILL		;fill shape (not implemented yet)
	DEFW $COPY		;copy area


*EJECT
	ORG  0100H
;******************************************************************************
;*			     	  S Y S T A B				      *
;******************************************************************************

DELAY1: DEFW 500   		;determines debounce time (start of key press)
DELAY2: DEFW 5000  		;determines debounce time (end   of key press)
�DELAY3: DEFW 35    		;determines wait time until key autorepeats
DELAY4:	DEFW 3  		;determines frequency of auto repeat
KEYTAB:	DEFW NBOARD		;contains ^(keyboard table)

;table contains codes for all caps (may be altered by user):
NBOARD:

;address 3801H (letter keys):
	DEFB '@','`',NUL	;@, SHIFT-@, CTRL-@
	DEFB 'a','A',SOH	;A, SHIFT-A, CTRL-A
	DEFB 'b','B',STX	;B, SHIFT-B, CTRL-B
	DEFB 'c','C',ETX	;C, SHIFT-C, CTRL-C
	DEFB 'd','D',EOT	;D, SHIFT-D, CTRL-D
	DEFB 'e','E',ENQ	;E, SHIFT-E, CTRL-E
	DEFB 'f','F',ACK	;F, SHIFT-F, CTRL-F
	DEFB 'g','G',BEL	;G, SHIFT-G, CTRL-G

;address 3802H (letter keys):
	DEFB 'h','H',BS 	;H, SHIFT-H, CTRL-H
	DEFB 'i','I',HT 	;I, SHIFT-I, CTRL-I
	DEFB 'j','J',LF 	;J, SHIFT-J, CTRL-J
	DEFB 'k','K',VT 	;K, SHIFT-K, CTRL-K
	DEFB 'l','L',FF 	;L, SHIFT-L, CTRL-L
	DEFB 'm','M',CR 	;M, SHIFT-M, CTRL-M
	DEFB 'n','N',SO 	;N, SHIFT-N, CTRL-N
	DEFB 'o','O',SI 	;O, SHIFT-O, CTRL-O

;address 3804H (letter keys):
	DEFB 'p','P',DLE	;P, SHIFT-P, CTRL-P
	DEFB 'q','Q',DC1	;Q, SHIFT-Q, CTRL-Q
	DEFB 'r','R',DC2	;R, SHIFT-R, CTRL-R
	DEFB 's','S',DC3	;S, SHIFT-S, CTRL-S
	DEFB 't','T',DC4	;T, SHIFT-T, CTRL-T
	DEFB 'u','U',NAK	;U, SHIFT-U, CTRL-U
	DEFB 'v','V',SYN	;V, SHIFT-V, CTRL-V
	DEFB 'w','W',ETB	;W, SHIFT-W, CTRL-W

;address 3808H (letter keys):
	DEFB 'x','X',CAN	;X, SHIFT-X, CTRL-X
	DEFB 'y','Y',EM 	;Y, SHIFT-Y, CTRL-Y
	DEFB 'z','Z',SUB	;Z, SHIFT-Z, CTRL-Z
	DEFB '[','{',ESC	;[, SHIFT-[, CTRL-[
	DEFB '\','|',FS 	;\, SHIFT-\, CTRL-\
	DEFB ']','}',GS 	;], SHIFT-], CTRL-]
	DEFB '^','~',RS 	;^, SHIFT-^, CTRL-^
	DEFB '_','^',RS 	;_, SHIFT-_, CTRL-_

;address 3810H (number keys):
	DEFB '0','0',0  	;0, SHIFT-0, CTRL-0
	DEFB '1','!',0  	;1, SHIFT-1, CTRL-1
	DEFB '2','"',0  	;2, SHIFT-2, CTRL-2
	DEFB '3','#',0  	;3, SHIFT-3, CTRL-3
	DEFB '4','$',0  	;4, SHIFT-4, CTRL-4
	DEFB '5','%',0  	;5, SHIFT-5, CTRL-5
	DEFB '6','&',0  	;6, SHIFT-6, CTRL-6
	DEFB '7','''',0 	;7, SHIFT-7, CTRL-7

;address 3820H (number & special keys):
	DEFB '8','(',0  	;8, SHIFT-8, CTRL-8
	DEFB '9',')',0  	;9, SHIFT-9, CTRL-9
	DEFB ':','*',0  	;:, SHIFT-:, CTRL-:
	DEFB ';','+',0  	;;, SHIFT-;, CTRL-;
	DEFB ',','<',0  	;,, SHIFT-,, CTRL-,
	DEFB '-','=',0  	;-, SHIFT--, CTRL--
	DEFB '.','>',0  	;., SHIFT-., CTRL-.
	DEFB '/','?',0 		;/, SHIFT-/, CTRL-/

;address 3840H (special keys):	
	DEFB CR,CR,0    	;NEWLINE   , SHIFT-NEWLINE   , CTRL-NEWLINE
	DEFB DEL,0FCH,0 	;CLEAR     , SHIFT-CLEAR     , CTRL-CLEAR
	DEFB ESC,0FDH,0 	;BREAK     , SHIFT-BREAK     , CTRL-BREAK
	DEFB STX,VT,ETB 	;UP-ARROW  , SHIFT-UP-ARROW  , CTRL-UP-ARROW
	DEFB LF,ETX,SUB 	;DOWN-ARROW, SHIFT-DOWN-ARROW, CTRL-DOWN-ARROW
	DEFB SOH,CAN,BS  	;LEFT-ARROW, SHIFT-LEFT-ARROW, CTRL-LEFT-ARROW
	DEFB ACK,HT,BEL  	;RGHT-ARROW, SHIFT-RGHT-ARROW, CTRL-RGHT-ARROW
	DEFB ' ',' ',0 		;SPACE     , SHIFT-SPACE     , CTRL-SPACE

;address 38A0H (function keys):	
	DEFB 80H,80H,0  	;F1, SHIFT-F1, CTRL-F1
	DEFB 81H,81H,0  	;F2, SHIFT-F2, CTRL-F2
	DEFB 82H,82H,0  	;F3, SHIFT-F3, CTRL-F3
	DEFB 83H,83H,0  	;F4, SHIFT-F4, CTRL-F4
	DEFB 84H,84H,0  	;F5, SHIFT-F5, CTRL-F5
	DEFB 85H,85H,0  	;F6, SHIFT-F6, CTRL-F6
	DEFB 86H,86H,0  	;F7, SHIFT-F7, CTRL-F7
	DEFB 87H,87H,0 		;F8, SHIFT-F8, CTRL-F8

;address 38C0H (number keys [numeric keypad]):	
	DEFB '0','0',0  	;1, SHIFT-1, CTRL-1
	DEFB '1','1',0  	;2, SHIFT-2, CTRL-2
	DEFB '2','3',0  	;3, SHIFT-3, CTRL-3
	DEFB '3','3',0  	;4, SHIFT-4, CTPL-4
	DEFB '4','4',0  	;5, SHIFT-5, CTRL-5
	DEFB '5','5',0  	;6, SHIFT-6, CTRL-6
	DEFB '6','6',0  	;7, SHIFT-7, CTRL-7
	DEFB '7','7',0 		;8, SHIFT-8, CTRL-8

;address 3880H (function keys & escape key):
	DEFB 0,0,0      	;SHIFT
	DEFB 0,0,0      	;CTRL
	DEFB ESC,ESC,0  	;ESC
	DEFB 8CH,8CH,0  	;P5, SHIFT-P5, CTRL-P5
	DEFB 8BH,8BH,0  	;P4, SHIFT-P4, CTRL-P4
	DEFB 8AH,8AH,0  	;P3, SHIFT-P3, CTRL-P3
	DEFB 89H,89H,0  	;P2, SHIFT-P2, CTRL-P2
	DEFB 88H,88H,0 		;P1, SHIFT-P1, CTRL-P1

;address 38E0H (number & special keys [numeric keypad]):	
	DEFB '8','8',0  	;8 , SHIFT-8 , CTRL-8
	DEFB '9','9',0  	;9 , SHIFT-9 , CTRL-9
	DEFB 0FEH,0FEH,0	;00, SHIFT-00, CTRL-00
	DEFB 0,0,0      	;LOCK
	DEFB ',',',',0  	;, , SHIFT-, , CTRL-,
	DEFB '-','-',0  	;- , SHIFT-- , CTRL--
	DEFB '.','.',0  	;. , SHIFT-. , CTRL-.
	DEFB 0,0FBH,0		;SHIFT-PRINT


*EJECT
;table contains codes for all caps (special WordStar version):
WBOARD:

;address 3801H (letter keys):
	DEFB '@','`',NUL	;@, SHIFT-@, CTRL-@
	DEFB 'a','A',SOH	;A, SHIFT-A, CTRL-A
	DEFB 'b','B',STX	;B, SHIFT-B, CTRL-B
	DEFB 'c','C',ETX	;C, SHIFT-C, CTRL-C
	DEFB 'd','D',EOT	;D, SHIFT-D, CTRL-D
�	DEFB 'e','E',ENQ	;E, SHIFT-E, CTRL-E
	DEFB 'f','F',ACK	;F, SHIFT-F, CTRL-F
	DEFB 'g','G',BEL	;G, SHIFT-G, CTRL-G

;address 3802H (letter keys):
	DEFB 'h','H',BS 	;H, SHIFT-H, CTRL-H
	DEFB 'i','I',HT 	;I, SHIFT-I, CTRL-I
	DEFB 'j','J',LF 	;J, SHIFT-J, CTRL-J
	DEFB 'k','K',VT 	;K, SHIFT-K, CTRL-K
	DEFB 'l','L',FF 	;L, SHIFT-L, CTRL-L
	DEFB 'm','M',CR 	;M, SHIFT-M, CTRL-M
	DEFB 'n','N',SO 	;N, SHIFT-N, CTRL-N
	DEFB 'o','O',SI 	;O, SHIFT-O, CTRL-O

;address 3804H (letter keys):
	DEFB 'p','P',DLE	;P, SHIFT-P, CTRL-P
	DEFB 'q','Q',DC1	;Q, SHIFT-Q, CTRL-Q
	DEFB 'r','R',DC2	;R, SHIFT-R, CTRL-R
	DEFB 's','S',DC3	;S, SHIFT-S, CTRL-S
	DEFB 't','T',DC4	;T, SHIFT-T, CTRL-T
	DEFB 'u','U',NAK	;U, SHIFT-U, CTRL-U
	DEFB 'v','V',SYN	;V, SHIFT-V, CTRL-V
	DEFB 'w','W',ETB	;W, SHIFT-W, CTRL-W

;address 3808H (letter keys):
	DEFB 'x','X',CAN	;X, SHIFT-X, CTRL-X
	DEFB 'y','Y',EM 	;Y, SHIFT-Y, CTRL-Y
	DEFB 'z','Z',SUB	;Z, SHIFT-Z, CTRL-Z
	DEFB '[','{',ESC	;[, SHIFT-[, CTRL-[
	DEFB '\','|',FS 	;\, SHIFT-\, CTRL-\
	DEFB ']','}',GS 	;], SHIFT-], CTRL-]
	DEFB '^','~',RS 	;^, SHIFT-^, CTRL-^
	DEFB '_','^',RS 	;_, SHIFT-_, CTRL-_

;address 3810H (number keys):
	DEFB '0','0',0  	;0, SHIFT-0, CTRL-0
	DEFB '1','!',0  	;1, SHIFT-1, CTRL-1
	DEFB '2','"',0  	;2, SHIFT-2, CTRL-2
	DEFB '3','#',0  	;3, SHIFT-3, CTRL-3
	DEFB '4','$',0  	;4, SHIFT-4, CTRL-4
	DEFB '5','%',0  	;5, SHIFT-5, CTRL-5
	DEFB '6','&',0  	;6, SHIFT-6, CTRL-6
	DEFB '7','''',0 	;7, SHIFT-7, CTRL-7

;address 3820H (number & special keys):
	DEFB '8','(',0  	;8, SHIFT-8, CTRL-8
	DEFB '9',')',0  	;9, SHIFT-9, CTRL-9
	DEFB ':','*',0  	;:, SHIFT-:, CTRL-:
	DEFB ';','+',0  	;;, SHIFT-;, CTRL-;
	DEFB ',','<',0  	;,, SHIFT-,, CTRL-,
	DEFB '-','=',0  	;-, SHIFT--, CTRL--
	DEFB '.','>',0  	;., SHIFT-., CTRL-.
	DEFB '/','?',0 		;/, SHIFT-/, CTRL-/

;address 3840H (special keys):	
	DEFB CR,CR,0    	;NEWLINE   , SHIFT-NEWLINE   , CTRL-NEWLINE
	DEFB 8DH,8EH,DEL	;CLEAR     , SHIFT-CLEAR     , CTRL-CLEAR
				;CLEAR 	     = erase to end of line
				;SHIFT-CLEAR = erase to start of line
				;CTRL -CLEAR = erase previous character
	DEFB NAK,0FDH,0  	;BREAK     , SHIFT-BREAK     , CTRL-BREAK
				;BREAK = abort current operation
	DEFB ENQ,8FH,90H 	;UP-ARROW  , SHIFT-UP-ARROW  , CTRL-UP-ARROW
				;      UP-ARROW = cursor up
				;SHIFT-UP-ARROW = start of text
				;CTRL -UP-ARROW = start of screen
	DEFB CAN,91H,92H 	;DOWN-ARROW, SHIFT-DOWN-ARROW, CTRL-DOWN-ARROW
				;      DOWN-ARROW = cursor down
				;SHIFT-DOWN-ARROW = end of text
				;CTRL -DOWN-ARROW = end of screen
	DEFB DC3,93H,SOH 	;LEFT-ARROW, SHIFT-LEFT-ARROW, CTRL-LEFT-ARROW
				;      LEFT-ARROW = cursor left
				;SHIFT-LEFT-ARROW = start of line
				;CTRL -LEFT-ARROW = word left
	DEFB EOT,94H,ACK  	;RGHT-ARROW, SHIFT-RGHT-ARROW, CTRL-RGHT-ARROW
				;      RIGHT-ARROW = cursor right
				;SHIFT-RIGHT-ARROW = end of line
				;CTRL -RIGHT-ARROW = word right
	DEFB ' ',' ',95H	;SPACE     , SHIFT-SPACE     , CTRL-SPACE
				;CTRL-SPACE = hard space

;address 38A0H (function keys):	
	DEFB SYN,SYN,0  	;F1, SHIFT-F1, CTRL-F1
				;F1 = toggle insert mode
	DEFB SO,SO,0    	;F2, SHIFT-F2, CTRL-F2
				;F2 = insert line
	DEFB BEL,BEL,0  	;F3, SHIFT-F3, CTRL-F3
				;F3 = delete character
	DEFB DC4,DC4,0  	;F4, SHIFT-F4, CTRL-F4
				;F4 = delete word
	DEFB EM,EM,0   		;F5, SHIFT-F5, CTRL-F5
				;F5 = delete line
	DEFB STX,STX,0  	;F6, SHIFT-F6, CTRL-F6
				;F6 = reformat paragraph
	DEFB 96H,96H,0  	;F7, SHIFT-F7, CTRL-F7
				;F7 = toggle hyphen help
	DEFB 97H,97H,0  	;F8, SHIFT-F8, CTRL-F8
				;F8 = toggle right justifying

;address 38C0H (number keys [numeric keypad]):	
	DEFB '0','0',0  	;1, SHIFT-1, CTRL-1
	DEFB '1','1',0  	;2, SHIFT-2, CTRL-2
	DEFB '2','3',0  	;3, SHIFT-3, CTRL-3
	DEFB '3','3',0  	;4, SHIFT-4, CTRL-4
	DEFB '4','4',0  	;5, SHIFT-5, CTRL-5
	DEFB '5','5',0  	;6, SHIFT-6, CTRL-6
	DEFB '6','6',0  	;7, SHIFT-7, CTRL-7
	DEFB '7','7',0 		;8, SHIFT-8, CTRL-8

;address 3880H (function keys & escape key):
	DEFB 0,0,0      	;SHIFT
	DEFB 0,0,0      	;CTRL
	DEFB ESC,ESC,0  	;ESC
	DEFB ETX,ETX,0 		;P5, SHIFT-P5, CTRL-P5
				;P5 = page down
	DEFB DC2,DC2,0  	;P4, SHIFT-P4, CTRL-P4
				;P4 = page up	
	DEFB SUB,SUB,0  	;P3, SHIFT-P3, CTRL-P3
				;P3 = line down
	DEFB ETB,ETB,0  	;P2, SHIFT-P2, CTRL-P2
				;P2 = line up
	DEFB HT,HT,0    	;P1, SHIFT-P1, CTRL-P1
				;P1 = TAB

;address 38E0H (number & special keys [numeric keypad]):	
	DEFB '8','8',0  	;8 , SHIFT-8 , CTRL-8
	DEFB '9','9',0  	;9 , SHIFT-9 , CTRL-9
	DEFB 0FEH,0FEH,0	;00, SHIFT-00, CTRL-00
	DEFB 0,0,0      	;LOCK
	DEFB ',',',',0  	;, , SHIFT-, , CTRL-,
	DEFB '-','-',0  	;- , SHIFT-- , CTRL--
	DEFB '.','.',0  	;. , SHIFT-. , CTRL-.
	DEFB 0,0FBH,0		;SHIFT-PRINT


*EJECT
VECTOR:	DEFW FKEYS 		;function key vector

OFFSET  DEFL 0			;initialize offset

FKEYS:	REPT 13			;function key pointer
	DEFW F0+OFFSET
OFFSET	DEFL OFFSET+81
	ENDM
	DEFW ERAEND,ERABEG,SOTXT,SOCRT,EOTXT,EOCRT
	DEFW SOLIN,EOLIN,HSPACE,HYPHEN,JSTIFY

F0:
;	.XLIST
   	REPT 13			;function key buffer
	DEFB 1
	REPT 80
	DEFB 0
	ENDM
	ENDM
	.LIST

;special WordStar part:
ERAEND:	DEFB 2			;erase to end of line
	DEFB DC1,'Y',0
ERABEG:	DEFB 2			;erase to start of line
	DEFB DC1,DEL,0
SOTXT:	DEFB 2			;start of text
	DEFB DC1,'R',0
SOCRT:	DEFB 2			;start of screen
	DEFB DC1,'E',0
EOTXT:	DEFB 2			;end of text
	DEFB DC1,'C',0
EOCRT:	DEFB 2			;end of screen
	DEFB DC1,'X',0
SOLIN:	DEFB 2			;start of line
	DEFB DC1,'S',0
EOLIN:	DEFB 2			;end of line
	DEFB DC1,'D',0
HSPACE:	DEFB 2			;hard space
	DEFB DLE,'O',0
HYPHEN:	DEFB 2			;toggle hyphen help
	DEFB SI,'H',0
JSTIFY:	DEFB 2			;toggle right justifying
	DEFB SI,'J',0
		

*EJECT
;table of control codes:
;  first byte = 0    	single ASCII control code
;  first byte = 0FFH	escape sequence

TAB1S:	DEFB 0,BEL		;beep
	DEFB 0,BS		;cursor left
	DEFB 0,LF		;cursor down
	DEFB 0,VT		;cursor up
	DEFB 0,FF		;cursor right
	DEFB 0,CR		;carriage return
	DEFB 0,RS		;home cursor
TAB2S:	DEFB 0FFH,'='		;absolute cursor addressing

	DEFB 0FFH,'F'		;select window
	DEFB 0FFH,'I'		;set top line
	DEFB 0FFH,'J'		;set bottom line
	DEFB 0FFH,'K'		;set left column
	DEFB 0FFH,'L'		;set right column

TAB2E:	DEFB 0FFH,' '		;set erase character
	DEFB 0FFH,FF		;cursor off
	DEFB 0FFH,CR		;cursor on
	DEFB 0FFH,'A'		;ASCII character set
	DEFB 0FFH,'D'		;disable status line
	DEFB 0FFH,'E'		;enable status line
	DEFB 0FFH,'G'		;German character set
	DEFB 0FFH,'N'		;normal keyboard
	DEFB 0FFH,'O'		;WordStar keyboard			
	DEFB 0FFH,'R'		;inverse display mode
	DEFB 0FFH,'S'		;normal display mode
	DEFB 0FFH,'X'		;turn on wrap around mode
	DEFB 0FFH,'Y'		;turn off wrap around mode

	DEFB 0FFH,'P'		;insert character
	DEFB 0FFH,'V'		;insert line
	DEFB 0FFH,'Q'		;delete char
	DEFB 0,CAN		;erase to end of line
	DEFB 0FFH,'W'		;delete line
	DEFB 0,EM		;erase to end of screen
TAB1E:	DEFB 0,SUB		;clear screen	


*EJECT
	INCLUDE FONT12		;font set

;drive control tables (5 inch):

;drive 0:
DCT:    DEFB 01110000B          ;bit 7   : reserved
                                ;bit 6   : no. of         0 = single sided
                                ;          surfaces       1 = double sided
                                ;bit 5   : density        0 = single density
                                ;                         1 = double density
                                ;bit 4   : desity of      0 = single density
                                ;          first track    1 = double density
                                ;bit 3   : no. of first   0 = zero
                                ;          sec. on track  1 = one
                                ;bit 2   : steps per      0 = one step
                                ;          trk to trk     1 = two steps
                                ;bits 1,0: track stepping rate
                                ;          0 =  3 msec    1 =  6 msec
                                ;          2 = 10 msec    3 = 15 msec
        DEFB 10000000B          ;bits 7,6: sector length
                                ;          0 = 128 bytes  1 =  256 bytes
                                ;          2 = 512 bytes  3 = 1024 bytes
                                ;bit 5   : 0 = new sector numbering on backside
                                ;          1 = sector numbering continued on
                                ;              backside
                                ;bit 0   : drive status (used by disk driver --
                                ;                        do not alter)
        DEFB 2                  ;interleaving factor
        DEFB 20                 ;sector count per track
        DEFB 80                 ;number of usable tracks
        DEFB 0                  ;current track

;drive 1:
        DEFB 01110000B
        DEFB 10000000B
        DEFB 2
        DEFB 20
        DEFB 80
        DEFB 0

;drive 2:
        DEFB 01110000B,10000000B,2,20,80,0

;drive 3:
        DEFB 01110000B,10000000B,2,20,80,0


;drive control tables (8 inch):

;drive 0:
;Megabyte 8:
        
        DEFB 01110000B
        DEFB 11000000B
        DEFB 3
        DEFB 18
        DEFB 80
        DEFB 0

;drive 1:
        DEFB 01110000B,11000000B,3,18,80,0

;drive 2:
        DEFB 01110000B,11000000B,3,18,80,0

;drive 3:
        DEFB 01110000B,11000000B,3,18,80,0


TRYS:   DEFB 10                 ;# of times to try I/O until routine gives up


*EJECT
;Winchester disk control tables:

;drive 0:
DCTW:   DEFB 01100000B          ;bits 7-5: no. of surfaces
                                ;          0 = one   head    4 = five  heads
                                ;          1 = two   heads   5 = six   heads
                                ;          2 = three heads   6 = seven heads
                                ;          3 = four  heads   7 = eight heads
                                ;bit 4   : no. of first      0 = zero
                                ;          sector on track   1 = one
                                ;bits 3-0: track stepping rate
                                ;0 = 35  usec    6 = 3.0 msec   11 = 5.5 msec
                                ;1 = 0.5 msec    7 = 3.5 msec   12 = 6.0 msec
				;2 = 1.0 msec    8 = 4.0 msec   13 = 6.5 msec
				;3 = 1.5 msec    9 = 4.5 msec   14 = 7.0 msec
				;4 = 2.0 msec   10 = 5.0 msec   15 = 7.5 msec
				;5 = 2.5 msec
        DEFB 10000000B          ;bits 7,6: sector length
                                ;          0 =  256 bytes  1 = 512 bytes
                                ;          2 = 1024 bytes  3 = 128 bytes
                                ;bit 0   : drive status (used by disk driver --
                               ;                        do not alter)
	DEFB 32   		;starting track for write precomp / 4
        DEFB 1                  ;interleaving factor
        DEFB 9                  ;sector count per track
        DEFW 1440               ;number of usable tracks

;drive 1:
        DEFB 00100000B
        DEFB 10000000B
        DEFB 0FFH
        DEFB 1 
        DEFB 9
        DEFW 612

;drive 2:
        DEFB 00100000B,01000000B,0,1,16
        DEFW 1224
;-------------------------------------------:

*EJECT
;powerup/reset parameters:

;powerup/reset marker:
POWUP:	DEFS 1

;table of video parameters:
VIDPAR: DEFB 110 		;horizontal total
	DEFB 80			;horizontal displayed
	DEFB 8  		;h sync position
	DEFB 25			;h sync width
	DEFB 29			;vertical total
	DEFB 1			;v total adjust
	DEFB 25  		;vertical displayed
	DEFB 26			;v sync position
	DEFB 1			;interlace mode (non interlace)
	DEFB 10   		;max scan line address
	DEFB 6CH		;cursor start
	DEFB 10			;cursor end
	DEFB 0  		;start address (H)
	DEFB 0			;start address (L)
	DEFB 0			;cursor (H)
   	DEFB 0			;cursor (L)

;character set:
CHRSET:	DEFB 'G'		;'A' = ASCII  character set
				;'G' = German character set

;RS-232-C parameters:
SER0:	DEFB 11000100B
	DEFB 8

SER1:	DEFB 11000100B
	DEFB 8

;clock ?
CLOCK:	DEFB 1			;0 = software clock
				;1 = hardware clock 


*EJECT
;*******************
;*  $ V D I N I T  *
;*******************

;entry: HL = address of video parameter table

;  struct {
;	    char R0, R1, R2 , R3 , R4 , R5 , R6 , R7 ,
;		 R8, R9, R10, R11, R12, R13, R14, R15;
;	  } *HL;

;  R0  = This 8 bit write-only register determines the horizontal frequency of
;	 HS. It is the total of displayed plus non-displayed character time
;	 units minus one.
;  R1  = This 8 bit write-only register determines the number of displayed 
;	 characters per horizontal line.
;  R2  = This 8 bit write-only register determines the horizontal sync position
;	 on the horizontal line.
;  R3  = This 4 bit write-only register determines the width of the HS pulse.
;	 It may not be apparent why this width needs to be programmed. However,
;	 consider that all timing widths must be programmed as multiples of the
;	 character clock period which varies. If HS width were fixed as an
;	 integral number of character times, it would vary with character rate
;	 and be out of tolerance for certain monitors. The rate programmable
;	 feature allows compensating HS width.
;  R4
;  R5  = The vertical frequency of VS is determined by both R4 and R5. The
;	 calculated number of character line times is usually an integer plus a
;	 fraction to get exactly a 50 or 60 Hz vertical refresh rate. The
;	 integer number of character line times minus one is programmed in the
;	 7 bit write-only Vertical Total Register (R4); the fraction is
;	 programmed in the 5 bit write-only Vertical Scan Adjust Register (R5)
;	 as a number of scan line times.
;  R6  = This 7 bit write-only register determines the number of displayed
;	 character rows on the CRT screen, and is programmed in character row
;	 times.
;  R7  = This 7 bit write-only register determines the vertical sync position
;	 with respect to the reference. It is programmed in character row
;	 times.
;  R8  = This 2 bit write-only register controls the raster scan mode. When bit
;	 0 and bit 1 are reset, or bit 0 is reset and bit 1 set, the non-
;	 interlace raster scan mode is selected. Two interlace modes are
;	 available. Both are interlaced 2 fields per frame. When bit 0 is set
;	 and bit 1 is reset, the interlace sync raster scan mode is selected.
;	 Also when bit 0 and bit 1 are set, the interlace sync and video raster
;	 scan mode is selected.
;  R9  = This 5 bit write-only register determines the number of scan lines per
;	 character row including spacing. The programmed value is a max address
;	 and is one less than the number of scan lines.
;  R10 = This 7 bit write-only register controls the cursor format. Bit 5 is
;	 the blink timing control. When bit 5 is low, the blink frequency is
;	 1/16 of the vertical field rate, and when bit 5 is high, the blink
;	 frequency is 1/32 of the vertical field rate. Bit 6 is used to enable
;	 a blink. The cursor start scan line is set by the lower 5 bits.
;  R11 = This 5 bit write-only register sets the cursor end scan line.
;  R12
;  R13 = Start Address Register is a 14 bit write-only register which
;	 determines the first address put out as a refresh address after
;	 vertical blanking. It consists of an 8 bit lower register (R13), and a
;	 6 bit higher register (R12).
;  R14
;  R15 = This 14 read/write register stores the cursor location. This register
; 	 consists of an 8 bit lower (R15) and 6 bit higher (R14) register.
 
$CRTREG EQU  0F6H		;CRT controller address register
$CRTCMD EQU  0F7H		;CRTC command register

;initialize the video controller chip � 6845:
$VDINIT:LD   A,10H		;source      bank = 1
				;destination bank = 0
VDINIT1:LD   DE,$VIDPAR		;^temp buffer 		   --> reg. DE
	LD   B,16		;length of parameter table --> reg. B
	CALL $XMOVE		;get video parameter table
        LD   BC,1000H		;CRTC register count       --> reg.  B
				;CRTC start register       --> reg.  C
	LD   HL,$VIDPAR		;^video parameter table    --> reg. HL
OUTCMD:	LD   A,C		;CRTC register no.         --> accu
       	OUT  ($CRTREG),A	;select CRTC register
	LD   A,(HL)		;video parameter --> accu
	OUT  ($CRTCMD),A	;output CRTC command
	INC  HL			;bump ^video parameter
	INC  C			;increment CRTC register no.
	DJNZ OUTCMD		;output 16 parameters
	LD   A,($VIDPAR+10)	;get control byte for cursor start
	LD   (CURBEG),A		;store it for subsequent use
	RET  			;return to caller

CURBEG:	DEFS 1			;temporary storage for cursor start byte
$VIDPAR:DEFS 16     		;temporary buffer for video parameter table


*EJECT
;*******************
;*  $ R S I N I T  *
;*******************

;entry: B = number  of RS232C interface (0, 1)
;	A = data format
;	E = baud rate

;  A
;  Bit    0: 0 = no   parity
;	     1 =      parity
;  Bit    1: 0 = odd  parity
;	     1 = even parity
;  Bits 3-2: 1 = 1   stop bit
;	     2 = 1.5 stop bits
;            3 = 2   stop bits
;  Bits 7-6: 0 = 5 bits word length
;	     1 = 7 bits word length
;	     2 = 6 bits word length
;	     3 = 8 bits word length

;  	    Desired Baud Rate  | reg. E
;	  =====================|=======
;          	 50	       |   2
;          	 75	       |   3
;	      	110	       |  15
;	  	134.5	       |   4
;	  	150	       |  14
;		200	       |   5
;	  	300	       |  13
;	  	600	       |   6
;	       1200	       |  11
;	       1800	       |  10
;	       2400	       |   7
;	       4800	       |   9
;	       9600	       |   8
;	      19200	       |   0


RATE	EQU  0F1H		;baud rate register
BTx  	EQU  0F2H		;dual baud rate register

;calc initialization routine entry:
$RSINIT:LD   HL,RSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine
	 
;RS232C initialization driver entry routine:
RSTAB:	DEFW RSINIA,RSINIB	

;control register of SIO A:
WR0A	EQU  0D2H

RSINIA: LD   C,A		;save data format
        AND  0C0H		;mask word length bits
	SET  0,A     		;receiver enable
	LD   (WR3A),A		;load write register 3
        LD   A,C   		;restore data format
	AND  0FH		;mask stop bits and parity
        SET  6,A		;x 16 clock mode
	LD   (WR4A),A		;load write register 4
	LD   A,C		;restore data format
	RRA
	AND  60H		;mask word length bits
	OR   88H   		;set DTR, transmitter enable
	LD   (WR5A),A		;load write register 5
	LD   A,B		;relative port number --> accu
	OR   A
	IN   A,(RATE)		;read baud rates
	AND  0F0H		;mask baud rate of channel A
	LD   HL,INITBLA
	JR   RSINIB1

INITBLA:DEFB 1
	DEFB BTx
	DEFB 0
	DEFB 9
        DEFB WR0A
	DEFB 18H		;channel reset
	DEFB 1
	DEFB 0			;disable interrupts
	DEFB 4
WR4A:	DEFS 1
	DEFB 5
WR5A:	DEFS 1
	DEFB 3
WR3A:	DEFS 1
	DEFB 0


*EJECT
;control register of SIO B:
WR0B	EQU  0D3H

RSINIB: LD   C,A		;save data format
        AND  0C0H		;mask word length bits
	SET  0,A     		;receiver enable
	LD   (WR3B),A		;load write register 3
        LD   A,C   		;restore data format
	AND  0FH		;mask stop bits and parity
        SET  6,A		;x 16 clock mode
	LD   (WR4B),A		;load write register 4
	LD   A,C		;restore data format
	RRA
	AND  60H		;mask word length bits
	OR   88H   		;set DTR, transmitter enable
	LD   (WR5B),A		;load write register 5
	LD   A,B		;relative port number --> accu
	OR   A
	IN   A,(RATE)		;read baud rates
	AND  0FH		;mask baud rate of channel B
	SLA  E			;shift baud rate code into upper nibble
	SLA  E
	SLA  E
	SLA  E
	LD   HL,INITBLB
RSINIB1:OR   E			;set baud rate
	OUT  (RATE),A		;output baud rate
RSINIB2:LD   A,(HL)
	OR   A			;end of table ?
	RET  Z			;return if yes
	LD   B,A		;byte count  --> reg. B
	INC  HL			;bump table pointer
	LD   C,(HL)		;port number --> reg. C
	INC  HL			;bump table pointer
	OTIR			;output bytes
	JR   RSINIB2		;output next byte stream

INITBLB:DEFB 1
	DEFB BTx
	DEFB 0
	DEFB 9
        DEFB WR0B
	DEFB 18H		;channel reset
	DEFB 1
	DEFB 0			;disable interrupts
	DEFB 4
WR4B:	DEFS 1
	DEFB 5
WR5B:	DEFS 1
	DEFB 3
WR3B:	DEFS 1
	DEFB 0

								
*EJECT
;*******************
;*  $ K B C H A R  *  
;*******************

;exit: A = char (0 = no char available)

$SYS0	EQU  0F9H		;bank select port 0
$SYS1	EQU  0FAH		;bank select port 1

;get a keyboard character if available:
$KBCHAR:LD   A,(RDYKEY)		;active key ?
	OR   A
	RET  NZ        		;return if yes
	DI			;disable the interrupts
	LD   A,(KLEN)		;A = buffer length
	OR   A			;jump if
	JR   Z,KBCHAR2		;buffer empty
	DEC  A			;dec the length
	LD   (KLEN),A		;save it
	LD   HL,(CPTR)		;HL = character pointer
	LD   A,(HL)		;A = key value
	LD   (RDYKEY),A		;store it
	INC  HL			;bump pointer
	LD   DE,KBUF+80		;DE = end of bufferr pointer
	EX   DE,HL		;swap the pointers
	SBC  HL,DE		;wrap around the buffer ?
	EX   DE,HL		;swap the pointers
	JR   NZ,KBCHAR1		;jump if no wrap around
	LD   HL,KBUF		;HL = new pointer
KBCHAR1:LD   (CPTR),HL		;save the pointer
KBCHAR2:EI			;reenable interrupts
	RET			;return

KLEN:	DEFB 0			;number of active keys
EPTR:	DEFW KBUF		;pointer to next free location
CPTR:	DEFW KBUF		;pointer to first active key
KBUF:	DEFS 80			;type ahead buffer

*EJECT
;this area makes the preliminary check of keyboard rows:
$SCAN:  IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11000110B		;enable memory mapped I/O
				;disable graphic page
				;enable keyboard
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	CALL SCAN		;scan keyboard
	LD   C,A		;code of scanned key --> reg. C
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A		;write it
	RET			;return to interrupt service routine
	
SCAN:	LD   HL,KEYHLD		;HL = keyboard work area ptr
	LD   IX,KEYBRD		;IX = row address table ptr
	LD   BC,38E0H		;BC = row A10 ptr
	LD   D,10 		; E = column index
	LD   A,(BC)		;load row 10
	AND  0F7H		;mask out LOCK key
	LD   E,A		;8 column bits
	XOR  (HL)               ;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E        		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row 10
	DEC  D			;decrement row index
       	INC  HL			;eleven byte buffer indexed by row
        LD   C,(IX)		;row address (LSB) --> reg. C
	LD   A,(BC)		;load row 9
	AND  0FCH		;mask out SHIFT + CTRL keys
	LD   E,A		;8 column bits
	XOR  (HL)               ;XOR with previous
	LD   (HL),E		;store column bits in buffer
	AND  E        		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row 9
     	INC  IX			;increment ^row address table
	DEC  D			;decrement row index
CHKKEY:	INC  HL			;ten byte buffer indexed by row
        LD   C,(IX)		;row address (LSB) --> reg. C
	LD   A,(BC)		;load row N
	LD   E,A		;8 column bits
	XOR  (HL)		;XOR with previous
	LD   (HL),E   		;store column bits in buffer
	AND  E     		;then test for active row
	JR   NZ,ACTIVE		;go if key active in row N
     	INC  IX			;increment ^row address table
	DEC  D			;decrement row index
	JP   P,CHKKEY		;try next row

;check for previous key:
	PUSH AF			;save column bits
       	LD   HL,(OLDROW)	;^previous row   --> reg. HL
        LD   A,(OLCLMN)		;old column bits --> accu
        AND  (HL)               ;previous key active ?
	JR   NZ,PREV    	;jump to wait/repeat procedure if yes
	XOR  A			;clear repeat mode
	LD   (REPEAT),A
	LD   H,A
	LD   L,A
        LD   (COUNT1),HL        ;reset first counter
	LD   HL,(DELAY3)        ;preset second counter
	LD   (COUNT2),HL
	POP  AF      		;restore column bits
	RET   			;no key depression - return

;delay routine until key autorepeats:
PREV:	PUSH AF                 ;save previous column bits
	PUSH HL                 ;save previous row
	LD   HL,(COUNT1)        ;increment first counter
	INC  HL
   	LD   (COUNT1),HL
	LD   DE,(COUNT2)        ;and compare it with second counter
	LD   A,H
        CP   D
	JR   NZ,REST  
	LD   A,L
	CP   E
REST:  	POP  HL			;restore previous row
	JR   NZ,RTN		;return if first counter <> second counter
	POP  AF			;restore previous column bits
	CPL			;clear previous row
	AND  (HL)
	LD   (HL),A
	LD   A,1		;set repeat mode
	LD   (REPEAT),A		
	LD   HL,0		;clear first counter
	LD   (COUNT1),HL
	LD   HL,(DELAY4)	;initialize second counter
	LD   (COUNT2),HL	
	POP  AF			;adjust stack pointer
	JR   SCAN		;scan keyboard again
RTN:	POP  AF			;restore column bits
	POP  AF
	RET			;no key active - return
	
;fist debounce routine:
ACTIVE:	LD   E,A		;save column bits
	PUSH BC			;save active row address
	LD   BC,(DELAY1)	;delay count value
	CALL DELAY		;delay for 7.33 milliseconds (may be varied)
	POP  BC			;restore row address
	LD   A,(BC)		;and reload original flags from active row
	AND  E			;then combine current flag bits with original
				;flag bits
	RET  Z			;rtn to caller if zero because row was not
				;active on 2nd test
	LD   (OLDROW),HL	;save row

;calculate ordinal number of pressed key:
	LD   A,D		;otherwise we have a legimately active row
	RLCA			;row index * 2
	RLCA			;row index * 4
	RLCA			;row index * 8
	LD   D,A		;save in D
	LD   C,1		;start with bit 0
AGAIN:	LD   A,C		;mask
	AND  E			;test for non-zero column
	JR   NZ,FOUND		;go if found
	INC  D			;bump column number
	RLC  C			;align mask
	JR   AGAIN		;try again
FOUND:	LD   A,C      		;column bits --> accu
	LD   (OLCLMN),A		;store them
	LD   E,D		; row * 8 + column (0 - 7)  --> reg. DE
	LD   D,0
	LD   H,D		; row * 8 + column (0 - 7)  --> reg. HL
	LD   L,E
	ADD  HL,HL		;(row * 8 + column (0 - 7)) * 2
 	ADD  HL,DE		;(row * 8 + column (0 - 7)) * 3
		
;get ASCII code of pressed key:
	LD   BC,(KEYTAB)	;^table of ASCII codes --> reg. BC
	ADD  HL,BC              ;calculate ^ASCII code of pressed key
	LD   A,(3880H)          ;load SHIFT bit
	BIT  0,A		;SHIFT ?
	JR   Z,CTRL             ;jump if not
	INC  HL 		;adjust table pointer
	JR   LOCK
CTRL:	BIT  1,A		;CTRL ?
	JR   Z,LOCK		;jump if not
	INC  HL			;adjust table pointer
	INC  HL
	LD   A,(HL)		;get ASCII code
	JR   DBOUNCE

;check if caps lock:
LOCK:   LD   A,(38E0H)          ;load LOCK bit
	BIT  3,A		;LOCK ?
	JR   Z,UMLAUT           ;jump if not
	LD   A,(HL)    		;restore char
	CP   'a'		;is it a letter ?
	JR   C,DBOUNCE          ;jump if not
	LD   A,(GERMAN)		;German character set ?
	OR   A
	LD   A,(HL)		;restore char
	JR   Z,UCAPS		;jump if US-ASCII
	CP   DEL
	JR   NC,DBOUNCE		;adjust to lower case
	JR   UCASE
UCAPS:  CP   '{'  		;adjust to lower case
	JR   NC,DBOUNCE
UCASE:	AND  5FH                ;force upper case
	JR   DBOUNCE

;check if German character set:
UMLAUT:	LD   A,(GERMAN)		;German character set ?
	OR   A
	LD   A,(HL)		;restore char
	JR   Z,DBOUNCE		;jump if US-ASCII
        LD   A,(3880H) 		;load SHIFT bit
	BIT  0,A      		;SHIFT ?
        LD   A,(HL)   		;restore char
	JR   NZ,SHIFT     	;jump if SHIFT
	CP   '['    		;"Umlaut" ?
      	JR   C,DBOUNCE		;jump if not
	CP   '_'
	JR   NC,DBOUNCE
        JR   FILTER
SHIFT:  CP   '{'   		;"Umlaut" ?
	JR   C,DBOUNCE          ;jump if not
	CP   DEL
	JR   NC,DBOUNCE
FILTER: XOR  20H		;change to upper/lower case

;second debounce routine:
DBOUNCE:LD   D,A      		;save character
	LD   A,(REPEAT)		;auto repeat ?
	OR   A
	JR   NZ,NBOUNCE		;no debounce if repeat mode
	LD   BC,(DELAY2)        ;load delay count
	CALL DELAY 		;delay
NBOUNCE:LD   A,D       		;A = ASCII - like character
	RET			;return

KEYBRD:	DEFB 80H,0C0H,0A0H,40H,20H,10H,08H,04H,02H,01H
GERMAN: DEFB 0    		;switch bit to alter character set
				;(0 = US-ASCII, FF = German)
KEYHLD:	DEFB 0,0,0,0,0,0        ;keyboard work area
	DEFB 0,0,0,0,0
COUNT1: DEFW 0     		;delay counters for auto repeat function
COUNT2: DEFW 0     
OLDROW: DEFW 0     		;temporary memory for keyboard driver
OLCLMN: DEFB 0     
RDYKEY:	DEFB 0			;key code memory
REPEAT:	DEFB 0			;repeat mode


*EJECT
;*******************
;*  $ K B W A I T  *
;*******************

;exit: A = char

;wait for a keyboard character:

;scan for special function key:
$KBWAIT:LD   A,(COUNT3)		;letter counter --> accu
	OR   A			;test it
	JR   Z,DZERO		;jump if counter empty
	DEC  A			;decrement counter
	LD   (COUNT3),A		;store it
	LD   HL,(FPTR)		;load letter pointer
	LD   A,(HL)  		;load next letter
	INC  HL			;bump letter pointer
	LD   (FPTR),HL		;store it
	LD   C,A		;save active key
	LD   A,(HL)		;get next key
	LD   (RDYKEY),A		;store that sucker
	LD   A,C		;restore active key
	JP   TSTKEY+2

;scan for special key "00":
DZERO:  LD   HL,RDYKEY		;^scanned key --> reg. HL
	LD   A,(HL)		; scanned key --> accu
	CP   0FBH		;is it PRINT ?
	JR   Z,PRINT		;jump if yes
	CP   0FCH		;is it SHIFT - CLEAR ?
	JR   Z,ERASE		;jump if yes
	CP   0FDH		;is it SHIFT - BREAK ?
	JR   Z,GERSET		;jump if yes
	CP   0FEH		;is it "00" ?
	JR   C,FKEY  		;jump if not
	INC  A			;bump "00"-counter
	LD   (HL),A		;store "00"-counter
	LD   A,'0'		;return one zero
	RET			;return to caller
PRINT:	PUSH HL			;save reg. HL
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
      	LD   HL,$SCREEN		;address of first screen location --> reg. HL
	LD   IX,(VDTABP)	;^current parameter table	  --> reg. IX
	LD   A,(IX)		;line count of screen		  --> reg. D
	LD   D,A
PRINT1:	LD   A,(IX+1)		;column count of screen		  --> reg. B
	LD   B,A
PRINT2:	LD   A,(HL)		;screen character 		  --> accu
	AND  7FH		;mask it
	INC  HL			;bump screen pointer
 	CALL PRCHR0		;output character to printer 0
	DJNZ PRINT2		;repeat "column count" times
	LD   A,CR		;output a carriage return
	CALL PRCHR0
	LD   A,LF		;output a line feed
	CALL PRCHR0
	DEC  D			;decrement line counter
	JR   NZ,PRINT1		;print next line	
	POP  HL			;restore reg. HL
	JR   GERSE3		;go on
ERASE:	LD   A,SUB
	PUSH HL
	CALL $VDCHAR		;clear screen
	POP  HL
	JR   GERSE3		;go on
GERSET:	PUSH HL
	LD   A,ESC
	CALL $VDCHAR
       	LD   A,(GERMAN)		;load switch bit for changing char set
	CPL			;invert it
	LD   (GERMAN),A		;store it
	OR   A
	JR   Z,GERSE1
	LD   A,'G'		;load German character set
	JR   GERSE2
GERSE1:	LD   A,'A'		;load ASCII character set
GERSE2:	CALL $VDCHAR
	POP  HL
GERSE3:	XOR  A			;clear key code	
	JR   TSTKEY

;test if function key:
FKEY:	BIT  7,A		;check if code >= 80H
	JR   Z,TSTKEY		;jump if not 	 
	PUSH HL			;save ^key memory
	LD   C,A		;save key code
	LD   E,A
	LD   HL,VECTOR		;^function key vector --> reg. HL
	LD   A,(HL)		;function key vector = 0 ?
	LD   D,A		;save LSB of key vector
	INC  HL
	OR   (HL)
	JR   Z,FKEYEND		;jump if no special function
	LD   H,(HL)		;function key vector --> reg. HL
	LD   L,D
	LD   D,0
	SLA  E			;most significant 7 bits of code * 2
	ADD  HL,DE		;calculate vector address
	LD   A,(HL)		;no special function ?
	LD   E,A
	INC  HL
	LD   D,(HL)
	OR   D
	JR   Z,FKEYEND
	LD   A,(DE)		;vector --> accu
	LD   (COUNT3),A		;load counter
	INC  DE
	LD   (FPTR),DE		;load address of first function key character
	POP  HL			;adjust stack pointer
	JP   $KBWAIT
FKEYEND:LD   A,C		;restore original key code	
	POP  HL			;restore ^key memory

;test key memory if legal code:
TSTKEY: LD   (HL),0		;clear key memory
	OR   A			;legal key code ?
	RET  NZ       		;return to caller

;scan keyboard:
        CALL $KBCHAR		;scan keyboard
	JP   $KBWAIT		;test if active key

COUNT3:	DEFB 0     		;letter counter for function keys
FPTR:	DEFW 0     		;letter pointer for function keys


*EJECT
;*******************
;*  $ V D C H A R  *
;*******************

;entry: A = char

$BUZZ	EQU  3860H		;buzzer address
$SCREEN EQU  3800H		;address of first screen location

;character output routine:
$VDCHAR:LD   C,A		;save character
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	LD   A,C		;restore character

        LD   IX,(VDTABP)	;^^screen constants --> reg. IX
	LD   HL,ESCAPE 		;test if escape sequence
	BIT  2,(HL)		
	JR   NZ,ESCSQ2		;cursor addressing routine
	BIT  1,(HL)
	JR   NZ,ESCSQ1		;handle second byte of escape sequence
	BIT  0,(HL)
	JR   NZ,ESCSEQ		;handle first byte of escape sequence
	CP   ESC		;char = ESC ?
	JR   NZ,NORMAL 		;jump if normal ASCII char
	SET  0,(HL)		;remark escape sequence
	RET

;handling of single byte ASCII's:
NORMAL: CP   20H		;control char ?
	JR   C,CNTRL 
	LD   L,A		;save char
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	LD   A,L		;restore char	
        OR   A			;ASCII code > 80H ?
	JP   P,NORMAL1		;jump if not
	CP   0A0H		;ASCII code > 0A0H ?
	JR   NC,NORMAL1		;jump if yes
	SUB  80H		;convert code if special char
NORMAL1:OR   (IX+11)		;put invert mask over character
	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   (HL),A		;output char
	JP   CURRGT		;output cursor

;handling of control codes: 
CNTRL:	OR   A			;control code = 0 ?
	RET  Z
      	LD   HL,TAB1E+1		;^end of control code table --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length               --> reg. BC
CAGAIN:	CPDR			;search char
	RET  NZ			;return to caller if not found
	INC  (HL)		;escape sequence ?
	DEC  (HL)
	JR   NZ,CAGAIN		;search next char
	JR   ESCEND

;first entry into escape sequence:
ESCSEQ:	RES  0,(HL)		;reset escape bit
	LD   HL,TAB1E+1		;^end of ESC-sequence-table-1 --> reg. HL
	LD   BC,TAB1E-TAB1S+2	;table length                 --> reg. BC
EAGAIN:	CPDR          		;search char
	RET  NZ			;return to caller if not found
	INC  (HL)		;escape sequence ?
	DEC  (HL)
	JR   Z,EAGAIN		;search next char
ESCEND:	LD   HL,CTRLJP		;jump vector --> reg. HL
        DEC  BC			;calc jump address
	ADD  HL,BC
	LD   C,(HL)		;jump address --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute function

;second entry into escape sequence:
ESCSQ1: RES  1,(HL)		;reset second escape bit
	SUB  20H		;adjust line/column no.
	LD   D,A		;save it
	LD   A,(ESCCHR)		;load first byte of escape sequence
	LD   HL,TAB2E+1		;^end of ESC-sequence-table-2 --> reg. HL
	LD   BC,TAB2E-TAB2S+2	;table length                 --> reg. BC
	CPDR			;search char
	LD   HL,ESCJP 		;^jump vector
	LD   A,D		;restore line/column no.
	JR   ESCEND+3

;third entry into escape sequence:
ESCSQ2: RES  2,(HL)		;reset third escape bit
	SUB  20H		;adjust column no.
	CP   (IX+7)		;legal column no. ?
	RET  NC			;return if not
	ADD  A,(IX+3)		;add left column
	LD   (IX+9),A		;store new column no.
	LD   A,(LINE)  		;fetch new line no.
	ADD  A,(IX+2)		;add top line
	LD   (IX+8),A		;store it
	CALL OUTCUR		;output cursor
	JP   CURON+4		;turn on cursor

;handle first byte of two or three byte escape sequence:
ESC1ST: LD   (ESCCHR),A		;store first byte of escape sequence
	LD   HL,ESCAPE
	SET  1,(HL)		;remark it
	RET

;handle second byte of three byte escape sequence:
ESC2ND: CP   (IX+6)		;legal line no. ?
	RET  NC			;return if not
	LD   (LINE),A  		;save new line
	LD   HL,ESCAPE
	SET  2,(HL)		;remark cursor addressing sequence
	RET

;beep:
BEEP:   IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11000110B		;enable memory mapped I/O
				;disable graphic page
				;enable buzzer
	OUT  ($SYS1),A		;write system byte 1

     	LD   BC,0     		;repeat counter --> reg. B
				;  wait counter --> reg. C
	DI			;force clean tone
BEEP1:	LD   A,($BUZZ)		;turn on buzzer
	PUSH BC			;save base value of wait counter
BUZZON: NOP			;little delay for lower frequency
	NOP
	NOP
	DEC  C			;decrement wait counter
	JR   NZ,BUZZON		;wait `til end of buzz
	POP  BC			;restore wait counter
	DJNZ BEEP1 		;turn on buzzer eleven times
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A		;write it
	RET

;cursor left:
CURLFT: LD   A,(IX+3)		;left column --> accu
	CP   (IX+9)		; > current column ?
	JP   M,CURLFT1		;jump if not
	LD   A,(WRAP)		;wrap around mode ?
	OR   A
	RET  Z			;return if not	
       	LD   A,(IX+5)		;right column --> current column
	LD   (IX+9),A
	JR   CURUP
CURLFT1:DEC  (IX+9) 		;decrement column no.
	JP   INSLI3

;cursor down:
CURDWN: LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; >= bottom line ?
	JP   P,CURDW1		;scroll up if yes
	INC  (IX+8) 		;increment line no.
	JP   OUTCUR
CURDW1: LD   A,(IX+2)		;top line --> current line
	LD   (IX+8),A
	JP   SCRLU		;scroll window up one line

;cursor up:
CURUP:  LD   A,(IX+2)		;top line --> accu
	CP   (IX+8)		; >= current line ?
	RET  P			;return if yes
	DEC  (IX+8) 		;decrement line
	JP   OUTCUR

;cursor right:
CURRGT:	LD   A,(IX+5)		;right column --> accu
	CP   (IX+9)		;right column >= current column ?
	RET  M			;return if cursor beyond right column
	PUSH AF			;save status reg.
	INC  (IX+9) 		;increment column no.
	POP  AF			;restore status reg.
	JP   NZ,OUTCUR		;output cursor 
	LD   A,(WRAP)		;wrap around mode ?
	OR   A
	JP   Z,CUROFF+4		;turn cursor off
       	LD   A,(IX+3)		;left column  --> current column
	LD   (IX+9),A
	CALL OUTCUR		;output cursor
	JR   CURDWN		;perform line feed

;carriage return:
NEWLIN:	LD   A,(IX+3)		;left column  --> current column
	LD   (IX+9),A
	JP   INSLI3		;output cursor
	
;home cursor:
HOME:	LD   A,(IX+2)		;top line    --> current line
	LD   (IX+8),A
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	JP   OUTCUR		;output cursor

;select window:
WINDOW:	LD   C,A		;save window # 
	LD   A,(STONOFF)	;status line enabled ?
	RET  NZ			;return if yes 
	LD   A,C		;restore window #
	OR   A			;window # < 0 ?
	RET  M			;return if yes
	CP   8			;window # > 7 ?
	RET  NC			;return if yes
	ADD  A,A		;multiply window number by 13
	ADD  A,C
	ADD  A,A
	ADD  A,A
	ADD  A,C
	LD   B,0		;window number * 13 --> reg. BC 
	LD   C,A
	LD   HL,VDTAB		;^screen constants  --> reg. HL
	ADD  HL,BC		;calc current table entry
	LD   (VDTABP),HL	;store it
	PUSH HL         	;^screen constants  --> reg. IX
	POP  IX
	LD   A,(IX+12)		;cursor off ?
	OR   A
	JR   Z,WINDOW2 		;jump if not
WINDOW1:CALL CUROFF+4		;turn off cursor
	JP   OUTCUR             ;output cursor & return to caller
WINDOW2:LD   A,(IX+5)		;right column --> accu
	CP   (IX+9)		;right column >= current column ?
	JR   C,WINDOW1 		;turn off cursor beyond right column
	CALL OUTCUR		;position cursor
	JR   CURON+4		;turn on cursor & return to caller

;set top line:
SETTOP:	CP   (IX)		;legal  line/column no. ?
	RET  NC			;return if not
	LD   B,A		;save line/column
	SUB  (IX+4)		;top    line   - bottom line
				;left   column - right  column
	NEG			;bottom line   - top    line
				;right  column - left   column
	JP   M,SETTO1		;jump if illegal top line/left column
	INC  A			;adjust line/column count
	LD   (IX+6),A		;store new line/column count
SETTO1:	LD   A,B		;restore line column
	RET  M
	LD   (IX+2),A		;store new top line/left column
	CP   (IX+8)		;current line   > top  line ?
				;current column > left column ?
	RET  C			;return to caller if yes
SETTO2: LD   (IX+8),A		;store new current line/column
       	LD   IX,(VDTABP)	;adjust ^screen constants
	JP   OUTCUR		;output cursor

;set bottom line:
SETBOT:	CP   (IX)		;legal  line/column no. ?
	RET  NC			;return if not
	LD   B,A		;save line/column
	SUB  (IX+2)		;bottom line   - top  line
				;right  column - left column
	JP   M,SETTO1		;jump if illegal bottom line/left column
	INC  A			;adjust line/column count
	LD   (IX+6),A		;store new line/column count
       	LD   A,B		;restore line column
	LD   (IX+4),A		;store new bottom line/left column
	CP   (IX+8)		;current line   > bottom line ?
				;current column > right  column ?
	RET  P			;return to caller if not
	JR   SETTO2

;set left column:
SETLFT: INC  IX			;adjust ^screen constants
	JR   SETTOP		;set left column

;set right column:
SETRGT: INC  IX			;adjust ^screen constants
	JR   SETBOT		;set right column

;set erase character:
SETERA:	ADD  A,20H		;restore ASCII code of erase character
	CP   80H		;ASCII between 80H and 9FH ?
	JR   C,SETERA1
	CP   0A0H
	JR   NC,SETERA1
	RES  7,A		;make code between 00H and 1Fh
SETERA1:LD   (IX+10),A		;store new erase character
	RET			;return to caller

;turn off cursor:
CUROFF:	LD   (IX+12),0FFH	;store remark byte
        LD   A,10		;CRTC register no. --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,20H
	OUT  ($CRTCMD),A	;turn off cursor
	RET

;turn on cursor:
CURON:	LD   (IX+12),0 		;clear remark byte
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	LD   A,(IX+12)		;load remark byte
	OR   A			;test remark byte
	RET  NZ			;no action if cursor is invisible
       	LD   A,10		;CRTC register no. --> accu
	OUT  ($CRTREG),A	;select CRTC register
	LD   A,(CURBEG)		;cursor image      --> accu
	OUT  ($CRTCMD),A	;turn on cursor
	RET

;set ASCII character set:
SETASC:	XOR  A			;clear accu
SETAS1:	LD   (GERMAN),A		;set ASCII char set
	JP   SELCHR  		;select ASCII character set and ret to caller

;disable status line:
STATOFF:LD   A,(STONOFF)	;status line enabled ?
	OR   A
	RET  Z			;return if not
	XOR  A 			;clear marker
        LD   HL,VDTEMP		;restore screen parameter table
	JR   STATO1

;enable status line:
STATON:	LD   A,(STONOFF)	;status line already enabled ?
	OR   A
	RET  NZ			;return if yes
	CPL			;set marker
       	LD   HL,(VDTABP)	;save screen parameter table
	LD   DE,VDTEMP
	LD   BC,13
	LDIR
	LD   HL,VDSTAT		;setup status line parameters
STATO1:	LD   DE,(VDTABP)
	LD   BC,13
	LDIR
	LD   (STONOFF),A	;store marker
	JP   OUTCUR		;output cursor

;set German character set:
SETGER:	LD   A,0FFH		;set accu to ones
	JR   SETAS1		;set German char set

;switch on normal keyboard:
SETNKB:	LD   HL,NBOARD		;^normal key table  --> reg. HL
SETNK1:	LD   (KEYTAB),HL	;store it
	RET			;return to caller

;switch on WordStar keyboard:
SETWKB:	LD   HL,WBOARD		;^WordStar key table --> reg. HL
	JR   SETNK1		 

;turn on inverse display mode:
INVON:	LD   (IX+11),80H	;store invert mask
	RET

;turn off inverse display mode:
INVOFF: LD   (IX+11),0  	;clear invert mask
	RET

;turn on wrap around mode:
WRAPON:	LD   A,0FFH
	LD   (WRAP),A   	;remember wrap around mode
	RET

;turn off wrap around mode:
WRAPOFF:XOR  A
	LD   (WRAP),A
	RET

;insert character:
INSCHR:	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   A,(IX+5)		;right column            --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	JR   Z,INSCH1		;no columns to shift
	LD   B,0		;no of columns to shift --> reg. BC
	LD   C,A
	ADD  HL,BC		;now HL contains address of last column
	LD   D,H
	LD   E,L		;now DE contains address of last column
	DEC  HL			;now HL contains address of last column - 1
	LDDR			;shift rest of line right one char
	INC  HL			;now HL contains current cursor address
INSCH1:	LD   A,(IX+10)		;get erase char
        LD   (HL),A  		;insert one space at current cursor location
	RET

;insert line:
INSLIN:	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	L   A,(IX+4		;botto� lin� --� accu
	SUB  (IX+8)		;calc. no. of lines to scroll
	LD   B,(IX+4)		;bottom line --> current line
	LD   (IX+8),B
INSLI1: JR   Z,INSLI2		;return if line count = 0
       	CALL CALC		;calculate start position
	PUSH HL			;save it
	LD   D,0 		;maximum column count --> reg. DE
	LD   E,(IX+1)
	SBC  HL,DE		;now HL contains ^(last line - 1)
	POP  DE			;restore ^last line
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll down one line
	DEC  (IX+8)		;decrement current line
	DEC  A			;decrement counter
	JR   INSLI1		;scroll down all lines
INSLI2:	CALL ERAEOLN		;erase current line
INSLI3:	CALL OUTCUR		;output cursor
	JP   CURON+4		;turn on cursor

;delete character:
DELCHR:	LD   HL,(CURADR)	;absolute screen address  --> reg. HL
       	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;calc. no. of columns right to the cursor
	RET  M			;return, if cursor beyond right column
	JR   Z,INSCH1		;no columns to shift
	LD   B,0		;no. of columns to shift --> reg. BC
	LD   C,A
	LD   D,H
	LD   E,L		;now DE contains absolute screen address
	INC  HL			;now HL contains absolute screen address + 1
	LDIR			;shift rest of line left one char
	DEC  HL			;now HL contains address of last column
	JR   INSCH1		;insert one space at last column

;erase to end of line:
ERAEOLN:CALL CALC		;calculate absolute screen address
	LD   A,(IX+5)		;right column --> accu
	SUB  (IX+9)		;now accu contains number of columns to erase
	RET  M			;return if cursor beyond right column
       	LD   C,(IX+10)		;get erase char
ERAEO1:	LD   (HL),C  		;clear column
	INC  HL			;bump column ptr
	DEC  A			;decrement column counter
	JP   P,ERAEO1		;erase all columns right to the cursor
	RET

;delete line:
DELLIN: LD   A,(IX+3)		;left  column --> current column
	LD   (IX+9),A
       	LD   A,(IX+8)		;current line no. --> accu
	PUSH AF			;save it
	CALL SCRLU		;scroll rest of window up one line
	POP  AF
	LD   (IX+8),A		;restore current line
	JR   INSLI3		;output cursor
 
;erase to end of screen:
ERAEOS: CALL ERAEOLN		;erase to end of first line
	LD   B,(IX+8)		;save current line
	LD   C,(IX+9)		;save current column
	PUSH BC
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
	LD   A,(IX+4)		;bottom line --> accu
	SUB  B			;now accu contains number of lines to erase
	LD   B,A		;counter --> reg. B
        JR   Z,ERAES2		;no further lines to erase
ERAES1: INC  (IX+8)		;increment current line
	PUSH BC			;save counter
	CALL ERAEOLN		;erase current line
	POP  BC			;restore counter
	DJNZ ERAES1		;erase to end of whole window
ERAES2: POP  BC
        LD   (IX+8),B		;restore original line   no.
	LD   (IX+9),C		;restore original column no.
	RET

;clear screen:
ERAALL: CALL HOME		;home cursor
	JR   ERAEOS		;clear to end of screen

;output cursor:
OUTCUR:	CALL CALC               ;calculate absolute screen address
	LD   (CURADR),HL	;store it
	LD   DE,$SCREEN		;base address of video RAM --> reg. DE
	OR   A			;clear carry flag
	SBC  HL,DE		;subtract base address from current cursor
				;address
	LD   C,$CRTREG		;CRTC address register --> reg. C
	LD   A,14		;CRTC register number  --> accu
	OUT  (C),A		;select CRTC register
	INC  C			;CRTC command register --> reg. C
	OUT  (C),H		;output cursor address (MSB)
	INC  A			;increment CRTC register no.
	DEC  C			;decrement port number
	OUT  (C),A		;select CRTC register
	INC  C			;CRTC command register --> reg. C
	OUT  (C),L		;output cursor address (LSB)
	RET

;scroll up routine:
SCRLU:	LD   A,(IX+9)		;current column --> accu
	PUSH AF			;save it
	LD   A,(IX+3)		;left column --> current column
	LD   (IX+9),A
      	LD   A,(IX+4)		;bottom line  --> accu
	SUB  (IX+8)		;calc. no. of lines to scroll
SCRLU1: JR   Z,SCRLU2		;clear last line if count = 0
        CALL CALC		;calculate start position
	PUSH HL			;save it
	LD   D,0 		;maximum column count --> reg. DE
	LD   E,(IX+1)
	ADD  HL,DE		;now HL contains address of line to scroll
	POP  DE			;restore ^line before
	LD   B,0		;column count --> reg. BC
	LD   C,(IX+7)
	LDIR			;scroll up one line
	INC  (IX+8)		;increment current line
	DEC  A			;decrement counter
	JR   SCRLU1             ;scroll up all lines
SCRLU2:	CALL ERAEOLN		;clear last line
	POP  AF			;restore column no.
	LD   (IX+9),A		;store it
	RET

;calculate absolute cursor address:
CALC:	LD   HL,$SCREEN		;address of first screen loc --> reg. HL
	LD   D,0		;maximum column count        --> reg. DE
	LD   E,(IX+1)
	LD   B,(IX+8)		;current line                --> reg. B
	DEC  B
	INC  B
        JR   Z,CALC2		;jump if line no. = 0
CALC1:	ADD  HL,DE
	DJNZ CALC1		;handle all lines
CALC2:	LD   E,(IX+9)		;current column --> reg. DE
	ADD  HL,DE		;now HL contains absolute screen address
	RET

;jump vectors:
CTRLJP:	DEFW BEEP,CURLFT,CURDWN,CURUP,CURRGT,NEWLIN,HOME,ESC1ST,ESC1ST,ESC1ST
	DEFW ESC1ST,ESC1ST,ESC1ST,ESC1ST,CUROFF,CURON,SETASC,STATOFF,STATON
	DEFW SETGER,SETNKB,SETWKB,INVON,INVOFF,WRAPON,WRAPOFF,INSCHR,INSLIN
	DEFW DELCHR,ERAEOLN,DELLIN,ERAEOS,ERAALL
ESCJP:	DEFW ESC2ND,WINDOW,SETTOP,SETBOT,SETLFT,SETRGT,SETERA

;table of screen constants:
VDTABP:	DEFW VDTAB
VDTAB:	REPT 8
	DEFB 24			;maximum line   count
	DEFB 80			;maximum column count
	DEFB 0			;top     line
	DEFB 0			;left    column
	DEFB 23			;bottom  line
	DEFB 79			;right   column
	DEFB 24			;line    count
	DEFB 80			;column  count
	DEFB 0			;current line
	DEFB 0			;current column
	DEFB ' '		;erase   character 
        DEFB 0     		;0 = normal mode,  80H = inverse mode
       	DEFB 0     		;0 = cursor on  , 0FFH = cursor off
	ENDM

;status line constants:
VDSTAT:	DEFB 25			;maximum line   count
	DEFB 80			;maximum column count
	DEFB 24			;top     line
	DEFB 0			;left    column
	DEFB 24			;bottom  line
	DEFB 79			;right   column
	DEFB 1 			;line    count
	DEFB 80			;column  count
	DEFB 24			;current line
	DEFB 0			;current column
	DEFB ' '		;erase   character 
        DEFB 0     		;0 = normal mode,  80H = inverse mode
       	DEFB 0     		;0 = cursor on  , 0FFH = cursor off

ESCAPE:	DEFB 0     		;contains escape remarks
ESCCHR: DEFB 0     		;memory for escape char
LINE:  	DEFB 0     		;memory for line number
CURADR: DEFW 3800H		;memory for absolute cursor address
WRAP:   DEFB 0			;0 = normal mode, 0FFH = wrap around mode
STONOFF:DEFB 0			;0 = status line off, 0FFH = status line on
VDTEMP:	DEFS 13			;temporary storage area for screen constants


*EJECT
;*******************
;*  $ P R S T A T  *
;*******************

;entry: B = number of Centronics interface (0, 1)

;exit : A = printer status
;       0 = printer ready 
;    <> 0 = printer not ready

;calc entry of printer status routine:
$PRSTAT:LD   HL,PSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
 	LD   L,C
	JP   (HL)		;execute printer status routine

;printer status routine entry table:
PSTAB:	DEFW PRSTA0,PRSTA1

;test status of printer 0:
$PTR0	EQU  0FDH		;printer port 0

PRSTA0:	IN   A,($PTR0)		;read printer status
	AND  0F0H		;mask it
	XOR  30H
	RET			;return to caller

;test status of printer 1:
$PTR1	EQU  0D5H		;printer port 1

PRSTA1:	IN   A,($PTR1)		;read printer status
	AND  0F0H		;mask it
	XOR  30H
	RET			;return to caller


*EJECT
;*******************
;*  $ P R C H A R  *
;*******************

;entry: A = char
;       B = number of Centronics interface (0, 1)

;calc entry of printer output routine:
$PRCHAR:LD   HL,POTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
 	LD   L,C
	JP   (HL)		;execute printer output routine

;printer output routine entry table:
POTAB:	DEFW PRCHR0,PRCHR1

;output a character to printer 0:
PRCHR0:	LD   C,A		;save char
	CALL PRSTA0		;test status of printer 0
	JR   NZ,PRCHR0+1	;wait for printer ready
	LD   A,C		;restore char
	OUT  ($PTR0),A		;print it
	RET			;return to caller
			  
;output a character to printer 1:
$PTR1D	EQU  0D4H		;data port of PIO

PRCHR1:	LD   C,A		;save char
	CALL PRSTA1		;test status of printer 0
	JR   NZ,PRCHR1+1	;wait for printer ready
	LD   A,C		;restore char
	OUT  ($PTR1D),A		;output it
	XOR  A
	OUT  ($PTR1),A		;set STROBE
	INC  A
	OUT  ($PTR1),A		;clear STROBE

	RET			;return to caller
			  

*EJECT
;*******************
;*  $ R S R C S T  *
;*******************

;entry: B = number of RS232C interface (0, 1)

;exit : A = input status
;	0 = no char available
;    <> 0 = char available	

;calc entry of RS232C input status routine:
$RSRCST:LD   HL,RSSTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine
	 
;RS232C input status routine entry table:
RSSTAB:	DEFW RSRCSA,RSRCSB	

;get input status of SIO A:
RSRCSA: IN   A,(WR0A)    	;read status
	AND  1   		;character available ?
	RET  NZ 		;return to caller if yes
	LD   B,A		;load counter
	LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0A),A		;request to send
RSRCSA1:IN   A,(WR0A)		;read status	
	BIT  0,A		;character available ?
	JR   NZ,RSRCSA2		;jump if character ready
	DJNZ RSRCSA1		;scan 256 times
	LD   C,0		;no character available
	JR   RSRCSA3
RSRCSA2:LD   C,1		;character available
RSRCSA3:LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	OUT  (WR0A),A		;data terminal ready
        LD   A,C		;get input status
	RET

;get input status of SIO B:
RSRCSB: IN   A,(WR0B)    	;read status
	AND  1   		;character available ?
	RET  NZ 		;return to caller if yes
	LD   B,A		;load counter
	LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0B),A		;request to send
RSRCSB1:IN   A,(WR0B)		;read status	
	BIT  0,A		;character available ?
	JR   NZ,RSRCSB2		;jump if character ready
	DJNZ RSRCSB1		;scan 256 times
	LD   C,0		;no character available
	JR   RSRCSB3
RSRCSB2:LD   C,1		;character available
RSRCSB3:LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	OUT  (WR0B),A		;data terminal ready
        LD   A,C		;get input status
	RET

 
*EJECT
;*****************
;*  $ R S R C V  *
;*****************

;entry: B = number of RS232C interface (0, 1)

;exit : A = char	

;calc entry of RS232C input routine:
$RSRCV: LD   HL,RSRTAB		;base of entry table --> reg. HL
	LD   C,B		;calc table entry
	LD   B,0
	SLA  C
	ADD  HL,BC
	LD   C,(HL)		;get entry address
	INC  HL
	LD   H,(HL)
	LD   L,C
	JP   (HL)		;execute initialization routine
	 
;RS232C input routine entry table:
RSRTAB:	DEFW RSRCVA,RSRCVB	

;read character from SIO A:
DRA	EQU  0D0H		;data register of SIO A

RSRCVA:	IN   A,(WR0A) 		;read status
	BIT  0,A     		;character available ?
	JR   NZ,RSRCVA2		;jump if yes
	LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0A),A		;request to send
RSRCVA1:IN   A,(WR0A)		;read status	
	BIT  0,A		;character available ?
	JR   Z,RSRCVA1		;loop `til character ready
        LD   A,5		;speak to write register 5
	OUT  (WR0A),A
	LD   A,(WR5A)		;get write register 5
	OUT  (WR0A),A		;data terminal ready
RSRCVA2:IN   A,(DRA)		;read character
	RET
	
;read character from SIO B:
DRB	EQU  0D1H		;data register of SIO A

RSRCVB:	IN   A,(WR0B) 		;read status
	BIT  0,A     		;character available ?
	JR   NZ,RSRCVB2		;jump if yes
	LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	SET  1,A		;set RTS
	OUT  (WR0B),A		;request to send
RSRCVB1:IN   A,(WR0B)		;read status	
	BIT  0,A		;character available ?
	JR   Z,RSRCVB1		;loop `til character ready
        LD   A,5		;speak to write register 5
	OUT  (WR0B),A
	LD   A,(WR5B)		;get write register 5
	OUT  (WR0B),A		;data terminal ready
RSRCVB2:IN   A,(DRB)		;read character
	RET
	

*EJECT
;*******************
;*  $ R S T X S T  *
;******************* 
	
;entry: B = number of RS232C interface (0, 1)

;exit : A = terminal status
;       0 = data terminal ready
;    <> 0 = data terminal not ready

;get output status of SIO:
$RSTXST:LD   A,WR0A    		;control register of SIO A --> accu
	ADD  A,B		;add relative port number
	LD   C,A		;absolute port address --> reg. C
	LD   A,10H		
	OUT  (C),A		;reset ext/status interrupts
	IN   A,(C)		;read status
	AND  2CH		;buffer empty, data set ready, clear to send ?
        SUB  2CH
	RET
	

*EJECT
;***************
;*  $ R S T X  *
;***************

;entry: A = char
;       B = number of RS232C interface (0, 1)

;write character to SIO:
$RSTX:	LD   E,A		;save character
        CALL $RSTXST  		;test output status
	JR   NZ,$RSTX+1		;wait for CTS
	DEC  C
	DEC  C			;now reg. C points to data port
	OUT  (C),E		;output character
	RET


*EJECT
;disk driver:

;FDC registers:
$FDSEL  EQU  0E0H               ;FDC select  register
$FDCMD  EQU  0ECH               ;FDC command register
$FDSTAT EQU  0ECH               ;FDC status  register
$FDTRK  EQU  0EDH               ;FDC track   register
$FDSIZ  EQU  0EEH               ;FDC size    register
$FDSEC  EQU  0EEH               ;FDC sector  register
$FDDATA EQU  0EFH               ;FDC data    register

;FDC commands:
$SEEK   EQU  10H                ;seek
$RDSEC  EQU  88H                ;read sector
$WRSEC  EQU  0A8H               ;write sector
$SET8   EQU  0C0H               ;set disk size to 5 inch
$FCINT  EQU  0D0H               ;force interrupt
$DDDEN  EQU  0FFH               ;set double density


;***************
;*  $ R E A D  *
;***************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       E  = track  number
;       HL = buffer pointer

;exit : A = error code
;       0 = NO ERROR
;       1 = ILLEGAL DRIVE #
;       2 = TRACK # TOO HIGH
;       3 = SECTOR # TOO HIGH
;       4 = DEVICE NOT AVAILABLE
;       6 = TRIED TO READ LOCKED/DELETED RECORD
;       7 = DATA RECORD NOT FOUND DURING READ
;       8 = PARITY ERROR DURING READ
;       9 = LOST DATA DURING READ

;read a sector:
$READ:  LD   C,A                ;save drive #/bank #
        LD   A,0FFH             ;set READ-flag
        JR   TASK


*EJECT
;*****************
;*  $ W R I T E  *
;*****************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       E  = track  number
;       HL = buffer pointer

;exit : A = error code
;       0 = NO ERROR
;       1 = ILLEGAL DRIVE #
;       2 = TRACK # TOO HIGH
;       3 = SECTOR # TOO HIGH
;       4 = DEVICE NOT AVAILABLE
;       5 = WRITE PROTECTED DISKETTE
;       6 = WRITE FAULT ON DISK DRIVE
;       7 = DATA RECORD NOT FOUND DURING WRITE
;       8 = PARITY ERROR DURING WRITE
;       9 = LOST DATA DURING WRITE

;write a sector:
$WRITE: LD   C,A                ;save drive #/bank #
        XOR  A                  ;clear READ-flag

;dominant controller:
TASK:   LD   (RDFLAG),A         ;set/reset READ-flag
	LD   A,C		;restore drive/bank #
      	RRA   			;get bank number of transfer buffer
	RRA   
	RRA   
	RRA   
	AND  0FH
	LD   (BANK),A		;store bank #
        LD   A,C      		;restore drive/bank #
	AND  0FH		;mask drive #
        CP   8                  ;legal drive # ?
        JR   C,TRKNO            ;jump if yes
        LD   A,1                ;error code 1 --> accu
        RET
TRKNO:  LD   (DRIVE),A          ;store drive #
        LD   (BUFFER),HL        ;store buffer pointer
        CALL GETDCT             ;get control table ptr
        LD   A,E                ;track # --> accu
        CP   (IX+4)             ;legal track # ?
        JR   C,SECNO            ;jump if yes
        LD   A,2                ;error code 2 --> accu
        RET
SECNO:  LD   (TRACK),A          ;store track #
        LD   A,B                ;sector # --> accu
        CP   (IX+3)             ;legal sector # ?
        JR   C,TRYNO            ;jump if yes
        LD   A,3                ;error code 3 --> accu
        RET
TRYNO:	LD   (SECTOR),A		;store sector #
        LD   A,(TRYS)           ;get # of err tries
        INC  A                  ;adjust it
        LD   (TRIES),A          ;store in counter

;set double density & disk size to 8 inch:
        LD   A,$DDDEN           ;set double density command
        BIT  5,(IX)             ;density ?
        JR   NZ,SETDEN          ;jump if double density
        DEC  A                  ;set single density
SETDEN: OUT  ($FDCMD),A         ;set density
        LD   C,$SET8            ;set 8 inch command
        LD   A,(DRIVE)          ;drive # --> accu
	CP   4			;disk size ?
        JR   NC,SETSIZ          ;jump if 8 inch
        RES  6,C                ;set 5 inch command
SETSIZ:	LD   A,C
        OUT  ($FDSIZ),A         ;set disk size

;actual I/O handler:
INIT:   LD   HL,0               ;clear wait counter
        LD   (WAIT),HL
        LD   A,$FCINT           ;force interrupt
        OUT  ($FDCMD),A         ;reset FDC
        IN   A,($FDSTAT)        ;get FDC status
        LD   (OLDSTAT),A        ;save drive status
        CALL SELECT             ;select drive
        BIT  0,(IX+1)           ;is drive initialized ?
        JR   NZ,TRKSEC          ;yes skip init process

;restore drive head:
        SET  0,(IX+1)           ;set init bit in DCT
        LD   A,255              ;max possible track # --> accu
        LD   (IX+5),A           ;make current track # to 255
        XOR  A                  ;desired track # = 0
        JR   TRKSE8

;set track and sector:
TRKSEC: LD   A,(TRACK)          ;track # --> accu
        BIT  5,(IX)             ;disk density ?
        JR   Z,TRKSE1           ;jump if single density
        BIT  4,(IX)             ;density of first track ?
        JR   NZ,TRKSE1          ;jump if double density
        INC  A                  ;increment track #
TRKSE1: BIT  2,(IX)             ;step count from track to track
        JR   Z,TRKSE2           ;jump if step count = 1
        ADD  A,A                ;track # * 2
TRKSE2: CP   (IX+5)             ;same as current track
        JR   NZ,TRKSE6          ;jump to SEEK cmd if not
	LD   C,A		;save track #
	LD   A,$FCINT		;force interrupt
	OUT  ($FDCMD),A
	LD   A,C		;restore track #
        BIT  2,(IX)             ;step count from track to track
        JR   Z,TRKSE3           ;jump if step count = 1
        SRL  A                  ;track # / 2
TRKSE3: OUT  ($FDTRK),A         ;adjust current track #
        LD   A,(SECTOR)         ;sector # --> accu
        BIT  6,(IX)             ;single or double sided ?
        JR   Z,TRKSE4           ;jump if single sided
        BIT  5,(IX+1)           ;sector numbering continued on backside ?
        JR   NZ,TRKSE4          ;jump if yes
        LD   B,(IX+3)           ; sectors/track --> reg. B
        SRL  B                  ;(sectors/track) / 2
        CP   B                  ;front or back side ?
        JR   C,TRKSE4           ;jump if front side
        SUB  B                  ;adjust sector #
TRKSE4: BIT  3,(IX)             ;test number of first sector
        JR   Z,TRKSE5           ;jump if zero
        INC  A                  ;else adjust sector #
TRKSE5: OUT  ($FDSEC),A         ;store sector # in FDC reg
        JR   WAITEN             ;no SEEK
TRKSE6: LD   C,A                ;save track #
        SUB  (IX+5)             ;subtract current track #
        JR   NC,TRKSE7
        NEG                     ;make result positive
TRKSE7: LD   (WAIT),A           ;store calculated step count
        LD   A,C                ;restore track #
TRKSE8: OUT  ($FDDATA),A        ;store track # in FDC reg
	LD   A,$FCINT
        OUT  ($FDCMD),A         ;reset FDC
        LD   A,(IX+5)           ;current track from DCT
        OUT  ($FDTRK),A         ;FDC track register
        LD   A,(IX)
        AND  3                  ;step rate --> accu
	PUSH AF			;save it
        LD   HL,(WAIT)          ;get step count
        JR   Z,TRKS10           ;jump if step rate = 3 msec
        LD   D,H                ;step count --> reg. DE
        LD   E,L
        LD   B,A                ;step rate --> reg. B
TRKSE9: ADD  HL,DE              ;counter = step count * step rate
        DJNZ TRKSE9
TRKS10: LD   B,H                ;counter --> reg. BC
        LD   C,L
        ADD  HL,HL              ;counter * 2
        ADD  HL,BC              ;counter * 3
	LD   A,(DRIVE)		;drive # --> accu
        CP   4                  ;disk size ?
        JR   NC,TRKS11          ;jump if 8 inch
	ADD  HL,HL		;counter * 6
TRKS11: LD   BC,15              ;adjust value for delay loop --> reg. BC
        ADD  HL,BC              ;adjust wait counter
        LD   (WAIT),HL          ;store wait counter (msecs of passed time)
	POP  AF			;restore step rate
        OR   $SEEK              ;or step rate with "seek" command
        OUT  ($FDCMD),A         ;issue seek command
TRKS12: CALL SELECT             ;select drive
	IN   A,($FDSTAT)	;get disk status
        BIT  7,A                ;drive not ready ?
        JP   NZ,READ2           ;jump to error exit
        BIT  0,A                ;seek done ?
        JR   NZ,TRKS12          ;no, loop
        LD   BC,4000            ;load delay counter
        CALL DELAY              ;15 msec head settle delay
        IN   A,($FDTRK)         ;get current track
        LD   (IX+5),A           ;store in drive's DCT
        JP   TRKSEC             ;check track # again

;motor on / head load time:
WAITEN: LD   A,(DRIVE)          ;get drive #
        LD   HL,OLDDRV          ;^previous drive # --> reg. HL
        CP   (HL)               ;new drive # same as old drive # ?
        LD   (HL),A             ;store new drive #
        LD   A,(OLDSTAT)        ;get old FDC status
        RLCA                    ;drive rotating already
        JR   C,WAITE2           ;jump to motor on delay loop, if not
        JR   Z,WAITE6           ;jump if same drive #
WAITE1: LD   HL,50              ;50 msec head load time
        JR   WAITE3
WAITE2: BIT  7,(IX)             ;8 inch drive
        JR   NZ,WAITE1          ;jump if 8 inch drive
        LD   HL,800             ;500 msec delay after motor on
WAITE3: LD   BC,(WAIT)          ;msecs of passed time --> reg. BC
        OR   A                  ;clear carry bit
        SBC  HL,BC              ;calculate remaining wait time
        JR   C,WAITE6           ;no further time to wait
        JR   Z,WAITE6
WAITE5: LD   BC,253             ;1 msec delay
        CALL DELAY
        DEC  HL
        LD   A,H
        OR   L
        JR   NZ,WAITE5          ;loop HL times
WAITE6: IN   A,($FDSTAT)        ;get FDC status
        RLCA                    ;drive rotating already ?
        JP   C,READ2            ;jump if not

;init READ/WRITE:
TASK1:  CALL SELECT             ;select drive
        LD   HL,(BUFFER)        ;get buffer pointer
        LD   A,(RDFLAG)
        OR   A                  ;READ or WRITE ?
	PUSH AF			;save status
	LD   A,(BANK)		;bank # of transfer buffer --> accu
	JP   IO 		;handle disk I/O in common memory

;test controller status:
STATUS: IN   A,($FDSTAT)        ;get FDC status
        BIT  6,A                ;write protect ?
        JR   Z,STATU1           ;jump if not
        LD   A,5                ;error code 5 --> accu
        RET
STATU1: BIT  5,A                ;hardware fault (WRITE) ?
                                ;sector   prot  (READ ) ?
        JR   Z,STATU2           ;jump if no
        LD   A,6                ;error code 6 --> accu
        RET
STATU2: AND  1CH                ;any errors ?
        RET  Z
        RES  0,(IX+1)           ;clear init bit in DCT
        LD   HL,TRIES           ;get tries counter
        DEC  (HL)               ;dec value
        JP   NZ,INIT            ;try again, reseek
        BIT  4,A                ;data record not found ?
        JR   Z,STATU3
        LD   A,7                ;error code 7 --> accu
        RET
STATU3: BIT  3,A                ;parity error ?
        JR   Z,STATU4
        LD   A,8                ;error code 8 --> accu
        RET
STATU4: LD   A,9                ;error code 9 --> accu
        RET

;put drive control table pointer in "IX":
GETDCT: PUSH DE                 ;save reg. DE
        LD   H,0                ;drive # --> reg. HL
        LD   L,A
        ADD  A,A                ; drive # * 2
        ADD  A,L                ; drive # * 3
        ADD  A,A                ; drive # * 6
        LD   L,A                ;(drive # * 6) --> reg. HL
        LD   DE,DCT             ;get drive table start
        ADD  HL,DE              ;add offset and get ^DCT
        PUSH HL                 ;^DCT --> reg. IX
        POP  IX
        POP  DE                 ;restore reg. DE
        RET                     ;return to caller

;select drive:
SELECT: LD   A,(DRIVE)          ;get drive #
	AND  3			;force # between 0 and 3
        OR   A                  ;drive # zero ?
        LD   B,A                ;drive # --> reg. B
        LD   A,1                ;select code for drive zero
        JR   Z,SELEC1           ;jump if drive # zero
        RLCA                    ;rotate left accu
        DJNZ $-1                ;decrement drive #
SELEC1: BIT  6,(IX)             ;single or double sided ?
        JR   Z,SELEC2           ;jump if single sided
        LD   C,A                ;save select code
        LD   A,(SECTOR)         ;sector #       --> accu
        LD   B,(IX+3)           ; sectors/track --> reg. B
        SRL  B                  ;(sectors/track) / 2
        CP   B                  ;front or back side ?
        LD   A,C                ;restore select code
        JR   C,SELEC2           ;jump if front side
        SET  4,A                ;set side select bit
SELEC2: OUT  ($FDSEL),A         ;select drive and side
        RET                     ;return to caller

DRIVE:  DEFS 1                  ;drive
TRACK:  DEFS 2                  ;track
SECTOR: DEFS 1                  ;sector
BUFFER: DEFS 2                  ;I/O buffer
OLDDRV: DEFB 0FFH               ;contains # of previous selected disk
OLDSTAT:DEFS 1			;contains drive status
TRIES:  DEFS 1                  ;counter for counting # of times to try I/O
                                ;after error occurs
RDFLAG: DEFS 1                  ;flag (0 = WRITE, 0FFH = READ)
WAIT:   DEFS 2                  ;counter for passed time


*EJECT
;*******************
;*  $ G E T T I M  *
;*******************

;entry: HL = address of a 21 bytes long buffer, containing on exit
;	     time & date in the form WWW MM/DD/YY HH:MM:SS

;		  WWW = weekday
;		   MM = month
;		   DD = day
;		   YY = year
;		   HH = hours
;		   MM = minutes
;		   SS = seconds		 

;get time & date in ASCII format:
$GETTIM:DI			;critical phase
	PUSH HL			;save ^user buffer
        CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer --> reg. IX

	LD   A,(IX+6)		;weekday      --> accu
	AND  7			;make binary
	LD   H,0		;weekday      --> reg. HL			
	LD   L,A
	LD   DE,DAYTAB		;base of weekday table --> reg. DE
	ADD  A,A		;calc table entry
	ADD  A,L
	LD   L,A
	ADD  HL,DE
	LD   DE,ATIMBUF		;^ASCII buffer 	       --> reg. DE	
	LD   BC,3		;length of table entry --> reg. BC
	LDIR			;move weekday into ASCII buffer
	INC  DE			;bump buffer ptr over space

	LD   A,(IX+2)		;month (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+3)		;month (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX+4)		;day (tenths) --> accu
	AND  '3'		;mask leapyear bit
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+5)		;day (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over slash		

	LD   A,(IX)		;year (tenths) --> accu
	LD   (DE),A		;store it
	INC  DE
	LD   A,(IX+1)		;year (ones)   --> accu
	LD   (DE),A		;store it
	INC  DE
	INC  DE			;bump buffer pointer over space		

	LD   A,(IX+7)		;hours (tenths) --> accu
	AND  '3'		;mask format bit 
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+8)		;hours (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon	

	LD   A,(IX+9)		;minutes (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+10)		;minutes (ones)   --> accu
	LD   (DE),A		;store them
	INC  DE
	INC  DE			;bump buffer pointer over colon	

	LD   A,(IX+11)		;seconds (tenths) --> accu
	LD   (DE),A		;store them
	INC  DE
	LD   A,(IX+12)		;seconds (ones)   --> accu
	LD   (DE),A		;store them

	POP  DE			;restore ^user buffer
	LD   HL,ATIMBUF		;^(time & date buffer) 	      --> reg. HL
	LD   B,21		;length of time & date string --> reg. BC
	LD   A,01H		;source bank      = 0
				;destination bank = 1
	JP   $XMOVE		;transfer time & date string and return

;read time & date from clock chip:
GETTIM:	IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  10111111B		;1.78 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
        LD   HL,TIMBUF		;^temp buffer --> reg. HL
	LD   DE,10C4H		;register address displacement --> reg. D
				;register address & read mode  --> reg. E
	LD   B,13		;byte counter 		       --> reg. B
GETTI1:	LD   A,E		;read date & time
	OUT  (5BH),A
	SUB  D
	LD   E,A
	IN   A,(5AH)	 	
	AND  0FH		;mask undesired bits
	OR   '0'		;make ASCII digit
	LD   (HL),A
	INC  HL			;bump ^(time & date)
	DJNZ GETTI1
	POP  AF       		;restore system byte 1
	OUT  ($SYS1),A		;write system byte 1
	RET			;return to caller

DAYTAB:	DEFM 'SatSunMonTueWedThuFri'
TIMBUF:	DEFS 13
ATIMBUF:DEFM 'WWW MM/DD/YY HH:MM:SS'


*EJECT
;*******************
;*  $ S E T T I M  *
;*******************

;entry:  A = weekday (0 - 6, 0 = Sat)
;	 B = month   (MM)
;        D = hours   (HH)
;	 E = minutes (MM)
;	 H = day     (DD)
;	 L = year    (YY)


;set time and date in binary format:
$SETTIM:DI			;critical phase
	LD   IX,TIMBUF		;^temp buffer --> reg. IX
	LD   (IX+6),A		;weekday      --> buffer
	LD   A,L		;year (ones)  --> accu
	AND  0FH		;mask it
	LD   (IX+1),A		;year (ones)  --> buffer
	LD   A,L		;shift reg. L four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX),A		;year  (tenths) --> buffer
	LD   A,B		;month (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+3),A		;month (ones)   --> buffer
	LD   A,B		;shift reg. B four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+2),A		;month (tenths) --> buffer
	LD   A,H		;day   (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+5),A		;day   (ones)   --> buffer
	LD   A,H		;shift reg. H four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+4),A		;day   (tenths) --> buffer
	LD   A,D		;hours (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+8),D		;hours (ones)	--> buffer
	LD   A,D		;shift reg. D four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+7),A		;hours   (tenths) --> buffer
	LD   A,E		;minutes (ones)   --> accu
	AND  0FH		;mask it
	LD   (IX+10),A		;minutes (ones)   --> buffer
	LD   A,E		;shift reg. E four bits right
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	LD   (IX+9),A		;minutes (tenths) --> buffer
	LD   (IX+11),0		;seconds (tenths) --> buffer
	LD   (IX+12),0		;seconds (ones)   --> buffer
	LD   HL,TIMBUF		;^buffer	  --> reg. HL
	LD   DE,10D2H		;register address displacement --> reg. D
				;register address	       --> reg. E
	LD   B,13		;byte counter 		       --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  10010111B		;disable graphic page
				;1.78 MHz clock frequency
	OR   00000101B		;disable memory mapped I/O
				;disable boot EPROM
	OUT  ($SYS1),A		;write system byte 1
SETTI1:	LD   A,E		;set date & time
	SUB  D
	LD   E,A
	OUT  (05BH),A
	LD   A,(HL)
	OUT  (5AH),A
	INC  HL			;bump ^(time & date)
	DJNZ SETTI1
	IN   A,($SYS1)		;read system byte 1
	OR   01000000B		;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	JP   GETTIM		;adjust clock chip and return to caller


*EJECT
;Winchester disk driver:

	COND SASI		;Xebec part

MAXDRIVE EQU 2			;drive count

;DC registers:
WPORT0	EQU  00H		;SASI write port 0 - write data
WPORT1	EQU  01H		;SASI write port 1 - software reset
WPORT2	EQU  02H		;SASI write port 2 - cntlr select
RPORT0	EQU  00H		;SASI read  port 0 - read data
RPORT1	EQU  01H		;SASI read  port 1 - read status

;DC commands:
$TSTDRV	EQU  00H		;test drive ready
$REST  	EQU  01H		;recalibrate
$STATUS	EQU  03H		;request sense status
$$READ	EQU  08H		;read
$$WRITE	EQU  0AH		;write
$INIDRV EQU  0CH		;initialize drive characteristics

;DC status bits:
REQMASK EQU  01H		;request mask for bit test
BUSYMASK EQU 02H		;busy    mask for bit test
CDMASK	EQU  08H                ;command/data bit position test
IOMASK	EQU  10H		;input/output bit mask
ERROR	EQU  02H		;test for an error

	ELSE			;WD1002 part

MAXDRIVE EQU 3			;drive count

;WDC registers:
$DATA  	EQU  50H  		;data register	
$WPC    EQU  51H  		;write precomp register
$ERROR  EQU  51H  		;error register
$SECNO 	EQU  53H  		;sector number register
$CYLLO  EQU  54H  		;cylinder low register
$CYLHI  EQU  55H  		;cylinder high register
$SDH	EQU  56H		;size/drive/head register
$COMND  EQU  57H		;command register
$STATUS	EQU  57H		;status register

;WDC commands:
$REST   EQU  10H		;restore
$$READ 	EQU  20H		;read sector
$$WRITE	EQU  30H		;write sector
$DSEL	EQU  98H		;deselect drive

	ENDC


*EJECT
;*****************
;*  $ R E A D W  *
;*****************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       DE = track  number
;       HL = buffer pointer

;exit : A  = error status returned from controller
;	 0 = NO ERROR
;	-1 = ILLEGAL DRIVE #
;	-2 = TRACK # TOO HIGH
;	-3 = SECTOR # TOO HIGH
;	else error code returned by controller

;read a sector:
$READW:	LD   C,A		;save drive/bank number
       	LD   A,0FFH
	JR   TASKW		;read sector


*EJECT
;*****************
;*  $ W R I T W  *
;*****************

;entry: A  = drive  number 	     (lower nibble)
;	     bank   number of buffer (upper nibble)	
;       B  = sector number
;       DE = track  number
;       HL = buffer pointer

;exit : A  = error code
;	 0 = NO ERROR
;	-1 = ILLEGAL DRIVE #
;	-2 = TRACK # TOO HIGH
;	-3 = SECTOR # TOO HIGH
;	else error code returned by controller

;write a sector:
$WRITW:	LD   C,A		;save drive/bank number
       	XOR  A


;dominant controller:
TASKW:	LD   (RDFLAG),A		;set/cear READ-flag
	LD   A,C		;restore drive/bank #
      	RRA    			;get bank number of transfer buffer
	RRA
	RRA
	RRA
	AND  0FH
	LD   (BANK),A		;store bank #
        LD   A,C      		;restore drive/bank #
	AND  0FH		;mask drive #
     	CP   MAXDRIVE		;legal drive # ?
	JR   C,TRKNOW		;jump if yes
	LD   A,-1		;error code 1 --> accu
	RET
TRKNOW: LD   (DRIVE),A		;store drive #
	LD   (BUFFER),HL	;store buffer pointer
       	CALL GETWCT		;get control table ptr
	LD   A,D        	;track # (MSB) --> accu
      	CP   (IX+6)		;legal track # ?
	JR   C,SECNOW		;jump if yes
	JR   Z,CPLOW		;compare LSB's
TRKERR:	LD   A,-2		;error code 2 --> accu
	RET
CPLOW:	LD   A,E      		;track (LSB) --> accu
	CP   (IX+5)		;legal track # ?
	JR   NC,TRKERR		;jump if not
SECNOW:	LD   (TRACK),DE		;store track #
	LD   A,B       		;sector # --> accu
	CP   (IX+4)		;legal sector # ?
	JR   C,INITW		;jump if yes
	LD   A,-3		;error code 3 --> accu
	RET

;actual I/O handler:		
INITW:	LD   (SECTOR),A		;store sector #


*EJECT
	COND SASI		;Xebec part

	LD   A,(OLDW)		;number of previously accessed drive --> reg. C
	LD   C,A
	OR   A			;no drive previously accessed ?
	JP   P,INITW1		;select controller
	OUT  (WPORT1),A		;reset controller
INITW1:	LD   A,(DRIVE)		;drive # --> accu
	LD   (OLDW),A		;save it
	CP   C			;same as old drive ?
	JR   Z,INITW2 		;no drive selection needed if yes

;select Winchester drive:
       	LD   IY,WPARS		;^Winchster parameters --> reg. IY
	LD   H,(IX+6)		;track count --> reg. HL
	LD   L,(IX+5)
	LD   D,0   		;clear MSB of divisor
    	LD   E,(IX)  		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	LD   (IY+2),E		;load head count
	CALL DIV		;calc cylinder count
	LD   (IY),H		;load cylinder count
	LD   (IY+1),L
	LD   (IY+3),H		;load starting cylinder 
	LD   (IY+4),L		;for reduced write current
	LD   H,0		;calc startimg cylinder for write precomp
	LD   L,(IX+2)
	ADD  HL,HL
	ADD  HL,HL
	LD   (IY+5),H		;load starting cylinder for write precomp
	LD   (IY+6),L
	LD   A,$INIDRV		;initialize drive data
	CALL TASKOUT

	LD   HL,WPARS		;^Winchester parameters --> reg. HL
	LD   BC,8 SHL 8+WPORT0	;number of bytes	--> reg. B
				;SASI port 0 		--> reg. C
        CALL REQWAIT		;wait for data request
SELDRV:	IN   A,(RPORT1)		;read status again
	AND  IOMASK+CDMASK+REQMASK	
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,SELDRV1		;jump if data transfer finished
	CP   REQMASK
	JR   NZ,SELDRV 		;wait for request
	OTIR			;load disk parameters
	JR   SELDRV

SELDRV1:CALL GETSTAT		;get error status
	JR   NZ,ERREXIT		;any errors ?

INITW2:	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,RWINI		;jump if yes

;restore drive heads:
RESTOW:	LD   A,$TSTDRV		;test drive ready
	CALL TASKOUT
	CALL GETSTAT		;get error status
	JR   NZ,RESTOW		;retry if drive not ready
        LD   A,$REST  		;recalibrate drive
	CALL TASKOUT
	CALL GETSTAT		;get error status
	JR   NZ,ERREXIT		;any errors ?
      	SET  0,(IX+1)		;set init bit in WCT


*EJECT
	ELSE			;WD1002 part

	EX   DE,HL		;track #  --> reg. HL
	LD   D,0   		;clear MSB of divisor
    	LD   E,(IX)  		;get no. of surfaces
	LD   B,5
	SRL  E
	DJNZ $-2
	INC  E
	CALL DIV		;cylinder # = track # / head count (HL)
				;surface #  = track # % head count (DE)
	LD   A,(DRIVE)		;drive # --> accu
	ADD  A,A		;shift drive # 3 bits left
	ADD  A,A
	ADD  A,A
	ADD  A,E		;add surface #
	LD   E,A		;and save it
	LD   A,(IX+1)		;get sector length bits
	RRA
	AND  60H		;mask sector length bits
	ADD  A,E		;add surface # and drive #
	OR   80H		;set ECC error correction bit
	LD   E,A		;save drive select bits
	BIT  0,(IX+1)		;is drive initialized ?
	JR   NZ,TRKSEW 		;yes, skip init process

;restore drive heads:
RESTOW:	IN   A,($STATUS)	;read WDC status
	AND  0C0H		;mask it
	CP   40H		;busy ?
	JR   NZ,RESTOW		;wait `til WDC is ready to accept a command
	OUT  ($SDH),A		;select drive
	LD   A,(IX)		;get step rate bits
	AND  0FH		;mask them
	OR   $REST		;or with "restore" command
	OUT  ($COMND),A		;restore drive heads
RESTO1: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;restore done ?
	JR   NZ,RESTO1 		;no, loop
      	SET  0,(IX+1)		;set init bit in WCT

;set track and sector:
TRKSEW: LD   A,(IX+2)		;set starting track for write precomp
	OUT  ($WPC),A
        LD   A,(SECTOR)		;sector # --> accu
	BIT  4,(IX)		;test number of first sector
	JR   Z,TRKSW1		;jump if zero
	INC  A			;else adjust sector #
TRKSW1:	OUT  ($SECNO),A         ;set sector #
	LD   A,L     		;set cylinder # (LSB)
	OUT  ($CYLLO),A
	LD   A,H                ;set cylinder # (MSB)
	OUT  ($CYLHI),A
	LD   A,E		;restore drive select bits
	OUT  ($SDH),A		;select drive

;init READ/WRITE:
	LD   E,(IX+1)		;get sector length bits
	LD   B,6
	SRL  E
	DJNZ $-2
	LD   C,$DATA		;init byte counter and data port number

	ENDC

RWINI:  LD   HL,(BUFFER)	;get buffer pointer	
	LD   A,(RDFLAG)		;READ or WRITE ?
	OR   A
	PUSH AF			;save status
	JR   Z,RWINI1		;jump if write
	LD   A,$$READ		;issue read command
	JR   RWINI2
RWINI1:	LD   A,$$WRITE		;issue write command
	
	COND SASI		;Xebec part

RWINI2:	CALL TASKOUT

	ELSE

RWINI2:	OUT  ($COMND),A		;WD1002 part

	ENDC

	LD   A,(BANK)		;bank # of transfer buffer --> accu
	JP   IOW		;handle Winchester I/O in common memory

;test controller status:

	COND SASI		;Xebec part

WDCSTAT:CALL GETSTAT		;get status
	RET  Z			;return if no errors
ERREXIT:LD   A,$STATUS		;request sense status
	CALL TASKOUT
	
        CALL REQWAIT		;wait for data request
        IN   A,(RPORT0)		;read error code
	LD   D,A		;save it temporarily
	IN   A,(RPORT0)		;skip rest
	IN   A,(RPORT0)
	IN   A,(RPORT0)
	CALL GETSTAT		;get status 
	JR   NZ,ERREXIT

        LD   A,D      		;restore error code
	AND  7FH
	RET

	ELSE			;WD1002 part

WDCSTAT:IN   A,($STATUS)	;get WDC status
	AND  1  		;any errors ?
	LD   C,A		;save error status
	JR   Z,DSEL		;return if no errors
	IN   A,($ERROR)	        ;read WDC error register
	LD   C,A		;save error code

DSEL:	LD   A,$DSEL 		;deselect drive
	OUT  ($SDH),A
	LD   A,C		;error code --> accu
	RET			;return to caller

	ENDC

;put drive control table pointer in "IX":
GETWCT: PUSH DE			;save reg. DE
	LD   H,0		;drive # --> reg. HL	
	LD   L,A		
	ADD  A,A		;drive # * 2
	ADD  A,L		;drive # * 3
	ADD  A,A		;drive # * 6
	ADD  A,L  		;drive # * 7	
	LD   L,A		;drive # * 7 --> reg. H
	LD   DE,DCTW		;get drive table start
  	ADD  HL,DE		;add offset and get ^DCT
	PUSH HL			;^DCT --> reg. IX
	POP  IX
	POP  DE			;restore reg. DE
	RET			;return

BANK:	DEFS 1			;bank number of transfer buffer


*EJECT
	COND SASI		;Xebec part

;output a command to SASI controller:
TASKOUT:PUSH HL			;save regs. HL & IY
	PUSH IY			;save reg. IY
	LD   IY,DCCMD		;^command block --> reg. IY
	LD   (IY),A		;store command
	LD   A,(DRIVE)		;load drive #
	RRCA
	RRCA
	RRCA
	LD   (IY+1),A
	LD   DE,(TRACK)		;track #         	 --> reg. DE
	LD   HL,0		;clear result
	LD   B,(IX+4)		;sectors/track 		 --> reg. B
TASKO1: ADD  HL,DE		;track # * sectors/track --> reg. HL
	DJNZ TASKO1
	LD   D,0		;sector # 		 --> reg. DE
	LD   A,(SECTOR)
	LD   E,A
	ADD  HL,DE		;block # = track # * sectors/track + sector #
	LD   (IY+2),H		;load block #
	LD   (IY+3),L
	LD   A,(IX)		;get step rate ?
	AND  0FH
	LD   A,0
	JR   NZ,TASKO2  	;jump if not
	LD   A,5		;set buffered step mode
TASKO2: LD   (IY+5),A		;load control byte

TASKO3:	IN   A,(RPORT1)		;read status port
	AND  BUSYMASK		;mask busy bit
	JR   NZ,TASKO3		;jump, if busy
	LD   A,1		;cntlr default select code
	OUT  (WPORT0),A		;send it to transparent latch
TASKO4:	OUT  (WPORT2),A		;generate a select strobe
      	IN   A,(RPORT1)		;get cntlr response
	AND  BUSYMASK		;isolate the busy mask
	JR   Z,TASKO4		;wait for cntlr busy

	LD   HL,DCCMD		;^command block --> reg. HL
	LD   BC,6 SHL 8+WPORT0	;byte count	--> reg. B
				;port number	--> reg. C
	CALL REQWAIT   		;wait for controller request
	OTIR			;load command

	POP  IY			;restore regs. HL & IY
	POP  HL
	RET

;get status:
GETSTAT:CALL REQWAIT		;wait for request
	IN   A,(RPORT0)		;read in the status byte
	LD   C,A		;save status temporarily
	CALL REQWAIT		;wait for second byte
	IN   A,(RPORT0)		;get the null byte
	LD   A,C		;restore status to A
	AND  ERROR		;isolate the error bit
	RET

;Winchester drive parameters:
WPARS:	DEFS 2			;cylinder count
	DEFS 1			;head 	  count
	DEFS 2          	;starting cylinder for reduced write current
	DEFS 2			;starting cylinder for write precompensation
	DEFB 11			;length of ECC impulse

;command control block:
DCCMD:	DEFS 1			;opcode
	DEFS 1			;luno
	DEFS 2			;block number
	DEFB 1			;block count
	DEFS 1			;control field

SENSE:	DEFS 4			;sense status bytes
OLDW:	DEFB 0FFH		;previously accessed drive

	ENDC


*EJECT
;*******************
;*  $ G T I M E 3  *
;*******************

;entry: HL = pointer to a 5 byte buffer containing on exit
;	     date and time in the form DDDDHHMMSS

;	      DDDD = number of days since January 1st, 1978 (binary    )
;		HH = hours   				    (BCD format)
;		MM = minutes 				    (BCD format)
;		SS = seconds 				    (BCD format)

;get time & date in CP/M 3 format (software clock):
$GTIME3S:
	EX   DE,HL		;^user buffer --> reg. DE
	DI			;critical phase
	JP   GTIME5		;transfer time & date into caller's buffer

;get time & date in CP/M 3 format (hardware clock):
$GTIME3H:
	DI			;critical code (not reentrant)
	PUSH HL			;save ^user buffer
        CALL GETTIM		;read time & date from clock chip
	LD   IX,TIMBUF		;^temp buffer   --> reg. IX
	LD   IY,BINARY$DATE 	;^result buffer --> reg. IY	

	LD   A,(IX+7)		;hours (tenths) --> reg. C
	AND  3			;make binary
	RLCA    		;hours (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	--> reg. C
	LD   A,(IX+8)		;hours (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+2),A           ;store BCD hours	

	LD   A,(IX+9)		;minutes (tenths) --> reg. C
	AND  7			;make binary
	RLCA    		;minutes (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+10)		;minutes (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+3),A           ;store BCD minutes

	LD   A,(IX+11)		;seconds (tenths) --> reg. C
	AND  7			;make binary
	RLCA    		;seconds (tenths) --> upper nibble
	RLCA
	RLCA
	RLCA
	LD   C,A		;upper nibble	  --> reg. C
	LD   A,(IX+12)		;seconds (ones)   --> accu
	AND  0FH   		;make binary
	ADD  A,C		;add upper nibble
	LD   (IY+4),A           ;store BCD seconds

	LD   A,(IX+1)		;year (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;year (ones)   --> reg. C
	LD   A,(IX)		;year (tenths) --> accu
	AND  0FH		;make binary
	CALL BCDBIN		;convert BCD year to binary
	LD   (YEAR),A		;store it

	LD   A,(IX+3)		;month (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;month (ones)   --> reg. C
	LD   A,(IX+2)		;month (tenths) --> accu
	AND  1  		;make binary
	CALL BCDBIN		;convert BCD month to binary
	LD   (MONTH),A		;store it

	LD   A,(IX+5)		;day (ones)   --> accu
	AND  0FH		;make binary
	LD   C,A		;day (ones)   --> reg. C
	LD   A,(IX+4)		;day (tenths) --> accu
	AND  3  		;make binary
	CALL BCDBIN		;convert BCD day to binary
	LD   (DAY),A		;store it

	LD   A,(YEAR)		;binary year --> accu
	SUB  78                 ;subtract base year
	JR   NC,GTIME1          ;result negative ?
	ADD  A,100              ;correct year	
GTIME1: SRL  A			;year / 4 --> accu
	RR   C        		;year % 4 --> reg. C
	SRL  A
	RR   C
	LD   B,6
GTIME2: SRL  C
	DJNZ GTIME2
	LD   HL,0               ;clear daycount
	OR   A			;year / 4 == 0 ?
	JR   Z,GTIME4		;no multiplication
	LD   B,A                ;year / 4 --> reg. B
	LD   DE,1461		;number of days in 4 years --> reg. DE
GTIME3: ADD  HL,DE              ;daycount = year / 4 * 1461
	DJNZ GTIME3
GTIME4:	EX   DE,HL		;daycount --> reg. DE

;calc table index:
	LD   A,C		;year %  4    --> accu
	ADD  A,A		;accu *  2
 	ADD  A,A		;accu *  4
	LD   C,A     		;accu *  4    --> reg. C
  	ADD  A,A		;accu *  8
	ADD  A,C   		;accu * 12
	LD   C,A		;accu * 12    --> reg. C
	LD   A,(MONTH)          ;binary month --> accu
	DEC  A     		;normalize
	ADD  A,C		;index = year % 4 * 12 + month - 1
	ADD  A,A		;make byte index
	LD   C,A		;table index       --> reg. BC
	LD   HL,MONTAB          ;base of day table --> reg. HL
	ADD  HL,BC		;add index
	LD   A,(HL)		;table[index]      --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,A

	ADD  HL,DE 		;daycount += table[index]
	LD   A,(DAY)		;binary day --> accu
	LD   C,A   		;day        --> reg. BC
	ADD  HL,BC		;now reg. HL contains number of days
	        		;since January 1st, 1978

	LD   (IY),L 		;store daycount
	LD   (IY+1),H           

	POP  DE			;restore ^user buffer
GTIME5:	LD   HL,BINARY$DATE	;^temporary buffer --> reg. HL
	LD   B,5		;buffer length	   --> reg. B
	LD   A,(INT)		;called from interrupt service routine ?
	OR   A
	LD   A,1  		;source bank      = 0
				;destination bank = 1
	JP   Z,$XMOVE		;move time & date into user buffer and return,
				;if not called from interrupt service routine

	LD   BC,5		;buffer length --> reg. BC
	LDIR			;no interbank move, if called from interrupt
	RET			;service routine

;convert BCD to binary:
BCDBIN:	ADD  A,A		;lower nibble *  2
	LD   B,A		;lower nibble *  2 --> reg. B
	ADD  A,A		;lower nibble *  4
	ADD  A,A		;lower nibble *  8
	ADD  A,B		;lower nibble * 10
	ADD  A,C		;add lower nibble
	RET

YEAR:	DEFS 1
MONTH:	DEFS 1
DAY:	DEFS 1


*EJECT
;*******************
;*  $ S T I M E 3  *
;*******************

;entry:  D = hours   (HH)
;	 E = minutes (MM)
;	HL = number of days since January 1st, 1978 (binary)

;set time & date in CP/M 3 format (software clock):
$STIME3S:
	DI			;critical phase
	LD   (BINARY$DATE),HL	;load binary date
	LD   HL,TIME$IN$BCD	;^BCD time --> reg. HL
	LD   (HL),D		;load BCD hours
	INC  HL
	LD   (HL),E		;load BCD minutes
	INC  HL
	LD   (HL),0		;reset BCD seconds
	RET			;return to caller

;set time & date in CP/M 3 format (hardware clock):
$STIME3H:
	PUSH DE			;save hours & minutes
	PUSH HL			;save daycount
	DEC  HL			;normalize

        XOR  A     		;clear quotient
	LD   DE,1461  		;number of days in 4 years --> reg. DE
STIME1: SBC  HL,DE              ;daycount / 1461 	   --> accu
	JR   C,STIME2
	INC  A
	JR   STIME1
STIME2: ADD  HL,DE              ;adjust remainder
	EX   DE,HL		;remainder --> reg. DE
	ADD  A,A		;accu * 2
	ADD  A,A		;accu * 4
	LD   (YEAR),A           ;year = daycount / 1461 * 4

;search table entry:
	LD   A,47               ;last index 	   --> accu
STIME3: LD   H,0                ;index #           --> reg. HL
	LD   L,A
	ADD  HL,HL  		;make byte index
	LD   BC,MONTAB          ;dase of day table --> reg. BC
	ADD  HL,BC		;calc table entry
	LD   B,(HL)             ;table[index]      --> reg. HL
	INC  HL
	LD   H,(HL)
	LD   L,B
	SBC  HL,DE              ;daycount >= table index ?
	JR   C,STIME4 		;if yes search finished
	JR   Z,STIME4
	DEC  A  		;index = index - 1
	JP   P,STIME3

STIME4: LD   B,0                ;clear quotient
STIME5:	SUB  12                 ;index / 12 --> accu
	JR   C,STIME6
	INC  B			;increment quotient
	JR   STIME5
STIME6:	ADD  A,13		;adjust remainder and calc month
	LD   (MONTH),A          ;store it
	LD   A,(YEAR) 		;year --> accu
	ADD  A,B   		;year += index / 12
	SUB  22			;normalize
	JR   NC,STIME7          ;year negative ?
	ADD  A,100		;correct it
STIME7: LD   (YEAR),A           ;store it
	LD   A,L		;table[index] - daycount --> accu
	NEG     		;daycount - table[index] --> accu
	INC  A     		;day = daycount - table[index] + 1
	LD   (DAY),A            ;store it

	POP  HL			;restore day count
	LD   A,H		;daycount (MSB)	      --> accu
	LD   C,L		;daycount (LSB)	      --> reg. C
	LD   DE,7		;no. of days per week --> reg. DE
	LD   HL,0		;clear accumulator
	LD   B,16		;init counter
STIME8:	RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
	SBC  HL,DE		;subtract divisor
	JR   NC,$+3		;subtraction ok
	ADD  HL,DE		;restore accumulator
	CCF			;complement carry flag
	DJNZ STIME8		;counter = 0 ?
	LD   A,L		;weekday no. --> accu
        PUSH AF 		;save weekday

	LD   A,(MONTH)		;binary month --> accu
	CALL BINBCD		;convert to BCD format
	LD   D,A     		;save month

	LD   A,(DAY)		;binary day --> accu
	CALL BINBCD		;convert to BCD format
	LD   H,A		;BCD day     --> reg. H
	LD   A,(YEAR)		;binary year --> accu
	RRA			;year / 4
	JR   C,STIME9
	RRA
	JR   C,STIME9
       	SET  6,H		;set leapyear flag

STIME9:	LD   A,(YEAR)		;binary year --> accu
	CALL BINBCD		;convert to BCD format
	LD   L,A   		;BCD year    --> reg. L

	LD   B,D		;BCD month   --> reg. B
	POP  AF			;weekday     --> accu
	POP  DE			;BCD hours   --> reg. D
				;BCD minutes --> reg. E
	SET  7,D		;set "24 hour" format
	JP   $SETTIM		;set time & date and return to caller

;convert binary to BCD:
BINBCD:	LD   C,0		;clear result
BINBC1: SUB  10			;accu / 10
	JR   C,BINBC2
	INC  C  		;increment quotient
	JR   BINBC1
BINBC2: ADD  A,10		;adjust remainder
	LD   B,4
BINBC3:	SLA  C			;quotient --> upper nibble
	DJNZ BINBC3
	ADD  A,C		;add remainder
	RET

;day table:
;	     Jan  Feb  Mar  Apr  May  Jun  Jul  Aug  Sep  Oct  Nov  Dec	
MONTAB:	DEFW 0000,0031,0059,0090,0120,0151,0181,0212,0243,0273,0304,0334  ;1978
        DEFW 0365,0396,0424,0455,0485,0516,0546,0577,0608,0638,0669,0699  ;1979
        DEFW 0730,0761,0790,0821,0851,0882,0912,0943,0974,1004,1035,1065  ;1980
        DEFW 1096,1127,1155,1186,1216,1247,1277,1308,1339,1369,1400,1430  ;1981


*EJECT
;*******************
;*  $ L D C H A R  *
;*******************

;entry:  A = ASCII code of character to be loaded (00 - 7F)
;	HL = address of dot matrix (16 bytes)

;load user character:
$LDCHAR:AND  7FH		;make seven bit ASCII code
	PUSH AF			;save ASCII code
	LD   DE,PATTERN		;^dot matrix     --> reg. DE
	LD   B,16		;number of bytes --> reg. B
	LD   A,10H		;source bank 	  = 1
				;destination bank = 0
	CALL $XMOVE		;load matrix
	POP  BC			;ASCII code --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	LD   A,B		;ASCII code --> accu
	LD   (3C00H),A		;load ASCII code
	LD   DE,PATTERN		;^dot matrix 	  	     --> reg. DE
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
LDCHAR1:LD   A,(DE)		;get first scan	line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ LDCHAR1		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	OR   80H		;set MSB
	LD   (3C00H),A		;reload code	
	LD   DE,PATTERN		;^dot matrix 	  	     --> reg. DE
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
LDCHAR2:LD   A,(DE)		;get first scan	line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ LDCHAR2		;load next scan line
	LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A
	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;disable character RAM
	OUT  ($SYS0),A		;write system byte 0
	RET			;return to caller
PATTERN:DEFS 16			;temporary storage area for dot matrix
SAVECH:	DEFS 1


*EJECT
;*******************
;*  $ R S T C H R  *
;*******************

;restore original character set:
$RSTCHR:IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01000100B		;disable boot EPROM
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1
	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	XOR  A  		;reset code counter
	LD   DE,FONTSET		;^dot matrices --> reg. DE
RSTCHR1:LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
RSTCHR2:LD   A,(DE)		;get first scan	line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ RSTCHR2		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	INC  A			;increment ASCII code
	JP   P,RSTCHR1		;load next character

;load inverted characters
	LD   DE,FONTSET		;^dot matrices --> reg. DE
RSTCHR3:LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
RSTCHR4:LD   A,(DE)		;get first scan	line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ RSTCHR4		;load next scan line
	LD   A,(3C00H)		;get ASCII code
	INC  A			;increment ASCII code
	JR   NZ,RSTCHR3		;load next character
	LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A

;select ASCII or national character set:
SELCHR:	IN   A,($SYS0)		;read system byte 0
	AND  00111111B		;enable bank 0
	OR   00000011B		;enable character RAM
	DI			;disable interrupts
	OUT  ($SYS0),A		;write system byte 0
	LD   A,(3C00H)		;save character at 3C00
	LD   (SAVECH),A
	LD   IX,NATIONAL	;^national codes --> reg. IX
	LD   A,(GERMAN)		;national char set ?
	OR   A
	JR   Z,SELCHR1		;jump if no 
	LD   DE,FONTSET+136*16	;^dot matrices  --> reg. DE
	JR   SELCHR2
SELCHR1:LD   DE,FONTSET+128*16	;^dot matrices  --> reg. DE
SELCHR2:LD   A,(IX)		;character code --> accu
	OR   A			;end of table ?
	JR   Z,SELCHR4		;jump if yes
	INC  IX			;bump table ptr
        LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
SELCHR3:LD   A,(DE)		;get first scan	line
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ SELCHR3		;load next scan line
	JR   SELCHR2  		;load next character

;load inverted characters:
SELCHR4:LD   IX,NATIONAL	;^national codes --> reg. IX
        LD   A,(GERMAN)		;national char set ?
	OR   A
	JR   Z,SELCHR5		;jump if no 
	LD   DE,FONTSET+136*16	;^dot matrices  --> reg. DE
	JR   SELCHR6
SELCHR5:LD   DE,FONTSET+128*16	;^dot matrices  --> reg. DE
SELCHR6:LD   A,(IX)		;character code --> accu
	OR   A			;end of table ?
	JR   Z,SELCHR8		;jump if yes
	OR   80H		;make code of inverted char
	INC  IX			;bump table ptr
        LD   (3C00H),A		;load ASCII code
	LD   HL,8400H		;^first character 	     --> reg. HL
	LD   B,16		;maximum count of scan lines --> reg. B
SELCHR7:LD   A,(DE)		;get first scan	line
	CPL			;invert bit pattern
	LD   (HL),A		;load character RAM
	INC  DE			;bump scan line pointer
	LD   A,8		;bump ^scan line in character RAM
	ADD  A,H
	LD   H,A
	DJNZ SELCHR7		;load next scan line
	JR   SELCHR6  		;load next character

SELCHR8:LD   A,(SAVECH)		;restore character at 3C00
	LD   (3C00H),A
	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;disable character RAM
	OUT  ($SYS0),A		;write system byte 0
	EI			;reenable interrupts
	RET			;return to caller


;codes of national character set:
NATIONAL:
	DEFM '@[\]{|}~' 
	DEFB 0


*EJECT
;*******************
;*  $ S C R N I O  *
;*******************

;entry:  A = control code
;	     0  read  window
;	     1  write window
;	HL = address of user buffer
;	 D = 0  contiguous  buffer
;	     1  full screen buffer 	
;	 E = attribute
;	     0  normal   display
;	     1  inverted display	

;direct screen I/O:
$SCRNIO:LD   IX,(VDTABP)	;^screen constants --> reg. IX
	LD   (IOMODE),A		;save I/O mode
	PUSH HL			;save ^user buffer
	PUSH DE			;save buffer mode
	LD   A,(IX+8)		;save current line
	LD   (SLINE),A
	LD   A,(IX+9)		;save current column
	LD   (SCOLUMN),A
	LD   A,(IX+11)		;save current display mode
	LD   (SMODE),A	
	LD   A,(IX+12)		;save cursor state
	LD   (SCUROFF),A
	LD   A,(WRAP)		;save "wrap around" mode
	LD   (SWRAP),A
	DEC  E			;test display mode
	JR   Z,SCRNIO1		;jump if inverse display mode
	CALL INVOFF		;turn on normal display mode 
	JR   SCRNIO2
SCRNIO1:CALL INVON		;turn on inverse display mode
SCRNIO2:CALL CUROFF		;turn off cursor
	CALL WRAPOFF		;turn off "wrap around" mode
	CALL HOME		;home cursor
	
	POP  DE			;get buffer mode
	DEC  D			;calc buffer increment
	JR   Z,SCRNIO3		;jump if full screen buffer
	LD   A,(IX+7)		;buffer increment = column count
	JR   SCRNIO4
SCRNIO3:LD   A,(IX+1)		;buffer increment = maximum column count
	POP  DE			;get base address of screen buffer
	ADD  HL,DE		;add cursor address (returned from "HOME")
	PUSH HL			;save actual buffer address
SCRNIO4:LD   (BINC),A		;store buffer increment

;screen I/O:
	LD   A,(IOMODE)		
	OR   A			;read or write screen ?
	JR   NZ,SCRNIO9		;jump if write screen


*EJECT
;read screen:
SCRNIO5:LD   IY,LINBUF		;^temp buffer --> reg. IY
	LD   B,(IX+7)		;column count --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1

SCRNIO6:PUSH BC			;save remaining column count
	LD   HL,(CURADR)	;absolute screen address --> reg. HL
	LD   A,(HL)		;character under cursor  --> accu
	AND  7FH		;mask it
	CP   (IX+10)		;erase character ?
	JR   NZ,SCRNIO7		;jump if not
	LD   A,' '		;convert it to space
SCRNIO7:CP   ' '		;graphic character ?
	JR   NC,SCRNIO8		;jump if not
	ADD  A,80H		;convert code of graphic character
SCRNIO8:LD   (IY),A		;store character
	INC  IY			;inc buffer pointer
	CALL CURRGT		;move cursor right
	POP  BC			;restore column count
	DJNZ SCRNIO6		;read next character

	IN   A,($SYS1)		;read system byte 1
	OR   01010101B		;disable memory mapped I/O
	OUT  ($SYS1),A		;write system byte 1
	LD   HL,LINBUF		;source      address --> reg. HL
	POP  DE			;destination address --> reg. DE
	PUSH DE
	LD   B,(IX+7)		;byte count	     --> reg. B
	LD   A,1		;source      bank = 0
				;destination bank = 1
	CALL $XMOVE		;transfer screen line into user buffer

        LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; == bottom line ?
	JR   Z,SCRNI12      	;jump if yes

	CALL NEWLIN		;carriage return
	CALL CURDWN		;line feed

	LD   HL,(BINC)		;buffer increment --> reg. HL
	LD   H,0
	POP  DE			;buffer pointer   --> reg. DE
	ADD  HL,DE		;increment buffer pointer
	PUSH HL			;save it
	JR   SCRNIO5		;read next line


*EJECT
;write screen:
SCRNIO9:POP  HL			;source      address --> reg. HL
SCRNI10:PUSH HL			;save it
	LD   DE,LINBUF		;destination address --> reg. HL
	LD   B,(IX+7)		;byte count	     --> reg. B
	LD   A,10H		;source      bank = 1
				;destination bank = 0
	CALL $XMOVE		;transfer screen line into user buffer

        LD   IY,LINBUF		;^temp buffer --> reg. IY
	LD   B,(IX+7)		;column count --> reg. B
	IN   A,($SYS1)		;read system byte 1
	AND  11010110B		;enable memory mapped I/O
				;disable graphic page
	OR   01010100B		;disable boot EPROM
				;enable full screen
				;7.2 MHz clock frequency
	OUT  ($SYS1),A		;write system byte 1

SCRNI11:PUSH BC			;save remaining column count
	LD   A,(IY)		;character --> accu
	CALL NORMAL		;display character
	INC  IY			;inc buffer pointer
	POP  BC			;restore column count
	DJNZ SCRNI11		;display next character

	IN   A,($SYS1)		;read system byte 1
	OR   01010101B		;disable memory mapped I/O
	OUT  ($SYS1),A		;write system byte 1

        LD   A,(IX+8)		;current line --> accu
	CP   (IX+4)		; == bottom line ?
	JR   Z,SCRNI12		;jump if yes

	CALL NEWLIN		;carriage return
	CALL CURDWN		;line feed

	LD   HL,(BINC)		;buffer increment --> reg. HL
	LD   H,0
	POP  DE			;buffer pointer   --> reg. DE
	ADD  HL,DE		;increment buffer pointer
	JR   SCRNI10		;write next line


*EJECT
;restore old screen state:
SCRNI12:POP  HL			;adjust stack pointer
	LD   A,(SLINE)		;restore current line
	LD   (IX+8),A
	LD   A,(SCOLUMN)	;restore current column
	LD   (IX+9),A
	LD   A,(SMODE)		;restore current display mode
	LD   (IX+11),A		
	LD   A,(SCUROFF)	;restore cursor state
	LD   (IX+12),A		
	LD   A,(SWRAP)		;restore "wrap around" mode
	LD   (WRAP),A
	CALL OUTCUR		;position cursor
	JP   CURON+4		;turn on (?) cursor and return to caller

;temporary storage area:
SLINE:	DEFS 1			;current cursor line
SCOLUMN:DEFS 1			;current cursor column
SMODE:	DEFS 1			;current display mode
SCUROFF:DEFS 1			;current cursor state
SWRAP:	DEFS 1			;current "wrap around" mode
IOMODE:	DEFS 1			;read or write screen ?
BINC:	DEFS 1			;buffer pointer increment
LINBUF:	DEFS 80			;line buffer


*EJECT
;***************
;*  $ I N I T  *
;***************

;general initialization routine:
$INIT:	DI			;disable interrupts
	IM   1			;select interrupt mode 1 (RST 38H)
 	IN   A,($SYS0)		;read system byte 0
	AND  00110011B		;enable bank 0
				;RTC interrupt only
	OUT  ($SYS0),A		;write system byte 0

	CALL $RSTCHR		;load character set

	XOR  A			;source bank      = 0
				;destination bank = 0
	LD   HL,VIDPAR		;^video parameters --> reg. HL
	CALL VDINIT1		;initialize video controller chip MC6845

	LD   A,ESC		;select national character set
	CALL $VDCHAR
	LD   A,(CHRSET)
	CALL $VDCHAR

	LD   B,0		;# of RS232C interface --> reg. B
	LD   HL,(SER0)		;data format 	       --> accu
	LD   A,L
	LD   E,H		;baud rate   	       --> reg. E
	CALL $RSINIT		;initialize Z80 SIO A

	LD   B,1		;# of RS232C interface --> reg. B
	LD   HL,(SER1)		;data format 	       --> accu
	LD   A,L
	LD   E,H		;baud rate   	       --> reg. E
	CALL $RSINIT		;initialize Z80 SIO B

	LD   HL,PIO$INIT$TBL	;initialize Z80 PIO 
STREAM$OUT:
	LD   A,(HL)
	OR   A
	JR   Z,$FCINIT
	LD   B,A
	INC  HL
	LD   C,(HL)
	INC  HL
	OTIR
	JR   STREAM$OUT		;now Z80 PIO acts as Centronics interface
PIO$INIT$TBL:
	DEFB 2,0D6H,0FH,07H
	DEFB 3,0D7H,0CFH,0F0H,07H
	DEFB 1,0D5H,01H
	DEFB 0

$FCINIT:LD   A,$FCINT           ;initialize floppy disk controller chip WD2791
        OUT  ($FDCMD),A


*EJECT
;powerup/reset test:
	LD   A,10H		;source      bank    = 1
				;destination bank    = 0
	LD   HL,0038H		;source      address = interrupt entry point
	LD   DE,JUMP		;destination address = test variable
	LD   B,1		;byte count 	     = 1
	CALL $XMOVE		;get byte from interrupt entry point in bank 1

	LD   A,(JUMP)		;JP ?
	CP   0C3H
	JR   NZ,$POWUP		;jump if power up
	XOR  A			;clear power up marker
	JR   $RESET
$POWUP:	LD   HL,1		;reset binary date
	LD   (BINARY$DATE),HL
	LD   HL,TIME$IN$BCD	;^BCD time --> reg. HL
	XOR  A
	LD   (HL),A		;reset BCD hours
	INC  HL
	LD   (HL),A		;reset BCD minutes
	INC  HL
	LD   (HL),A		;reset BCD seconds
	CPL        		;set power up marker
$RESET: LD   (POWUP),A

;set interrupt jump vectors:
	LD   A,3		;initialize bank number
$SETINT:LD   HL,0038H		;interrupt entry point --> reg. HL & DE
	LD   D,H
	LD   E,L
	LD   B,3		;byte count 	       --> reg. B
	PUSH AF			;save bank number
	CALL $XMOVE		;transfer jump vector
	POP  AF			;restore bank number
	DEC  A			;decrement bank number
	JR   NZ,$SETINT		;load next interrupt entry point

;hardware clock ?
	LD   A,(CLOCK)
	OR   A
	JR   Z,$CLSGR		;jump if not
	LD   HL,$GTIME3H	;alter entry vectors to 
	LD   ($GTIME3),HL	;clock maintenance routine
	LD   HL,$STIME3H
	LD   ($STIME3),HL

;clear graphic pages:
$CLSGR:	XOR  A			;colour = black
	LD   B,A		;clear graphic page 0
	CALL $CLS
	XOR  A			;colour = black
	LD   B,1		;clear graphic page 1
	CALL $CLS

;calc number of graphic scan lines:
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   DE,(VIDPAR+6)	;number of text	lines		    --> reg. DE
	LD   D,0
	LD   H,D
	LD   L,D
LOOP:	ADD  HL,DE		;calc total number of scan lines - 1
	DJNZ LOOP
	DEC  HL
	LD   (YMAX),HL		;store them		

;build table of y-addresses:
	LD   BC,(VIDPAR+5)	;number of text lines --> reg. B
	LD   DE,YTAB		;^address table	      --> reg. DE
	LD   HL,8000H   	;^graphic screen      --> reg. HL
OLOOP:	PUSH BC			;save line counter
	LD   (YBASE),HL		;store base address
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
ILOOP:	LD   A,L		;calc y address
	LD   (DE),A
	INC  DE
	LD   A,H
	LD   (DE),A
	INC  DE
	LD   A,8
	ADD  A,H
	LD   H,A
	DJNZ ILOOP		;process next scan line
	LD   HL,(YBASE)		;bump base address
	LD   BC,80
	ADD  HL,BC
	POP  BC			;restore line counter
	DJNZ OLOOP		;process next text line

;build table of normalized y-addresses:
	LD   IX,YNTAB		;^address table --> reg. IX
	LD   DE,0		;initialize scan line counter

NOLOOP:	PUSH DE			;save it

	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   HL,0			
NILOOP:	ADD  HL,DE		;y-coordinate * # of scan lines
	DJNZ NILOOP

	LD   DE,18		;load divisor
	CALL DIV
	LD   A,E		;remainder --> accu
	CP   9			;remainder >= 9 ?
	JR   C,$+3  		;jump if not
	INC  HL			;round normalized y-coordinate

	ADD  HL,HL		;make word index
	LD   DE,YTAB		;^unnormalized address table --> reg. DE
	ADD  HL,DE		;calc entry address
	LD   A,(HL)		;copy table entry
	LD   (IX),A
	INC  IX
	INC  HL
	LD   A,(HL)
	LD   (IX),A
	INC  IX
	
	POP  DE			;restore scan line counter
	INC  DE			;increment it
	LD   HL,450		;total count of scan lines --> reg. HL
	CALL CMP		;reached ?
	JR   NZ,NOLOOP		;process next scan line if not
	RET

YBASE:	DEFS 2       		;base address of graphic screen - 80
JUMP:	DEFS 1			;byte at 0038H in bank 1


*EJECT
;*****************
;*  $ C L O C K  *
;*****************

;entry: A =  0  clock display off
;	  <> 0  clock display on
;	B = line   number (0 - 24)
;	E = column number (0 - 79)

;set clock display on/off:
$CLOCK:	LD   IX,(VDTABP)	;^screen constants 		  --> reg. IX
	LD   HL,$SCREEN		;address of first screen location --> reg. HL
	LD   C,E		;display column			  --> reg. C
	LD   D,0		;maximum column count		  --> reg. DE
	LD   E,(IX+1)
	DEC  B			;calc absolute screen address
	INC  B
	JR   Z,CLOCK2
CLOCK1:	ADD  HL,DE
	DJNZ CLOCK1
CLOCK2:	LD   E,C
	ADD  HL,DE
	LD   (CLOCK$LOC),HL	;save display address
       	LD   (CLOCKON),A	;set/reset display marker
	RET			;return to caller
CLOCKON:DEFB 0
CLOCK$LOC:
	DEFS 2


*EJECT
;***************
;*  $ D I S P  *
;***************

;entry: A =  0  turn off graphic display
;	  <> 0  turn on  graphic display
;	B =  graphic page number (0, 1)

$DISP:	LD  C,A			;save accu
	IN  A,($SYS0)		;read system byte 0
	AND 00100001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	INC B			;test page number
	DEC B
	JR  Z,DISP1		;jump if page 0
  	SET 4,A			;select page 1
DISP1:	OUT ($SYS0),A		;write system byte 0
	
	IN  A,($SYS1)		;read system byte 1
	AND 11010101B		;7.2 MHz clock rate
				;disable graphic page
				;disable boot ROM
				;disable graphic display
				;disable memory mapped I/O
	INC C			;test display mode
	DEC C
	JR  Z,DISP2		;jump if no display
	SET 1,A			;enable graphic display
DISP2:	OUT ($SYS1),A		;write system byte 1
	RET			;return to caller


*EJECT
;*************
;*  $ C L S  *
;*************

;entry: A = 0  black
;	    1  white
;	B = graphic page number (0, 1)

;clear graphic page:
$CLS:	LD  C,A			;save colour
	IN  A,($SYS0)		;read system byte 0
	AND 00010001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	INC B			;test page number
	DEC B
	JR  Z,CLS1		;jump if page 0
	SET 5,A			;select page 1
CLS1:	OUT ($SYS0),A		;write system byte 0


	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	LD  A,C			;restore colour
	LD  HL,8000H		;^graphic memory        --> reg. HL
	LD  DE,8001H		;^graphic memory + 1    --> reg. DE
	LD  BC,7FFFH		;size of graphic memory --> reg. BC
	OR  A			;colour ?
	JR  Z,CLS2		;jump if black
	LD  A,0FFH		;select white
CLS2:	LD  (HL),A
	LDIR			;clear graphic page

	IN  A,($SYS1)		;read system byte 1
	AND 11010111B		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	RET			;return to caller


*EJECT
;***************
;*  $ P L O T  *
;***************

;entry:  A = 0  non-normalized (high nibble) 
;	     1      normalized 
;	     0  black          (low  nibble)
;	     1  white
;        B = graphic page number (0, 1)
;	HL = y-coordinate (0 - YYY)
;	DE = x-coordinate (0 - 639)

$PLOT:	PUSH BC			;save graphic page #
      	PUSH AF			;save colour
	PUSH DE			;save x-coordinate
	AND  0F0H		;normalize y-coordinate ?
	JR   Z,PLOT1		;jump if not
	
;normalize y-coordinate:
      	EX   DE,HL		;y-coordinate 		  --> reg. DE
	OR   A			;clear carry flag
 	LD   HL,449   		;maximum scan line number --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   C,PLOT2		;jump if overflow

      	PUSH DE			;save x-coordinate
	
 	ADD  HL,HL        	;make word index
	LD   DE,YNTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL) 
	JR   PLOT4


*EJECT
PLOT1:	EX   DE,HL		;y-coordinate 		  --> reg. DE
	OR   A			;clear carry flag
 	LD   HL,(YMAX)		;maximum scan line number --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   NC,PLOT3		;jump if no overflow
PLOT2:	POP  HL			;adjust stack
	POP  HL
	RET

PLOT3:	PUSH DE			;save x-coordinate
	
 	ADD  HL,HL        	;make word index
	LD   DE,YTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL) 

PLOT4:	POP  HL			;get x-coordinate
;divide x-coordinate by 8:
	XOR  A			;clear remainder
	SRL  H			;/ 2
	RR   L
	RRA
	SRL  H			;/ 4
	RR   L
	RRA
	SRL  H			;/ 8
	RR   L
	RRA

	LD   C,A		;save accu
	LD   A,H		;test MSB of result
	OR   A
	JR   NZ,PLOT2		;return if overflow
	LD   A,L		;test LSB of result
	CP   80
	JR   NC,PLOT2		;return if overflow
	LD   A,C		;restore accu

	ADD  HL,DE		;final result = y-address + x / 8
	SET  7,H		;select upper 32K page

	RRA			;build SET/RES instruction
	RRA
	OR   0C6H		;SET instruction
	POP  BC			;get colour
	BIT  0,B		;black or white ?
	JR   NZ,$+4		;jump if white
	AND  0BEH		;RES instruction
	LD   (SETRES),A		;load instruction

	IN   A,($SYS0)		;read system byte 0
	AND  00010001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	POP BC			;get  page number
	INC B			;test page number
	DEC B
	JR  Z,PLOT5		;jump if page 0
	SET 5,A			;select page 1
PLOT5:	OUT ($SYS0),A		;write system byte 0

	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	DEFB 0CBH		;SET/RES dot
SETRES:	DEFS 1

	IN  A,($SYS1)		;read system byte 1
	AND 11010111B		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	EI			;reenable interrupts
	RET			;return to caller

YMAX:	DEFS 2			;total number of scan lines
YTAB:	DEFS 800		;addresses of all y-coordinates
YNTAB:	DEFS 900		;address of all normalized y-coordinates


*EJECT
;*****************
;*  $ P O I N T  *
;*****************

;entry:  B = graphic page number (0, 1)
;	HL = y-coordinate (0 - YYY)
;	DE = x-coordinate (0 - 639)
;
;exit :  A = 0  black
;	     1  white

$POINT:	PUSH BC			;save graphic page #
	PUSH DE			;save x-coordinate
	
POINT1:	EX   DE,HL		;y-coordinate 		    --> reg. DE
	OR   A			;clear carry flag
 	LD   HL,(YMAX)		;total number of scan lines --> reg. HL
	SBC  HL,DE		;calc physical y-coordinate
	POP  DE			;restore x-coordinate
	JR   NC,POINT3		;jump if no overflow
POINT2:	XOR  A			;clear accu
	POP  HL			;adjust stack
	RET

POINT3:	PUSH DE			;save x-coordinate
	
 	ADD  HL,HL        	;make word index
	LD   DE,YTAB		;^y-addresses --> reg. DE
	ADD  HL,DE		;get entry address
	LD   E,(HL)		;y-address    --> reg. DE
	INC  HL
	LD   D,(HL) 

      	POP  HL			;get x-coordinate
;divide x-coordinate by 8:
	XOR  A			;clear remainder
	SRL  H			;/ 2
	RR   L
	RRA
	SRL  H			;/ 4
	RR   L
	RRA
	SRL  H			;/ 8
	RR   L
	RRA

	LD   C,A		;save accu
	LD   A,H		;test MSB of result
	OR   A
	JR   NZ,POINT2		;return if overflow
	LD   A,L		;test LSB of result
	CP   80
	JR   NC,POINT2		;return if overflow
	LD   A,C		;restore accu

	ADD  HL,DE		;final result = y-address + x / 8
	SET  7,H		;select upper 32K page

	RRA			;build BIT instruction
	RRA
	OR   46H
	LD   (BITTST),A		;load instruction

	IN   A,($SYS0)		;read system byte 0
	AND  00010001B	 	;enable bank 0
				;select graphic page 0
				;RTC interrupt only
				;disable character RAM
	POP BC			;get  page number
	INC B			;test page number
	DEC B
	JR  Z,POINT4		;jump if page 0
	SET 5,A			;select page 1
POINT4:	OUT ($SYS0),A		;write system byte 0

	IN  A,($SYS1)		;read system byte 1
	OR  01011101B		;7.2 MHz clock rate
				;enable graphic page
				;disable boot ROM
				;disable memory mapped I/O
	DI			;disable interrupts
	OUT ($SYS1),A		;write system byte 1

	DEFB 0CBH		;BIT test
BITTST:	DEFS 1

	IN  A,($SYS1)		;read system byte 1
	RES 3,A      		;disable graphic page
	OUT ($SYS1),A		;write system byte 1
	EI			;reenable interrupts

	LD   A,0		;clear accu
	RET  Z			;accu = 0 if dot = black
	INC  A			;accu = 1 if dot = white
	RET			;return to caller


*EJECT
;***************
;*  $ L I N E  *
;***************

;entry:  A = 0  non-normalized (high nibble) 
;	     1      normalized 
;	     0  black          (low  nibble)
;	     1  white
;        B = graphic page number (0, 1)
;	HL = ^coordinates (x1, y1, x2, y2)

;draw line:
$LINE:	PUSH BC			;save page number
	PUSH AF			;save mode & colour
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X1		;^coordinates --> reg. DE
	LD   B,8		;byte count   --> reg. BC	
	CALL $XMOVE		;get coordinates
	POP  AF			;get mode
	LD   C,A		;save colour
	AND  0F0H		;normalize y-coordinates ?
	LD   A,C		;restore colour
	PUSH AF			;save colour
	JR   Z,LINE4		;jump if not

;normalize y-coordinates:
	POP  AF			;get colour
	AND  0FH		;mask mode
	PUSH AF
	LD   B,2		;y1, y2
	LD   IX,Y1		;^first y-coordinate 		    --> reg. IX
LINE1:	PUSH BC			;save counter
	LD   BC,(VIDPAR+8)	;number of scan lines per text line --> reg. B
	INC  B
	LD   D,(IX+1)		;y-coordinate 			    --> reg. DE
	LD   E,(IX)
	LD   HL,0
LINE2:	ADD  HL,DE		;y-coordinate * # of scan lines
	DJNZ LINE2

	LD   DE,18		;load divisor
	CALL DIV
	LD   A,E		;remainder --> accu
	CP   9			;remainder >= 9 ?
	JR   C,LINE3		;jump if not
	INC  HL			;round normalized y-coordinate
LINE3:	LD   (IX+1),H		;store normalized y-coordinate
	LD   (IX),L
	INC  IX			;get ^second y-coordinate
	INC  IX 		
	INC  IX 
	INC  IX
	POP  BC			;restore counter
	DJNZ LINE1		;normalize second y-coordinate
	 	
;calc px and dx:
LINE4:	LD   HL,0		;clear pp
	LD   (PP),HL
      	LD   HL,(X2)		;second x-coordinate --> reg. HL
	LD   DE,(X1)		;first  x-coordinate --> reg. DE
	CALL CMP		;x2 >= x1 ?
	JP   M,LINE5		;jump if x2 < x1
	LD   BC,1		;dx = 1
	JR   LINE6
LINE5:	LD   BC,-1		;dx = -1
	EX   DE,HL		
LINE6:	LD   (DX),BC		;store dx
	OR   A
	SBC  HL,DE		;px = x2 - x1 + 1 (x1 - x2 + 1)
	INC  HL
	LD   (PX),HL
	
;calc py and dy:
      	LD   HL,(Y2)		;second y-coordinate --> reg. HL
	LD   DE,(Y1)		;first  y-coordinate --> reg. DE
	CALL CMP		;y2 >= y1 ?
	JP   M,LINE7		;jump if y2 < y1
	LD   BC,1		;dy = 1
	JR   LINE8
LINE7:	LD   BC,-1		;dy = -1
	EX   DE,HL		
LINE8:	LD   (DY),BC		;store dx
	OR   A
	SBC  HL,DE		;py = y2 - y1 + 1 (y1 - y2 + 1)
	INC  HL
	LD   (PY),HL
	
;plot first dot:
	CALL LPLOT		;plot first point of line

;py <= px:
	LD   HL,(PX)		;px --> reg. HL
	LD   DE,(PY)		;py --> reg. DE
	CALL CMP		;py <= px ?
	JP   M,YLIN		;jump if py > px
XLIN:	LD   HL,(X1)
	LD   DE,(X2)
	CALL CMP		;x1 == x2 ?
	JP   Z,ENDLIN		;break if yes
	LD   HL,(PP)		;pp += py
	LD   DE,(PY)
	ADD  HL,DE	
	LD   (PP),HL
	LD   DE,(PX)
	CALL CMP		;pp >= px
	JP   M,XLIN1		;jump pp < px
	OR   A
	SBC  HL,DE		;pp -= px
	LD   (PP),HL
	LD   HL,(Y1)		;y1 += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (Y1),HL
XLIN1:	LD   HL,(X1)		;x1 += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (X1),HL
	CALL LPLOT		;plot next point of line
	JR   XLIN 	

;py > px:
YLIN:	LD   HL,(Y1)
	LD   DE,(Y2)
	CALL CMP		;y1 == y2 ?
	JR   Z,ENDLIN		;break if yes
	LD   HL,(PP)		;pp += px
	LD   DE,(PX)
	ADD  HL,DE	
	LD   (PP),HL
	LD   DE,(PY)
	CALL CMP		;pp >= py
	JP   M,YLIN1		;jump pp < py
	OR   A
	SBC  HL,DE		;pp -= py
	LD   (PP),HL
	LD   HL,(X1)		;x1 += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (X1),HL
YLIN1:	LD   HL,(Y1)		;y1 += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (Y1),HL
	CALL LPLOT		;plot next point of line
	JR   YLIN

;end of draw line routine:
ENDLIN:	POP  HL			;adjust stack
	POP  HL
	RET

;plot (x1, y1):
LPLOT:	POP  HL			;skip return address
 	POP  AF			;get colour
	POP  BC			;get graphic page
	PUSH BC			;save that suckers again
	PUSH AF
	PUSH HL			;save return address
	LD   HL,(Y1)		;y-coordinate --> reg. HL
	LD   DE,(X1)		;x-coordinate --> reg. DE
	JP   $PLOT

;variables for draw line, circle, and arc:
XM:	DEFS 2
YM:	DEFS 2
XX:
X1:	DEFS 2
YY:
Y1:	DEFS 2
X2:	DEFS 2
Y2:	DEFS 2
M1:
PX:	DEFS 2	
M2:
PY:	DEFS 2
DD:
PP:     DEFS 2
N1:	
XB:
XB1:	DEFS 2
N2:	
XB2:	DEFS 2
II:
N3:	DEFS 2
P1:	DEFS 2
P2:	DEFS 2
DX:	DEFS 2
DY:	DEFS 2 


*EJECT
;*******************
;*  $ C I R C L E  *
;*******************

;entry:  A = 0  black
;	     1  white
;        B = graphic page number (0, 1)
;	HL = ^coordinates, radius (xm, ym, r)

;draw circle:
$CIRCLE:PUSH BC			;save page number
	SET  4,A		;force normalizing
	PUSH AF			;save colour & mode
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,XM		;^coordinates --> reg. DE
	LD   B,6		;byte count   --> reg. BC	
	CALL $XMOVE		;get coordinates

	LD   HL,0		;dd = yy = 0
	LD   (DD),HL
	LD   (YY),HL
	LD   HL,(XX)		;m1 = 1 - (xx + xx)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	LD   (M2),HL		;m2 = 1
	OR   A
	SBC  HL,DE
	LD   (M1),HL

*EJECT
;plot first dots:
	LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym      --> reg. HL
	CALL CPLOT
		
	LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym      --> reg. HL
	CALL CPLOT
		
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   DE,(XX)
	ADD  HL,DE
	LD   DE,(XM)		;xm      --> reg. DE
	CALL CPLOT
		
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	LD   DE,(XM)		;xm      --> reg. DE
	CALL CPLOT
		
*EJECT
;circle loop:

;calc next coordinates:
CIRCLE1:LD   HL,(M1)		;p1 = m1 + d
	LD   DE,(DD)
	ADD  HL,DE
	LD   (P1),HL
	LD   HL,(M2)		;p2 = m2 + d
	ADD  HL,DE
	LD   (P2),HL

        LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
        LD   HL,(M2)		;m2 += 2
	INC  HL
	INC  HL
	LD   (M2),HL

	LD   HL,(P2)
	CALL ABS
	EX   DE,HL
	LD   HL,(P1)
	LD   DE,(M2)
	ADD  HL,DE
	CALL ABS
	CALL CMP		;jump if
	JR   C,CIRCLE2		;abs(p1 + m2) < abs(p2)

        LD   HL,(P2)		;dd = p2
	LD   (DD),HL
	JR   CIRCLE3

CIRCLE2:LD   HL,(XX)		;xx--
	DEC  HL
	LD   (XX),HL
	LD   HL,(P1)		;dd = p1 + m2
	LD   DE,(M2)
	ADD  HL,DE
	LD   (DD),HL
	LD   HL,(M1)		;m1 += 2
	INC  HL
	INC  HL
	LD   (M1),HL

*EJECT
;plot dots:
CIRCLE3:LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - yy --> reg. HL
	LD   BC,(YY)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - xx --> reg. DE
	LD   DE,(XX)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - yy --> reg. HL
	LD   BC,(YY)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm + yy --> reg. DE
	LD   DE,(YY)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   BC,(XX)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - yy --> reg. DE
	LD   DE,(YY)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + xx --> reg. HL
	LD   BC,(XX)
	ADD  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm + yy --> reg. DE
	LD   DE,(YY)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   BC,(XX)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
        LD   HL,(XM)		;xm - yy --> reg. DE
	LD   DE,(YY)
	OR   A
	SBC  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym - xx --> reg. HL
	LD   BC,(XX)
	OR   A
	SBC  HL,BC
	CALL CPLOT
		
	LD   HL,(XX)
	LD   DE,(YY)
	CALL CMP		;jump if
	JP   P,CIRCLE1		;xx >= yy

	POP  HL			;adjust stack
	POP  HL	
	RET

;plot (xx, yy):
CPLOT:	POP  IX			;skip return address
 	POP  AF			;get colour & mode
	POP  BC			;get graphic page
	PUSH BC			;save that suckers again
	PUSH AF
	PUSH IX			;save return address
	JP   $PLOT


*EJECT
;*************
;*  $ A R C  *
;*************

;entry:  A = 0  black
;	     1  white
;        B = graphic page number (0, 1)
;	HL = ^coordinates (xm, ym, x1, y1, x2, y2)

;draw arc:
$ARC:   PUSH BC			;save page number
	SET  4,A		;force normalizing
	PUSH AF			;save colour & mode
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,XM		;^coordinates --> reg. DE
	LD   B,12		;byte count   --> reg. BC	
	CALL $XMOVE		;get coordinates

	LD   HL,0		;dd = 0
	LD   (DD),HL
	LD   HL,(X1)		;xx = x1 - xm
	LD   DE,(XM)
	OR   A
	SBC  HL,DE
	LD   (XX),HL
	LD   HL,(X2)		;x2 -= xm
	OR   A
	SBC  HL,DE
	LD   (X2),HL
	LD   HL,(Y1)		;yy = y1 - ym
	LD   DE,(YM)
	OR   A
	SBC  HL,DE
	LD   (YY),HL
	LD   HL,(Y2)		;y2 -= xm
	OR   A
	SBC  HL,DE
	LD   (Y2),HL

;plot first dot:
	LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
		
*EJECT
;arc loop:

;calc next coordinates:
ARC1:   LD   HL,(YY)		
	BIT  7,H		;jump if
	JR   NZ,ARC2		;yy < 0
	LD   HL,-1		;dx = -1
	LD   (DX),HL   
	LD   HL,(XX)		;m1 = 1 - (xx + xx)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	OR   A
	SBC  HL,DE
	JR   ARC3
ARC2:	LD   HL,(XX)		;m1 = 1 + xx + xx
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1		;dx = 1
	LD   (DX),HL
	ADD  HL,DE
ARC3:	LD   (M1),HL

        LD   HL,(XX)		
	BIT  7,H		;jump if
	JR   NZ,ARC4		;xx < 0
     	LD   HL,(YY)		;m2 = 1 + yy + yy
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1		;dy = 1
	LD   (DY),HL
	ADD  HL,DE
	JR   ARC5
ARC4:	LD   HL,-1		;dy = -1
	LD   (DY),HL
	LD   HL,(YY)		;m2 = 1 - (yy + yy)
	ADD  HL,HL
	EX   DE,HL
	LD   HL,1
	OR   A
	SBC  HL,DE
ARC5:	LD   (M2),HL

	LD   DE,(DD)		;p2 = m2 + dd
	ADD  HL,DE
	LD   (P2),HL
	CALL ABS		;n3 = abs(p2)
	LD   (N3),HL
	LD   HL,(M1)		;p1 = m1 + d
	ADD  HL,DE
	LD   (P1),HL
	CALL ABS		;n1 = abs(p1)
	LD   (N1),HL
	LD   HL,(P1)		;n2 = abs(p1 + m2)
	LD   DE,(M2)
	ADD  HL,DE
	CALL ABS
	LD   (N2),HL

	LD   DE,(N1)
	CALL CMP		;jump if
	JR   C,ARC8   		;n1 >= n2
	JR   Z,ARC8   
	LD   HL,(N3)
	CALL CMP		;jump if
	JR   C,ARC6   		;n1 >= n3
	JR   Z,ARC6   

	LD   HL,(XX)		;xx += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (XX),HL
	LD   HL,(P1)		;dd = p1
	LD   (DD),HL
	JR   ARC9

ARC6:   LD   HL,(P2)		;dd = p2
	LD   (DD),HL
ARC7:   LD   HL,(YY)		;yy += dy
	LD   DE,(DY)
	ADD  HL,DE
	LD   (YY),HL
	JR   ARC9

ARC8:   LD   DE,(N3)
	CALL CMP		;jump if
	JP   P,ARC6   		;n2 >= n3

        LD   HL,(XX)		;xx += dx
	LD   DE,(DX)
	ADD  HL,DE
	LD   (XX),HL
	LD   HL,(P1)		;dd = p1 + m2
	LD   DE,(M2)
	ADD  HL,DE
	LD   (DD),HL
	JR   ARC7


*EJECT
;plot dot:
ARC9:   LD   HL,(XM)		;xm + xx --> reg. DE
	LD   DE,(XX)
	ADD  HL,DE
	EX   DE,HL
	LD   HL,(YM)		;ym + yy --> reg. HL
	LD   BC,(YY)
	ADD  HL,BC
	CALL CPLOT
		
	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JP   NZ,ARC1		;xx != x2
	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   NZ,ARC1		;yy != y2

	POP  HL			;adjust stack
	POP  HL	
	RET


*EJECT
;***************
;*  $ F I L L  *
;***************

;entry:  A = 0  non-normalized   	(high nibble) 
;	     1      normalized 
;	     graphic page number (0, 1) (low  nibble)
;	BC = ^fill pattern
;       HL = y-coordinate within shape
;	DE = x-coordinate within shape

;fill shape with user supplied pattern:
$FILL	EQU  $			;not implemented yet


*EJECT
;***************
;*  $ C O P Y  *
;***************

;entry:  A = source      page (high nibble)
;	     destination page (low  nibble)
;	     0 = graphic page 0
;	     1 = graphic page 1
;	     F = user buffer
;		 (user/user [FF] = invalid combination)
;	HL = ^parameter block (x1, y1, x2, y2, dx, dy
;			    or x2, y2, dx, dy
;			    or x1, y1, dx, dy)
;	DE = ^user buffer

;copy graphic area:
$COPY:	LD   (UBUF),DE		;save ^user buffer
	LD   C,A		;save source page
	AND  0FH		;mask it
	CP   0FH		;destination == user buffer ?
	JP   Z,COPY17		;jump if yes
	PUSH AF
	LD   A,C		;restore source page
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	CP   0FH		;source == user buffer ?
	JP   Z,COPY10		;jump if yes
	PUSH AF
	
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X1		;^parameter block --> reg. DE
	LD   B,12		;byte count       --> reg. BC	
	CALL $XMOVE		;get coordinates

*EJECT
;copy on screen:

;setup variables:
	LD   HL,(X1)		;xb1 = x1
	LD   (XB1),HL
	LD   HL,(X2)		;xb2 = x2
	LD   (XB2),HL

;determine copy direction of x-coordinate:
	LD   DE,(X1)
  	CALL CMP
	JR   C,COPY1  		;jump if
	JR   Z,COPY1  		;x1 >= x2
	LD   DE,(PX)		;xb2 += dx - 1
	DEC  DE
	ADD  HL,DE
	LD   (XB2),HL
	LD   HL,(XB1)		;xb1 += dx - 1
	ADD  HL,DE
	LD   (XB1),HL
	LD   HL,(X1)		;x1--
	DEC  HL
	LD   (X1),HL
	LD   HL,-1		;dx = -1
	JR   COPY2
COPY1:	LD   HL,(X1)		;x1 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X1),HL
	LD   HL,1		;dx = 1
COPY2:	LD   (PX),HL

;determine copy direction of y-coordinate:
	LD   HL,(Y1)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   P,COPY3		;y1 >= y2
	DEC  HL			;yy = --y1 + dy
	LD   (Y1),HL
	LD   DE,(PY)
	ADD  HL,DE
	LD   (YM),HL
	LD   HL,(Y2)		;y2 += dy - 1
	DEC  DE
	ADD  HL,DE
	LD   (Y2),HL
	LD   HL,-1		;dy = -1
	JR   COPY4
COPY3:	LD   (YM),HL		;yy = y1
	LD   DE,(PY)		;y1 += dy
	ADD  HL,DE
	LD   (Y1),HL
	LD   HL,1		;dy = 1
COPY4:	LD   (PY),HL

*EJECT
;copy area:
COPY5:	LD   HL,(YM)
	LD   DE,(Y1)
	CALL CMP		;jump if
	JR   Z,COPY8		;yy == y1

	LD   HL,(XB1)		;xx = xb1
	LD   (XM),HL
	LD   HL,(XB2)		;x2 = xb2
	LD   (X2),HL

COPY6:	LD   HL,(XM)
	LD   DE,(X1)
	CALL CMP		;jump if
	JR   Z,COPY7		;xx == x1
	
	POP  BC			;source page # --> reg. B
	PUSH BC
	LD   HL,(YM)		;y-coordinate  --> reg. HL
	LD   DE,(XM)		;x-coordinate  --> reg. DE
	CALL $POINT		;read source dot

	POP  HL			;destination page # --> reg. B
	POP  BC
	PUSH BC
	PUSH HL
	LD   HL,(Y2)		;y-coordinate       --> reg. HL
	LD   DE,(X2)		;x-coordinate	    --> reg. DE
	CALL $PLOT		;set destination dot

	LD   HL,(XM)		;xx += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (XM),HL	
	LD   HL,(X2)		;x2 += dx
	ADD  HL,DE
	LD   (X2),HL
	JR   COPY6

COPY7:	LD   HL,(YM)		;yy += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (YM),HL
	LD   HL,(Y2)		;y2 += dy
	ADD  HL,DE
	LD   (Y2),HL
	JR   COPY5

COPY8:	POP  HL			;adjust stack
COPY9:	POP  HL
	RET

*EJECT
;copy from user buffer to screen:
COPY10:	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X2		;^parameter block --> reg. DE
	LD   B,8 		;byte count       --> reg. BC	
	CALL $XMOVE		;get coordinates

;setup variables:
	LD   HL,(Y2)		;yy = y2
	LD   (YY),HL
	LD   HL,(X2)		;xb = x2
	LD   (XB),HL
	LD   HL,(PX)		;pp = dx / 8 + (dx % 8 != 0)
	LD   A,L
	SRL  H
	RR   L
	SRL  H
	RR   L
	SRL  H
	RR   L
	AND  7
	JR   Z,COPY11
	INC  HL
COPY11:	LD   (PP),HL
	LD   HL,(X2)		;x2 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X2),HL
	LD   HL,(Y2)		;y2 += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (Y2),HL

*EJECT
;copy area:
COPY12:	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JR   Z,COPY9		;yy == y2

	LD   HL,(UBUF)		;^user buffer --> reg. HL
	LD   DE,LINBUF		;^temp buffer --> reg. DE
	LD   A,(PP)		;byte count   --> reg. B
	LD   B,A
	LD   A,10H		;source bank      = 1
				;destination bank = 0
	CALL $XMOVE		;get user bytes

	LD   HL,(XB)		;xx = xb
	LD   (XX),HL
	LD   HL,0    		;ii = 0
	LD   (II),HL

COPY13:	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JR   Z,COPY16 		;xx == x2
	
	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(II)		;divide buffer index by 8
	XOR  A
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	ADD  HL,DE		;now reg. HL contains byte address
	RRA			;build BIT instruction
	RRA
	OR   46H
	LD   (COPY14),A
	DEFB 0CBH		;BIT instruction
COPY14:	DEFS 1

	LD   A,0		;initialize colour (black)
	JR   Z,COPY15		;dont't change colour if tested bit = 0
	INC  A			;change colour (white)
COPY15:	POP  BC			;graphic page number # --> reg. B
	PUSH BC
	LD   HL,(YY)		;y-coordinate 	       --> reg. HL
	LD   DE,(XX)		;x-coordinate	       --> reg. DE
	CALL $PLOT 		;set dot

	LD   HL,(XX)		;xx++
	INC  HL
	LD   (XX),HL
	LD   HL,(II)		;ii++
	INC  HL
	LD   (II),HL
	JR   COPY13

COPY16:	LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
	LD   HL,(UBUF)		;bump pointer to user buffer
	LD   DE,(PP)
	ADD  HL,DE
	LD   (UBUF),HL
	JP   COPY12

*EJECT
;copy from screen to user buffer:
COPY17:	LD   A,C		;restore source page
	RRA
	RRA
	RRA
	RRA
	AND  0FH
	PUSH AF

	LD   A,10H		;source bank      = 1
				;destination bank = 0
	LD   DE,X2		;^parameter block --> reg. DE
	LD   B,8 		;byte count       --> reg. BC	
	CALL $XMOVE		;get coordinates

;setup variables:
	LD   HL,(Y2)		;yy = y2
	LD   (YY),HL
	LD   HL,(X2)		;xb = x2
	LD   (XB),HL
	LD   HL,(PX)		;pp = dx / 8 + (dx % 8 != 0)
	LD   A,L
	SRL  H
	RR   L
	SRL  H
	RR   L
	SRL  H
	RR   L
	AND  7
	JR   Z,COPY18
	INC  HL
COPY18:	LD   (PP),HL
	LD   HL,(X2)		;x2 += dx
	LD   DE,(PX)
	ADD  HL,DE
	LD   (X2),HL
	LD   HL,(Y2)		;y2 += dy
	LD   DE,(PY)
	ADD  HL,DE
	LD   (Y2),HL

*EJECT
;copy area:
COPY19:	LD   HL,(YY)
	LD   DE,(Y2)
	CALL CMP		;jump if
	JP   Z,COPY9		;yy == y2

	LD   HL,(XB)		;xx = xb
	LD   (XX),HL
	LD   HL,0    		;ii = 0
	LD   (II),HL

COPY20:	LD   HL,(XX)
	LD   DE,(X2)
	CALL CMP		;jump if
	JR   Z,COPY22 		;xx == x2
	
       	POP  BC			;graphic page number # --> reg. B
	PUSH BC
	LD   HL,(YY)		;y-coordinate 	       --> reg. HL
	LD   DE,(XX)		;x-coordinate	       --> reg. DE
	CALL $POINT		;read dot
	LD   C,A		;colour		       --> reg. C

	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(II)		;divide buffer index by 8
	XOR  A
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	SRL  D
	RR   E
	RRA
	ADD  HL,DE		;now reg. HL contains byte address
	RRA			;build SET/RES instruction
	RRA
	OR   0C6H		;SET instruction
	BIT  0,C		;colour black or white ?
	JR   NZ,$+4		;jump if white
	AND  0BEH		;RES instruction
	LD   (COPY21),A		;load instruction
	DEFB 0CBH		;SET/RES instruction
COPY21:	DEFS 1

	LD   HL,(XX)		;xx++
	INC  HL
	LD   (XX),HL
	LD   HL,(II)		;ii++
	INC  HL
	LD   (II),HL
	JR   COPY20

COPY22:	LD   HL,LINBUF		;^temp buffer --> reg. HL
	LD   DE,(UBUF)		;^user buffer --> reg. DE
	LD   A,(PP)		;byte count   --> reg. B
	LD   B,A
	LD   A,1  		;source bank      = 0
				;destination bank = 1
	CALL $XMOVE		;put user bytes

       	LD   HL,(YY)		;yy++
	INC  HL
	LD   (YY),HL
	LD   HL,(UBUF)		;bump pointer to user buffer
	LD   DE,(PP)
	ADD  HL,DE
	LD   (UBUF),HL
	JP   COPY19

UBUF:	DEFS 2			;^user buffer


*EJECT
;division HL / DE, quotient --> HL, remainder --> DE:
DIV:	LD   A,H		;dividend (MSB) --> accu
	LD   C,L		;dividend (LSB) --> reg. C
	LD   HL,0		;clear accumulator
	LD   B,16		;init counter
DIV1:	RL   C			;rotate result left
	RLA
	ADC  HL,HL		;shift left
	SBC  HL,DE		;subtract divisor
	JR   NC,$+3		;subtraction ok
	ADD  HL,DE		;restore accumulator
	CCF			;complement carry flag
	DJNZ DIV1		;counter = 0 ?
	RL   C			;get last result bit
	RLA
	EX   DE,HL		;remainder --> reg. DE
	LD   H,A		;quotient  --> reg. HL
	LD   L,C
	RET  

;compare HL with DE:
CMP:	PUSH HL			;save reg. HL
	OR   A			;clear carry flag
	SBC  HL,DE		;compare operands
	POP  HL			;restore reg. HL
	RET

;HL = abs(HL):
ABS:	BIT  7,H		;number positive ?
	RET  Z			;return if yes
	PUSH DE			;save reg. DE
	EX   DE,HL		;number --> reg. DE
	LD   HL,0
	OR   A			;clear carry flag
	SBC  HL,DE		;negate number
	POP  DE			;restore reg. DE
	RET


*EJECT
;******************************************************************************
;*	       I N T E R R U P T   S E R V I C E   R O U T I N E	      *
;******************************************************************************

INT1:	PUSH BC			;save user register set
	PUSH DE
	PUSH HL
	PUSH IX
	PUSH IY

;scan keyboard:
	CALL $SCAN		;scan the keyboard
	LD   A,C		;get code of pressed key
	OR   A			;key pressed ?
	JR   Z,RTC3		;jump if not
	LD   A,(KLEN)		;A = buffer length
	LD   B,A		;save it
	CP   80			;jump if
	JR   Z,RTC2		;it's full
	LD   A,(REPEAT)		;auto repeat ?
	OR   A
	JR   Z,RTC0		;jump if not
	LD   A,B		;restore buffer length
	OR   A			;buffer empty ?
	JR   NZ,RTC3		;return no repeated key if buffer not empty
RTC0:	LD   A,C		;get code of pressed key
     	LD   HL,(EPTR)		;HL = next location pointer
	LD   (HL),A		;save the key
	INC  HL			;bump the pointer
	LD   DE,KBUF+80		;DE = end of buffer pointer
	EX   DE,HL		;swap the pointers
	SBC  HL,DE		;wrap around the buffer ?
	EX   DE,HL		;swap the pointers
	JR   NZ,RTC1		;jump if no wrap around
	LD   HL,KBUF		;HL = new pointer
RTC1:	LD   (EPTR),HL		;save the pointer
	LD   HL,KLEN		;HL = buffer length pointer
	INC  (HL)		;bump it
	JR   RTC3
RTC2:	CALL BEEP		;alarm

;clock maintenance routine:
RTC3:	LD   HL,RTC$TICK$COUNT	;downdate tick count
	DEC  (HL)
	JR   NZ,INT6		;is not at 0 yet
	LD   (HL),45		;one second has elapsed so 
				;reset to original value

	LD   A,(CLOCK)		;hardware clock ?
	OR   A
	JR   NZ,INT2		;jump if yes	

	LD   B,3		;maximum number of values to update
	LD   DE,TIME$IN$BCD$END	;DE -> seconds of BCD time
	LD   HL,UPDATE$TIME	;HL -> control table
RTC$UPDATE$DIGIT:
	LD   A,(DE)
	INC  A			;bump a time period, seconds
	DAA			;then minutes, then ours
	LD   (DE),A
	SUB  (HL)		;compare period to max. unit value
	JR   NZ,INT2		;jump if unit not max. value
	LD   (DE),A		;else reset period to zero
	DEC  DE			;and bump increment and
	INC  HL			;test addresses to next unit
	DJNZ RTC$UPDATE$DIGIT	;loop till periods incremented or no overflow
				;from one period to the next
	LD   HL,(BINARY$DATE)	;HL -> number of days since Jan 1st, 1978
	INC  HL			;bump day count
	LD   (BINARY$DATE),HL

*EJECT
INT2:	LD   A,(CLOCKON)
	OR   A			;display clock ?
	JR   Z,INT6		;jump if not
	LD   A,(CLOCK)		;hardware clock ?
	OR   A
	JR   Z,INT3		;jump if not 
	LD   HL,BINARY$DATE	;^time & date buffer --> reg. HL
	LD   (INT),A		;mark interrupt service routine
	CALL $GTIME3H		;read hardware clock
	XOR  A
	LD   (INT),A
INT3:	LD   HL,TIME$IN$BCD	;^BCD   time --> reg. HL
	LD   DE,$ATIME		;^ASCII time --> reg. DE
	LD   B,3		;convert hours, minutes, and seconds
INT4:	CALL BCDASC
	DJNZ INT4			
	IN   A,($SYS1)		;read system byte 1
	PUSH AF			;save it
	AND  11111110B		;enable memory mapped I/O
	OR   00010000B		;enable video RAM
	OUT  ($SYS1),A
	LD   HL,$ATIME		;^ASCII time 	   --> reg. HL
	LD   DE,(CLOCK$LOC)	;^display location --> reg. DE
	LD   B,8		;byte count 	   --> reg. B
INT5:	LD   A,(DE)		;get screen character
	AND  80H		;mask invert bit
	OR   (HL)		;over clock character
	LD   (DE),A		;display clock character
	INC  DE			;get next clock character
	INC  HL			;get next screen location
	DJNZ INT5		;display whole clock	
	POP  AF			;restore system byte 1
	OUT  ($SYS1),A
	
INT6:	POP  IY
	POP  IX
     	POP  HL			;restore user register set
	POP  DE
	POP  BC
	JP   $INT1		;jump to end of interrupt service routine

;convert BCD to ASCII:
BCDASC:	LD   A,(HL)		;get high nibble
	RRA
	RRA
	RRA
	RRA
        AND  0FH
	ADD  A,'0'		;convert it to ASCII
	LD   (DE),A		;store high digit
        LD   A,(HL)		;get low nibble
	AND  0FH		;get low nibble
	ADD  A,'0'		;convert to ASCII
	INC  DE   
	INC  HL
	LD   (DE),A		;store low digit
	INC  DE			;bump over colon 
	INC  DE
	RET

RTC$TICK$COUNT:
	DEFB 45
UPDATE$TIME:
	DEFB 60H		;BCD 60 seconds
	DEFB 60H		;BCD 60 minutes
	DEFB 24H		;BCD 24 hours
$ATIME:	DEFM 'HH:MM:SS'		;time in ASCII format
INT:	DEFB 0			;marker for interrupt service routine


*EJECT
;******************************************************************************
;*  		  C O M M O N   P A R T   O F   D R I V E R S		      *
;******************************************************************************

	ORG  3500H
	.PHASE 0FE00H		;common memory

;time & date location will not be destroyed during reset:
BINARY$DATE:
	DEFW 1
TIME$IN$BCD:
	DEFB 0
	DEFB 0
TIME$IN$BCD$END:
	DEFB 0

;*****************
;*  $ X M O V E  *
;*****************

;entry:  A  	upper nibble = source 	   bank
;	    	lower nibble = destination bank
;	 B  =   byte count
;      	DE  =   destination address
;	HL  =   source      address

;interbank transfer:
$XMOVE:	LD   C,A		;save source/dest bank #'s
	IN   A,($SYS0)		;read system byte 0
	PUSH AF			;save current bank #
	LD   A,C		;restore source/dest bank #'s
	PUSH DE			;save destination address
	LD   C,B		;byte count --> reg. BC
	LD   B,0
	PUSH BC			;save byte count
	PUSH AF        		;save destination bank number
	SRL  A			;get source bank number
	SRL  A
	SRL  A
	SRL  A
	CALL SWITCH		;select source bank
	LD   DE,SBUF		;^scratch buffer --> reg. DE
	LDIR			;transfer data from source buf to scratch buf
	POP  AF			;get destination bank number
	AND  0FH
	CALL SWITCH		;select destination bank
	POP  BC			;restore byte count
	LD   HL,SBUF		;^scratch buffer --> reg. HL
	POP  DE			;restore destination address
	LDIR			;transfer data from scratch buf to dest buf
	POP  AF			;restore current bank #
	OUT  ($SYS0),A		;select it
	RET
		
;select memory bank:
SWITCH:	RRCA			;lowest two bits --> highest two bits
	RRCA
	AND  0C0H
	OR   1
       	LD   D,A		;save bank number
       	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;RTC interrupt only
				;disable character RAM
	OR   D			;set bank number
	OUT  ($SYS0),A		;write system byte 0
	RET	 

SBUF:	DEFS 128		;scratch buffer


*EJECT
;entry to interrupt service routine:
	DEFS 64			;local stack
$INT:	LD   (SAVESP),SP	;save user stack
	LD   SP,$INT     	;get local stack
	PUSH AF			;save user accu/status
	IN   A,($FDSEL)		;reset interrupt flipflop
	IN   A,($SYS0)		;get current bank #
	PUSH AF          	;save it
	AND  00111111B		;enable bank 0
	OUT  ($SYS0),A		;select it
	JP   INT1		;perform interrupt service routine

$INT1:	POP  AF          	;get user bank
	OUT  ($SYS0),A		;select it
	POP  AF			;restore user accu/status
	LD   SP,(SAVESP)	;restore user stack
	EI			;enable interrupts
	RET			;return to user task
SAVESP:	DEFS 2			;SP save area


*EJECT
;floppy disk I/O:
IO:	CALL SWITCH		;select bank of transfer buffer
	POP  AF			;restore status
	JR   Z,WRITE1		;jump if write

;read sector:
        LD   A,$RDSEC        	;issue "read" command
	DI			;disable interrupts
	OUT  ($FDCMD),A
        LD   BC,12              ;56 usec delay
        CALL DELAY
        LD   C,$FDDATA          ;data register
READ1:	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  0,A                ;full sector transferred ?
        JR   Z,IOEND            ;yes, go end process
	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,READ3           ;yes, get byte
        BIT  7,A                ;drive not ready ?
        JR   Z,READ1            ;no loop
READ2:  LD   A,4                ;error code 4 --> accu
        RET
READ3:  INI                     ;read char
        JR   READ1

;write sector:
WRITE1: LD   A,$WRSEC        	;issue "write" command
	DI			;disable interrupts
	OUT  ($FDCMD),A
        LD   BC,12              ;56 usec delay
        CALL DELAY
        LD   C,$FDDATA          ;data register
WRITE2:	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,WRITE3          ;yes, put byte
        BIT  0,A                ;full sector written ?
        JR   Z,IOEND            ;yes, go end process
	IN   A,($FDSTAT)	;get FDC status
        BIT  1,A                ;data request ?
        JR   NZ,WRITE3          ;yes, put byte
        BIT  7,A                ;drive not ready ?
        JR   Z,WRITE2           ;no loop
        JR   READ2              ;jump to error exit
WRITE3: OUTI                    ;write char
        JR   WRITE2             ;put next byte

IOEND:	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;enable bank 0
	OR   00000001B
	OUT  ($SYS0),A		;write system byte 0
	JP   STATUS		;check status

;delay for ((BC-1)*26+17)*2.255 T-states:
DELAY:	DEC  BC			;decrement cycle count
	LD   A,B		;test if count zero
	OR   C			;combine LSB/MSB of count
	JR   NZ,DELAY		;loop until delay count exhausted
	RET			;rtn to caller


*EJECT
;Winchester I/O:
IOW:	CALL SWITCH		;select bank of transfer buffer
	POP  AF			;restore status
	JR   Z,WRITW1		;jump if WRITE

;read sector:
	COND SASI		;Xebec part

	LD   BC,RPORT0		;SASI port 0  --> reg. C
        CALL REQWAIT		;wait for request from cntlr
READW1:	IN   A,(RPORT1)		;get cntlr status lines
	AND  IOMASK+CDMASK+REQMASK
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,WDBACK 		;jump if data transfer finished
	CP   IOMASK+REQMASK
	JR   NZ,READW1 		;wait for request
	INIR 			;transfer memory bytes to sector buffer
	JR   READW1

	ELSE			;WD1002 part

READW1: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;read done ?
	JR   NZ,READW1  	;no, loop
	LD   A,E		;sector length bits --> accu
	OR   A   		;test sector length bits
	JR   Z,R256		;read 256 bytes
	DEC  A
	JR   Z,R512             ;read 512 bytes
        DEC  A
      	JR   Z,R1024		;read 1024 bytes
	LD   B,128 		;load new byte counter
      	JR   R256    		;read 128 bytes
R1024:  INIR		        ;transfer sector
	INIR
R512:   INIR
R256: 	INIR
        JR   WDBACK    		;jump back into banked memory

	ENDC

;write sector:
	COND SASI		;Xebec part

WRITW1:	LD   BC,WPORT0		;SASI port 0 --> reg. C
        CALL REQWAIT		;wait for cntlr request
WRITW2:	IN   A,(RPORT1)		;get cntlr status lines
	AND  IOMASK+CDMASK+REQMASK
	CP   IOMASK+CDMASK+REQMASK
	JR   Z,WDBACK 		;jump if data transfer finished
	CP   REQMASK
	JR   NZ,WRITW2 		;wait for request
	OTIR			;transfer memory bytes to sector buffer
	JR   WRITW2

	ELSE			;WD1002 part

WRITW1:	LD   A,E		;sector length bits --> accu
	OR   A   		;test sector length bits
	JR   Z,W256		;write 256 bytes
	DEC  A
	JR   Z,W512             ;write 512 bytes
        DEC  A
      	JR   Z,W1024		;write 1024 bytes
	LD   B,128 		;load new byte counter
      	JR   W256    		;write 128 bytes
W1024:  OTIR		        ;transfer sector
	OTIR
W512:   OTIR
W256: 	OTIR
WRITW2: IN   A,($STATUS)	;read WDC status
	BIT  7,A		;write done ?
	JR   NZ,WRITW2   	;no, loop

	ENDC

WDBACK:	IN   A,($SYS0)		;read system byte 0
	AND  00111101B		;enable bank 0
	OR   00000001B
	OUT  ($SYS0),A		;write system byte 0
	JP   WDCSTAT

	COND SASI		;Xebec part

;wait for data request of SASI controller:
REQWAIT:IN   A,(RPORT1)		;get cntlr status bits
	AND  REQMASK		;isolate the contoller
	JR   Z,REQWAIT		;request and wait for it
	RET

	ENDC

	END
	