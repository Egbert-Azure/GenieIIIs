; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; *                                                                       *
; *                                                                       *
; *			       	Z X R I O P                               *
; *                                                                       *
; *			    ("Z X-Ray Machine")                           *
; *                                                                       *
; *              System Examination and Patching IOP Module		  *
; *                                                                       *
; *                                  by                                   *
; *                             Joe Mortensen                             *
; *                            4214 Chelsea Ct.                           *
; *                            Midland MI 48640                           *
; *         								  *
; *			Voice..........517 835-6923                       *
; *                     Ladera Znode...213 670-9465                       *
; *									  *
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;
;
; Revision History
; ----------------
;
; 02/07/92	
;  v1.0 initial release -- Joe Mortensen
; 03/03/92
;  v1.1 -- slight changes in address entry to allow for less than
;   		four byte address --- jm
; 04/17/92
;  v1.2 -- minor change at display routine to filter out hi-bit
;		graphic characters --- jm
;
;=======================================================================
;
; ZXRIOP should be assembled and linked as follows:
;	ZMAC ZXRIOP;ZML ZXRIOP /P
; to create a PRL file to append to IOPZXR.
;
;=======================================================================
;
; Equates
;
vers	equ	12		; Program version
month	equ	04		; Revision date
day	equ	17
year	equ	92
;
bell	equ	07
on	equ	0ffh
off	equ	0
bs	equ	08
cr	equ	0dh
space	equ	20h

	public	cin,cout
;
; Include library routines
;
	.request vlib,z3lib,syslib
	ext	at,ereol,z3vinit
	ext	pa2hc,phl4hc,eval16

;=======================================================================
;
; The following jumps and package ID are a fixed data structure
; and cannot be changed if this package is to work with standard
; loaders and SHOW programs.
;
; REL module name is needed if loading package with NZCOM:

	name	('IOPZXR')
;
; IOP Input Jump Table
;
iop:	jp	zero		; Internal Status Routine	(IOP+0)
	jp	select		; Device Select Routine 	(IOP+3)
	jp	zero		; Device Name Routine		(IOP+6)
	jp	iopinit		; Initialize IOP		(IOP+9)
;
cons:	jp	const		; Console Input Status
	jp	iconin		; Console Input Character
	jp	conout		; Console Output Character
	jp	list		; List Output Character
	jp	punch		; Punch Output Character
	jp	reader		; Reader Input Character
	jp	listst		; List Output Status
;
; Optional routines not used by IOPZXR
;
	jp	zero		; I/O Driver Installation	(IOP+33)
	jp	zero		; Open CON: Disk File		(IOP+36)
	jp	zero		; Close CON: Disk File		(IOP+39)
	jp	zero		; Open LST: Disk File		(IOP+42)
	jp	zero		; Close LST: Disk File		(IOP+45)
;
;  I/O package identification
;
	db	'Z3IOP'		; NZCOM IOP ID			(IOP+48)
	db	'IOPZXR'	; Package name (8 bytes)	(IOP+53)
	db	vers/10+'0',vers mod 10+'0'
;
; IOP Output Jump Table.	; (IOP+61)
;
; The targets of the following seven jumps are filled in by the IOPINIT
; routine, always called by any IOP loader, to point to the NZBIOS jump
; table.
;
const:	jp	0
conin:	jp	0
conout:	jp	0
list:	jp	0
punch:	jp	0
reader:	jp	0
listst:	jp	0
;
;--------------------------------------------------------------------------
; The preceding jumps and package ID MUST remain in their present positions
; to maintain the integrity of the IOP structure.
;
; The main body of the IO Package starts here.	Code and structure from
; here on is free-form and may be moved about as you wish.
;
; IOPZXR onfiguration area, filled in by IOPZXR loader	; IOP+82
;
config:
trigger:db	0		; Hotkey to invoke program
zsclk:	dw	0
;
;--------------------------------------------------------------------------
;
; Intercept CONIN
;
iconin:	call	conin			; get console character
	ld	hl,trigger		; is it the hotkey?
	cp	(hl)
	ret	nz			; no, quit
;
	ld	(stack),sp		; set up internal stack
	ld	sp,stack
;
mainlp:	call	poscur			; position cursor
	ld	hl,menu			; display menu
	call	pstr
	call	cin			; get keyboard character
	and	5fh			; make it upper case
	cp	'C'
	call	z,change
	cp	'D'
	call	z,dump
	cp	'E'
	call	z,env
	cp	'T'
	call	z,time
	cp	'Q'
	jr	nz,mainlp		; fall through to quit
;
exit:	call	poscur		; position cursor, clear line
	ld	sp,(stack)
	ret
;
; Get and Display Environment Information
;
ccp	equ	3fh
dos	equ	42h
bio	equ	45h
cbio	equ	01
;
env:	call	poscur		; position cursor
	push	ix		; save IX register
	ld	ix,(109h)	; point to Z3 environment
	ld	hl,ccmsg	; print 'CCP'
	call	pstr
	ld	l,(ix+ccp)	; CCP address
	ld	h,(ix+ccp+1)
	call	phl4hc
	ld	hl,dosmsg	; print 'DOS'
	call	pstr
	ld	l,(ix+dos)	; DOS address
	ld	h,(ix+dos+1)
	call	phl4hc
	ld	hl,biomsg	; NZBIOS 
	call	pstr
	ld	l,(ix+bio)
	ld	h,(ix+bio+1)
	call	phl4hc
	ld	hl,cbmsg	; CBIOS
	call	pstr
	ld	l,(ix+cbio)
	ld	h,(ix+cbio+1)
	call	phl4hc
	ld	hl,envmsg	; Z3ENV
	call	pstr
	ld	hl,(109h)
	call	phl4hc
	pop	ix
	jp	cin
;
; Change one or more bytes in memory
;
change:	call	poscur		; position cursor, clear to end of line
	call	prompt		; get prompt
	call	getadr		; get address to change
chg0:	ld	(chgadr),hl	; save it
	call	poscur		; reposition cursor
	call	phl4hc		; display address
	call	twosp		; print 2 spaces
	ld	b,8		; maximum of eight bytes to change at one pass
chglp:	ld	a,(hl)		; display byte to change
	call	pa2hc		
	call	onesp		; print one space
	call	cin		; get ASCII character
	cp	cr		; is it a CR?
	jr	z,chgdun	; yes, we're done
	cp	space		; is it a space?
	jr	nz,chg1		; no
	dec	b		; yes, decrement b
	jr	z,chgdun	; if b=0, stop here
	inc	hl		; increment hl
	jr	chglp		; do next byte
chg1:	push	hl		; save pointer to ram
	ld	hl,chgbuf	; point to change buffer
	push	hl		; save it
	ld	(hl),a		; store character in (hl)
	call	cout		; print input character
	inc	hl
	call	cin		; get next input character
	ld	(hl),a		; save it in buffer
	call	cout		; print it
	inc	hl		; move pointer
	xor	a		
	ld	(hl),a		; terminate ASCII string
	call	onesp		; print a space
	pop	hl		; get back change buffer address
	call	eval16		; convert to binary, low byte result in E
	pop	hl		; get back ram location
	ld	(hl),e		; put new value in it
	call	onesp		; print a space
	inc	hl
	djnz	chglp		; do next byte
chgdun: call	poscur
	ld	hl,(chgadr)
	call	dump16
	push	hl		; save pointer (now at end of 16 bytes)
	ld	hl,cmenu
	call	pstr
	pop	hl		; get back pointer
	call	cin		; get command character
	and	5fh
	cp	'A'		; A=another address to change
	jr	z,change
	cp	'D'		; D=dump a new address
	ret	nz		; fall through
;
; Display 16 bytes in both hex and ASCII
;
dump:	call	poscur
	call	prompt
	call	getadr
dump0:	call	dump16
	call	onesp
	push	hl		; save pointer (now at end of 16 bytes)
	ld	hl,dmenu
	call	pstr
	pop	hl		; get back pointer
	call	cin		; get command character
	cp	'A'-40h		; ^A -- ASCII toggle
	jr	nz,nxtcmd
ascit:	ld	a,(ascif)
	cpl
	ld	(ascif),a
	xor	a
	ld	de,10h
	sbc	hl,de
	jr	dump0
nxtcmd:	cp	','
	jr	z,dprv
	cp	'<'
	jr	z,dprv
	cp	'.'
	jr	z,dump0
	cp	'>'
	jr	z,dump0
	and	5fh		; make upper case
	cp	'A'
	jr	z,dump
	cp	'C'
	jp	z,change
	jp 	mainlp

dprv:	ld	de,20h			; back up 32 bytes
	sbc	hl,de
	jr	dump0
;
; Dump 16 bytes to screen, first in hex, then ASCII
;
dump16: push	hl
	call	poscur
	call	phl4hc
	call	twosp
	ld	b,16
dumplp:	ld	a,(hl)
	inc	hl
	call	pa2hc
	call	onesp
	djnz	dumplp
	call	onesp
	pop	hl
	ld	b,16
dumplp0:ld	a,(ascif)		; get ascii toggle flag
	or	a
	ld	a,(hl)
	inc	hl
	jr	nz,filter
	cp	0a0h
	jr	nc,okprint
filter:	cp	0a0h
	jr	nc,noprint
filter0:cp	7fh
	jr	nc,noprint
ckctrl:	cp	20h
	jr	nc,okprint
noprint	ld	a,'.'
okprint:call	cout
	djnz	dumplp0
	ret

;
; Display current date and time
;
time:	ld	de,timebuf
	ld	hl,(zsclk)	; get ZSDOS clock address
	ld	a,h		; if address = 0, then quit
	or	l
	ret	z
	ld	c,0
	call	jphl		; read clock
;
	call	poscur		; display date and time
	ld	hl,timebuf+1
	ld	a,(hl)
	call	pa2hc
	ld	a,'/'
	call	cout
	inc	hl
	ld	a,(hl)
	call	pa2hc
	ld	a,'/'
	call	cout
	dec	hl
	dec	hl
	ld	a,(hl)
	call	pa2hc
	call	twosp
	ld	hl,timebuf+3
	ld	a,(hl)
	call	pa2hc
	ld	a,':'
	call	cout
	inc	hl
	ld	a,(hl)
	call	pa2hc
	jp	cin			; wait for keypress
;	
;--------------------------------------------------------------------------
;
; Subroutines:
;
; Move Cursor to line 24, column 1 of screen and clear line
;
poscur:	call	at
	db	24,1
	jp	ereol
;
; Display prompt on screen
;
prompt:	ld	a,'?'
	jp	cout
;
; Get Hex Address (up to 4 characters)
;
getadr:	ld	b,4
	ld	hl,adrbuf
;
geta0:	call	cin
	cp	cr			; is it CR?
	jr	z,geta4			; yes, we're done
;	
	cp	bs			; it is BackSpace?
	jr	nz,geta1		; no
;	
	inc	b			; yes, increment counter
	inc	b
	dec	hl			; decrement pointer
	jr	geta3			; move cursor back
;	
geta1:	cp	'a'			; check for lower case
	jr	c,geta2
	cp	'z'+1
	jr	nc,geta2
	and	05fh			; make it upper case
;	
geta2:	ld	(hl),a			; put in buffer
	inc	hl			; increment pointer
;	
geta3:	call	cout			; display it
	djnz	geta0			; get the next one
;	
geta4:	xor	a			; put terminating null in string
	ld	(hl),a
	ld	hl,adrbuf		; convert to hex
	call	eval16	
	ex	de,hl			; hl holds converted value
	ret	
;
	
menu:	db	'C=Chg  D=Dump  E=Env  T=Time  Q=Quit ?',bs,0
cmenu:	db	'ADQ ?',bs,0
dmenu:	db	'<>ACQ ?',bs,0
ccmsg:	db	'ccp=',0
dosmsg:	db	' dos=',0
biomsg:	db	' bios=',0
cbmsg:	db	' cbios=',0
envmsg:	db	' env=',0
chgbuf:
adrbuf:	
timebuf:ds	6
chgadr:	ds	2
ascif:	db	0ffh			; do filter hi-bit bytes
;
; get console character
;
cin:	exx				; save registers
	call	conin
	exx				; restore registers
	ret
;
; Display character in A on console
;
cout:	exx			; Save us from the BIOS...
	push	af
	ld	c,a		; BIOS wants character in C
	call	conout		; Display it
	pop	af
	exx			; restore registers
	ret
;
; Display 0-terminated string pointed to by HL
;
pstr:	ld	a,(hl)		; Get character
	inc	hl		; Point to next
	or	a		; Done?
	ret	z		; Yes, quit
;
	call	cout		; Display character
	jr	pstr		; Do next
;
; Call (HL)
;
jphl:	jp	(hl)

; Print spaces	(b=no. of spaces to print)
;
onesp:	push	bc
	ld	b,1
	jr	spaces
twosp:	push	bc
	ld	b,2
;
spaces:	ld	a,' '
splp:	call	cout
	djnz	splp
	pop	bc
	ret
;
; Device Select Routine
;
;  Entry: B=0FFH - Remove IOP
;  Exit : A=0, Z if bad command, A<>0, NZ if ok
;
select:	inc	b
	jr	z,remove	; Turn clock off (remove)
;
; Any IOP functions not implemented return ZERO to the caller.
;
zero:	xor	a		; Any call here returns Z
	ret
;
; Remove IOP
;
remove:	ld	hl,cons		; Our input jump table
	ld	de,const	; Our output jump table
	ld	b,7		; Patch 7 jumps
;
; Replace jump target at HL+1 with DE, increment HL and DE by 3.
;
target:	inc	hl		; Point to our jump target
	ld	(hl),e		; Move low order
	inc	hl		; Point to high order
	ld	(hl),d		; Move it
	inc	hl		; Point to next IOP input jump
	inc	de		; Point to next IOP output jump
	inc	de
	inc	de
	djnz	target		; Loop to do next
;
nzero:	or	0ffh		; Any call here returns NZ
	ret
;
; IOPINIT is one-time initialization code that is always called by the
; IOP loader when the IOP is first loaded and never again.  The space
; used by IOPINIT can be reused as buffer space if required.
;
; The seven character IO jumps in the NZBIOS jump table are vectored
; to our IOP Input Jump Table.	The NZBIOS has a jump table similar to
; our IOP Output Jump Table whose targets go directly to the BIOS
; character IO routines.  The address of this table is maintained at
; NZBIOS+1.  The IOP is 'installed' by pointing the jumps in our IOP
; Output Jump Table to the NZBIOS table.  If no IOP action is to take
; place, our IOP Input Jump Table vectors directly through the IOP
; Output Jump Table to the NZBIOS jump table.
;
iopinit:ld	hl,(109h)	; point to Z3 environment address
	call	z3vinit		; initialize VLIB stuff
;
; Initialize IOP output jump table
;
init:	ld	hl,(1)		; BIOS+3
	dec	hl		; BIOS+2
	ld	d,(hl)
	dec	hl		; BIOS+1
	ld	e,(hl)		; BIOS table
	ld	hl,const	; Our IOP output jump table
;
	ld	b,7		; Seven jumps
	jr	target
	
	ds	1dh
stack:	ds	2	
;
