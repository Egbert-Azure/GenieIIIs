(*                       LongInt.bib                   12. 7. 88       *)
(*--------------------=================--------------------------------*)
(* Das Bibliotheksprogramm Lange Integer Arithmetik stellt eine um-    *)
(* fangreiche Auswahl an Arithmetikproceduren und -funktionen fuer     *)
(* lange Integerzahlen zur Verfuegung. Der Benutzer legt die Konstan-  *)
(* ten Maxziff und Maxstrl fest.                                       *)
(* Maxziff  = (maximale Dezimalstellenanzahl)*log(10)/log(256)         *)
(* Maxstrl >= (maximale Dezimalstellenanzahl+10)                       *)

const  maxziff = 27;             (* reicht fuer 65 Dezimalstellen *)
       maxstrl = 75;             (* Maximale Stringlaenge         *)
       cr      : string[2]=^j^m; (* carriage return und line feed *)

type Tstr  = string[maxstrl];              (* Type String         *)
     TLint = record vorz : boolean;        (* Type Long Integer   *)
                    stel : integer;        (* 256er Zahlensystem! *)
                    ziff : array[1..maxziff] of byte;
             end;


(*... Schnelle Hilfsarithmetik mit einer Zahl b ( 0 <= b < 256) und ...*)
(*              einer Long Integer Zahl x als Operanden                *)

procedure bmult(b:integer;x:TLint;var r:TLint);                  forward;
procedure bdiv(x:TLint;b:integer;var q:TLint;var rest:integer);  forward;
procedure badd(b:integer;x:TLint;var r:TLint);                   forward;


(*...... Konvertierungs- sowie Ein- und Ausgabeproceduren .............*)

function  LongInt_to_Str(x:TLint): Tstr;                         forward;

procedure Int_to_LongInt(i:integer; var r:TLint);                forward;
procedure Str_to_LongInt(s:Tstr; var r:TLint);                   forward;
procedure Lwrite(s1:Tstr; var x:TLint; s2:Tstr);                 forward;
procedure Lread (s1:Tstr; var x:TLint; s2:Tstr);                 forward;


(*..... Arithmetikroutinen fuer Long Integer Zahlen als Operanden .....*)

function  absgg  (var x,y:TLint):boolean;  forward; (* abs(x)>=abs(y)? *)
function  kleiner(var x,y:TLint):boolean;  forward; (* x<y ?           *)
function  gleich (var x,y:TLint):boolean;  forward; (* x=y ?           *)
function  Test0  (var x  :TLint):boolean;  forward; (* x=0 ?           *)

procedure neg    (x  :TLint;var y:  TLint);forward; (* y:=-x           *)
procedure add    (x,y:TLint;var r:  TLint);forward; (* r:=x+y          *)
procedure sub    (x  :TLint;var y,r:TLint);forward; (* r:=x-y          *)
procedure mult   (x,y:TLint;var r:  TLint);forward; (* r:=x*y          *)
procedure divi   (x,y:TLint;var q,r:TLint);forward; (* q:=x div y;
                                                       r:=x mod y      *)
procedure potenz (b:TLint;e:integer; var p:TLint);  (* p:=b**e         *)
                                           forward;
procedure wurzel (x:TLint; var r:TLint);   forward; (* r:=sqrt(x)      *)

(*------------------- Rumpf des LongInt.Bib Programms -----------------*)

procedure Lwrite;  (* s1:Tstr; var x:TLint; s2:Tstr *)
var i:Integer;
begin
  write(s1);
  s1:=LongInt_to_Str(x);
  for i:=1 to length(s1) do
    begin
      if ( succ(length(s1)-i) mod 3 = 0) then
        if i<>2 then write(' ');
      write(s1[i]);
    end;
  write(s2);
end;

procedure Lread;  (* s1:Tstr; var x:TLint; s2:Tstr *)
begin
  write(s1); read(s1); Str_to_LongInt(s1,x); write(s2)
end;

procedure bmult(* b:integer;x:TLint;var r:TLint *);

var i,c : integer;

begin with r do begin
  if b<1 then begin stel:=0; exit; end; (* r:=0 da b<=0 *)
  r:=x;
  if (stel=0) or (b=1) then exit;       (* x=0 oder b=1 *)
  if b>255 then begin                   (* r:= 256*x    *)
      move(ziff[1],ziff[2],stel);
      stel:=succ(stel);
      ziff[1]:=0; end
    else begin
      c:=0;
      for i:=1 to stel do begin       (* r:= b*x  mit 2<=b<=255*)
        c:=ziff[i]*b+hi(c);
        ziff[i]:=lo(c) end;
      if hi(c)>0 then begin           (* r bekommt eine Ziffer mehr *)
          stel:=succ(stel);
          ziff[stel]:=hi(c) end;
  end; (* if (b> *)
end;end; (* bmult *)

procedure bdiv(* x:TLint; b:integer; var q:TLint; var rest:integer *);

var i  : integer;
    rr : real;

begin with q do begin
  q:=x;
  rest:=0;
  if (stel=0) or (b=1) then exit;
  if (b>255) or (b<1) then begin     (* x div 256 *)
      rest:=ziff[1];
      stel:=pred(stel);
      if stel=0 then exit;
      move(ziff[2],ziff[1],stel) end
    else begin
      for i:=stel downto 1 do begin
        rest:=ziff[i]+swap(rest);
        if rest>=0 then begin
            ziff[i]:=rest div b;
            rest:=rest mod b end
          else begin
            rr:=256.0*hi(rest)+ziff[i];
            ziff[i]:=trunc(rr/b);
            rest:=trunc(rr-int(ziff[i])*b)
        end;
      end; (* for i *)
      if ziff[stel]=0 then stel:=pred(stel);
    end; (* if *)
end;end; (* bdiv *)

procedure badd(* b:integer; x:TLint; var r:TLint *);

var i: integer;

begin with r do begin
  r:=x;
  if (b<1) or (b>255) then exit;
  if stel=0 then begin
      stel:=1;
      ziff[1]:=b; end
    else begin
      b:=ziff[1]+b;     (* 0<=b<=511 *)
      ziff[1]:=lo(b);
      if b<=255 then exit; (* kein Uebertrag *)
      for i:=2 to stel do begin
        b:=succ(ziff[i]);
        ziff[i]:=lo(b);
        if b<=255 then exit; end;
      stel:=succ(stel);
      ziff[stel]:=1;
    end; (* else *)
end;end; (* badd *)

procedure Int_to_LongInt; (* i:integer; var r:TLint *)

begin with r do begin
  vorz:=i<0;
  if i=0 then begin stel:=0; exit end;
  i:=abs(i);
  ziff[1]:=lo(i);
  if hi(i)=0
    then stel:=1
    else begin
      stel:=2;
      ziff[2]:=hi(i) end;
end;end;

procedure Str_to_LongInt; (* s:Tstr; var r:TLint *)

var i: integer;
    c: char;

begin with r do begin
  stel:=0;
  vorz:=false;
  for i:=1 to length(s) do begin
    c:=s[i];
    if c='-' then vorz:=not vorz;
    if c in ['0'..'9'] then begin
      bmult(10,r,r);
      badd(ord(c)-48,r,r) end
  end;
end;end;(* Str_to_LongInt *)

function  LongInt_to_Str; (*  (x:TLint): Tstr  *)

var    s : Tstr;
    rest : integer;

begin with x do begin
  if stel=0 then begin LongInt_to_Str:='+0'; exit end;
  s:='';
  while stel>0 do begin
    bdiv(x,10,x,rest);
    s:=chr(rest+48)+s end;
  if vorz then s:='-'+s else s:='+'+s;
  LongInt_to_Str:=s;
end;end; (* LongInt_to_Str *)

function absgg; (*  (var x,y:TLint):boolean   *)

var i: integer;
begin
  i:=x.stel;
  if i<y.stel then begin absgg:=false; exit end;
  absgg:=true;
  if (i>y.stel) or (i<1) then exit;
  while( x.ziff[i] = y.ziff[i] ) and (i>1) do i:=pred(i);
  if (x.ziff[i]<y.ziff[i]) then absgg:=false;
end;

function kleiner; (*   (var x,y:TLint):boolean  *)
label falseout;
begin
  kleiner:=true;
  if x.vorz>y.vorz then exit;
  if x.vorz<y.vorz then goto falseout;
  if x.vorz=false                               (* beide positiv *)
    then if not absgg(x,y) then exit
                            else goto falseout
    else if not absgg(y,x) then exit;
  falseout: kleiner:=false
end;

function gleich;   (*   (var x,y:TLint): boolean  *)
var i:integer;
begin
  gleich:=false;
  if x.vorz<>y.vorz then exit;
  if x.stel<>y.stel then exit;
  for i:=1 to x.stel do if x.ziff[i]<>y.ziff[i] then exit;
  gleich:=true
end;

function test0;    (*   (var x:TLint):boolean  *)
begin
  test0:=(x.stel=0)
end;

procedure neg; (* x:TLint; var y:TLint *)
begin
  y:=x; y.vorz:=not y.vorz
end;

procedure add; (* x,y:TLint;var r:TLint *)

var i,c : integer;

begin with r do begin
  if x.stel<y.stel
    then begin r:=y; y:=x; x:=r end
    else r:=x;                       (* r:=x und x.stel>=y.stel *)
  c:=0;
  if x.vorz=y.vorz then begin        (* Addition r:=x+y ab hier *)
      for i:=1 to y.stel do begin
        c:=x.ziff[i]+y.ziff[i]+hi(c);
        ziff[i]:=lo(c) end;
      while i<stel do begin          (* Uebertraege bearbeiten *)
        if hi(c)=0 then exit;
        i:=succ(i);
        c:=succ(ziff[i]);
        ziff[i]:=lo(c) end;
      if hi(c)>0 then begin
          stel:=succ(stel);
          ziff[stel]:=1 end;
      end                            (* Addition endet hier *)

    else begin                       (* Subtraktion beginnt hier *)
      if not absgg(x,y) then
        begin r:=y; y:=x; x:=r end;  (* abs(x) ist >= abs(y) *)
      for i:=1 to y.stel do begin
        c:=ziff[i]-y.ziff[i]-c;
        ziff[i]:=lo(c);
        c:=hi(255-c) end; (* c:=1,falls c<0 war *)
      while (i<stel) and (c>0) do begin
        i:=succ(i);
        c:=pred(ziff[i]);
        ziff[i]:=lo(c);
        c:=hi(255-c) end;
      while (stel>1) and (ziff[stel]=0) do stel:=pred(stel);
      if ziff[stel]=0 then stel:=0;
    end;(* else *)
end;end;(* add *)

procedure sub; (* var x,y,r:TLint *)
begin
  neg(y,r);
  add(x,r,r)
end;

procedure mult; (* x,y:TLint;var r:TLint *)

var  i : integer;
    zw : TLint;

begin
  r.stel:=0;
  if (x.stel=0) or (y.stel=0) then exit;
  r.vorz:= x.vorz xor y.vorz;
  if absgg(x,y) then
    begin zw:=y; y:=x; x:=zw end;
  for i:=x.stel downto 1 do begin
    bmult(256,r,r);
    bmult(x.ziff[i],y,zw);
    add(r,zw,r) end;
end;

procedure divi; (* x,y:TLint;var q,r:TLint *)

var vorz           (* Vorzeichen des Quotienten *)
        : boolean;
    p,             (* Potenz von 256 fuer Linksschieben *)
    z,             (* Ziffer (vorlaeufige) *)
    i,j            (* Indices *)
        : integer;
    a,b            (* fuer Probeteilen *)
        : real;

begin
  q.stel:=0; q.vorz:=false;
  r:=q;
  if y.stel=0 then begin writeln(#10,'Fehler: y divi 0 '); exit end;
  if x.stel=0 then exit;
  vorz:=x.vorz xor y.vorz;
  x.vorz:=false;
  y.vorz:=false;
  if not absgg(x,y) then begin r:=x;            exit
                         end;
  if y.stel=1 then begin bdiv(x,y.ziff[1],q,i);
                         Int_to_LongInt(i,r);
                         q.vorz:=vorz;          exit
                   end;

  (* im Folgenden: x,y sind mindestens 2-stellig und x>=y *)

  b:=256.0*y.ziff[y.stel]+y.ziff[pred(y.stel)];
  p:=x.stel-y.stel;
  q.stel:=succ(p);
  x.ziff[succ(x.stel)]:=0;
  for i:=x.stel downto y.stel do begin
    a:=65536.0*x.ziff[succ(i)]+256.0*x.ziff[i]+x.ziff[pred(i)];
    z:=trunc(a/b);
    repeat
      r:=x;
      if z>0 then begin
          if z>255 then z:=255;
          bmult(z,y,r);
          if p>0 then begin     (* r:= r*256**p Linksschieben *)
              r.stel:=r.stel+p;
              for j:=r.stel downto 1 do
                if j>p then r.ziff[j]:=r.ziff[j-p]
                       else r.ziff[j]:=0  end;
          sub(x,r,r) end;
      q.ziff[succ(p)]:=z;
      z:=pred(z);
    until not r.vorz;
    p:=pred(p);
    x:=r;
    if x.stel<i then
        for j:=succ(i) downto succ(x.stel) do x.ziff[j]:=0;
  end; (* for i *)
  q.vorz:=vorz;
  if q.ziff[q.stel]=0 then q.stel:=pred(q.stel);
end; (* divi *)

procedure potenz; (* b:TLint; e:integer; var p:TLint *)
begin
  int_to_LongInt(1,p);
  while e>0 do begin
    if odd(e) then begin mult(b,p,p); e:=pred(e) end;
    mult(b,b,b);
    e:=e shr 1; (* e div 2 *)
  end
end;

procedure wurzel; (* x:TLint; var r: TLint  *)

var i,s : integer;
    a   : real;
    q,d : TLint;

    procedure heron;
    begin
      divi(x,r,q,d);
      add (r,q,r);
      bdiv(r,2,r,s)
    end;

begin with r do begin
  r:=x;
  if vorz then begin
       writeln('FC-Fehler in WURZEL'); exit end;
  if stel>4 then if odd(stel) then s:=stel-2
                              else s:=stel-3
            else s:=1;
  a:=ziff[stel];
  for i:=pred(stel) downto s do a:=256.0*a+ziff[i];
  i:=succ(s) div 2;
  a:=sqrt(a);
  if a<256.0 then begin
               stel:=i; ziff[i]:=trunc(a) end
             else begin
               stel:=succ(i);
               ziff[stel]:=trunc(a/256.0);
               ziff[i]:=trunc(a-256.0*ziff[stel]) end;
  if i>1 then begin
      i:=pred(i);
      ziff[i]:=trunc(256.0*frac(a));
      while i>1 do begin
        i:=pred(i);
        ziff[i]:=0 end;
  end;
  i:=x.stel;
  while i>3 do begin
    heron; heron;
    i:=i div 3 end;
  mult(r,r,q);
  if not absgg(x,q) then begin
      Int_to_LongInt(1,q); sub(r,q,r) end;
end; end;