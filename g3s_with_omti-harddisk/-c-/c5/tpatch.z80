;--------------------------------
;TPATCH.Z80	ho	02-JAN-93
;--------------------------------
;Die Patches sind nach aufsteigenden Adressen angeordnet,
;nicht nach funktionalem Zusammenhang.

TPVers		EQU	300

		.XLIST
;Diverse EQUs >>
BELL		EQU	7
TAB		EQU	9
LF		EQU	10
CR		EQU	13
EOF		EQU	26
BuffInput	EQU	10
Reset		EQU	13
DriveSelect	EQU	14
OpenFile	EQU	15
CloseFile	EQU	16
SearchFirst	EQU	17
DeleteFile	EQU	19
WriteSeq	EQU	21
RenameFile	EQU	23
GetDrive	EQU	25
SetDMA		EQU	26
GetSetUsr	EQU	32
ReadRand	EQU	33
SecSize		EQU	128
JumpOp		EQU	0C3h

;Adressen Zeropage (CP/M, TP Variablen) >>
CurrDU		EQU	004h
BDOS		EQU	005h
BreakEntry	EQU	038h
DefaultFCB	EQU	05Ch
CmdLine		EQU	080h
IOJumps		EQU	0A0h
HeapPtr		EQU	0C4h
IORes		EQU	0D0h
BufPos		EQU	0D2h
BufNext		EQU	0D4h
BufLast		EQU	0D6h
StandAlone	EQU	0D8h
OvrDrv		EQU	0DCh
CBreak		EQU	0DDh
FreeRoot	EQU	0DEh
HLightFlag	EQU	0E0h
OvrBegin	EQU	0E6h
OvrLength	EQU	0E8h
FIOFlag1	EQU	0E8h

;Adressen Laufzeitbibliothek >>
IF TPVers EQ 300
RV		EQU	0		;RTL Verschiebung
EV1		EQU	0		;Editor Verschiebung
EV2		EQU	0
ELSE
RV		EQU	1
EV1		EQU	-33
EV2		EQU	-30
ENDIF

OutString	EQU	01D0h
Print		EQU	0200h+RV
ClrScr		EQU	023Eh+RV
InitCharIO	EQU	0364h+RV
@IOJumps	EQU	03A5h+RV
SConOut		EQU	03C9h+RV
ParseAFN	EQU	03EEh+RV
ParseFN		EQU	0406h+RV
ParseFN5	EQU	0453h+RV
FillSpace	EQU	047Bh+RV
ToUpper		EQU	04A6h+RV
CCompInts	EQU	0773h+RV	;CompInts+1
RandReal2	EQU	0FCDh+RV
Int2Real	EQU	1008h+RV
CheckDecim	EQU	1239h+RV
Assign2		EQU	13A0h+RV
ResetT		EQU	13FFh+RV
FOpen1		EQU	144Eh+RV
ClearFcb	EQU	145Ah+RV
FClose		EQU	1481h+RV
EdInit		EQU	14FDh+RV
EdCR		EQU	1556h+RV
ResetFO		EQU	1811h+RV
INCWord		EQU	18D1h+RV
FBDOS		EQU	19BAh+RV
ResetF		EQU	1A70h+RV
BlkRWErr	EQU	1AE9h+RV
BlockRW2	EQU	1B10h+RV
Erase		EQU	1B93h+RV
Rename		EQU	1BA5h+RV
Execute		EQU	1BEAh+RV
Overlay		EQU	1C59h+RV
JoinBl1		EQU	1E2Fh+RV
InitHeap	EQU	1EAFh+RV
ParamCnt1	EQU	1F9Dh+RV
BreakHandler	EQU	1FFBh+RV
RunTimErrX	EQU	2027h+RV
RunTimErr	EQU	2029h+RV
ERROR		EQU	202Ch+RV
HaltProgram	EQU	20D4h+RV

;Adressen Menue/Editor/Compiler >>
EditComp	EQU	20E2h+RV
InitMemIO	EQU	20E5h+RV
Balken		EQU	2128h+RV
WhoAmI		EQU	217Dh+EV1
MainMenue	EQU	223Bh+EV1
ShowMain	EQU	227Ah+EV1
GetLine		EQU	2261h+EV1
GetLine1	EQU	2270h+EV1
ShowOpt1	EQU	2374h+EV1
MJumps		EQU	2472h+EV1
MMainF		EQU	249Ah+EV1
MWorkF2		EQU	2506h+EV1
MWorkF3		EQU	250Ch+EV1
NotFoundJp	EQU	259Dh+EV1
NewFile		EQU	25BCh+EV1
AutoSaveQ	EQU	2601h+EV1
AutoSaveQuest	EQU	262Bh+EV1
MSave		EQU	2639h+EV1
MSave1		EQU	2692h+EV1
DefSBDOS	EQU	26D3h+EV1
EClearFcb	EQU	26DCh+EV1
L27EA		EQU	27EAh+EV1
L2841		EQU	2841h+EV1
L287B		EQU	287Bh+EV1
L29F8		EQU	29F8h+EV1
L2A41		EQU	2A41h+EV1
L2AB5		EQU	2AB5h+EV1
L2B7A		EQU	2B7Ah+EV1
MDir		EQU	2B93h+EV1
L2C29		EQU	2C29h+EV1
L2C8D		EQU	2C8Dh+EV1
MLogged		EQU	2CCEh+EV1
ParsePAS	EQU	2D2Ah+EV1
ParseEXT	EQU	2D2Fh+EV1
WorkFGiven	EQU	2D4Bh+EV1
L2D50		EQU	2D50h+EV1
ECmpFiles	EQU	2D7Fh+EV1
ClearText	EQU	2D8Fh+EV1
ReadMSG		EQU	2DA4h+EV1
PrintFName	EQU	2DF8h+EV1
L2E20		EQU	2E20h+EV1
OpenDefault	EQU	2E51h+EV1
L3566		EQU	3566h+EV2
EdiConO1	EQU	4220h+EV2
L44D2		EQU	44D2h+EV2
L44DF		EQU	44DFh+EV2
L44E1		EQU	44E1h+EV2
EndAddress	EQU	44F6h+EV2
LoggedDrive 	EQU	44F8h+EV2
MainFCB		EQU	44F9h+EV2
WorkFCB		EQU	451Dh+EV2
MSGPresent	EQU	4541h+EV2
LoggedUser	EQU	4543h+EV2	;Wird bereits von Overlay gerettet.
	;War vorher zum Zaehlen der ausgegebenen Zeichen. Das muss aber nicht
	;gerettet werden und wird jetzt als InTheCode-Variable realisiert.
$Overlay3	EQU	473Bh+EV2
$Overlay11	EQU	4821h+EV2
RWObjSec	EQU	6D09h+EV2
ScanSpc18	EQU	70A7h+EV2
RawInput3	EQU	721Ah+EV2
SBDOS		EQU	7265h+EV2
CDivInt		EQU	72AEh+EV2
ErrAlw2		EQU	730Ch+EV2
ObjFCB		EQU	7933h
SecBuf		EQU	7957h

		.LIST
;-----------------------------------------
;	Patches Laufzeitbibliothek
;-----------------------------------------
;+ Fehler behoben bei Int2Real (Endlosschleife bei $8000)
;+ Screenreset

.COMMENT %---------------------------------------
Fehler in OutString beheben: (Upgrade auf V3.01)

	RET	Z	    ->	JR	NZ,OutString1
	JR	OutString1  ->	OR	A		;NCarry
			    ->	RET
---------------------------------------% ;COMMENT

	ORG	0103h	;Magic, Copyright. 33 Byte frei

;ZCPR3-Programm
		DEFB	'Z3ENV'		;<- nach Programmstart koennen diese 6
		DEFB	1		;<- Byte bei Bedarf ueberschrieben werden
z3env:		DEFW	0		;=0109h
;=8 Byte lang

;Editor umschaltbar
EExtra:		LD	(BufNext),HL	;erstmal Befehl nachholen
EditFlag	EQU	$+1		;=010Fh
		LD	A,1		;0= TP-Editor, <>0= BDOS-10
		AND	A		;normal?
		JP	Z,EdInit	;ja -> zurueck
;hier liessen sich zur Not noch drei Byte sparen, wenn man die
;oberen 4 Zeilen ersetzt durch:
;EditFlag:	JP	EdInit		bzw.	LD	DE,EdInit
;		(EditFlag = 0C3h)		(EditFlag = 11h)
	;HL= BufPos, C= Max.Laenge, B= Flag (0= input, <>0= CON:/TRM:)
		LD	(HL),C
		PUSH	BC
		PUSH	HL
		EX	DE,HL
		LD	C,BuffInput
		CALL	BDOS
		POP	HL		;=BufPos
		LD	D,H
		LD	E,L
		INC	HL
		LD	A,(HL)		;tatsaechliche Laenge
		INC	HL		;zeigt auf erstes Zeichen

		DEFB	1		;LD BC,.. Frequency maskieren!
;=25 lang, nix mehr frei
;Frequency:	DEFW	4
	ORG	0126h	;Version?, PatchArea, TermTypStr. 66 Byte frei

		AND	A		;=0?
;hier kann zur Not 1 Byte gespart werden, wenn die folgende Zeile
;entfernt wird und LDIR ersetzt wird durch CALL NZ,LdirRet, wobei
;LdirRet nur die Befehle LDIR und RET ausfuehrt (z.B. bei PushVars
;in TP-RTL1.INC zu finden)
		JR	Z,Leer
		LD	C,A
		LD	B,0
		LDIR			;alles um 2 nach vorne rutschen
Leer:		EX	DE,HL		;Zeiger hinter Ende nach HL
		POP	BC		;Flag holen
		JP	EdCR		;den Rest darf der alte Editor tun
;=13 lang (insgesamt, ohne Maskierung: 37)


IExtra:		LD	A,C
		OR	A
		RET	Z
		LD	A,JumpOp
		LD	(BreakEntry),A
		LD	HL,BreakHandler
		LD	(BreakEntry+1),HL
		RET
;=15 lang


OExtra:		LD	(FIOFlag1),A	;ueberschriebenen Befehl nachholen
;E: FilePointer in HL
;V: AF, BC / R:-
OER:		PUSH	HL
		LD	BC,12+13
		ADD	HL,BC
		BIT	7,(HL)		;wenn Bit 7 gesetzt,
		JR	Z,OER1
		CALL	XUserFF		;dann den akt. User
		OR	80h		;einsetzen, aber Bit 7
		LD	(HL),A		;gesetzt lassen
OER1:		POP	HL
		RET
;=20 lang


ScreenReset:	LD	HL,ScreenStr
		CALL	OutString
		LD	A,(StandAlone)	;Befehl nachholen
		RET
;=10 Byte lang
ScreenStr:	DEFB	1,18h,0,0,0,0,0,0
;zus. 66, nix mehr frei

.COMMENT %---------------------------------------
TP-RTL1.INC, Ende von CsrXY:
statt:		CALL	Delay
		POP	HL
		POP	DE
		POP	BC
		POP	AF
		RET
kuerzer:
		JP	ClrDelIns+6
spart 5 Byte.
CALL NC,Delay geht, da NC von OutString wegen nicht-leerem Cursorsteuerstring.
Und wenn der leer war, dann ist es auch kein Fehler, wenn nicht gewartet wird.
Nachfolgend: InsNumber, kann einfach verschoben werden
Befehl LD B,0 ist ueberfluessig, da nach LDIR bzw. DJNZ B=0
Dadurch auf 8 Byte vergroesserbar. Evtl. sogar noch mehr.
Oder: ein Befehl spaeter JR HLVideo1+3 spart auch 5 Byte.
---------------------------------------% ;COMMENT

;Kommandozeile retten
;Wenn die Kommandozeile nicht kopiert wurde, ist der Inhalt von DE' uninteressant,
;da nach CALL InitCharIO das LD HL,Endadresse ausgefuehrt wird.
;Wurde die Kommandozeile allerdings kopiert, so enthaelt DE' die neue Adresse,
;welche in DefaultIO nach HL gebracht wird, und der Befehl LD HL,Endadresse wird
;nicht ausgefuehrt (Returnadresse wurde verbogen)
	ORG	InitCharIO
		EXX			;BC und HL retten
		LD	HL,CmdLine
		LD	A,(HL)		;Laenge der Kommandozeile
		AND	A
		JR	Z,NixTun
		EX	(SP),HL		;Returnadresse runter
		INC	HL		;Skip LD HL,...
		LD	E,(HL)
		INC	HL
		LD	D,(HL)
		INC	HL
		EX	(SP),HL		;wieder drauf
	;DE= Programmende (= Anfang Heap), HL= CmdLine, A= Laenge
		LD	C,A		;Bruttolaenge nach BC
		LD	B,H		;=0
		INC	BC
		PUSH	DE
		LDIR
		POP	HL
NixTun:		LD	(ParamCnt1+1),HL
	;neue Endadresse nach DE', BC und HL holen
		EXX
		LD	(BufPos),HL
		LD	A,B
		LD	(CBreak),A
		CALL	IExtra
;<fall through>

DefaultIO:	LD	HL,@IOJumps
		LD	DE,IOJumps
		LD	BC,8*3+6*2	;FIBs gleich mit!
		LDIR
		LD	HL,IORes
		LD	(HL),H		;=0
		INC	HL		;BufLen
		LD	(HL),7Eh
		LD	L,LOW BufNext
		CALL	Clear4Bytes
		LD	L,LOW HLightFlag
		LD	(HL),L		;irgendwas, nur nicht 0 oder 0FFh
		EXX
		EX	DE,HL		;neue Endadresse nach HL
		RET
;DefaultIO =29 Bytes lang (im Original ist das Teil 43 Byte lang!)


;Parse-Routine aufblasen fuer User
;E: B=0! Das ist beim Aufruf von ParseAFN bzw. ParseUFN der Fall,
;da der vorhergehende Aufruf von FillSpace mit B=0 zurueckkommt.
;Im Menue ist jedoch eine einzige Stelle (ParseEXT in TP-ME2.INC),
;wo ParseFN direkt aufgerufen wird. Hier aufpassen!
	ORG	ParseFN
		PUSH	DE		;merken fuer Fehlerfall
		LD	A,(DE)		;schauen, ob Laufwerk
		CALL	ToUpper		;angegeben:
		CP	'A'		;'A' bis 'P' zulaessig
		JP	C,PExtra
	;hier koennte man zur Not noch 1 Byte sparen: JR C runter zum JP NZ,PExtra
		CP	'P'+1
		JP	NC,PExtra
		SUB	'A'-1
		LD	B,A		;Drive merken
	;die naechsten drei Zeilen kann man durch CALL Ziffer+6
	;ersetzen, das spart ein Byte
		INC	DE
		LD	A,(DE)
		CP	':'
		JP	NZ,PExtra
	;ok. nur Drive.
		INC	DE
		POP	HL		;gemerkten Zeiger wegwerfen
		JP	PutDrive
PBack:		LD	(HL),B		;Laufwerk ablegen

;Veraendert A nicht. Wenn A veraendert werden darf, kann hier
;eine Version hin, die auch den Extent loescht, das spart bei
;den aufrufenden Routinen. Fuer Parse(A/U)FN ist A zwar egal,
;aber ich verzweige aus mehreren Routinen hierher, und alle
;Faelle zu verfolgen ohne dabei was zu uebersehen ...
;Da ging mir die Sicherheit vor maximaler Platzersparnis.
	ORG	ParseFN5
		LD	HL,DefaultFCB+14 ;Extent und s1 lassen
XParseFN:	LD	B,22

.COMMENT %---------------------------------------
TP-RTL4.INC, Ende von SinReal:
SinReal5:	POP	AF
		JP	NegateReal-1
spart 6 Byte
---------------------------------------% ;COMMENT

;Fehler bei Int2Real (Endlosschleife bei $8000)
	ORG	Int2Real+11
		LD	A,91h		;+eins mehr
		DEFB	6		;+eingeflickt LD B,29h
;--- ab hier nur um eins nach hinten verschoben
Int2Real1:	ADD	HL,HL
		DEC	A
		BIT	7,H
		JR	Z,Int2Real1
		LD	B,H
		LD	C,L
		LD	DE,0
		LD	H,D
		LD	L,A
		EX	AF,AF'
;--- hier wird das eine Byte eingespart:
;--- statt RET NZ/RES 7,B/RET
		JR	Z,RandReal2		;=RES 7,B/RET
		RET

	ORG	ResetT+1	;RewriteT/ResetT
		CALL	OExtra		;User kompatibel
	ORG	FOpen1-7	;DeleteFile
		CALL	XBDOS		;User dazu
	ORG	FOpen1+1	;MakeFile
		CALL	XBDOS		;User dazu

;bei FOpen s1-Byte nicht schrotten
	ORG	ClearFcb+7
		LD	(HL),0		;Extent loeschen
		INC	HL
		INC	HL		;s1-Byte lassen
		JP	XParseFN	;ParseFN5+3
		DEFB	'h'		;frei

	ORG	FClose+11
		CALL	XBDOS		;User dazu

;Editor umschaltbar
	ORG	EdInit-3
		JP	EExtra

.COMMENT %---------------------------------------
TP-RTL6B.INC, Ende von SeekEnd
statt >>>
		JR	Z,SeekEnd3
		...
		JR	Z,SeekEnd2
		...
		JR	Z,SeekEnd2
		...
		JR	NC,SeekEnd3
		...
		JR	Z,SeekEnd3
		...
SeekEnd2:	LD	HL,1
		RET
SeekEnd3:	LD	HL,0
		RET

kuerzer >>>
		JR	Z,SeekEnd3
		...
		JR	Z,SeekEnd2
		...
SeekEnd2:	JP	Z,Equal (2.INC, = LD HL,1/RET Z/...)
		...
		JP	NC,TruncReal3 (= LD HL,0/RET)
		...
SeekEnd3:	JP	Z,TruncReal3
		...

Spart 8-3 = 5 Byte
---------------------------------------% ;COMMENT

	ORG	ResetFO+1	;RewriteFO/ResetFO
		CALL	OExtra		;User kompatibel
	ORG	FBDOS+22
		CALL	XBDOS		;User dazu
	ORG	ResetF+1	;RewriteF/ResetF
		CALL	OExtra		;User kompatibel
	ORG	ResetF+33	;FileSize
		CALL	XBDOS		;User dazu
	ORG	BlockRW2+23	;ReadRand/WriteRand
		CALL	XBDOS		;User dazu

;Platz schaffen
	ORG	Erase+4
		CALL	OER		;User kompatibel
		LD	C,DeleteFile
		CALL	FBDOS+17
		INC	A
		RET	NZ
;das ist vorverlegt
ErrNoFile:	;E: A=0!
		INC	A		;Fehler 01 'file does not exist'
		JP	BlkRWErr	;= LD (IORes),A/RET

	ORG	Rename+24
		CALL	OER		;User kompatibel
		LD	DE,12
		LD	B,D
		LD	C,E
		ADD	HL,DE
		PUSH	HL		;Zeiger auf FCB in FIB
		LD	E,16
		ADD	HL,DE		;Zeiger auf zweite Haelfte
		EX	DE,HL
		LD	L,DefaultFCB	;H=0 (war DE=16)
		LDIR
		POP	DE
		PUSH	DE
		LD	C,RenameFile
		CALL	XBDOS
		POP	DE
		INC	A
		JP	NZ,Assign2+13
		JR	ErrNoFile
;hier jetzt 13 Byte Platz

;E:- / V: AF, BC / R: akt. User in A
XUserFF:	LD	A,0FFh
;E: User oder 0FFh in A
;V: AF, BC
;R: - oder akt. User in A
XUser:		PUSH	DE
		PUSH	HL
		LD	E,A
		LD	C,GetSetUsr
		CALL	BDOS
		POP	HL
		POP	DE
		RET
;=13 lang, nix mehr frei


;altes Chain/Execute totlegen
	ORG	Execute
		NOP
		LD	A,0CEh		;Chain/Execute-Fehler
		JP	RunTimErrX
;ab hier jetzt 92 Byte frei


;BDOS-Funktion ausfuehren, aber
;- vorher User setzen (steht in s1-Byte des FCB) und nachher wieder dort eintragen
;- eingestellten User dabei nicht veraendern
;Ueberall anstelle des normalen BDOS-Aufrufs einsetzen,
;wo ein Zeiger auf einen FCB in DE uebergeben wird.
;Registerverwendung beim BDOS-Aufruf:
;E: C Funktionsnummer, DE zeigt auf FCB
;R: Status in A (Status auch in HL, dies wird aber nirgends verwendet)
;d.h. fuer mich, dass ich vor dem BDOS-Aufruf nur BC und DE
;und nach dem Aufruf AF zu retten brauche
XBDOS:	;eingestellten User holen
		PUSH	BC
		CALL	XUserFF
		LD	(OldUsr),A
	;meinen User setzen (und merken)
		LD	HL,13
		ADD	HL,DE		;Adresse des s1-Bytes im FCB
		LD	A,(HL)		;ausrechnen. Dort steht User.
		LD	(MyUsr),A	;holen und merken
		AND	1Fh		;Bit 7 loeschen
		CALL	XUser
		POP	BC
	;eigentliche Aktion
		PUSH	HL
		CALL	BDOS		;BDOS-Aufruf, verwendet s1-Byte
		POP	HL		;HL= Zeiger auf s1-Byte in FCB
	;meinen User wieder in FCB eintragen
MyUsr		EQU	$+1		;InTheCode!
		LD	(HL),0		;User eintragen
	;vorherigen User wieder einstellen
		PUSH	AF
OldUsr		EQU	$+1
		LD	A,0
		CALL	XUser
		POP	AF
		RET
;=36 lang


;Parse-Routine aufblasen fuer User
PExtra:		CALL	Ziffer
		JR	Z,UserInL
		LD	H,L
		CALL	Ziffer
		JR	NZ,PutCurrDU
		LD	A,H
		ADD	A,A
		ADD	A,A
		ADD	A,H
		ADD	A,A
		ADD	A,L
		CP	32
		JR	NC,PutCurrDU
		LD	L,A
UserInL:	LD	A,L
		POP	HL		;gemerkten Zeiger wegwerfen
		INC	DE		;Zeiger nach ':' richten
		JR	PutDU

Ziffer:		CALL	CheckDecim
		JR	NC,PutCDU	;hier liesse sich noch durch
		LD	L,A		;einen unschoenen JP C,13E0h
		INC	DE		;ein Byte sparen
		LD	A,(DE)
		CP	':'
		RET

;Fehler
PutCDU:		POP	AF		;werfe Returnadresse weg
PutCurrDU:	POP	DE		;gemerkten Zeiger holen
		LD	B,0		;akt. Drive
;Drive in B
PutDrive:	LD	A,0FFh		;eigentlich nur Bit 7 setzen
					;Vermutlich ginge auch CPL.
;User in A, Drive in B
PutDU:		LD	HL,DefaultFCB+12 ;Extent
		LD	(HL),H		;=0
	;Notwendig, da ParseFN5 Extent nicht loescht
		INC	HL		;s1
		LD	(HL),A		;User ablegen
		LD	L,LOW DefaultFCB
		JP	PBack
;=55 lang, 1 frei
		DEFB	'h'		;frei


;Overlay laden von Drive/User
	ORG	Overlay
		LD	(OvrBegin),HL
		EX	DE,HL
		LD	(OvrLength),HL
		POP	HL		;Zeiger auf Overlaybereich
		PUSH	HL		;auf Stack merken
		LD	C,(HL)
		LD	(HL),E
		INC	HL
		LD	B,(HL)
		LD	(HL),D
		EX	DE,HL
		OR	A
		SBC	HL,BC
		JP	Z,Overlay3
	;DE zeigt 1 Byte vor Name
		CALL	ParseFN5	;FCB loeschen. H=0, B=0
		EX	DE,HL
		LD	E,DefaultFCB	;das Byte vor dem Namen wird zwar
		LD	C,12		;unnoetigerweise mitkopiert, aber
		LDIR			;das erspart mir INC HL und INC DE
		PUSH	HL
		XOR	A
		LD	(DE),A		;Extent
		INC	DE
		CALL	XUserFF
		LD	(DE),A		;s1-Byte
		PUSH	DE		;Zeiger darauf merken
		LD	E,DefaultFCB
		LD	A,(OvrDrv)
		LD	(DE),A
		LD	C,OpenFile
		CALL	XBDOS		;nicht BDOS, sonst wird s1-Byte geschrottet
		POP	HL		;Zeiger auf s1-Byte
		INC	A
		JR	NZ,OverL1	;hat geklappt -> weiter
	;nicht gefunden -> installierten DU:
OUser		EQU	$+1
		LD	(HL),0		;User
		LD	L,DefaultFCB
ODrive		EQU	$+1
		LD	(HL),0		;Drive
		EX	DE,HL
		LD	C,OpenFile
		CALL	XBDOS
		INC	A
OverL1:		POP	DE		;zeigt auf Platz fuer Funktion
		JR	Z,Overlay4	;nein -> Fehler
		LD	HL,(OvrBegin)
		LD	(DefaultFCB+33),HL ;random record position
		LD	BC,(OvrLength)
Overlay2: ;Funktion einlesen
		PUSH	BC
		PUSH	DE
		LD	C,SetDMA
		CALL	BDOS
		LD	DE,DefaultFCB
		LD	C,ReadRand
		CALL	XBDOS
		POP	DE
		POP	BC
		OR	A
		JR	NZ,Overlay4
		LD	HL,DefaultFCB+33 ;random rec. Position
		CALL	INCWord
		LD	L,SecSize	;H=0
		ADD	HL,DE
		EX	DE,HL
		DEC	BC		;Zaehler erniedrigen
		LD	A,B		;fertig?
		OR	C
		JR	NZ,Overlay2	;nein -> weiterlesen
	;Datei schliessen
		LD	DE,DefaultFCB
		LD	C,CloseFile
		JP	OVExtra

Overlay4: ;Fehler beim Oeffnen der Datei oder beim Lesen
		LD	A,0F0h
		JP	RunTimErrX
;1 frei
		DEFB	'o'		;frei!

	ORG	JoinBl1+3
		JR	InitHX		;InitHeap+3
;ab hier jetzt 9 Byte frei

OVExtra:	CALL	XBDOS
Overlay3: ;Funktion starten
		POP	HL		;HL= OvrArea. Startadresse ausrechnen
		LD	DE,13
		ADD	HL,DE
		JP	(HL)		;los geht's
;=9 lang, nix mehr frei

	ORG	InitHeap
		LD	(FreeRoot),HL
InitHX:		LD	(HeapPtr),HL
Clear4Bytes:


;Kommandozeile retten
	ORG	ParamCnt1+3
		LD	B,(HL)
		RES	7,B		;safety first
		INC	HL
		LD	C,0
ParamCnt3:	INC	B
		DEC	B
		JR	Z,ParamCnt5
		LD	A,(HL)
		CP	' '
		JR	Z,ParamCnt4
		CP	TAB
		JR	NZ,ParamCnt5
ParamCnt4:	INC	HL
		DEC	B
		JR	ParamCnt3
ParamCnt5:	LD	E,L
		LD	A,H
		LD	(Spezial),A	;HighByte retten!
ParamCnt6:	INC	B
		DEC	B
		JR	Z,ParamCnt7
		LD	A,(HL)
		CP	' '
		JR	Z,ParamCnt7
		CP	TAB
		JR	Z,ParamCnt7
		INC	HL
		DEC	B
		JR	ParamCnt6

ParamCnt7:	LD	A,L
		SUB	E
		JR	Z,ParamCnt8
		INC	C
		DEC	D
		JR	NZ,ParamCnt3
ParamCnt8:	LD	L,C
		LD	H,0
Spezial		EQU	$+1
		LD	D,0		;gemerkte Stelle auf Wort erweitern
		RET

	ORG	ERROR+1
		CALL	DefaultIO

	ORG	HaltProgram
		CALL	ScreenReset


;-----------------------------------------
;	Patches Menue/Editor
;-----------------------------------------
;Da keine grossen Platzprobleme auch nicht sonderlich optimiert.
;Kann keine DIR:-Form.
;Eingabezeile des Editors fuer Dateinamen um eins vergroessert (15 -> 16)
;auf Kosten der Eingabezeile fuer den Options-String (10 -> 9)
;Grund: 'A10:FILENAME.TYP' = 16 Zeichen!

	ORG	EditComp
		JP	OpeningMenue	;Sprung anpassen

	ORG	Balken	;und PrSpace, OpeningMenue(1). 85 bzw. 51 Bytes frei bis WhoAmI
PrintFExtra:	CALL	SConOut		;Befehl nachholen
		LD	HL,13		;s1-Byte holen
		ADD	HL,DE
		LD	A,(HL)
		SCF

;davor steht CALL SConOut, das veraendert AF nicht.
;davor steht ADD A,'A', das setzt NCarry und NZero
ShowExtra: ;aktuellen User anzeigen. Sollte C nicht veraendern.
		CALL	NC,XUserFF	;hole aktuellen User
ShowUser:	LD	B,'0'-1
SubWeiter:	INC	B
		SUB	10
		JR	NC,SubWeiter
		ADD	A,10+'0'
		LD	H,A		;merken
		LD	A,B
		CP	'0'
		CALL	NZ,SConOut
		LD	A,H
		JP	SConOut
;=32 Byte lang

ParseExtra:	LD	B,C		;=0
		CALL	ParseFN		;Befehl nachholen
UserEintragen:	LD	A,(DefaultFCB+13) ;s1-Byte
		INC	A		;=0FFh?
		RET	NZ		;nein, dann war einer angegeben
		CALL	XUserFF
		LD	(DefaultFCB+13),A ;aktuellen eintragen
		RET
;=16 Byte lang
;zus. 48, 37 bzw. 3 frei


;WhoAmI:	DEFB	'TURBO ...
;'duu:filename ' = 13 Zeichen Platz freihalten


	ORG	WhoAmI+13	;OpeningMenue(2). 102 Byte bis neues OpeningMenue
;Original, nur verschoben
PrSpace:	CALL	Print
		DEFB	' ',0
		DJNZ	PrSpace
		RET
;=8 Byte lang
;Kann ich weg kriegen:
;L30F6 und L3D03 beide LD A,' '/CALL SConOut/DJNZ/RET.
;Wenn ich nun bei einem PUSH AF/CALL <den anderen>/POP AF/RET mache,
;dann entspricht das PrSpace.


;Erweiterung fuer MLogged um User
;Die folgenden 3 Zeilen lassen sich wegkriegen:
;1. Unterroutine GetCurrDU: LD A,(CurrDU)/AND 0Fh/RET (6 Byte)
;2. im Aufruf CALL M,GetCurrDU/LD H,A/JP MLExtra
MLExtra:	LD	A,(CurrDU)
		AND	0Fh
DriveOk:	LD	H,A
		LD	A,(DefaultFCB+13) ;User
		LD	L,A
		INC	A
		LD	A,(CurrDU)
		JR	Z,NoChange
		LD	A,L
		CP	16
		RET	NC
		CALL	XUser
		LD	A,L
		RLCA
		RLCA
		RLCA
		RLCA
NoChange:	AND	0F0h
		OR	H
JustReset:	PUSH	AF		;wenn gewuenscht ist, dass nur das neue
		LD	C,Reset		;Ziellaufwerk zurueckgesetzt wird, dann
		CALL	SBDOS		;empfiehlt sich ShLeft (TP-RTL2.INC)
		POP	AF		;um die Maske zu erzeugen:
		LD	(CurrDU),A	;(Lw in B) LD HL,1/CALL ShLeft
		AND	0Fh
		LD	E,A		;hier laesst sich 3 einsparen
		LD	C,DriveSelect	;durch JP 2C9Fh (in MDir)
		JP	SBDOS
;=49 Byte lang


;beim Vergleichen von Dateinamen auch User mit vergleichen
CmpFiles:	LD	DE,WorkFCB
		LD	HL,MainFCB
		LD	B,12
CmpFil1:	LD	A,(DE)
		SUB	(HL)
		RET	NZ
		INC	DE
		INC	HL
		DJNZ	CmpFil1
	;ab hier neu dazugekommen
		INC	DE		;ignoriere Extent
		INC	HL
		LD	A,(DE)		;aber vergleiche s1-Byte
		SUB	(HL)
		RET
;=20 Byte lang
;zus. 77, 25 frei


;OpeningMenue weg, TURBO.MSG immer laden, aktuellen User als LoggedUser merken,
;Dateinamen aus der CP/M-Kommandozeile uebernehmen als Work- und Main-File
	ORG	MainMenue-75
OpeningMenue: ;Ende des verfuegbaren Speichers
		LD	HL,(BDOS+1)
		LD	BC,-708
		ADD	HL,BC
		LD	(EndAddress),HL
	;Logged DU
		LD	C,GetDrive	;mit CALL GetCurrD (s.o.) 2 einsparbar
		CALL	BDOS
		INC	A
		LD	(LoggedDrive),A
		CALL	XUserFF		;hole aktuellen User
		LD	(LoggedUser),A
	;Kommandozeile auswerten
		LD	HL,CmdLine
		LD	D,H		;=0
		LD	E,(HL)		;Laenge
		LD	(HL),H		;=0. Wichtig fuer InitMemIO!
		INC	HL
		ADD	HL,DE
		LD	(HL),EOF	;mit EOF statt 0 terminieren
		LD	E,CmdLine+1	;D=0
		;die folgenden zwei Zeilen sind nicht unbedingt noetig,
		;sofern man TURBO nicht mit GO starten will
		XOR	A
		LD	(WorkFCB+1),A	;kein Workfile
		CALL	GetLine1
		JR	Z,OpeningM1
		CALL	ParsePAS
		PUSH	DE
		LD	DE,WorkFCB
		CALL	Assign2+13	;DefaultFCB kopieren
		POP	DE
		CALL	GetLine1
		CALL	MMainF+26
OpeningM1:	CALL	InitMemIO
	;Messages und Workfile einlesen
LoadMenue	EQU	$+1		;Installierbar: 0CDh= ja, 21h= nein
		CALL	ReadMSG
		CALL	MyWorkF		;WorkFile einlesen
	;	CALL	ShowMain
;hier schliesst sich MainMenue an
;=75

;Im Hauptmenue 'Logged Drive:' --> 'Logged DU:'
	ORG	ShowMain+13
		DEFB	'DU:',' '+80h,0
		LD	C,GetDrive	;mit CALL GetCurrD (s.o.) 2 einsparbar
		CALL	BDOS
		ADD	A,'A'
		CALL	SConOut
		CALL	ShowExtra

	ORG	ShowOpt1+2
		JP	PrSpace		;Sprung anpassen

	ORG	MJumps+2
		DEFW	MWorkF		;Sprung anpassen

	ORG	MMainF+38
		JP	Assign2+13	;= LD HL,DefaultFCB/LD BC,36/LDIR/RET
;--- MWorkF Original, rutscht nur 6 Byte nach oben
MWorkF:		LD	HL,NewFile
		LD	(NotFoundJp+1),HL
		CALL	AutoSaveQ
		CALL	Print
		DEFB	CR,LF,'Work file name',0
		CALL	GetLine
		LD	A,0
		LD	(WorkFCB+1),A
		JR	NZ,MWorkF1
		CALL	ClearText
		JP	MainMenue

MWorkF1:	CALL	ParsePAS
		LD	DE,WorkFCB
;--- ab hier neu
		CALL	Assign2+13
		JR	MWorkF3		;ab hier jetzt 11 Byte frei

MyWorkF:	CALL	WorkFGiven
		JP	Z,ClearText
		LD	HL,NewFile
		JR	MWorkF2+3	;= LD (NotFoundJp+1),HL/MWorkF3
;=11 Byte lang, nix mehr frei

;Pieps vor AutoSave (Holger special)
;Problem: wenn man den aktuellen WorkFile geaendert hatte und einen
;neuen WorkFile waehlen moechte, dann kommt die Frage: 'Save? (Y/N)'.
;Wenn man aber nicht hinschaut, sondern den neuen Dateinamen blind
;eingibt, und dieser zufaellig ein 'N' enthaelt, dann wird der geaenderte
;aktuelle WorkFile weggeworfen ... Deshalb bei dieser Frage piepsen.
	ORG	AutoSaveQuest
		DEFB	'Save',BELL

;User dazu
	ORG	MSave+48	;DeleteFile
		CALL	SXBDOS
	ORG	MSave1+6	;MakeFile
		CALL	SXBDOS
	ORG	DefSBDOS+3
		JP	SXBDOS


;s1-Byte stehenlassen
	ORG	EClearFcb
		LD	HL,12
		JP	ClearFcb+6	;in ClearFcb von Laufzeitbibliothek
;ab hier jetzt 11 Byte frei

;LoggedDrive + LoggedUser an Overlay uebergeben
OverExtra:	LD	A,(LoggedDrive)
		LD	H,A
		LD	A,(LoggedUser)
		LD	L,A
		RET
;= 9 Byte lang
		DEFB	'ho'		;2 frei


;CmpFiles-Aufruf umbiegen
	ORG	L27EA
		CALL	CmpFiles


;User dazu
	ORG	L2841+32	;MCompile DeleteFile
		CALL	SXBDOS
	ORG	L2841+38	;MCompile MakeFile
		CALL	SXBDOS


;MCompile: z3env in generiertem COM-File auf Null setzen
	ORG	L287B+15	;MCompile WriteSeq
		LD	HL,(z3env)
		PUSH	HL
		LD	C,SetDMA
		CALL	CompExtra
		POP	HL
		LD	(z3env),HL


;Kopieren von Drive/Name: User mitnehmen
	ORG	L29F8+24	;in MCompile
		LD	BC,14		;statt 12
	ORG	L2A41+11
		LD	BC,14
	ORG	L2AB5+3	;in MRun
		LD	BC,14

;User dazu
	ORG	L2AB5+28	;MRun OpenFile
		CALL	SXBDOS


;Aufruf des Overlays: LoggedUser mit uebergeben
	ORG	L2B7A+2
		CALL	OverExtra
		PUSH	HL


;akt. User verwenden wenn keiner angegeben wurde
	ORG	MDir+18		;nach CALL ParseAFN
		CALL	UserEintragen	;<-- zusaetzlich
;--- ab hier Original, nur um drei nach hinten verschoben
		LD	C,GetDrive	;mit CALL GetCurrD (s.o.) 2 einsparbar
		CALL	SBDOS
		PUSH	AF
		PUSH	AF
		LD	A,(DefaultFCB)
		OR	A
		JR	Z,L2BBB
		POP	HL
		DEC	A
		LD	E,A
		PUSH	AF
		LD	C,DriveSelect
		CALL	SBDOS
L2BBB:		POP	AF
		ADD	A,'A'
		LD	(L2C8D),A
		LD	DE,SecBuf
		LD	C,SetDMA
		CALL	SBDOS
		LD	DE,0
		LD	C,SearchFirst
L2BCE:		PUSH	DE
		CALL	DefSBDOS
		POP	DE
;--- das hier ist um drei kuerzer	;war:
		INC	A		;LD C,A/INC A
		JR	Z,L2C29
		DEC	A		;LD A,C/ADD A,A/ADD A,A
		RRCA			;ADD A,A
		RRCA			;ADD A,A
		RRCA			;ADD A,A
;--- bis hierher
	ORG	L2C29-2
		JR	L2BCE		;Sprung korrigieren


;MLogged aufblasen fuer DU-Form
	ORG	MLogged+7
		DEFB	'DU',0
		CALL	GetLine
		LD	A,(CurrDU)
		JP	Z,JustReset
		LD	HL,(BufLast)
		LD	(HL),EOF
		DEC	HL
		LD	(HL),':'
		CALL	ParseAFN
		LD	A,(DE)		;muss alles verdaut sein
		CP	EOF
		RET	NZ
		LD	A,(DefaultFCB+1) ;es darf kein Dateiname angegeben sein
		CP	'?'
		RET	NZ
		LD	A,(DefaultFCB)	;Drive
		DEC	A
		JP	P,DriveOk	;hier auch:
		JP	MLExtra		;CALL M,GetCurrD/LD H,A/JP MLExtra
		DEFB	'h'		;frei


;akt. User verwenden wenn keiner angegeben wurde
	ORG	ParseEXT+8
		CALL	ParseExtra

	ORG	L2D50+10
		CALL	MWorkF	;Sprung anpassen


	ORG	ECmpFiles	;CmpFiles ist ausgelagert. 16 Byte Platz
;Versuch starten mit Drive=A, User=B,
;sofern nicht gerade schon dort nachgesehen wurde
XOpenDefault:	CP	(HL)
		LD	(HL),A
		JR	NZ,XOpenDef1
		LD	A,(DefaultFCB+13)
		CP	B
		RET	Z
XOpenDef1:	LD	A,B
		LD	(DefaultFCB+13),A
		JP	OpenDefault	;etwas zu weit fuer JR
;=16 Byte lang, nix frei


;PrintFName um Anzeige von User erweitern
	ORG	PrintFName+8
		PUSH	HL
		CALL	PrintFExtra
		POP	HL
		LD	A,':'
		CALL	SConOut


;Suchen von Dateien anhand Pfad: User dazu
	ORG	L2E20+10
		LD	A,(LoggedUser)
		LD	B,A
		LD	A,(LoggedDrive)
		CALL	XOpenDefault
		RET	NZ
;Installierbarer DU:
		LD	A,10
SearchDisk	EQU	$-1
		LD	B,10
SearchUser	EQU	$-1
		CALL	XOpenDefault
		RET	NZ

.COMMENT %---------------------------------------
Zeichen mit gesetztem Bit 7 behandeln: (Upgrade auf V3.01)
L2F3A+5:	JR	Z,L2F44   ->	JR	NC,L2F44

L2FA8+5:			  ->	CP	DEL
				  ->	RET	NC
---------------------------------------% ;COMMENT

.COMMENT %---------------------------------------
TP-ME2.INC, L33E4 (IsAlsum des Editors):
		CALL	IsAlnum (des Compilers)
		CCF
		RET
spart 18 Byte
---------------------------------------% ;COMMENT

;Eingabezeile des Editors fuer Dateinamen um eins vergroessern
;auf Kosten des Options-Strings
	ORG	L3566
		LD	DE,L44DF-1
	ORG	L3566+6
		LD	DE,L44E1-1

;L4543 freimachen fuer LoggedDrive
	ORG	EdiConO1
		LD	A,0
CountChars	EQU	$-1		;InTheCode!
		NOP
		SUB	2
		LD	(CountChars),A


;Eingabezeile des Editors fuer Dateinamen um eins vergroessern
	ORG	L44D2
		DEFB	9
	ORG	L44DF-1
		DEFB	16,0

;-----------------------------------------
;	Patches Compiler
;-----------------------------------------
;Erzeugung von Overlay-Dateien: User nicht schrotten
;CALL 1460h ist auch moeglich, aber die Platzersparnis bringt hier nix
;Lieber weniger Taktzyklen.
	ORG	$Overlay3+54
		LD	(HL),0		;Extent loeschen
		INC	HL
		INC	HL
		CALL	XParseFN

;User dazu
	ORG	$Overlay3+67	;Overlay: DeleteFile
		CALL	SXBDOS
	ORG	$Overlay3+73	;Overlay: MakeFile
		CALL	SXBDOS
	ORG	$Overlay11-3	;Overlay: CloseFile
		CALL	SXBDOS
	ORG	RWObjSec+13	;Patches: ReadRand/WriteRand
		CALL	SXBDOS
	ORG	ScanSpc18+23	;ScanSpace: OpenFile
		CALL	SXBDOS
	ORG	RawInput3+12	;RawInput: ReadSeq
		CALL	SXBDOS
	ORG	ErrAlw2+11	;ErrAlways: CloseFile
		CALL	SXBDOS

.COMMENT %---------------------------------------
TP-C6.INC, IsNumber, CCompInts:
Umleiten auf entsprechende Routinen in Laufzeitbibliothek
spart 7+13 (abzueglich Umleitung)
CMultInt geht leider nicht so einfach, da etwas anders.
---------------------------------------% ;COMMENT

;die Divisionsroutine wird nirgendwo verwendet!
	ORG	CDivInt	;26 Byte Platz
CompExtra:	CALL	SBDOS		;SetDMA
		LD	HL,0
		LD	(z3env),HL
		LD	C,WriteSeq
		LD	DE,ObjFCB
;<fall through> =14 Byte

;SBDOS mit User
SXBDOS:		PUSH	IX
		PUSH	IY
		CALL	XBDOS
		JR	SBDOS+7		;JP wenn nicht an dieser Stelle,+1 Byte
;=9 Byte lang
;zus. 23, 3 Byte frei
		DEFB	'hoh'

		END
