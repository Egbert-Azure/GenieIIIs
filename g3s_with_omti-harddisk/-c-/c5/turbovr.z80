		TITLE	TP Overlay

.COMMENT %
---------------------------------------------------------------------
		(TP-OVR = Turbo Pascal - TURBO.OVR)

		Disassembliert von Herbert Oppmann
		Drausnickstr. 29 Zi.405, D-8520 Erlangen
		erweiterte Version 04-JAN-93
---------------------------------------------------------------------
%

;ASCII
CtlC		EQU	3
LF		EQU	10
CR		EQU	13
EOF		EQU	26

;Adressen
WBoot		EQU	000h
CurrDU		EQU	004h
BDOS		EQU	005h
DefaultFCB	EQU	05Ch
DefaultDMA	EQU	080h
CmdLine		EQU	080h
TPA		EQU	100h
Z3		EQU	109h
OverArea	EQU	9000h

;BDOS-Funktionen
ConIO		EQU	6
ConString	EQU	9
Reset		EQU	13
DriveSelect	EQU	14
OpenFile	EQU	15
ReadSeq		EQU	20
GetDrive	EQU	25
SetDMA		EQU	26
GetSetUser	EQU	32

;sonstiges
BiosJumps	EQU	20	;ein bischen mehr schadet nicht
FCBSize		EQU	36
SecSize		EQU	80h

;MACROs zum Anpassen der Adressen im residenten Teil

PCount		ASET	0

setp		MACRO	Nr
PPos&Nr		EQU	$-3-ResBase
		ENDM

rel		MACRO	Cmd1, Address, Cmd2
PCount		ASET	PCount+1
		Cmd1&Address-ResBase&Cmd2
		setp	%PCount
		ENDM

defp		MACRO	Nr
		DEFW	PPos&Nr
		ENDM

;>> Code

		.PHASE	OverArea
		JP	OvrInit


;>> der folgende Teil wird ausgelagert (residenter Teil)
ResBase		EQU	$

;>> gestartetes Programm darf bis hierher ueberschreiben, wenn es das BDOS braucht

;das soll auf eine Adresse xx06h!
;BDOS-Umleitung
RoutBDOS:	LD	A,C		;hole Funktionsnummer
		CP	Reset-1		;groesser gleich 12?
		JR	NC,GotoBDOS	;ja -> durchlassen
	;nein -> ueber Tabelle verteilen
	rel	<LD	HL,>,BdosTbl
		LD	B,0		;Tabellenplatz adressieren
		ADD	HL,BC
		ADD	HL,BC
		LD	A,(HL)		;Eintrag holen
		INC	HL
		LD	H,(HL)
		LD	L,A
		ADD	A,H		;=0?
		JR	Z,GotoBDOS	;ja -> durchlassen
	;ok. Dieser Aufruf muss umgeleitet werden, wenn er von draussen kam
	rel	<LD	A,(>,BDOSSrc,<)> ;wurde dieser BDOS-Aufruf von einer unserer
		OR	A		;Umleitungsroutinen abgesetzt?
		JR	NZ,GotoBDOS	;ja -> muss durchgelassen werden
		INC	A		;ok, setze Flag:
	rel	<LD	(>,BDOSSrc,<),A> ;wir sind in Umleitungsroutine
	;Routine starten, so dass hinterher ClrBDOSSrc aufgerufen wird
		PUSH	HL
	rel	<LD	HL,>,ClrBDOSSrc
		EX	(SP),HL
		JP	(HL)

GotoBDOS:	JP	1234h
OldBDOS2	EQU	$-2


;Tabelle fuer BDOS-Funktionen 0-11
BdosTbl: rel	<DEFW	>,RoutWBoot	;Boot
	rel	<DEFW	>,RoutConsole	;ConIn
	rel	<DEFW	>,RoutConsole	;ConOut
		DEFW	0,0,0		;RdrIn - SetIOByte
		DEFW	0,0,0		;durchlassen
	rel	<DEFW	>,RoutConsole	;ConString
	rel	<DEFW	>,RoutBufInp	;BuffInput
	rel	<DEFW	>,RoutConsole	;ConStat


;Loesche BDOSSrc
;E:- / V:- / R: BDOSSrc =0
ClrBDOSSrc:	PUSH	HL
	rel	<LD	HL,>,BDOSSrc
		LD	(HL),0
		POP	HL
		RET


RoutConsole:
	rel	<LD	HL,>,DummyRet	;nachher nix ausgeben
RoutIO:
	rel	<LD	(>,RoutPatch,<),HL>
		LD	A,1		;setze Flag 'BDOS ruft BIOS auf'
	rel	<LD	(>,BIOSSrc,<),A>
		CALL	BDOS
		LD	B,A		;merke Taste
	rel	<LD	A,(>,CtlCFlag,<)> ;alles klar?
		OR	A
	rel	<LD	(>,BIOSSrc,<),A> ;Flag loeschen, fuer den Fall, dass =0
		LD	A,B		;Taste holen
		RET	Z		;ja -> zurueck
	;nein -> Tschuess!
		CALL	1234h
RoutPatch	EQU	$-2		;InTheCode!
		JP	WBoot


;Buffered Console Input (BDOS-Funktion 10)
RoutBufInp:
	rel	<LD	HL,>,CtlCMessage ;nachher ^C ausgeben
		JR	RoutIO


CtlCMessage:
	rel	<LD	DE,>,CtlCTxt
		LD	C,ConString
		CALL	BDOS
		RET

CtlCTxt:	DEFB	LF,'^C$'


;>> was hier folgt, muss zwar nicht gerettet werden,
;   aber sonst waere hier eine ungenutzte Luecke

;residenten Teil einhaengen in BDOS/BIOS-Aufrufe,
;Programm laden und starten
ResInit: ;BDOS umleiten
	rel	<LD	HL,>,RoutBDOS
		LD	(BDOS+1),HL
	;ganzes BIOS nach vorne verlegen, um Overlay zu schuetzen
	rel	<LD	HL,>,@WBoot
		LD	(WBoot+1),HL
	;einzelne BIOS-Spruenge umleiten
	rel	<LD	HL,>,RoutWBoot
	rel	<LD	(>,@WBoot+1,<),HL>
	rel	<LD	HL,>,RoutConInp
	rel	<LD	(>,@ConInp+1,<),HL>
	;Programm laden und TurboFCB kopieren
	rel	<LD	A,(>,FCBCopy+13,<)>	;User
		LD	E,A
		LD	C,GetSetUser
		CALL	BDOS
	rel	<CALL	>,FLoad
	rel	<LD	HL,>,TurboFCB
	rel	<LD	DE,>,FCBCopy
		LD	BC,FCBSize
		LDIR
	;Stack setzen, Returnadresse auf WBoot setzen, Programm starten
		LD	HL,(BDOS+1)
		LD	DE,-100
		ADD	HL,DE
		LD	SP,HL
		LD	HL,WBoot
		PUSH	HL
		JP	TPA

TurboFCB:	DEFB	0,'TURBO   COM'
		DEFS	TurboFCB+FCBSize-$

		DEFS	250-($-RoutBDOS)	; auf naechste Pagegrenze

;>> gestartetes Programm darf bis hierher ueberschreiben, wenn es das BDOS nicht braucht
BiosTbl:	DEFS	3
@WBoot:		DEFS	3
		DEFS	3
@ConInp:	DEFS	3
		DEFS	3*(BiosJumps-4)

;WBoot-Umleitung: residenten Teil ausklinken aus BDOS/BIOS-Aufrufen,
;dann TURBO.COM einladen und starten
RoutWBoot:	LD	SP,TPA
	rel	<LD	DE,>,HitKeyTxt
		LD	C,ConString
		CALL	BDOS
WaitForKey:	LD	C,ConIO
		LD	E,0FFh
		CALL	BDOS
		OR	A
		JR	Z,WaitForKey
	; CurrDU wiederherstellen, CurrDrive selektieren
	rel	<LD	A,(>,CurrUser,<)>
		RLCA
		RLCA
		RLCA
		RLCA
		LD	B,A
	rel	<LD	A,(>,CurrDrive,<)>
		OR	B
		LD	(CurrDU),A
		AND	0Fh
		LD	E,A
		LD	C,DriveSelect
		CALL	BDOS
		JR	TryAgain2

TryAgain:	LD	C,Reset
		CALL	BDOS
TryAgain2: ;probiere erst LoggedDU, dann CurrDU, dann installierbarer DU
	rel	<LD	A,(>,LoggedUser,<)>
		LD	E,A
	rel	<LD	A,(>,LoggedDrive,<)>
	rel	<CALL	>,FOpen
		JR	NZ,TurboFound	;ok -> weiter
	rel	<LD	A,(>,CurrUser,<)>
		LD	E,A
		XOR	A		;drive 0 = aktuelles
	rel	<CALL	>,FOpen
		JR	NZ,TurboFound	;ok -> weiter
		LD	E,0
InstUser	EQU	$-1
		LD	A,0
InstDrive	EQU	$-1
	rel	<CALL	>,FOpen
		JR	NZ,TurboFound
		LD	A,CR
	rel	<CALL	>,PutChar
		LD	A,LF
	rel	<CALL	>,PutChar
	rel	<CALL	>,PrintFN
	rel	<LD	DE,>,NotFoundTxt
		LD	C,ConString
		CALL	BDOS
YesNo:		LD	C,ConIO
		LD	E,0FFh
		CALL	BDOS
		CP	'y'
		JR	Z,TryAgain
		CP	'Y'
		JR	Z,TryAgain
		CP	'n'
		JR	Z,ForgetIt
		CP	'N'
		JR	NZ,YesNo
ForgetIt:	LD	HL,WBoot
	rel	<LD	(>,RetAdresse,<),HL>
		JR	Restore

TurboFound:
	rel	<LD	DE,>,LoadingTxt
		LD	C,ConString
		CALL	BDOS
	rel	<LD	A,(>,FCBCopy,<)>
		ADD	'@'
	rel	<CALL	>,PutChar
		LD	A,0
FoundUser	EQU	$-1
		LD	B,'0'-1
SubWeiter:	INC	B
		SUB	10
		JR	NC,SubWeiter
		ADD	A,10+'0'
		LD	C,A
		LD	A,B
		CP	'0'
	rel	<CALL	NZ,>,PutChar
		LD	A,C
	rel	<CALL	>,PutChar
		LD	A,':'
	rel	<CALL	>,PutChar
	rel	<CALL	>,PrintFN
	rel	<CALL	>,FLoad
	rel	<LD	HL,>,ResEnd
	rel	<LD	DE,(>,SaveStart,<)>
	rel	<LD	BC,(>,SaveLength,<)>
		LDIR
		XOR	A
		LD	(CmdLine),A
Restore:
	rel	<LD	HL,(>,OldWBoot,<)>
		LD	(WBoot+1),HL
	rel	<LD	HL,(>,OldBDOS,<)>
		LD	(BDOS+1),HL
		JP	WBoot
RetAdresse	EQU	$-2		;InTheCode!

PrintFN:
	rel	<LD	HL,>,FCBCopy+1
		LD	B,11
PrintFN2:	LD	A,(HL)
		INC	HL
		CP	' '
	rel	<CALL	NZ,>,PutChar
		LD	A,B
		CP	4
		LD	A,'.'
	rel	<CALL	Z,>,PutChar
		DJNZ	PrintFN2
		RET

;E: Zeichen in A
;V: AF, DE
PutChar:	PUSH	BC
		PUSH	HL
		LD	E,A
		LD	C,ConIO
		CALL	BDOS
		POP	HL
		POP	BC
		RET

;V: AF, B, DE, HL
;R: Zero wenn 'Z3ENV'
;Positionsunabhaengig geschrieben, da es vor und nach dem Verschieben verwendet wird
IsZProg:	LD	HL,0103h
		LD	A,(HL)
		CP	'Z'
		RET	NZ
		INC	HL
		LD	A,(HL)
		CP	'3'
		RET	NZ
		INC	HL
		LD	A,(HL)
		CP	'E'
		RET	NZ
		INC	HL
		LD	A,(HL)
		CP	'N'
		RET	NZ
		INC	HL
		LD	A,(HL)
		CP	'V'
		RET

;E: Drive in A, User in E
;V: AF, BC, HL
;R: User gesetzt, User in FoundUser, Zero in A wenn Datei nicht gefunden
FOpen:		PUSH	AF
		LD	A,E
	rel	<LD	(>,FoundUser,<),A>
		LD	C,GetSetUser
		CALL	BDOS
		POP	AF
	rel	<LD	DE,>,FCBCopy
		LD	(DE),A
		LD	C,OpenFile
		CALL	BDOS
		INC	A		;hat's geklappt?
DummyRet:	RET


;Datei laden, CurrUser setzen, Z3EnvAdr setzen,
;LF/CR ausgeben, DMA auf Default setzen
;E: Stack aus dem Weg, eigener Code aus dem Weg, FCBCopy, User gesetzt
;V: AF, BC, DE, HL
;R:-
FLoad:		LD	DE,TPA-SecSize
FLoad1:		LD	HL,SecSize
		ADD	HL,DE
		EX	DE,HL
		PUSH	DE
		LD	C,SetDMA
		CALL	BDOS
	rel	<LD	DE,>,FCBCopy
		LD	C,ReadSeq
		CALL	BDOS
		POP	DE
		OR	A		;alles klar?
		JR	Z,FLoad1	;ja -> weiter
	rel	<LD	A,(>,CurrUser,<)>
		LD	E,A
		LD	C,GetSetUser
		CALL	BDOS
	rel	<CALL	>,IsZProg
		JR	NZ,FLoad2
	rel	<LD	HL,(>,Z3EnvAdr,<)>
		LD	(Z3),HL
FLoad2:		LD	C,ConIO
		LD	E,LF
		CALL	BDOS
		LD	C,ConIO
		LD	E,CR
		CALL	BDOS
		LD	DE,DefaultDMA
		LD	C,SetDMA
		JP	BDOS


;ConInp-Umleitung
RoutConInp:
		CALL	WBoot		;Taste holen
OldConInp	EQU	$-2
		CP	CtlC		;war es Control-C?
		RET	NZ		;nein -> alles klar
	rel	<LD	A,(>,BIOSSrc,<)> ;Stammt der ConInp-Aufruf vom BDOS?
		OR	A
		LD	A,CtlC
		RET	Z		;nein -> liefere Control-C
		LD	A,CR		;ja -> setze Flag und gaukle dem BDOS
	rel	<LD	(>,CtlCFlag,<),A> ;CR vor, damit dieses nicht unterbricht
		RET


;>> Konstanten und vorbesetzte Variablen fuer residenten Teil

BDOSSrc:	DEFB	0		;=0 BDOS-Aufruf kam vom aufgerufenen Prg.
					;=1 Aufruf kam von Umleitungsroutine
BIOSSrc:	DEFB	0		;=0 BIOS-Aufruf kam vom aufgerufenen Prg.
					;=1 Aufruf kam vom BDOS
CtlCFlag:	DEFB	0

HitKeyTxt:	DEFB	CR,LF,'Hit any key to reload Turbo Pascal$'
LoadingTxt:	DEFB	CR,LF,'Loading $'
NotFoundTxt:	DEFB	' not found. Retry? (Y/N)$'

LoggedDU:
LoggedUser:	DEFB	0
LoggedDrive:	DEFB	0
CurrUser:	DEFB	0
CurrDrive:	DEFB	0

Z3EnvAdr:	DEFW	0

OldBDOS:	DEFW	0
OldWBoot:	DEFW	0
SaveStart:	DEFW	0
SaveLength:	DEFW	0

FCBCopy:	DEFS	FCBSize

ResEnd		EQU	$		;Ende residenter Teil
ResLength	EQU	ResEnd-ResBase


;>> Parameter auswerten, residenten Teil auslagern und anpassen an
;   neue Adresslage, Variablen von TURBO retten

OvrInit: ;Parameter uebernehmen
		POP	HL
		LD	(RetAdresse),HL
		POP	HL
		LD	(SaveStart),HL
		POP	HL
		LD	(SaveLength),HL
		POP	HL
		LD	(ParseRoutine),HL
		POP	HL
		LD	(LoggedDU),HL	;H= drive, L= user
		POP	HL
		LD	DE,FCBCopy
		LD	BC,FCBSize
		LDIR
		POP	DE
		LD	SP,TPA
		PUSH	DE
	;akt. Drive/User ermitteln und retten
		LD	C,GetDrive
		CALL	BDOS
		LD	(CurrDrive),A
		LD	C,GetSetUser
		LD	E,0FFh
		CALL	BDOS
		LD	(CurrUser),A
		LD	(DefaultA+13),A
		LD	(DefaultB+13),A
	;Kommandozeile aufbauen
		POP	DE
		CALL	ParseCmd
	;ZCPR3 Environment Deskriptor Adresse retten
		CALL	IsZProg		; defensiv ...
		JR	NZ,OvrInit2
		LD	HL,(Z3)
		LD	(Z3EnvAdr),HL
OvrInit2: ;BDOS/BIOS-Adressen retten
		LD	HL,(BDOS+1)
		LD	(OldBDOS),HL
		LD	(OldBDOS2),HL
		LD	HL,(WBoot+1)
		LD	(OldWBoot),HL
	;BIOS-Sprungleiste kopieren
		DEC	HL		;ColdBoot mitnehmen
		DEC	HL
		DEC	HL
		LD	DE,BiosTbl
		LD	BC,3*BiosJumps
		LDIR
		LD	HL,(@ConInp+1)
		LD	(OldConInp),HL
	;Startadresse fuer residenten Teil ausrechnen
		LD	HL,(BDOS+1)
		LD	DE,(SaveLength)
		OR	A
		SBC	HL,DE
		LD	DE,-ResLength
		ADD	HL,DE
		LD	A,L
		CP	6
		JR	NC,OverInit3
		DEC	H
OverInit3:	LD	L,6
		LD	(NewBDOS),HL
	;residenten Teil kopieren
		LD	SP,HL
		EX	DE,HL
		LD	HL,ResBase
		LD	BC,ResLength
		LDIR
	;TURBO Variablen kopieren
		LD	HL,(SaveStart)
		LD	BC,(SaveLength)
		LDIR
	;residenten Teil anpassen
		CALL	Anpassen
	;Tabelle
PCnt		ASET	0
		REPT	PCount
PCnt		ASET	PCnt+1
		defp	%PCnt
		ENDM
		DEFW	-1		;terminieren
		LD	HL,(NewBDOS)
		LD	DE,ResInit-ResBase
		ADD	HL,DE
		JP	(HL)


;E: Zeiger auf mit -1 terminierte Tabelle in auf Stack,
;   (BDOS+1) zeigt auf residenten Teil
;V: AF, BC, DE, HL, (SP) / R:-
Anpassen:	POP	HL		;Zeiger in Tabelle holen
		LD	E,(HL)		;Eintrag holen
		INC	HL
		LD	D,(HL)
		INC	HL
		PUSH	HL		;Zeiger retten
		INC	DE
		LD	A,E		;war der Eintrag -1?
		OR	D
		RET	Z		;ja -> fertig
		LD	HL,WBoot	;Startadresse des residenten Teils
NewBDOS		EQU	$-2
		EX	DE,HL
		ADD	HL,DE		;anzupassende Stelle adressieren
		LD	C,(HL)		;Wort lesen
		INC	HL
		LD	B,(HL)
		EX	DE,HL
		ADD	HL,BC		;anpassen
		EX	DE,HL
		LD	(HL),D		;und zurueckspeichern
		DEC	HL
		LD	(HL),E
		JR	Anpassen


;E: Zeiger auf mit EOF terminierten String in DE
;V: AF, BC, DE, HL
;R: CmdLine und DefaultFCB
ParseCmd:	PUSH	DE
	;erstmal alte Kommandozeile tilgen
		LD	HL,CmdLine
		LD	(HL),0
		INC	HL
		LD	(HL),0
		CALL	SkipBlanks	;ruecke vor. Leer?
		JR	Z,ParseC3	;ja -> keine Kommandozeile
	;Kommandozeile kopieren, dabei in Grossbuchstaben wandeln
		LD	(HL),' '
		INC	HL
		LD	B,1		;Laenge
ParseC1:	LD	A,(DE)
		CP	EOF		;zuende?
		JR	Z,ParseC2	;ja ->
		CP	'a'		;wenns kleiner als 'a' ist
		JR	C,ParseCUp
		CP	'z'+1		;oder groesser als 'z',
		JR	NC,ParseCUp	;dann ists kein Kleinbuchstabe
		SUB	20h		;wenn doch, dann wandeln wir
ParseCUp:	LD	(HL),A
		INC	DE
		INC	HL
		INC	B
		JR	ParseC1

ParseC2: ;Laenge in B, Zeiger hinter letztes Zeichen in HL
		LD	(HL),0		;mit Null terminieren
		LD	A,B
		LD	(CmdLine),A	;Laenge eintragen
ParseC3: ;Kommandozeile steht
		POP	DE
		CALL	SkipBlanks	;ruecke vor. Leer?
		JR	Z,ParseC4	;ja -> keine Kommandozeile
	;Parse ersten Parameter fuer DefaultFCB und hole ihn
		CALL	ParseAFN
		PUSH	DE
		LD	DE,DefaultA
		LDIR
		POP	DE
		CALL	SkipBlanks	;war das alles?
		JR	Z,ParseC4	;ja -> kein zweiter Parameter
	;Parse zweiten Parameter und hole ihn
		CALL	ParseAFN
		LD	DE,DefaultB
		LDIR
ParseC4: ;Kopiere beide nach DefaultFCB
		LD	DE,DefaultFCB
		LD	HL,DefaultA
		LD	C,32
		LDIR
		RET

DefaultA:	DEFB	0,'           ',0,0,0,0
DefaultB:	DEFB	0,'           ',0,0,0,0

;Dateiname parsen, akt. User eintragen falls keiner angegeben war (s1 =0FFh)
ParseAFN:	CALL	WBoot
ParseRoutine	EQU	$-2		;InTheCode!
		LD	BC,16
		LD	HL,DefaultFCB
		LD	A,(DefaultFCB+13)
		INC	A
		RET	NZ
		LD	A,(CurrUser)
		LD	(DefaultFCB+13),A
		RET

;E: Zeiger auf mit EOF terminierten String in DE
;V: AF, DE
;R: DE zeigt auf erstes Nicht-Blank, Zero wenn EOF
SkipBlanks:	LD	A,(DE)
		CP	EOF
		RET	Z
		CP	' '
		RET	NZ
		INC	DE
		JR	SkipBlanks
		.DEPHASE

		END
