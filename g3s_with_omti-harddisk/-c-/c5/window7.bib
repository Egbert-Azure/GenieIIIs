{ =================================================================== }
{ Bibliotheks-Modul WINDOW7.BIB                                       }
{ Verkuerzte Version nur fuer 7 Bit ASCII Code                        }
{ Fuer diese speichersparende Abwandlung von WINDOW.BIB muessen       }
{ folgende Aussagen auf den Rechnertyp zutreffen:                     }
{ 1. Sie benutzen, mit Ausnahme der Grafikzeichen fuer den Rahmen der }
{    Windows, nur den 7-Bit ASCII Code                                }
{ 2. Ihr einziges Videoattribut ist LowVideo                          }
{ =================================================================== }
{ Allgemeine Fenstertechnik ohne direkten Bildschirm-Zugriff          }
{ Vorausgesetzt wird das INCLUDE-File WINDOW.PAR mit den entsprechen- }
{ den Parametern fuer Grafikzeichen, Bildschirmgroesse und ConOut.    }
{ Falls ConOut unbekannt, gibt 'writeln(ConOutPtr)' Auskunft          }
{ Folgende Bezeichner sind privat und sollten nicht benutzt werden:   }
{ t Screen Bildschirm                                                 }
{ t Attribut Flag fuer High- und LowVideo                             }
{ WindowPtr, t WindowInh gefaehrlich dynamisch !!!!!                  }
{ v OrgConOut, v TmpConout                                            }
{ v Window die maximal 255 Fenster                                    }
{ v ActScreen, v ActAttr der momentane Bildschirm                     }
{ p wrtchar, p CLS, p InvVideo, p NorVideo, p EraEol                  }
{ p wwrite, p RewriteScreen, p MoveScreen, p RemoveScreen             }
{                                                                     }
{ Das Modul liefert folgende Bezeichner und High-Level-Routinen:      }
{ p InitWindows     schaltet Fenstertechnik ein                       }
{ p ExitWindows     schaltet Fenstertechnik aus                       }
{ p OpenWindows(x1,y1,x2,y2) Oeffnet ein Fenster von                  }
{              (x1,y1) = LinksOben bis (x2,y2) = Rechtsunten          }
{ p CloseWindow     schliesst das letzte Fenster                      }
{ p SelWindow(Nr)   holt bei ueberlappenden Fenstern das Nr-te nach   }
{                   vorn und macht es aktiv                           }
{ p ChangeWindow(Nr)     wie SelWindow, wenn keine Ueberlappung       }
{ v inverse : boolean    gibt an, ob gerade LowVideo gilt             }
{ v ScreenPtr : byte gibt die Nummer des gerade aktiven Fensters      }
{ v initialisiert : boolean gibt an, ob InitWindows aufgerufen wurde  }
{ =================================================================== }


const ScreenPtr : byte = 0;  (* gibt die Anzahl der eroeffneten Fenster an *)
      Inverse   : boolean = false;
      OrgConOut : integer = ConOut; (* Zeigt Standard-Ausgabe *)
      TmpConOut : integer = ConOut;
      initialisiert : boolean = false;
      t_LO = #128; t_LU = #129;
      t_RO = #130; t_RU = #131;
      t_WO = #132; t_WU = #133;
      t_SL = #134; t_SR = #135;
      GraphChar : array[#128..#135] of char =
           (LinksOben,LinksUnten,RechtsOben,RechtsUnten,
            WaagrechtO,WaagrechtU,SenkrechtL,SenkrechtR);

type Screen = array[1..BildschirmZeilen,1..BildschirmSpalten] of char;
     attribut = array[1..BildschirmZeilen,1..BildschirmSpalten] of byte;
     windowPtr = ^windowinh;
     windowinh = record
                   x1,y1,x2,y2 : byte;     (* Fenster-Koordinaten          *)
                   cx, cy      : byte;     (* letzte Cursor-Position       *)
                   ScrPtr : ^Screen;       (* Zeiger auf Zwischenspeicher  *)
                 end;

var  Window      : array [byte] of windowPtr;
     ActScreen   : screen;
     ActAttr     : Attribut;
     MaxScreen   : byte;

procedure wrtchr(c:char);
  begin
    BDOS(2,ord(c))
  end;

procedure CLS;
  begin
    ConOutPtr:=OrgConOut;
    ClrScr;
    ConoutPtr:=TmpConOut;
    if initialisiert then with Window[0]^ do
      begin
        fillchar(ActAttr,Sizeof(Attribut),0);
        fillchar(ActScreen,SizeOf(Screen),' ');
        cx:=1; cy:=1
      end
  end;

procedure locate(x,y :byte);
  begin
    ConOutPtr:=OrgConOut;
    gotoxy(x,y);
    ConOutPtr:=TmpConOut
  end;

procedure InvVideo;
  begin
    ConOutPtr:=OrgConOut;
    LowVideo;
    ConOutPtr:=TmpConOut;
  end;

procedure NorVideo;
  begin
    ConOutPtr:=OrgConOut;
    NormVideo;
    ConOutPtr:=TmpConOut;
  end;

procedure EraEol;
  Begin
    ConOutPtr:=OrgConOut;
    ClrEol;
    ConOutPtr:=TmpConOut;
  end;

procedure RewriteScreen(x1,y1,x2,y2:integer);
  var i,j : integer;
      v,w : boolean; c :char;
  begin
    v:=false; NorVideo;
    for i:=y1 to y2 do
      begin
      locate(x1,i);

      for j:=x1 to x2-ord((i=BildSchirmZeilen) and (x2=BildSchirmSpalten)) do
          begin
            c:=ActScreen[i,j]; w:=c>#135;
            if v xor w then if v and not w then NorVideo else InvVideo;
            v:=w;
            if (c<#128) or (c>#135) then wrtchr(chr(ord(c) and 127))
                                    else wrtchr(GraphChar[c])
          end;
      end;
     if inverse then InvVideo;
  end;

procedure DelLine;
  label exit;
  var   i,s : integer;
  begin
    if not initialisiert then goto EXIT;
    with Window[ScreenPtr]^ do
      begin
        s:=pred(x2-x1);
        for i:=succ(cy) to pred(y2) do
          begin
            move(ActAttr[i,succ(x1)],ActAttr[pred(i),succ(x1)],s);
            move(ActScreen[i,succ(x1)],ActScreen[pred(i),succ(x1)],s);
          end;
        fillchar(ActAttr[pred(y2),succ(x1)],s,0);
        fillchar(ActScreen[pred(y2),succ(x1)],s,32);
        RewriteScreen(succ(x1),cy,pred(x2),pred(y2));
        locate(cx,cy)
      end;
   exit:
end;

procedure InsLine;
  label exit;
  var   i,s,r : integer;
  begin
    if not initialisiert then goto exit;
    with Window[ScreenPtr]^ do
      begin
      s:=pred(x2-x1); r:=x2-cx;
      for i:=pred(y2) downto cy+2 do
        begin
          move(ActAttr[pred(i),succ(x1)],ActAttr[i,succ(x1)],s);
          move(ActScreen[pred(i),succ(x1)],ActScreen[i,succ(x1)],s)
      end;
    fillchar(ActAttr[succ(cy),succ(x1)],s,0);
    fillchar(ActScreen[succ(cy),succ(x1)],s,32);
    move(ActAttr[cy,cx],ActAttr[succ(cy),succ(x1)],r);
    move(ActScreen[cy,cx],ActScreen[succ(cy),succ(x1)],r);
    fillchar(ActAttr[cy,cx],r,0);
    fillchar(ActScreen[cy,cx],r,32);
    RewriteScreen(succ(x1),cy,pred(x2),pred(y2));
    locate(cx,cy)
  end;
exit:
end;

procedure wwrite(c : char);
(*$R-*)
  procedure scroll;  (* scrollt das aktuelle Fenster! *)
    var i : 1..BildSchirmZeilen;
    begin
      with Window[ScreenPtr]^ do
        begin cy:=succ(y1); DelLine; cy:=pred(y2); locate(cx,cy) end
    end;
begin (* wwrite *)
  with Window[ScreenPtr]^ do
     begin
       if ord(c)<32
         then case c of
                 ^H : cx:=pred(cx);
                 ^J : cy:=succ(cy);
                 ^M : cx:=succ(x1);
                 ^G : wrtchr(c);
              end
         else begin
                wrtchr(c);
                if inverse then ActScreen[cy,cx]:=chr(ord(c) or 128)
                           else ActScreen[cy,cx]:=c;
                cx:=succ(cx);
              end;
         if cx=x1
           then if cy=succ(y1)
                   then begin cx:=succ(x1); cy:=succ(y1) end
                   else begin cy:=pred(cy); cx:=pred(x2); locate(cx,cy) end;
         if cx=x2 then begin cy:=succ(cy); cx:=succ(x1) end;
         if cy=y2 then scroll;
         if (cx=succ(x1)) or (c=^H) then locate(cx,cy);
    end; (* with*)
end; (* wwrite *)

(****************************************************************************)
(*                     Bildschirm-Handling                                  *)
(****************************************************************************)

procedure gotoxy(x,y :byte);
   label EXIT;
   var xNeu,yNeu :byte;
   begin
     if not initialisiert then begin locate(x,y); goto exit end;
     with Window[ScreenPtr]^ do
       begin
         xNeu:=x+x1; yNeu:=y+y1;
         if xNeu<=BildSchirmSpalten then
           if yNeu<=BildSchirmZeilen then
             begin
               locate(xNeu,yNeu);
               cx:=xNeu;
               cy:=yNeu;
             end
       end;
    EXIT:
end;

procedure LowVideo;
  begin
    inverse:=true;
    InvVideo;
  end;

procedure NormVideo;
  begin
    inverse:=false;
    NorVideo;
  end;

procedure HighVideo;
  begin
    NormVideo
  end;

procedure ClrEol;
  var i : byte;
  begin
    if ScreenPtr=0
      then EraEol
      else if initialisiert then
        with Window[ScreenPtr]^ do
        begin
          for i:=cx to pred(x2) do
            begin
              ActAttr[cy,i]:=0;
              ActScreen[cy,i]:=' '; wrtchr(' ');
            end;
         locate(cx,cy)
       end;
    end;

procedure ClrScr;
  var i,s : integer;
  begin
    if (ScreenPtr=0) or not initialisiert
      then CLS
      else with Window[ScreenPtr]^ do
        begin
          s:=pred(x2-x1);
          for i:=succ(y1) to pred(y2) do
            begin
              fillchar(ActAttr[i,succ(x1)],s,0);
              fillchar(ActScreen[i,succ(x1)],s,32)
            end;
          RewriteScreen(succ(x1),succ(y1),pred(x2),pred(y2));
       end;
   gotoxy(1,1)
end;

function WhereX : integer;
  begin
    with Window[ScreenPtr]^ do WhereX:=cx-x1
  end;

function WhereY : integer;
  begin
    with Window[ScreenPtr]^ do WhereY:=cy-y1
  end;


(****************************************************************************)
(*                         Fenster-Hilfs-Prozeduren                         *)
(****************************************************************************)

procedure MoveScreen(a1,b1,a2,b2 : Byte; var P);  (* Privat *)
  var TempScr : array[1..2000] of char absolute P;
       dx, j   : byte;
         begin
           dx:=succ(a2-a1);
           for j:=b1 to b2 do
            begin
              move(ActScreen[j,a1],TempScr[(j-b1)*dx+1],dx);
            end
         end;

procedure RemoveScreen(a1,b1,a2,b2 : byte; var P); (* Privat *)
         var TempScr : array[1..2000] of char absolute P;
             dx, j   : byte;
         begin
           dx:=succ(a2-a1);
           for j:=b1 to b2 do
            begin
              move(TempScr[(j-b1)*dx+1],ActScreen[j,a1],dx);
            end
         end;

(****************************************************************************)
(*               Fensterwahl fuer ueberlappende Fenster                     *)
(****************************************************************************)
procedure SelWindow(x:byte);
  label exit;
  var i:byte;

  procedure Swap(i:byte);
    var Size : integer;
        tScr : ^Screen;
        tAttr: ^Attribut;
    begin
      with window[i]^ do
        begin
          Size:=succ(abs(x2-x1))*succ(abs(y2-y1));
          getmem(tScr,Size);
          getmem(tAttr,Size);
          MoveScreen(x1,y1,x2,y2,tScr^); (* ,tAttr^); *)
          RemoveScreen(x1,y1,x2,y2,ScrPtr^);
          move(tScr^,ScrPtr^,Size);
          freemem(tScr,Size);
          freemem(tAttr,Size);
        end
    end;

begin
  if not initialisiert or (x > MaxScreen) then goto exit;
  if ScreenPtr <> MaxScreen then
     if ScreenPtr=0 then for i:=1 to MaxScreen do swap(i)
        else begin
               swap(ScreenPtr);
               for i:=MaxScreen downto ScreenPtr+1 do Swap(i);
               for i:=ScreenPtr to MaxScreen do Swap(i);
             end;
  if x <> MaxScreen then
    if x=0 then for i:=MaxScreen downto 1 do Swap(i)
       else begin
              for i:=MaxScreen downto x do swap(i);
              for i:=x+1 to MaxScreen do swap(i);
              swap(x)
            end;
  if (ScreenPtr=0) or (x=0)
    then RewriteScreen(1,1,BildSchirmSpalten,BildSchirmZeilen)
      else begin
             with window[ScreenPtr]^ do RewriteScreen(x1,y1,x2,y2);
             with window[x]^ do RewriteScreen(x1,y1,x2,y2)
           end;
  ScreenPtr:=x; with window[ScreenPtr]^ do locate(cx,cy);
  EXIT:
end;

(****************************************************************************)
(*               Fensterwahl bei nebeneinanderliegenden Fenstern            *)
(****************************************************************************)

procedure ChangeWindow(x : byte);
  begin
    if initialisiert
      then if x<=MaxScreen
       then begin
              ScreenPtr:=x;
              with Window[ScreenPtr]^ do locate(cx,cy)
            end
  end;

(****************************************************************************)
(*                       Oeffnen eines Fensters                             *)
(****************************************************************************)

procedure OpenWindow(a1,b1,a2,b2:byte);
  label exit;
  var   size : integer;
        i, j : byte;

  procedure NewWindow; (* Malt den Rahmen und loescht den Bereich *)
    var i : integer;
    begin
      for i:=b1 to b2 do fillchar(ActAttr[i,a1],succ(a2-a1),0);
      ActScreen[b1,a1]:=t_LO;
      ActScreen[b1,a2]:=t_RO;
      ActScreen[b2,a1]:=t_LU;
      ActScreen[b2,a2]:=t_RU;
      for i:=succ(a1) to pred(a2) do
        begin
          ActScreen[b1,i]:=t_WO;
          ActScreen[b2,i]:=t_WU
        end;
      for i:=succ(b1) to pred(b2) do
        begin
          ActScreen[i,a1]:=t_SL;
          ActScreen[i,a2]:=t_SR;
          fillchar(ActScreen[i,succ(a1)],pred(a2-a1),32);
        end;
      RewriteScreen(a1,b1,a2,b2)
    end;

 begin
   if not initialisiert then goto exit;
   if (a1<1) or (a2>BildschirmSpalten) or (a1>a2) or
      (b1<1) or (b2>BildschirmZeilen ) or (b1>b2) then goto exit;
   if ScreenPtr <> MaxScreen then SelWindow(MaxScreen);
   inverse:=false; NormVideo;
   ScreenPtr:=succ(ScreenPtr);
   new(Window[ScreenPtr]);
   with Window[ScreenPtr]^ do
     begin
       x1:=a1; y1:=b1; x2:=a2; y2:=b2;
       cx:=succ(a1); cy:=succ(b1);
       Size:=succ(abs(x2-x1))*succ(abs(y2-y1));
       getmem(ScrPtr,Size);
       MoveScreen(a1,b1,a2,b2,ScrPtr^);
       NewWindow
     end;
   MaxScreen:=ScreenPtr; gotoxy(1,1);
   exit:
end;

(****************************************************************************)
(*               CloseWindow - schliesst das letzte Fenster                 *)
(****************************************************************************)

procedure CloseWindow;
  label EXIT;
  var Size : integer;
      i, j : byte;
  begin
    if (MaxScreen=0) or not initialisiert then goto exit;
    if ScreenPtr <> MaxScreen then SelWindow(MaxScreen);
    with Window[ScreenPtr]^ do
      begin
        NormVideo;
        RemoveScreen(x1,y1,x2,y2,ScrPtr^);
        RewriteScreen(x1,y1,x2,y2);
        Size:=succ(abs(x2-x1))*succ(abs(y2-y1));
        freemem(ScrPtr,Size);
      end;
    dispose(Window[ScreenPtr]);
    ScreenPtr:=pred(ScreenPtr);
    MaxScreen:=ScreenPtr;
    locate(Window[ScreenPtr]^.cx,Window[ScreenPtr]^.cy);
    EXIT:
  end;

(****************************************************************************)
(*           Init/ExitWindows - Initialisierung der Fenstertechnik          *)
(****************************************************************************)

procedure InitWindows; (* Erste Anweisung im Programm  *)
  begin
    initialisiert:=true; ScreenPtr:=0; MaxScreen:=0;
    OrgConOut:=ConoutPtr;
    TmpConOut:=addr(wwrite);
    ConOutPtr:=TmpConOut;
    new(Window[0]);
    with Window[0]^ do
      begin
        cls; ScreenPtr:=0;
        x1:=0; y1:=0; x2:=succ(BildschirmSpalten); y2:=succ(BildschirmZeilen);
      end;
  end;

procedure ExitWindows; (* Letzte Anweisung im Programm  *)
  begin
    ConOutPtr:=OrgConOut;
    initialisiert:=false;
  end;
