Program:  BCOMP 2.1
Author:   Rob Friefeld
Date:     3 May 1990



                          GENERAL INFORMATION
                              -----------

Purpose:

Compare and patch two binary files, or single file and memory.


Syntax:	

        BCOMP [dir:]file1 [dir:][file2] [/]

If no FILE2, then FILE1 name is used again.  If no DIR:FILE2, then second
window is memory.  For convenience, file names are wild-carded if the "/" 
option is used.

If FILE1 does not require all the buffer space allocated to it, the extra 
space is released to FILE2.  Therefore, FILE1 should be the smaller of the 
two files.


System Requirements:

ZCPR 3.0+ or Z3PLUS, 79 x 24 CRT (minimum) with TCAP support for EREOL, 
CLS, GOTOXY.  Use the NZTCAP4D to benefit from cursor on/off control.


Usage:

1) Compare two similar files.

If you just want to know -- Are two files the same or not? -- run an 
automatic comparison program such as COMP.  BCOMP is interactive.  It gives 
each file a window in which you can examine any part of the file and 
compare it to the other one visually or automatically.

        Example: BCOMP vers1.com vers2.com 

        VERS1 is the original version of a program which you have
        laboriously installed as VERS2.  You can see the differences
        as well as make further changes.


2) Compare disk file to memory image.

If only one file name is specified on the command line, the second window 
looks at RAM.  You may want to use this to compare ENV or TCAP files with 
those currently loaded.  You can also usually compare disk with memory 
images of type3 or type4 programs after they run.

	Example:  BCOMP sys.env
                

3) Patch a file or cross-patch file/file or file/RAM.

The patcher is roughly similar to ZPATCH, except that two files are open at 
once.  Use the second file for reference, update a file from changes poked 
into high memory (e.g. TCAP or ENV segments), or manually move in overlays.


Limitation:

This program is intended for executable binary files.  Files larger than 
64k (.LBR, .OVR) can be compared with BCOMP, but as the addresses wrap past 
FFFFh, their display becomes meaningless.  (The record number display 
remains correct.)


                              INSTALLATION
                                --------

    BCINSTAL.COM is a screen oriented control key installation program for
this version of BCOMP.  You could also patch BCOMP using BCOMP itself:  do
the patching in the memory window, try out your changes, move them to the
file window and save it.  The help screen scans the current control key 
bindings, so it is automatically updated.


                             PROGRAM COMMANDS
                                ---------

     This section describes the available program commands.  Call up the 
help screen (with "/" or "?") to view the current control key bindings.

COMPARING FILES
---------------

     The display shows 128 bytes of the first file on the upper half of the 
screen and 128 bytes of the second file on the lower half.  The alternate 
file displays a "**" in the HEX field where the two files are identical, a 
la COMP.


AUTO-COMPARE:
     Find the next byte in which the files differ.  Display both files at
that byte.  If the display did not start with the files in sync, then the
command will only move a single byte ahead.  If no difference is found, an
EOF message shows on the status line.  If the entire file did not fit into 
memory, read in more and continue the comparison.


VIDEO TOGGLE:
     Toggle highlighting of bytes in active window that are different from 
those in the alternate window.  When only a few bytes differ, it is much 
easier to see them this way.  Default is OFF.  
  


MOVING IN A FILE
----------------

     The display move forward by screen, line, byte, or to end of file.  It 
can move back by screen, line, byte or the start of file.  It can also move 
by record number or address.


MOVING BETWEEN FILES
--------------------


SWITCH FILES:  Toggle
	Cursor moves from one file to the other.

ECHO MODE:  Toggle
	Echo mode repeats a command for both files so you can move through
them in tandem.  The right upper screen shows a reminder when in echo mode.


READING FILES
-------------


	If BCOMP printed a "memory full" message, more of the file may be
read in.  The new read replaces data currently in memory.  If there is no 
more to read, you may start again at the beginning of the file.
	If the MEMORY window is used instead of a second file, twice the
buffer space is available.


ADDRESS AND OFFSET
------------------


SET ADDRESS:
     A hex (or decimal preceded by #) address is entered.  The display
then goes to that address relative to the current offset.  An address beyond
what is currently in memory will go to either the start or end of the buffer.
     Address may also be set relative to the current location with +/-nn.  
To advance 19H, use +19.
     If the offset is 100h, address 100 is the beginning of the file.  The
address disply is OK until 64k of file is read in, then it wraps to 0.  The
24 bit math needed to go beyond address FFFFh has not been implemented.
     
SET OFFSET:
     Input a new hex offset.  For files, the address display will change but 
the record number will not.  If an appropriate offset is chosen, the address 
will correspond to the location of the file memory image when running.  
Default offset for files is taken from the file type (e.g. COM, RCP, ENV) 
after the manner of ZPATCH.  Type 3 environment files will be displayed at 
their load address offsets.
     For the memory window, the address display is always absolute.  An 
offset is used to calculate a number for the record display.  For example, 
if you run a Type3 program, then run BCOMP to look at the file, the memory 
offset can be set to the program's load address (8000h).  The file and 
memory windows will then show the same addresses and record numbers as you 
compare the file to its memory image.

GO TO RECORD:
     Input a decimal (or hex with # trigger) record number to jump to.  
It is up to you to pick a record currently in memory.  BCOMP does not 
random read the file looking for your record.  Record count display is 
OK to 8 meg file max.

CALCULATE:
     The hex calculator from MU3 is included.  It does addition and 
subtraction as well as decimal-hex conversion.


FIND STRING
-----------

FIND:
     Find the series of hex bytes entered.  
Syntax (taken from POKE):   val1 val2 .. valn "text string...
No further hex bytes may follow the string trigger.  Note there is NO
terminating ".  The hex input routine (from MU3) will accept decimal bytes with
the # preface.


REPEAT FIND:
     Look for the same series again.  The string is maintained when switching
to the alternate file.


PATCHING
--------

     The patcher is screen oriented and fairly powerful.  There is no reason 
it cannot be used to patch a single file.

DUPE BLOCK:

     Overlay the 128 byte window of the alternate file onto the current file.
This command accomplishes with a single key what it takes a fair amount of
work to do with the edit commands (described next).  


EDIT MODE:

   Control keys for editing are installed separately from VIEW mode.  
They should be control characters, or they will be ignored when editing 
the ASCII field.  The EXIT and HEX CALC commands from VIEW mode work on 
the same keys in EDIT mode, however.  The SWITCH command also works, but 
can be installed separately for editing.  If <sp> is not used, it will 
move the cursor right one byte.

   Cursor Movement:
     Use the WordStar(tm) diamond or the arrow keys.

             ^E
              ^
         ^S < $ > ^D     Horizontal movement is to next nibble.
              v          <BS> and <SP> are alternates in HEX field.
             ^X

   Patching:
     In the HEX field, enter hex bytes directly (0..9,A..F).
     In the ASCII field, enter text directly.


   Saving:
     On exit, if any editing has been done, you get a prompt to "Save Changes? 
(y/N)"  On a "Y" response, the disk file (or memory) is updated.  [There is no 
need to edit on a CP/M record boundary.]



BLOCK COMMANDS:


Mark:	Set the block marker.  The marker is ONE end of the block, shown
	on screen as ">".  The other end is the current cursor position
        when another block function is executed.

Yank:	Save the data between the block marker and the cursor into a buffer.
	The cursor can be before, after, or on the marker.

 Error - Set Marker First:  Can't Yank until the Mark has been set in the
 current screen.  Hence, no more than 128 bytes can be Yanked.

Copy:	Replace the data starting at the cursor with whatever is in the block
	buffer.  This command enables you to move data from one file to the 
        other.

 Error - Ovfl:	The copy operation cannot overflow the current screen.  All
 of the data in the block buffer must fit, or the copy is cancelled.

Fill:   Fill from the block marker to the cursor with a byte value.


END BCOMP21.DOC

