'BCBC: CP/M VERSION 1.1, WRITTEN BY BRUCE W. TONKIN BEGINNING 5/3/83
'RELEASED 8/11/83. A BASIC COMPILER WRITTEN USING THE PBASIC PRE-PROCESSOR
'FOR MICROSOFT BASIC 5.2 OR HIGHER. PBASIC AND BCBC ARE PRODUCTS OF:
'T.N.T. SOFTWARE, INC., 34069 HAINESVILLE ROAD, ROUND LAKE, IL 60073
'TELEPHONE: (312) 223-0832 (PLEASE, DON'T CALL BEFORE NOON.)
'ANY SALE OR RESALE OF BCBC IS EXPRESSLY PROHIBITED 
'WITHOUT PRIOR PERMISSION OF T.N.T. SOFTWARE, INC.

'BCBC REQUIRES A LIBRARY FILE, CALLED BCBC.LIB, WHICH IS PROVIDED.

'BCBC GENERATES ASSEMBLER SOURCE CODE FOR DIGITAL RESEARCH'S
'ASM.COM, SINCE EVERYONE WITH CP/M HAS A COPY OF ASM. INTEL 8080
'OPCODES ARE USED THROUGHOUT. 8080, 8085, AND Z-80 OPERATION IS OK.

'IF YOU HAVE AN 8080, 8085, OR ANY Z-80 CHIP, YOUR MACHINE IS CAPABLE
'OF RUNNING BCBC.BAS (AS A BASIC PROGRAM) PROVIDED YOU
'ALSO HAVE MBASIC 5.2 OR BETTER. IF YOU DO NOT HAVE MBASIC 5.2,
'BCBC ALSO COMES AS A .COM FILE; NO VARIETY OF BASIC IS
'THEREFORE NECESSARY TO RUN BCBC.

'CP/M 2.2 OR COMPATIBLE IS ASSUMED. COMPATIBILITY WITH CP/M PLUS IS
'UNKNOWN, BUT DEPENDENT ON WHETHER MICROSOFT BASIC WILL RUN.
'MP/M IS NOT COMPATIBLE WITH CP/M. SORRY; TALK TO DIGITAL RESEARCH.
'MAYBE THEY'LL INSIST IT IS: TOO BAD. THEY'RE WRONG IF THEY DO.
'FOR THAT REASON, OPERATION OF BCBC UNDER MP/M IS NOT GUARANTEED,
'NOR IS IT EVEN RECOMMENDED, NOR IS MP/M RECOMMENDED FOR THAT MATTER.
'I DO NOT ANTICIPATE MODIFYING BCBC FOR MP/M, AND I DO NOT WANT TO
'HEAR OF ANYONE'S ADVENTURES IN DOING SO, EVEN FOR MP/M 86. YOUR TIME
'WOULD BE FAR BETTER SPENT IN MODIFYING BCBC FOR XENIX OR SOME OTHER
'REASONABLY RELIABLE AND COMPETENT OPERATING SYSTEM.

'FOR A COPY OF THE SOURCE DISK, WHICH INCLUDES COMPLETE BCBC
'SOURCE (BOTH IN PBASIC AND MBASIC 5.2) AND THE BCBC.COM FILE,
'PLEASE SEND $15.00 TO T.N.T. SOFTWARE, INC. A COMPLETE BCBC MANUAL
'IS ALSO AVAILABLE FOR $10.00 (INCLUDES POSTAGE FOR U.S., CANADA, AND
'MEXICO). USER EXTENSIONS ARE INVITED, AND WILL BE INCORPORATED WITH
'CREDIT WHERE COMPATIBLE WITH MY PREJUDICES REGARDING OPERATING SYSTEMS.

'PBASIC SELLS FOR $39.95, POSTPAID, INCLUDING COMPLETE DOCUMENTATION.
'DR. JERRY POURNELLE RECOMMENDED PBASIC IN A REVIEW IN THE APRIL 1983
'USER'S COLUMN OF BYTE MAGAZINE; SEE HIS ARTICLE FOR PARTICULARS.

	DEFINT A-Z
	DEF FNS$(A)=MID$(STR$(A),2)
	DEF FNP$(A$,B$)=LEFT$(A$,INSTR(A$,B$)-1)
	DIM R$(50),L$(10),F(100),V$(500),LN(500),NXT$(9),S(500)
	MAX=1000:T$=CHR$(9):FIL=0:Q$="LHLD Z":P$="SHLD Z":H$="LXI H,":D$="LXI D,":B$="LXI B,":PH$="PUSH H":SW$="!XCHG!":S1$="XCHG":I$="!INX H!":I1$="!DAD D!":I2$="DAD D":S$="!DCX H!":IS$="DCX H":E$="!"

'VERSION 1.0 (TEST) OF THE BASIC COMPILER WRITTEN IN BASIC
'KEYWORDS RECOGNIZED: PRINT,IF,THEN,GOTO,GOSUB,RETURN,INPUT,RUN,STOP,OPEN,
'CLOSE, VAL(,STR$(,LEN(,POKE,PEEK(,IPOKE,IPEEK(,VARPTR(,CHR$(,ASC(,STRUCTURE(,
'DIM,INKEY$,SIZE(,MID$(,LEFT$(,RIGHT$(,CALL,MEM,GET,PUT,LSET,RSET,END
'OPERATORS RECOGNIZED ARE: =, +, ++, -, --, *, AND /
'LOGICAL OPERATORS RECOGNIZED ARE: AND, OR, NOT, XOR, MOD
'ALL VARIABLES MUST BE EITHER STRING OR INTEGER.

	DATA PRINT,LPRINT,IF,THEN,GOTO,GOSUB,RETURN,INPUT,RUN,STOP,OPEN,CLOSE
	DATA VAL(,STR$(,INKEY$,LEN(,POKE,PEEK(,IPOKE,IPEEK(,VARPTR(,CHR$(,ASC(
	DATA STRUCTURE(,DIM,SIZE(,MID$(,LEFT$(,RIGHT$(,STRING$(,CALL,MEM,GET
	DATA PUT,LSET,RSET,FOR,NEXT,END
'	I MAY ADD ON . . . GOTO, ON . . . GOSUB, WHILE . . . WEND,
'	UNTIL/UEND, AND OTHER SIMILAR CONSTRUCTIONS LATER
'	PRESENTLY UNIMPLEMENTED ARE RUN, STRUCTURE(, DIM, SIZE(, MEM, LSET,RSET
	I=1:WHILE (R$(I-1)<>"END"):READ R$(I):I=I+1:WEND
	TOKENS=I:U=0
	DATA AND,OR,NOT,XOR,MOD
	FOR I=1 TO 5:READ L$(I):NEXT

	LINE INPUT"NAME OF PROGRAM TO COMPILE (DEFAULT TYPE IS .BAS): ";F$
	LINE INPUT"NAME OF DESIRED OUTPUT FILE (TYPE WILL BE .ASM)  : ";O$
	IF INSTR(F$,".")<1 THEN F$=F$+".BAS"
	IF O$<" " THEN O$=F$
	IF INSTR(O$,".") THEN O$=FNP$(O$,".")
	O$=O$+".ASM":@!UPPERC(F$):@!UPPERC(O$)

'	DO YOU WANT COMPLETE DOCUMENTATION?
@DOC
	PRINT"DO YOU WANT COMPLETE DOCUMENTATION IN YOUR ASSEMBLER":PRINT"LISTING OUTPUT (Y/N)?";
	LINE INPUT C$:@!UPPERC(C$):IF INSTR("YN",C$)<1 THEN @DOC
@GET.LIB.DR
	LINE INPUT"WHICH DRIVE LETTER IS BCBC.LIB ON: ";LD$:@!UPPERC(LD$)
	IF LEN(LD$)>1 OR LD$>"P" OR LD$<"A" THEN PRINT"!?!":GOTO @GET.LIB.DR

	OPEN"I",1,F$:I=0
'	I DO A PRESCAN FOR LINE NUMBERS SO WHEN I PARSE CONDITIONALS LATER
'	I WILL KNOW WHAT THE NEXT LINE NUMBER IS.
@LINELOOP
	IF EOF(1) THEN @FIXED
	LINE INPUT #1,L$:IF VAL(L$) THEN LN(I)=VAL(L$):I=I+1
	GOTO @LINELOOP
@FIXED
	CLOSE 1
	OPEN"I",1,F$:OPEN"O",2,O$
	PRINT#2,T$"ORG 0100H ;STANDARD CP/M ORIGIN":PRINT#2,T$"LXI SP,STACK":GOTO @GETLINE

@STRIPPER
	IF LEN(U$)<1 THEN RETURN
	JX=1:WHILE JX<LEN(U$) AND MID$(U$,JX,1)<=" ":JX=JX+1:WEND
	IF JX>1 THEN U$=MID$(U$,JX)
	IF LEN(U$)<2 THEN RETURN
	JX=LEN(U$):WHILE JX>1 AND MID$(U$,JX,1)<=" ":JX=JX-1:WEND
	IF JX<LEN(U$) THEN U$=LEFT$(U$,JX)
	RETURN

@GETLINE
	IF EOF(1) THEN @END
	LINE INPUT #1,L$:L1$="":OLN=LN:LN=VAL(L$)
	IF LN THEN W=65:PRINT#2,"I"FNS$(LN)":";:IF C$="Y" THEN PRINT#2,T$";"MID$(L$,INSTR(L$," ")+1):ELSE PRINT#2,""
	IF LN>0 THEN L$=MID$(L$,INSTR(L$," ")):LZ=LZ+1:ELSE LN=OLN
	IF INSTR(L$,"#ALL") THEN FOR PULL%=0 TO 33:F%(PULL%)=1:NEXT PULL%
	IF INSTR(L$,"#ASM")>0 THEN ASM%=1:GOTO @GETLINE
	IF ASM%<1 THEN @GETL2
	IF INSTR(L$,"#ENDASM")>0 THEN ASM%=0:GOTO @GETLINE
	PRINT #2,L$:GOTO @GETLINE
@GETL2
	A$=""

@MULTILINE
	L1$="":U$=L$:GOSUB @STRIPPER:L$=U$:IF L$<=" " THEN @GETLINE
	IF LEFT$(L$,1)="'" OR INSTR(L$,"REM")=1 THEN @GETLINE
	I=1:WHILE (INSTR(L$,R$(I))<>1 AND I<=TOKENS):I=I+1:WEND
	OK=0:GOSUB @GENERATE:IF OK THEN @MULTILINE
	IF L1$>STRING$(LEN(L1$),32) THEN L$=L1$:GOTO @MULTILINE
	GOTO @GETLINE

@GENERATE
'	LET'S SEE IF WE HAVE A MULTI-LINE STATEMENT HERE
	K1=1:K3=0
@LOOKFORMULTI
	J=INSTR(K1,L$,":"):IF J THEN FOR K2=1 TO J:K3=ABS(K3-(MID$(L$,K2,1)=CHR$(34))):NEXT
	IF J>0 AND K3=1 THEN K1=J+1:GOTO @LOOKFORMULTI
	IF J THEN L1$=MID$(L$,J+1):L$=LEFT$(L$,J-1)
'WE'VE STRIPPED OUT THE COLON SEPARATING THE MULTIPLE STATEMENTS ON ONE
'LINE AND L$ CONTAINS ONLY A SINGLE STATEMENT. L1$ HAS THE REST OF THE LINE.
	IF INSTR(L$,"PRINT")<>1 AND INSTR(L$,"LPRINT")<>1 THEN @NOTPRINT
	J=6-(INSTR(L$,"LPRINT")=1):WHILE MID$(L$,J,1)<=" " AND J<LEN(L$):J=J+1:WEND
	IF MID$(L$,J,1)<=" " THEN K=J+1:GOTO @FEED
	IF MID$(L$,J,1)<>CHR$(34) THEN @NOT.QUOTED.STRING
	J=INSTR(L$,CHR$(34)):K=INSTR(J+1,L$,CHR$(34))
@FEED
	IF K=J+1 THEN IF INSTR(L$,"LPRINT")=1 THEN PRINT#2,T$B$"5":GOTO @SHORTS:ELSE IF K=J+1 THEN PRINT#2,T$B$"2":GOTO @SHORTS

'	HERE, W IS A LOGICAL LINE LOCATION, LETTERED FROM A-Z WITHIN A LINE
'	TO HANDLE MULTIPLE LOCATIONS WITHIN THE LINE WHERE STRING DATA MAY BE
'	STORED. EXAMPLE: 120 PRINT"FU":PRINT"BAR" WILL CREATE LINE LOCATIONS
'	120A, 120B, 120C, AND 120D

	PRINT#2,T$"JMP I"FNS$(LN)CHR$(W+1):PRINT#2,"I"FNS$(LN)CHR$(W)": DB ";:W=W+1:FOR L=J+1 TO K-1:PRINT#2,FNS$(ASC(MID$(L$,L,1)));:IF (L-J-1) MOD 15=14 AND L<K-1 THEN PRINT#2,"":PRINT#2,T$"DB ";:ELSE IF L<K-1 THEN PRINT#2,",";:ELSE PRINT#2,""
	NEXT
	PRINT#2,"I"FNS$(LN)CHR$(W)":"H$"I"FNS$(LN)CHR$(W-1):W=W+1
'	HL POINTS TO STRING, DE CONTAINS STRING LENGTH, BC CONTAINS BDOS FUNC.
	PRINT#2,T$D$FNS$(K-J-1):PRINT#2,T$B$;:IF INSTR(L$,"LPRINT")=1 THEN PRINT#2,"5":ELSE PRINT#2,"2"
	PRINT#2,T$"CALL PSTR"
@SHORTS
	IF INSTR(K,L$,";")<1 THEN PRINT#2,T$"CALL PLNE"
	F(0)=1:RETURN

@NOT.QUOTED.STRING
	PRINT#2,T$;:IF INSTR(J,L$,"$")<1 THEN @NUMERIC.PRINT
	K3=INSTR(J,L$,"$"):L2$=MID$(L$,J,K3-J+1):F(0)=1:PRINT#2,Q$L2$"+2!"S1$:PRINT#2,T$Q$MID$(L$,J):PRINT#2,T$B$;:IF INSTR(L$,"LPRINT")=1 THEN PRINT#2,"5":ELSE PRINT#2,"2"
	PRINT#2,T$"CALL PSTR":IF INSTR(J,L$,";") THEN RETURN
	PRINT#2,T$"CALL PLNE":RETURN
@NUMERIC.PRINT
	L2$="":K3=J:WHILE (MID$(L$,K3,1)>="A" AND MID$(L$,K3,1)<="Z") OR (MID$(L$,K3,1)>="0" AND MID$(L$,K3,1)<="9"):L2$=L2$+MID$(L$,K3,1):K3=K3+1:WEND
	F(1)=1:IF VAL(L2$) THEN PRINT#2,H$L2$:ELSE PRINT#2,Q$L2$
	PRINT#2,T$B$;:IF INSTR(L$,"LPRINT")=1 THEN PRINT#2,"5":ELSE PRINT#2,"2"
	F(1)=1:PRINT#2,T$"CALL PNUM":IF INSTR(J,L$,";")<1 THEN PRINT#2,T$"CALL PLNE"
	RETURN

@NOTPRINT
'	IS THIS A VARIABLE ASSIGNMENT?
	IF I<>TOKENS THEN @NOT.ASSIGN
'	SINCE I LIKE THE 'C' INCREMENT/DECREMENT OPERATORS, I'M GOING TO
'	IMPLEMENT THEM IN MY VERSION OF BASIC FOR EXTRA SPEED. IF THE USER
'	ACTUALLY USES THEM, THE LIBRARY ADD/SUBTRACT ROUTINES WON'T BE USED.
	IF INSTR(L$,"++")=1 THEN PRINT#2,T$Q$MID$(L$,3)I$P$MID$(L$,3):RETURN
	IF INSTR(L$,"--")=1 THEN PRINT#2,T$Q$MID$(L$,3)S$P$MID$(L$,3):RETURN

	U$=FNP$(L$,"="):GOSUB @STRIPPER:V$=U$:J=0:WHILE (V$(J)<>"" AND V$(J)<>V$ AND J<MAX):J=J+1:WEND
	IF V$(J)="" THEN V$(J)=V$
	IF INSTR(V$,"$") THEN @STR.ASSIGNMENT

'	IS IT A DIRECT NUMERIC ASSIGNMENT?
	J=INSTR(L$,"=")+1:U$=MID$(L$,J):GOSUB @STRIPPER:V1$=U$:IF V1$>="A" AND V1$<="Z" THEN @NUM.EXPRESSION
	IF INSTR(V1$,"+")>0 OR INSTR(V1$,"-")>0 OR INSTR(V1$,"*")>0 OR INSTR(V1$,"/")>0 THEN @NUM.EXPRESSION
	PRINT#2,T$H$V1$:PRINT#2,T$P$V$:RETURN

@NUM.EXPRESSION
'	NUMERIC EXPRESSION TO BE EVALUATED?
'	V1$, ON ENTRY, BEGINS WITH THE FIRST NON-BLANK CHAR. AFTER THE =
	YES=0:GOSUB @IS.KEY.WORD:IF YES THEN RETURN
	EX=0
@NUM.EXP2
	K=1:WHILE (MID$(V1$,K,1)>="A" AND MID$(V1$,K,1)<="Z") OR (MID$(V1$,K,1)>="0" AND MID$(V1$,K,1)<="9"):K=K+1:WEND
@NUM.EVAL
'	K POINTS TO THE CHARACTER AFTER THE END OF THE CURRENT NUMBER OR
'	VARIABLE. THIS MAY BE A BLANK; LET'S SEE WHAT THE NEXT OPERATOR IS
'	BY BEGINNING AT POSITION K AND SCANNING FOR A NON-BLANK. WE'LL USE
'	THE VARIABLE K1 TO POINT TO THE OPERATOR, IF ANY.
	K1=K:V4=0
@HERE
	IF K1<=LEN(V1$) THEN IF MID$(V1$,K1,1)<=" " THEN K1=K1+1:GOTO @HERE
	V3$=LEFT$(V1$,1):OF=0:IF V3$>="0" AND V3$<="9" THEN OF=1
	IF OF=1 THEN PRINT#2,T$H$VAL(V1$)
'	WE'VE GOT TO CHECK FOR THE POSSIBILITY OF A MONADIC OPERATOR
'	AND DEAL WITH IT IMMEDIATELY, IF THERE IS ONE. PLEASE NOTE: THE
'	DOUBLED OPERATOR IS DEFINITELY GOING TO CAUSE TROUBLE. IT IS ILLEGAL
'	TO WRITE A STATEMENT LIKE: X = Y AND NOT Z. INSTEAD, WRITE SOMETHING
'	LIKE THIS: W=NOT Z:X=Y AND W
	V3=0:IF OF=0 AND EX MOD 2=0 AND (MID$(V1$,1,1)="-") THEN V3=1:V2=2
	IF OF=0 AND EX MOD 2=0 AND INSTR(V1$,"NOT")=1 THEN V3=1:V2=7
	IF EX=0 AND V3=1 THEN PRINT#2,T$D$"0"
@CONT1
	IF OF=0 AND V3<>1 THEN PRINT#2,T$Q$LEFT$(V1$,K-1)
	IF V3=1 THEN V3=0:V4=1:K=K1+V2\2:K1=K:GOTO @HERE
	EX=EX+V4:IF EX MOD 2<>1 THEN @CONT0
	IF V2=1 THEN PRINT#2,T$I2$:GOTO @CONT0
	PRINT#2,T$"CALL ARITH"FNS$(V2):F(3+V2)=1

@CONT0
'	STICK IN THE OPERATORS: OPERATOR TYPE IS IN THE A REGISTER

	V2=0:U$=MID$(V1$,K1):GOSUB @STRIPPER:V2$=LEFT$(U$,1):IF V2$>" " THEN V2=INSTR("+-*/",V2$)
	IF V2<1 THEN L=1:WHILE L<6 AND V2<1:V2=INSTR(U$,L$(L)):V2=-(L+4)*(V2=1):L=L+1:WEND:IF V2<1 AND V2$>" " THEN @ABORT
	IF V2<1 THEN V1$=MID$(V1$,K1):GOTO @MAYBE.DONE
'	AND,OR,NOT,XOR,MOD ARE THE OPERATORS WE JUST CHECKED FOR
'	NOW WE'LL SKIP PAST THE OPERATOR AND LOOK FOR ANY MORE OPERANDS
	IF V2>4 THEN K=K1+LEN(L$(V2-4)):ELSE IF V2>0 THEN K=K1+1
	V1$=MID$(V1$,K):K=1:K1=1
@CONT2
	IF EX MOD 2=0 THEN EX=EX+1
	PRINT#2,T$S1$:IF LEN(V1$)>0 THEN WHILE (MID$(V1$,K,1)<=" " AND K<=LEN(V1$)):K=K+1:WEND:V1$=MID$(V1$,K):K=1
	IF V1$>" " THEN @NUM.EXP2
'	CHECK TO SEE IF THERE WAS SOME BONEHEAD PLAY HERE: SAY, A TRAILING
'	OPERATOR OR SOMETHING SIMILAR.
@MAYBE.DONE
	IF V1$>STRING$(LEN(V1$)," ") THEN @ABORT
'	COMPUTATIONAL ROUTINES SHOULD RETURN ANSWERS IN HL.
'	THE HL REGISTER CONTAINS THE
'	MOST RECENT OPERAND, THE DE REGISTER THE OLDEST OPERAND.
'	WHEN THE ROUTINE RETURNS, THE RESULT APPEARS IN HL.
'	AT THE END OF EVALUATING THE EXPRESSION TO THE RIGHT OF THE = SIGN,
'	I NEED TO STORE THE RESULT OF THE COMPUTATION IN THE VARIABLE
'	MENTIONED AT THE LEFT OF THE = SIGN. THIS LITTLE THING DOES THAT.
	PRINT#2,T$P$LEFT$(L$,J-2):RETURN
@IS.KEY.WORD
'	CALLED TO FIND OUT IF THE NUMERIC OR STRING EXPRESSION TO BE
'	EVALUATED BEGINS WITH A KEYWORD, SUCH AS MID$(, VAL(, ETC.
	K=1:WHILE INSTR(V1$,R$(K))<>1 AND K<=TOKENS:K=K+1:WEND

	IF K>TOKENS THEN RETURN
'	IF WE DIDN'T FIND A TOKEN, WE MIGHT AS WELL RETURN AND CONTINUE EVAL.
'	WHAT WE'RE LOOKING FOR ARE THE FOLLOWING KEY WORDS:
'	INKEY$,VAL(,STR$(,LEN(,PEEK(,IPEEK(,VARPTR(,CHR$(,ASC(
'	MID$(,LEFT$(,RIGHT$(,STRING$(,MEM
	YES=1
	IF R$(K)="VAL(" THEN @IS.VAL
	IF R$(K)="STR$(" THEN @IS.STR$(
	IF R$(K)="LEN(" THEN @IS.LEN
	IF R$(K)="PEEK(" THEN @IS.PEEK
	IF R$(K)="IPEEK(" THEN @IS.IPEEK
	IF R$(K)="VARPTR(" THEN @IS.VARPTR
	IF R$(K)="CHR$(" THEN @IS.CHR$
	IF R$(K)="ASC(" THEN @IS.ASC
	IF R$(K)="LEFT$(" THEN @IS.LEFT$
	IF R$(K)="RIGHT$(" THEN @IS.RIGHT$
	IF R$(K)="MID$(" THEN @IS.MID$
	IF R$(K)="STRING$(" THEN @IS.STRING$
	IF R$(K)="INKEY$" THEN @IS.INKEY
	YES=0:RETURN
@IS.INKEY
'BDOS function 11 is check console status; if A=0FFH then something's waiting.
	PRINT#1,T$"MVI C,11! CALL 0005! ORA A! JNZ $+12"
	PRINT#1,T$H$"0!"P$V$"+2!JMP $+20"
'SOMETHING'S HERE! LET'S USE FUNCTION 6 TO SEE WHAT IT IS.
	PRINT#1,T$"MVI E,255!MVI C,6!CALL 0005!"H$"1!"P$V$"+2!"Q$V$"!MOV M,A"
	RETURN
@IS.VAL
	F(30)=1:V2$=MID$(V1$,5):V2$=FNP$(V2$,")")
'	DE POINTS TO STRING, BC CONTAINS LENGTH OF STRING, HL CONTAINS BINARY
'	SIGNED RESULT OF CONVERSION FOR VAL( FUNCTION.
	PRINT#2,T$Q$V2$SW$Q$V2$"+2":PRINT#2,T$"MOV B,H!MOV C,L!CALL ASCBIN":PRINT#2,T$P$V$:RETURN

@IS.STR$(
'	DE POINTS TO STRING DESCRIPTOR, HL CONTAINS BINARY NUMBER TO CONVERT
	F(31)=1:V2$=MID$(V1$,6):U$=FNP$(V2$,")"):GOSUB @STRIPPER:V2$=U$:PRINT#2,T$D$"Z"V$E$Q$V2$"!CALL STR":RETURN
@IS.LEN
	V2$=MID$(V1$,5):U$=FNP$(V2$,")"):GOSUB @STRIPPER:V2$=U$:PRINT#2,T$Q$V2$"+2!"P$V$:RETURN

@IS.PEEK
	V2$=MID$(V1$,6):U$=FNP$(V2$,")"):GOSUB @STRIPPER:V2$=U$:IF V2$<"A" THEN PRINT#2,T$H$;:ELSE PRINT#2,T$Q$;
	PRINT#2,V2$"!MOV A,M!"H$"0!MOV L,A!"P$V$:RETURN

@IS.IPEEK
	V2$=MID$(V1$,7):U$=FNP$(V2$,")"):GOSUB @STRIPPER:V2$=U$:IF V2$<"A" THEN PRINT#2,T$H$;:ELSE PRINT#2,T$Q$;
	PRINT#2,V2$"!MOV E,M"I$"MOV D,M"SW$P$V$:RETURN

@IS.VARPTR
	V2$=MID$(V1$,8):U$=FNP$(V2$,")"):GOSUB @STRIPPER:V2$=U$:PRINT#2,T$H$"Z"V2$E$P$V$:RETURN

@IS.CHR$
	V2$=MID$(V1$,6):U$=FNP$(V2$,")"):GOSUB @STRIPPER:V2$=U$:IF MID$(V2$,1,1)<="9" AND MID$(V2$,1,1)>="0" THEN V2=VAL(V2$):GOTO @IS.CHR$1
	PRINT#2,T$Q$V$SW$Q$V2$"!MOV A,L!STAX D":GOTO @IS.CHR$2
@IS.CHR$1
	PRINT#2,T$Q$V$"!MVI A,"V2"!MOV M,A"
@IS.CHR$2
	PRINT#2,T$H$"1!"P$V$"+2":RETURN

@IS.ASC
	V2$=MID$(V1$,5):U$=FNP$(V2$,")"):GOSUB @STRIPPER:V2$=U$:PRINT#2,T$Q$V2$"!MOV A,M!MOV L,A!MOV H,0!"P$V$:RETURN

@IS.LEFT$
	F(32)=1:V2$=MID$(V1$,7):U$=FNP$(V2$,")"):GOSUB @STRIPPER:V2$=U$
'	SYNTAX IS A$=LEFT$(B$,X), WHERE A$ AND B$ ARE STRING VARIABLES,
'	AND X IS A CONSTANT OR INTEGER VARIABLE. B$ CANNOT BE A QUOTED STRING.
	V3$=FNP$(V2$,","):V4$=MID$(V2$,INSTR(V2$,",")+1)
'	NOW V3$ HAS THE FIRST ARGUMENT, AND V4$ IS THE SECOND.
	U$=V4$:GOSUB @STRIPPER:V4$=U$:U$=V3$:GOSUB @STRIPPER:V3$=U$
	IF V4$<"A" THEN PRINT#2,T$H$V4$:ELSE PRINT#2,T$Q$V4$
	PRINT#2,T$P$V$"+2"
'	OK, NOW WE NEED TO TRANSFER THE BYTES FROM B$ TO A$, UNLESS B$=A$
	IF V$=V3$ THEN RETURN:ELSE PRINT#2,T$PH$
	PRINT#2,T$Q$V$"!MOV D,H!MOV E,L!"Q$V3$"!POP B":PRINT#2,T$"CALL STRMV":RETURN

@IS.RIGHT$
	F(32)=1:V2$=MID$(V1$,8):U$=FNP$(V2$,")"):GOSUB @STRIPPER:V2$=U$
'	SYNTAX IS A$=RIGHT$(B$,X), WHERE A$ AND B$ ARE STRING VARIABLES,
'	AND X IS A CONSTANT OR INTEGER VARIABLE. B$ CANNOT BE A QUOTED STRING.
	V3$=FNP$(V2$,","):V4$=MID$(V2$,INSTR(V2$,",")+1)
'	NOW V3$ HAS THE FIRST ARGUMENT, AND V4$ IS THE SECOND.
	U$=V4$:GOSUB @STRIPPER:V4$=U$:U$=V3$:GOSUB @STRIPPER:V3$=U$
	IF V4$<"A" THEN PRINT#2,T$H$V4$:ELSE PRINT#2,T$Q$V4$
	PRINT#2,T$P$V$"+2"
'	AT THIS POINT, HL CONTAINS THE NUMBER OF BYTES TO TRANSFER, AND THAT
'	NUMBER HAS BEEN PLACED INTO THE LENGTH WORD FOR THE DESTINATION.
'	OK, NOW WE NEED TO TRANSFER THE BYTES FROM B$ TO A$. WE WILL NOT CHECK
'	TO SEE IF THERE'S ENOUGH ROOM FOR THE TRANSFER ON EITHER END.
'	WE WILL GET THE ADDRESS OF THE SOURCE, ADD THE LENGTH OF THE SOURCE,
'	SUBTRACT THE NUMBER OF BYTES TO TRANSFER, AND PASS THAT RESULT AS THE
'	ORIGIN OF THE STRING MOVE.
	PRINT#2,T$PH$E$PH$E$Q$V3$SW$Q$V3$"+2!"I2$:PRINT#2,T$"POP D!MOV A,D!CMA!MOV D,A!MOV A,E!CMA!MOV E,A":PRINT#2,T$"INX D!"I2$SW$Q$V$SW$"POP B":PRINT#2,T$"CALL STRMV":RETURN

@IS.MID$
	F(32)=1:V2$=MID$(V1$,6):V2$=FNP$(V2$,")")
'	SYNTAX IS A$=MID$(B$,X,Y), WHERE A$ AND B$ ARE STRING VARIABLES
'	AND X AND Y ARE NUMERIC CONSTANTS OR INTEGER VARIABLES. Y IS
'	OPTIONAL; IF NOT GIVEN, THE TRANSFER WILL CONTINUE TO THE END OF THE
'	STRING B$.
	V3=INSTR(V2$,","):V4=INSTR(V3+1,V2$,",")
'	WAS THERE A Y PARAMETER? IF NOT, WE DO SOMETHING SIMPLER
	IF V4=0 THEN @IS.MID2$

	V3$=LEFT$(V2$,V3-1):V4$=MID$(V2$,V3+1,V4-V3-1):V5$=MID$(V2$,V4+1):U$=V3$:GOSUB @STRIPPER:V3$=U$:U$=V4$:GOSUB @STRIPPER:V4$=U$:U$=V5$:GOSUB @STRIPPER:V5$=U$
'	WE GET THE DESTINATION ADDRESS & SAVE IT; THE SOURCE ADDRESS & SAVE IT.
	PRINT#2,T$Q$V$E$PH$E$Q$V3$E$PH$
'	NOW WE GET THE STARTING BYTE NUMBER
	IF V4$<"A" THEN PRINT#2,T$H$V4$:ELSE PRINT#2,T$Q$V4$
'	AND ADD IT TO THE B$ ADDRESS TO GET THE SOURCE OF THE MOVE & SAVE IT.
	PRINT#2,T$"POP D"I1$IS$E$PH$
'	THE STACK NOW HAS THE SOURCE OF THE MOVE AND THE DESTINATION IN ORDER.
	IF V5$<"A" THEN PRINT#2,T$H$V5$:ELSE PRINT#2,T$Q$V5$
'	NOW WE STORE THE NUMBER OF BYTES IN THE DESTINATION'S LENGTH BYTE
	PRINT#2,T$P$V$"+2"
'	AND PUT THE NUMBER OF BYTES TO MOVE IN BC, THE SOURCE ADDRESS IN HL,
'	AND THE DESTINATION ADDRESS IN DE
	PRINT#2,T$PH$E$"POP B!POP H!POP D!CALL STRMV"
	RETURN

@IS.MID2$
'	HERE IS A$=MID$(B$,X)
	V3$=LEFT$(V2$,V3-1):V4$=MID$(V2$,V3+1):U$=V3$:GOSUB @STRIPPER:V3$=U$:U$=V4$:GOSUB @STRIPPER:V4$=U$
'	WE GET THE DESTINATION ADDRESS & SAVE IT; THE SOURCE ADDRESS & SAVE IT.
	PRINT#2,T$Q$V$E$PH$E$Q$V3$E$PH$
'	NOW WE GET THE STARTING BYTE NUMBER
	IF V4$<"A" THEN PRINT#2,T$H$V4$:ELSE PRINT#2,T$Q$V4$
'	AND ADD IT TO THE B$ ADDRESS TO GET THE SOURCE OF THE MOVE & SAVE IT.
	PRINT#2,T$"POP D"I1$IS$E$PH$
'	THE STACK NOW HAS THE SOURCE OF THE MOVE AND THE DESTINATION IN ORDER.
'	NOW WE GET THE LENGTH OF THE SOURCE STRING AND SUBTRACT THE STARTING
'	POSITION TO GET THE NUMBER OF BYTES TO MOVE. CAREFUL! THE RESULT MUST
'	ALWAYS BE 1 MORE THAN A NAIVE SUBTRACTION WOULD SUGGEST. WATCH WHEN
'	I DO THE SUBTRACTION; THERE'LL BE AN INX H RIGHT AFTER IT.
	PRINT#2,T$PH$E$Q$V3$SW$Q$V3$"+2!"I2$:PRINT#2,T$"POP D!MOV A,D!CMA!MOV D,A!MOV A,E!CMA!MOV E,A":PRINT#2,T$"INX D!"I2$I$PH$"!POP B!POP H!POP D":PRINT#2,T$"CALL STRMV":RETURN

@IS.STRING$
	V2$=MID$(V1$,9):V3=INSTR(V2$,","):V3$=MID$(V2$,V3+1):V2$=LEFT$(V2$,V3-1):U$=V2$:GOSUB @STRIPPER:V2$=U$:U$=LEFT$(V3$,INSTR(V3$,")")-1):GOSUB @STRIPPER:V3$=U$
'	first, we get the number of bytes to initialize into DE
	IF V2$>="A" THEN PRINT#2,T$"LHLD "V2$E$P$V$"+2!"S1$:ELSE PRINT#2,T$D$V2$E$H$V2$E$P$V$"+2"
'	get the address of the string into hl
'	then the ascii value into A
	PRINT#2,T$Q$V$:IF V3$>="A" THEN PRINT#2,T$PH$E$Q$V3$"!MOV A,M!POP H!STA $+4!MVI A,0":ELSE PRINT#2,T$"MVI A,"VAL(V3$)
'	and, finally, do the transfer
	PRINT#2,T$"MOV M,A!DCX D"I$"MOV A,D!ORA E!JNZ $-7":RETURN

@STR.ASSIGNMENT
	J=INSTR(L$,"=")+1:IF J THEN V1$=MID$(L$,J):ELSE @DETOUR
	U$=V1$:GOSUB @STRIPPER:V1$=U$:YES=0:GOSUB @IS.KEY.WORD:IF YES THEN RETURN
@DETOUR
	J=INSTR(L$,CHR$(34))+1:K=INSTR(J,L$,CHR$(34))-1:IF J=1 AND K=-1 THEN @STR.ASSIGNMENT2
	IF K<J THEN PRINT#2,T$H$"0!"P$V$"+2":RETURN
	PRINT#2,T$Q$V$
	FOR L=J TO K:PRINT#2,T$"MVI A,"FNS$(ASC(MID$(L$,L,1)));"!MOV M,A":IF L<>K THEN PRINT#2,T$"INX H"
	NEXT:PRINT#2,T$H$K-J+1;E$P$V$"+2":RETURN
@STR.ASSIGNMENT2
	J=INSTR(L$,"=")+1:V2$=MID$(L$,J):K=1:U$=V2$:GOSUB @STRIPPER:V2$=U$:K=INSTR(V2$,"$"):V3$=LEFT$(V2$,K):V2$=MID$(V2$,K+1):U$=V3$:GOSUB @STRIPPER:V3$=U$:U$=V2$:GOSUB @STRIPPER:V2$=U$
'	NOW V3$ IS THE VARIABLE AND V2$ IS THE REMAINDER OF THE COMMAND LINE.
'	WE NEED TO MOVE ONE AREA OF MEMORY TO ANOTHER FIRST. LET'S CHECK TO
'	SEE IF WE HAVE A CONCATENATION OF THE FORM A$=A$+
	IF V3$=V$ THEN @STR.ASSIGNMENT3
'	NOW WE GET THE NUMBER OF BYTES TO TRANSFER INTO BC.
'	THEN WE GET THE ADDRESS OF THE DESTINATION INTO DE
'	THE ADDRESS OF THE SOURCE IS IN HL
	PRINT#2,T$Q$V3$"+2!"PH$"!POP B":PRINT#2,T$Q$V$E$S1$:PRINT#2,T$Q$V3$:PRINT#2,T$"CALL STRMV":PRINT#2,T$Q$V3$"+2!"P$V$"+2":F(32)=1:IF V2$<=STRING$(LEN(V2$),32) THEN RETURN
@CATENATE
	U$=V2$:GOSUB @STRIPPER:V2$=U$:IF LEFT$(V2$,1)<>"+" THEN @ABORT
	V2$=MID$(V2$,2):U$=V2$:GOSUB @STRIPPER:V2$=U$:K=INSTR(V2$,"$"):V3$=LEFT$(V2$,K):V2$=MID$(V2$,K+1):U$=V3$:GOSUB @STRIPPER:V3$=U$:U$=V2$:GOSUB @STRIPPER:V2$=U$:PRINT#2,T$Q$V3$"+2!"PH$"!POP B":PRINT#2,T$Q$V$SW$Q$V$"+2"I1$S1$
	PRINT#2,T$Q$V3$"!CALL STRMV":PRINT#2,T$Q$V3$"+2"SW$Q$V$"+2!"I2$:PRINT#2,T$P$V$"+2"
@STR.ASSIGNMENT3
	IF V2$>STRING$(LEN(V2$),32) THEN @CATENATE
	RETURN
@NOT.ASSIGN
	'is it a string size request?
	IF INSTR(L$,"SIZE(")<>1 THEN @IS.GO.TO
	V2$=MID$(L$,6):U$=FNP$(V2$,","):GOSUB @STRIPPER:UV=VAL(MID$(L$,INSTR(L$,",")+1)):J=0:WHILE (V$(J)<>"" AND V$(J)<>U$ AND J<MAX):J=J+1:WEND
	IF V$(J)=U$ THEN S(J)=UV:RETURN
	IF V$(J)="" THEN V$(J)=U$:S(J)=UV
	RETURN
@IS.GO.TO
'	IS IT A GOTO?
	IF INSTR(L$,"GOTO")<>1 THEN @NOT.GOTO
	V=VAL(MID$(L$,5)):V$=FNS$(V):PRINT#2,T$"JMP I"V$:RETURN
@NOT.GOTO
'	IS IT A GOSUB?
	IF INSTR(L$,"GOSUB")<>1 THEN @NOT.GOSUB:ELSE V=VAL(MID$(L$,6)):V$=FNS$(V):PRINT#2,T$"CALL I"V$:RETURN
@NOT.GOSUB
'	IS IT A RETURN?
	IF INSTR(L$,"RETURN")<>1 THEN @NOT.RETURN:ELSE PRINT#2,T$"RET":RETURN
@NOT.RETURN
'	IS IT AN END?
	IF INSTR(L$,"END")<>1 THEN @NOT.END:ELSE PRINT#2,T$"JMP 000H":RETURN
@NOT.END
'	IS IT A STOP?
	IF INSTR(L$,"STOP")<>1 THEN @NOT.STOP:ELSE PRINT#2,T$"JMP 000H":RETURN
@NOT.STOP
'	IS IT AN INPUT?
	IF INSTR(L$,"INPUT")<>1 THEN @NOT.INPUT
'	CHECK TO SEE IF VARIABLE NAME HAS BEEN USED BEFORE
	U$=MID$(L$,6):GOSUB @STRIPPER:V$=U$:J=0:WHILE V$(J)<>V$ AND V$(J)<>"" AND J<MAX:J=J+1:WEND:IF V$(J)="" THEN V$(J)=V$
'	CHECK TO SEE IF IT IS A STRING VARIABLE
	IF INSTR(V$,"$")>0 THEN @STR.INPUT
'	IF IT IS A NUMBER, CONVERT IT TO BINARY AND STORE IT.
	F(13)=1:PRINT#2,T$"CALL GETNUM":PRINT#2,T$P$V$:RETURN
@STR.INPUT
'	IF IT IS A STRING, PLACE THE INPUT STRING IN THE CORRECT LOCATION,
'	AND INCREMENT THE STRING LENGTH COUNTER APPROPRIATELY.
'	DE POINTS TO STRING LOCATION; ON RETURN, HL CONTAINS STRING LENGTH
	PRINT#2,T$Q$V$:PRINT#2,T$S1$:PRINT#2,T$"CALL GETSTR!"P$V$"+2":F(14)=1:RETURN
@NOT.INPUT
'	IS IT A CONDITIONAL (IF) STATEMENT?
	IF INSTR(L$,"IF")<>1 THEN @NOT.CONDITIONAL
	K1=1:K2=0
@NOTINQUOTES
	K=INSTR(K1,L$,"THEN"):IF K<1 THEN @ABORT
	FOR K3=1 TO K:K2=ABS(K2+(MID$(L$,K3,1)=CHR$(34))):NEXT:IF K2 THEN K1=K+1:GOTO @NOTINQUOTES
	V1$="":V2$="":V3$=""
'	V1$ WILL CONTAIN THE FIRST OPERAND, V2$ THE COMPARISON, V3$ THE LAST.
'	NOTE THAT ALL OPERANDS MUST BE SIMPLE: I.E. MAY NOT CONTAIN ANOTHER
'	OPERATOR. LINES LIKE: IF MID$(A$,4,2)="TO" THEN . . . ARE PROHIBITED!
'	INSTEAD, LINES MUST LOOK LIKE: IF VAR1 RELATIONSHIP VAR2 THEN . . .
'	WHERE VAR1 AND VAR2 MUST BE SIMPLE STRING OR INTEGER VARIABLES.
'	I WILL, HOWEVER, PERMIT A NUMERIC CONSTANT ON EITHER SIDE OF THE
'	RELATIONSHIP. K POINTS TO THE 'THEN' KEYWORD.
	K1=3:WHILE MID$(L$,K1,1)<>"<" AND MID$(L$,K1,1)<>">" AND MID$(L$,K1,1)<>"=":IF MID$(L$,K1,1)>" " THEN V1$=V1$+MID$(L$,K1,1)
	K1=K1+1:WEND
	WHILE MID$(L$,K1,1)<"A" AND (MID$(L$,K1,1)>"9" OR MID$(L$,K1,1)<"0"):IF MID$(L$,K1,1)="<" OR MID$(L$,K1,1)=">" OR MID$(L$,K1,1)="=" THEN V2$=V2$+MID$(L$,K1,1)
	K1=K1+1:WEND
	WHILE K1<K:IF MID$(L$,K1,1)>" " THEN V3$=V3$+MID$(L$,K1,1)
	K1=K1+1:WEND
'	IF ONE OF THE OPERANDS OR THE RELATIONSHIP IS MISSING, ABORT COMPILE.
	IF V1$="" OR V2$="" OR V3$="" THEN @ABORT
	U$=V1$:GOSUB @STRIPPER:V1$=U$:U$=V2$:GOSUB @STRIPPER:V2$=U$:U$=V3$:GOSUB @STRIPPER:V3$=U$:K3=0:K2=INSTR(V1$,"$"):IF V2$="=" THEN K3=1:IF K2 THEN U$="SC":F(15)=1
	IF V2$="<>" OR V3$="><" THEN K3=2:IF K2 THEN U$="SC4":F(16)=1
	IF V2$="=<" OR V2$="<=" THEN K3=3:IF K2 THEN U$="SC9":F(19)=1
	IF V2$=">=" OR V2$="=>" THEN K3=4:IF K2 THEN U$="SC8":F(18)=1
	IF V2$="<" THEN K3=5:IF K2 THEN U$="SC5":F(17)=1
	IF V2$=">" THEN K3=6:IF K2 THEN U$="SCA":F(20)=1
	IF K3=0 THEN @ABORT
	IF K2 THEN PRINT#2,T$D$"Z"V1$E$H$"Z"V3$"!CALL "U$:GOTO @FIRST.PASS
	IF MID$(V1$,1,1)<="9" AND MID$(V1$,1,1)>="0" THEN PRINT#2,T$D$V1$:ELSE PRINT#2,T$Q$V1$E$S1$
	IF MID$(V3$,1,1)<="9" AND MID$(V3$,1,1)>="0" THEN PRINT#2,T$H$V3$:ELSE PRINT#2,T$Q$V3$
	IF K3=1 THEN U$="NC":F(21)=1:ELSE IF K3=2 THEN U$="NC1":F(22)=1
	IF K3=3 THEN U$="NC5":F(26)=1:ELSE IF K3=4 THEN U$="NC3":F(24)=1
	IF K3=5 THEN U$="NC2":F(23)=1:ELSE IF K3=6 THEN U$="NC4":F(25)=1
	PRINT#2,T$"CALL "U$
@FIRST.PASS
	PRINT#2,T$"ORA A!JZ I"FNS$(LN(LZ))
'	NOW NEED TO PERFORM THE REST OF THE LINE AFTER THE THEN KEYWORD
	L1$=MID$(L$,K+4)+":"+L1$:RETURN
@NOT.CONDITIONAL
'	IS IT A POKE? (SYNTAX: POKE A1,A2) WHERE A1 IS AN INTEGER OR INTEGER
'	VARIABLE, A2 IS AN INTEGER OR INTEGER VARIABLE. A1 IS AN ADDRESS,
'	AND A2 IS A QUANTITY. A2 IS POKED INTO ADDRESS A1.
	IF INSTR(L$,"POKE")<>1 THEN @NOT.POKE
	K1=5
@POKESUB
	V1$="":WHILE MID$(L$,K1,1)<"0":K1=K1+1:WEND:V1$=MID$(L$,K1):K1=INSTR(V1$,",")-1:V2$=LEFT$(V1$,K1)
'	V2$ NOW IS A2
	K1=K1+2:WHILE MID$(V1$,K1,1)<"0":K1=K1+1:WEND:IF K1>1 THEN V1$=MID$(V1$,K1):K1=1:WHILE MID$(V2$,K1,1)<"0":K1=K1+1:WEND:IF K1>1 THEN V2$=LEFT$(V1$,K1)
	IF LEFT$(V2$,1)<"A" THEN PRINT#2,T$D$V2$:ELSE PRINT#2,T$Q$V2$E$S1$
	IF LEFT$(V1$,1)<"A" THEN PRINT#2,T$H$V1$:ELSE PRINT#2,T$Q$V1$
'	DE CONTAINS ADDRESS, HL CONTAINS AMOUNT.
	PRINT#2,T$"MOV A,L!STAX D":RETURN
@NOT.POKE
'	IS IT AN INTEGER POKE?
	IF INSTR(L$,"IPOKE")<>1 THEN @NOT.IPOKE
	K1=6:GOSUB @POKESUB:PRINT#2,T$"INX D!MOV A,H!STAX D":RETURN
@NOT.IPOKE
'	IS IT A CALL?
'	there are two possibilities: call yyyy, where yyyy is a constant, and
'	call VVVV, where VVVV is a variable.
	IF INSTR(L$,"CALL")<>1 THEN @NOT.CALL
	XP=5:WHILE MID$(L$,XP,1)<=" ":XP=XP+1:WEND
	IF MID$(L$,XP,1)>="A" THEN XP2=XP+1:WHILE (XP2<LEN(L$) AND MID$(L$,XP2,1)>="0"):XP2=XP2+1:WEND:PRINT#2,T$Q$MID$(L$,XP,XP2-XP)E$"SHLD $+4!CALL 9999":RETURN
	PRINT#2,T$"CALL "VAL(MID$(L$,XP)):RETURN
@NOT.CALL
	IF INSTR(L$,"OPEN")<>1 THEN @RGET
	F(28)=1:XP=5:WHILE (MID$(L$,XP,1)>"9" OR MID$(L$,XP,1)<"1") AND XP<LEN(L$):XP=XP+1:WEND:IF XP=LEN(L$) THEN @ABORT
	FIL=VAL(MID$(L$,XP))
'	THE FILE NUMBER CANNOT PRESENTLY BE A VARIABLE. THE NAME CAN.
'	TO MAKE CLEAR WHICH IS INTENDED, THE NAME MUST BE ENCLOSED IN QUOTES
'	IF IT IS NOT A VARIABLE.
'	DE POINTS TO DESIRED FCB (1, 2 OR 3); HL POINTS TO THE FILE NAME;
'	AND B CONTAINS LENGTH OF PROPOSED FILE NAME (1-12).
'	SYNTAX IS OPEN X,FN, WHERE X IS THE FILE NUMBER AND FN THE NAME.
	XP=INSTR(L$,",")+1:IF MID$(L$,XP,1)=CHR$(34) THEN @ROPENS:ELSE FIL$=MID$(L$,XP)
'	OK, FIL IS THE FILE NUMBER, AND FIL$ IS THE VARIABLE FOR THE NAME.
	PRINT#2,T$D$"FCB"FNS$(FIL):PRINT#2,T$Q$FIL$"+2!MOV B,L!"Q$FIL$"!CALL ROPEN":RETURN
@ROPENS
'	USED IF THE FILE TO BE OPENED IS IN A QUOTED STRING
	PRINT#2,T$"JMP I"FNS$(LN)CHR$(W+2):W=W+1:PRINT#2,"I"FNS$(LN)CHR$(W)": DB '";:XX=XP+1:WHILE MID$(L$,XX,1)<>CHR$(34):PRINT#2,MID$(L$,XX,1);:XX=XX+1:WEND
	PRINT#2,"'":W=W+1:PRINT#2,"I"FNS$(W)": "H$FNS$(W-1)E$D$"FCB"FNS$(FIL)"!MVI B,"XX-XP-1;"!CALL ROPEN":RETURN

@RGET
	IF INSTR(L$,"GET")<>1 AND INSTR(L$,"PUT")<>1 THEN @RCLOSE
'	HERE'S WHERE WE DO THE RANDOM READ/WRITE. THE SYNTAX DESIRED IS:
'	GET X,R,A$
'	PUT X,R,A$
'	WHERE X IS THE FILE NUMBER, R IS THE RECORD NUMBER, AND A$ IS THE
'	STRING VARIABLE TO USE AS THE BUFFER. A$ MUST BE A VARIABLE, BUT
'	NEED NOT ACTUALLY BE A$; R CAN BE A CONSTANT OR VARIABLE; AND X
'	MUST BE A CONSTANT (EITHER 1, 2, OR 3 AT THIS POINT.)
	F(28)=1:FIL=VAL(MID$(L$,4)):IF FIL=0 THEN @ABORT
	XP=INSTR(L$,","):XP=XP+1:XQ=INSTR(XP,L$,","):U$=MID$(L$,XQ+1):GOSUB @STRIPPER:BUF$=U$:XX$=MID$(L$,XP,XQ-XP):IF VAL(XX$)<1 THEN @RGET2
'	IF WE'RE HERE, THE RECORD NUMBER IS A CONSTANT.
'	WE MUST PUT HL=RECORD NUMBER, DE=FCB, BC=DMA
'	XX$=RECORD NUMBER, FIL=FILE NUMBER, AND BUF$=BUFFER VARIABLE
'	SET UP THE DMA
'	FIX THE FCB
	PRINT#2,T$Q$BUF$"!MOV B,H!MOV C,L":PRINT#2,T$D$"FCB"FNS$(FIL):PRINT#2,T$H$XX$S$"CALL RGET":RETURN
'	AND THAT FIXES THE RECORD NUMBER. THE DCX IS BECAUSE CP/M NUMBERS THE
'	RECORDS BEGINNING WITH 0, AND BASIC BEGINS WITH 1.
@RGET2
'	IF WE GO HERE, THE RECORD NUMBER TO GET OR PUT IS A VARIABLE.
'	WE MUST PUT HL=RECORD NUMBER, DE=FCB, BC=DMA
'	XX$=RECORD NUMBER, FIL=FILE NUMBER, AND BUF$=BUFFER VARIABLE
'	SET UP THE DMA
'	FIX THE FCB
	PRINT#2,T$Q$BUF$"!MOV B,H!MOV C,L":PRINT#2,T$D$"FCB"FNS$(FIL):U$=XX$:GOSUB @STRIPPER:XX$=U$:PRINT#2,T$Q$XX$S$"CALL R"LEFT$(L$,3):RETURN
@RCLOSE
	IF INSTR(L$,"CLOSE")<>1 THEN @FORLOOP
	F(28)=1
'	SYNTAX DESIRED: CLOSE X, WHERE X IS THE FILE NUMBER TO CLOSE
'	IF X IS NOT STATED, THEN AN ERROR WILL BE REPORTED
	FIL=VAL(MID$(L$,6)):IF FIL<1 THEN @ABORT
	PRINT#2,T$D$"FCB"FNS$(FIL)"!CALL FCLOS":RETURN
@FORLOOP
	IF INSTR(L$,"FOR")<>1 THEN @NEXTLOOP
	U=U+1:Z$=L$:U$=MID$(L$,4,INSTR(L$,"TO")-4):GOSUB @STRIPPER:L$=U$:I=TOKENS:GOSUB @NOTPRINT:L$=Z$:XP=INSTR(L$,"TO"):XP1=INSTR(L$,"STEP"):NX=U-N-1:NX$=FNS$(U)+CHR$(13)+CHR$(10)+"NXT"+FNS$(U)+":"
	XP=XP+2:WHILE MID$(L$,XP,1)<=" ":XP=XP+1:WEND:U$=MID$(L$,XP):GOSUB @STRIPPER:Z$=U$:IF Z$<"A" THEN @FORLOOP1
	IF Z$>="A" THEN @FORLOOP2:ELSE @ABORT
@FORLOOP1
'	FOR LOOP ENDS WITH A CONSTANT, LIKE FOR I=X TO 10
	PRINT#2,"FOR"FNS$(U)": "D$VAL(Z$)
'	NOW HL CONTAINS LOOP INDEX, DE CONTAINS MAXIMUM LIMIT. WE WANT TO FIND
'	OUT IF THE STEP IS POSITIVE OR NEGATIVE, SO WE CAN COMPARE THE RESULT
'	AGAINST THE LIMIT AND BYPASS THE LOOP IF THE TEST FAILS. THIS MEANS
'	THE LOOP WILL NOT EXECUTE IF THE INITIAL VALUE EXCEEDS THE LIMIT.
'	EXAMPLE: X=2:FOR I=X TO 1
	IF XP1 THEN @FORLOOP3
	F(23)=1:PRINT#2,T$"CALL NC2!ORA A!JNZ NXT"FNS$(U):NXT$(NX)=T$+Q$+V$+I$+P$+V$+"!JMP FOR"+NX$:RETURN
@FORLOOP3
'	FOR LOOP ENDS WITH CONSTANT, BUT THERE IS A STEP COMMAND
	Z$=MID$(L$,XP1+5):WHILE LEFT$(Z$,1)<=" ":Z$=MID$(Z$,2):WEND:IF LEFT$(Z$,1)="-" THEN @FORLOOP4
	F(23)=1:PRINT#2,T$"CALL NC2!ORA A!JNZ NXT"FNS$(U)
	IF Z$<"A" THEN IF VAL(Z$)<6 THEN NXT$(NX)=T$+Q$+V$+E$:FOR XP=1 TO VAL(Z$):NXT$(NX)=NXT$(NX)+"INX H!":NEXT XP:NXT$(NX)=NXT$(NX)+P$+V$+"!JMP FOR"+NX$:RETURN
	IF Z$<"A" THEN NXT$(NX)=T$+Q$+V$+E$+D$+Z$+I1$+P$+V$+"!JMP FOR"+NX$:RETURN
	NXT$(NX)=T$+Q$+V$+SW$+Q$+Z$+I1$+P$+V$+"!JMP FOR"+NX$:RETURN
@FORLOOP4
	F(23)=1:PRINT#2,T$"CALL NC4!ORA A!JNZ NXT"FNS$(U)
	IF Z$<"A" THEN IF VAL(Z$)>-6 THEN NXT$(NX)=T$+Q$+V$+E$:FOR XP=1 TO VAL(Z$):NXT$(NX)=NXT$(NX)+IS$+E$:NEXT XP:NXT$(NX)=NXT$(NX)+P$+V$+"!JMP FOR"+NX$:RETURN
	IF Z$<"A" THEN NXT$(NX)=T$+Q$+V$+E$+D$+FNS$(ABS(VAL(Z$)))+SW$+"CALL ARITH2!"+P$+V$+"!JMP FOR"+NX$:F(5)=1:RETURN
	NXT$(NX)=T$+Q$+V$+SW$+Q$+MID$(Z$,2)+"!CALL ARITH2!"+P$+V$+"!JMP FOR"+NX$:F(5)=1:RETURN
@FORLOOP2
'	FOR LOOP ENDS WITH A VARIABLE, LIKE FOR I=X TO Y
	XP=1:WHILE MID$(Z$,XP,1)>="A" AND XP<LEN(Z$):XP=XP+1:WEND:PRINT#2,"FOR"FNS$(U)": "S1$E$Q$MID$(Z$,1,XP)E$S1$
'	NOW HL CONTAINS LOOP INDEX, DE CONTAINS MAXIMUM LIMIT. WE WANT TO FIND
'	OUT IF THE STEP IS POSITIVE OR NEGATIVE, SO WE CAN COMPARE THE RESULT
'	AGAINST THE LIMIT AND BYPASS THE LOOP IF THE TEST FAILS. THIS MEANS
'	THE LOOP WILL NOT EXECUTE IF THE INITIAL VALUE EXCEEDS THE LIMIT.
'	EXAMPLE: X=2:FOR I=X TO 1
	IF XP1 THEN @FORLOOP3
	F(23)=1:PRINT#2,T$"CALL NC2!ORA A!JNZ NXT"FNS$(U):NXT$(NX)=T$+Q$+V$+I$+P$+V$+"!JMP FOR"+NX$:RETURN
@NEXTLOOP
	IF INSTR(L$,"NEXT")<>1 THEN @TEMPABORT
	N=N+1:PRINT#2,NXT$(U-N):RETURN
@TEMPABORT
	RETURN
@ABORT
	PRINT"SYNTAX ERROR IN LINE":PRINT LN;L$:END
@END
	PRINT#2,T$"CALL 0000H"
	IF F(28) THEN FOR J=1 TO 3:PRINT#2,"FCB"FNS$(J)": DB"T$;:FOR TOT=1 TO 35:PRINT#2,"0,";:NEXT TOT:PRINT#2,"0":NEXT J
	GOSUB @RESOLVE.CALLS:TOT=0:J=0:WHILE V$(J)<>"":IF INSTR(V$(J),"$") THEN MAX=S(J):IF MAX<1 THEN MAX=80
	IF INSTR(V$(J),"$") THEN TOT=TOT+MAX:J$=FNS$(257+TOT-MAX):PRINT#2,"Z"V$(J)": DW STACK+"J$",0":ELSE PRINT#2,"Z"V$(J)": DW 0"
	J=J+1:WEND:PRINT#2,T$"DS 64":PRINT#2,"STACK:":PRINT#2,"SAREA: DW 0":PRINT#2,T$"END":CLOSE:END
@RESOLVE.CALLS
	CLOSE 1:A$=""
	OPEN"I",1,LD$+":BCBC.LIB"

	IF F(1) THEN F(0)=1:F(2)=1
	IF F(12) THEN F(7)=1
	IF F(16) THEN F(15)=1
	IF F(18) THEN F(17)=1
	IF F(19) THEN F(17)=1:F(15)=1
	IF F(20) THEN F(19)=1:F(17)=1:F(15)=1
	IF F(22) OR F(23) THEN F(21)=1
	IF F(24) OR F(25) THEN F(23)=1:F(21)=1
	IF F(26) THEN F(25)=1:F(23)=1:F(21)=1
	IF F(31) THEN F(2)=1
	FOR I=0 TO 33:IF F(I) THEN A=I+1:GOSUB @READ.LIBRARY
	NEXT I:RETURN

@READ.LIBRARY
	WHILE VAL(A$)<A:LINE INPUT #1,A$:WEND
	WHILE VAL(A$)<>A+1:LINE INPUT #1,A$
	IF EOF(1) THEN @LIB.ERROR
	IF C$="N" THEN IF INSTR(A$,";")<1 AND VAL(A$)<1 THEN PRINT#2,A$
	IF C$="Y" THEN IF VAL(A$)<1 THEN PRINT#2,A$
	WEND
	RETURN
@OPEN.ERROR
	PRINT"ERROR: LIBRARY (BCBC.LIB) NOT FOUND!"
	PRINT"CORRECT YOUR LIBRARY DRIVE LETTER (NOW "LD$"): ";:INPUT LD$
	GOTO @RESOLVE.CALLS
@LIB.ERROR
	PRINT"FATAL ERROR: UNEXPECTED END OF LIBRARY (BCBC.LIB)":END
